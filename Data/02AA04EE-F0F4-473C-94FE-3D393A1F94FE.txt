                1 
 
   
  è¡Œæ”¿é™¢åœ‹å®¶ç§‘å­¸å§”å“¡æœƒå°ˆé¡Œç ”ç©¶è¨ˆç•«  
   
 
åµŒå…¥å¼ç³»çµ±ä¹‹ç‰¹å®šæ‡‰ç”¨æ¶æ§‹ç ”ç©¶(III)   
ç ”ç©¶æˆæœå ±å‘Š(ç²¾ç°¡ç‰ˆ)  
 
 
    
è¨ˆç•«é¡åˆ¥ï¼š 
 
å€‹åˆ¥å‹ 
è¨ˆç•«ç·¨è™Ÿï¼š NSC 100-2221-E-035 -102 - 
åŸ·è¡ŒæœŸé–“ï¼š 100å¹´ 08 æœˆ 01æ—¥è‡³ 101å¹´ 07æœˆ 31æ—¥ 
åŸ·è¡Œå–®ä½ï¼š é€¢ç”²å¤§å­¸è³‡è¨Šå·¥ç¨‹å­¸ç³»ï¼ˆæ‰€ï¼‰ 
   
è¨ˆç•«ä¸»æŒäººï¼š ç‹ç›Šæ–‡ 
å…±åŒä¸»æŒäººï¼š é™³å¾·ç”Ÿ 
è¨ˆç•«åƒèˆ‡äºº
å“¡ï¼š 
åšå£«ç­ç ”ç©¶ç”Ÿ-å…¼ä»»åŠ©ç†äººå“¡ï¼šæ´ªç§‹éŸ» 
ç¢©å£«ç­ç ”ç©¶ç”Ÿ-å…¼ä»»åŠ©ç†äººå“¡ï¼šæ—ç‚˜æ¯… 
ç¢©å£«ç­ç ”ç©¶ç”Ÿ-å…¼ä»»åŠ©ç†äººå“¡ï¼šä½•é›…é›¯ 
ç¢©å£«ç­ç ”ç©¶ç”Ÿ-å…¼ä»»åŠ©ç†äººå“¡ï¼šé™³ç¿é¨ 
åŠ©æ•™-å…¼ä»»åŠ©ç†äººå“¡ï¼šé»ƒæ›¼ç² 
 
   
å‚™è¨»ï¼š æœ¬è¨ˆç•«å¯å…¬é–‹æŸ¥è©¢ 
ä¸­ è¯ æ°‘ åœ‹ 101 å¹´ 10 æœˆ 31 æ—¥  
   
 
 
 
  
                3 
ç ”ç©¶ç›®çš„ 
Embedded systems present a tremendous opportunity to customize designs by exploiting the 
application behavior. Shrinking time-to-market, coupled with short product lifetimes create a critical need 
for rapid exploration and evaluation of candidate Application Specific Instruction-set Processors (ASIPs). 
System architects critically need tools, techniques, and methodologies to perform rapid architectural 
exploration for a given set of applications to meet the diverse requirements, such as better performance, low 
power, smaller silicon area etc.  
The total number of custom instructions (CIs) of an ASIP is limited by the instruction encoding space 
as a global constraint when the data sharing among dependent CIs is profitable to performance speedup as a 
local constraint. The data sharing among CI candidates should be aware ahead to process the CI selection. 
However, the information cannot be known until CIs are finally selected when the encoding space constraint 
is applied. In this paper, integer linear programming formulations are proposed such that the data sharing 
and the encoding space constraint can be applied during CI selection to release micro-architectural I/O 
limitation but obtain optimal performance speedup. 
The focus of this project is to customize a set of applications along with all aspects of a hardware 
architecture such as the datapath, control path, instruction set, interconnect, and instruction/data memory 
subsystems to achieve the balance among performance, energy, and flexibility as well as to reduce both cost 
and complexity of implementations. 
 
æ–‡ç»æ¢è¨ 
Most research on automatic custom instructions is based on graph theory [5]. A subset of nodes is 
executed by a general purpose processor while another subset benefits from accelerated dedicated hardware. 
This choice is often modeled as an optimization problem, which many different variables affect the 
complexity of searching effective custom instructions: for example, the size of the candidates, the evaluation 
of a candidateâ€™s gain, and the number of CIs constrained by instruction coding space. Past literature in 
general considered only a subset of these factors, leading in general to solutions that are only valid for 
simplified cases of the problem.  
For example, [6] proposes an exact algorithm to find the best custom instructions in a basic block, but 
uses a greedy methodology when finding more than one CI and does not take recurrence into account. In [7] 
also did not consider recurrence in the evaluation of a candidate; however, since some treatment of 
recurrences is necessary in order to achieve significant speedups, it suggested ways to collect isomorphism 
tests in a nonrecurrence-aware search algorithm.  
Other literature achieves better reuse of the instructions or covering of the basic block, but restricts the 
search to simpler custom instructions. In particular, in [8] considering only single-output candidates reduces 
the problem complexity substantially. They solved the problem by using â€œbinate coveringâ€ method. In [9] 
defines a method based on dynamic programming to select the best occurrences under area constraints. The 
work presented in [10] takes into account constraints of a NIOS2 processor paired with an extension. The 
method tries to determine an optimal pattern selection that minimizes applicationâ€™s execution time.  
Incremental algorithms are also used for CIs selection. In [11], they propose an iterative algorithm 
based on a conflict graph. In [12] proposes three algorithms for this purpose. The first one is a greedy 
algorithm that determines, during each iteration, the best candidate in a graph that to be covered. It takes into 
account a number of occurrences of each selected candidates. The second algorithm is also incremental but 
provides optimal solutions. The last one is a heuristic algorithm that analyses a subset of solutions explored 
in the previous algorithm. Unfortunately, state register data sharing between custom instructions were not 
considered.  
The speed-up obtainable by custom instructions is limited by the available data bandwidth between the 
base processor and AFU. A multi-ported register file can increase the data bandwidth. However, additional 
                5 
 
   Figure 2. The design flow to generate ASIPs and the corresponding application codes. 
The overview of ASIP design flow is presented in Figure 2. The input of the proposed design flow is 
application specific programs in C code. We have relied on the Altera NIOS2 compiler infrastructure to 
generate the assembly code of the applications and to obtain the profiling information for each basic block 
which corresponding to the occurrence of each primitive instruction. Therefore, the control/data flow graph 
(CDFGs) are generated for the analysis of the data dependencies among the primitive instructions. Then, the 
most profitable CIs will be selected according to the proposed algorithm to meet the architectural constraints. 
Our main contribution is to propose an integer linear programming formulations in which the selection of 
custom instructions interacts with the SRs data sharing consideration by minimizing data transfers within 
base processor and AFU under the encoding space constraint in order to achieve optimal speedup solutions. 
The selected CIs will be used to conduct the graph covering on the CDFGs. The matching code segments on 
the CDFGs will be replaced with new opcodes representing the CIs. Then, the primitive instructions and CIs 
are scheduled as well as registers are allocated to generate the corresponding executable code to demonstrate 
the correctness and performance of the proposed approach. 
The main custom selection solution includes three phases: template generation, isomorphism checking, 
custom instruction selection. The problem is solved optimally if exact algorithms are employed in all cases. 
However, heuristics can be used in any of the phases to reduce complexity.  
The template generation can be loosely described as a process of identifying a valid subgraph as a 
template from the application data-flow graph (DFG) to form a single CI in order to maximize performance. 
A set of templates is generated based on two basic constraints. First, there are no load, store, jump or branch 
instructions include in the valid subgraph, due to the architectural limitation or designerâ€™s decision. Second, 
a valid subgraph, S, is convex if, for every pair of vertices u, v âˆˆ S, there is no path from u to v that involves 
an outside vertex w âˆ‰ S. Note that only convex subgraphs can be implemented as custom instructions 
because non-convex subgraphs cause cyclic dependency between the custom instructions and other 
instructions. We consider only connected subgraphs. If we consider disconnected subgraphs (disjoint 
components), both subgraph enumeration and custom instruction selection become much more significantly 
                7 
reduced. Thus, the cycle saved by this template is 1 (3-1-1) cycle. 
 
Figure 4. An example shows the IPi and OPi of Ti 
Encoding Space Formulation 
For each candidate Ck, a Boolean variable ck is introduced to identify the corresponding candidate is chosen 
as a CI or not.  Obviously, if any template Ti within candidate Ck is chosen, then ïƒ¥ ïƒ ï€¾ki CT ix 0
 and ck = 1.  
If no template within candidate Ck is chosen, then ïƒ¥ ïƒ ï€½ki CT ix 0
 and ck = 0.  The following two inequalities 
are used to obtain the value of ck, where |Ck| is the total number of templates within candidate Ck: 
ğ‘ğ‘˜ âˆ’ âˆ‘ ğ‘¥ğ‘– â‰¤ 0ğ‘‡ğ‘–âˆˆğ¶ğ‘˜           (3) 
|ğ¶ğ‘˜| âˆ— ğ‘ğ‘˜ âˆ’âˆ‘ ğ‘¥ğ‘–ğ‘‡ğ‘–âˆˆğ¶ğ‘˜ â‰¥ 0         (4) 
If the total number of CIs, N, is limited by the instruction encoding or hardware implementation cost, the 
following inequality is used to constrain the total number of CIs. 
âˆ‘ ğ‘ğ‘˜ â‰¤ ğ‘ğ‘˜=1              (5) 
Objective Function 
The software execution time of a template Ti, SW(Ti), is estimated as the sum of the software latencies of all 
instructions in Ti. As an example, for RISC processor SW(Ti) can be calculated as following where SWu 
represents the cycle time of instruction u.  
  (ğ‘‡ğ‘–)   âˆ‘     âˆˆğ‘‡ğ‘–               (6) 
The hardware execution time of a template T, HW(Ti), is dependent on the specific AFU synthesis. CST(Ti) 
is defined as the cycle saved of the template Ti that estimates the reduction in the schedule length of the 
application program by replacing the template Ti with a CI, multiplied by the occurrences of the template Ti, 
Occ(Ti).  
Formally:
  
iiiiiii xOPIPTHWTSWTOccTCST *))()((*)()( ï€­ï€­ï€­ï€½ (7)
 
The following expression is used to realize the non-overlapping templates constraint, because the 
overlapping nodes can only be executed in exactly once: 
ğ‘¥ğ‘– + ğ‘¥ğ‘— â‰¤ 1, âˆƒğ‘‡ğ‘– âˆ© ğ‘‡ğ‘— â‰  âˆ…            (8) 
Our objective is to maximize the cycle savings of candidates under the total number of chosen CIs constraint, 
N. The objective function of the ILP formulation of ASIP is defined as follows: 
âˆ‘ ğ¶ ğ‘‡(ğ‘‡ğ‘–)ğ‘ğ‘™ğ‘™ğ‘‡ğ‘–                (9) 
 
çµæœèˆ‡è¨è«– 
We have implemented our algorithm as a point tool in C++. Our tool takes the description of a CDFG which 
is obtained from gcc 3.4.6 and the parameters of the base processor architecture as input and then generates 
                9 
performance and encoding constraint in our flow. We set the maximal number of custom instructions to be 8. 
Performance can be improved by increasing the number of custom instructions included in the processor; 
more code segments of code can be accelerated. Figure 6 shows that the speedup can be increased at SRs 
data sharing, if encoding constraint is considered in custom 
Our approach is based on integer linear programming model that integrates the SRs data sharing and 
encoding space constraint to guide the custom instructions selection process. For an embedded processor 
with GPRF only two read ports and one write port, our methodology can maximize the potential data sharing 
instructions to achieve the performance up to 1.75 speedup. We are now investigating a wide range of 
applications involving speed, area and power consumption trade-offs. 
Figure 6. The performance speedup 
 
åƒè€ƒæ–‡ç» 
[1] R. E. Gonzalez. Xtensa: a configurable and extensible processor. IEEE Micro, 20(2):60â€“70, 2000. 
[2] Synopsys DesignWare Configurable Cores. http://www.synopsys.com/ip/configurablecores/. 
[3] Altera Nios II Processor. http://www.altera.com/products/ip/processors/nios2/. 
[4] Stretch. http://www.stretchinc.com/.  
[5] Galuzzi. The instruction-set extension problem: A survey.  In International Workshop on Applied Reconfigurable 
Computing (ARC), pp. 209-220, London (UK), March 2008.  
[6] K. Atasu, L. Pozzi, and P. Ienne. Automatic application-specific instruction- set extensions under microarchitectural 
constraints. In Proc. 40th Design Autom. Conf., Anaheim, CA, Jun. 2003, pp. 256â€“61.  
[7] N. Clark, H. Zhong, and S. Mahlke. Processor acceleration through automated instruction set customization. In 
MICRO 36: Proc. 36th Annu. Int. Symp. Microarchitecture, San Diego, CA, Dec. 2003, pp. 129â€“140.  
[8] J. Cong, Y. Fan, G. Han, and Z. Zhang. Application-specific instruction generation for configurable processor 
architectures. In FPGA â€™04: Proceedings of the 2004 ACM/SIGDA 12th international symposium on Field 
programmable gate arrays, 2004, pp. 183â€“189.  
[9] N. Clark, H. Zhong, and S. Mahlke. Automated custom instruction generation for domain-specific processor 
acceleration. Trans. on Computers, vol. 54, no. 10, pp. 1258â€“1270, 2005.  
[10] K. Martin, C. Wolinski, K. Kuchcinski, A. Floch, and F. Charot. Constraint-driven instructions selection and 
application scheduling in the DURASE system. In 20th IEEE International Conference on Application-specific 
Systems, Architectures and Processors (ASAP), Boston, USA, July7-9, 2009. 
[11] Y. Guo, G. J. Smit, H. Broersma, and P. M. Heysters. A graph covering algorithm for a coarse grain reconfigurable 
system. In LCTES â€™03: Proc. of the ACM SIGPLAN conference on Language, compiler, and tool for embedded 
systems, 2003, pp. 199â€“208.  
[12] P. Bonzini and L. Pozzi. Recurrence-aware instruction set selection for extensible embedded processors. IEEE Trans. 
Very Large Scale Integr. Syst., vol. 16, no. 10, pp. 1259â€“1267, 2008. 
[13] J. Cong, Y. Fan, G. Han, A. Jagannathan, G. Reinmann, and Z. Zhang. Instruction set extension with shadow registers 
for configurable processors. In FPGA 2005, Feb. 2005. 
[14] R. Jayaseelan, H. Liu, and T. Mitra. Exploiting forwarding to improve data bandwidth of instruction-set extensions. In 
43rd DAC, Anaheim, CA, July 2006. 
[15] L. Pozzi and P. Ienne. Exploiting pipelining to relax register file port constraints of instruction-set extensions. In 
CASES 2005, San Francisco, CA, Sept. 2005. 
[16] Kubilay Atasu, Robert G. Dimond, Oskar Mencer and Wayne Luk. Optimizing Instruction-set Extensible Processors 
under Data Bandwidth Constraints. In DATE 2007.  
[17] Kubilay Atasu, Can Ã– zturan and GÃ¼nhan DÃ¼ndar. CHIPS: Custom Hardware Instruction Processor Synthesis. IEEE 
Trans. on Computer-Aided Design of Integrated Circuits and Syst., VOL. 27, NO. 3, March 2008. 
[18] ILOG CPLEX. http://www.ibm.com/software/integration/optimization/cplex-optimizer/ 
[19] MiBench. http://eecs.umich.edu/mibench 
[20] æ—ç‚˜æ¯…, " ASIP Instruction Scheduling and Register Allocation" é€¢ç”²å¤§å­¸è³‡è¨Šå·¥ç¨‹å­¸ç³»ç¢©å£«è«–æ–‡, 2012. 
[21] å³ä¿Šé›„, " ASIP on Multi-Processor Architectures for Deblocking Filters" é€¢ç”²å¤§å­¸è³‡è¨Šå·¥ç¨‹å­¸ç³»ç¢©å£«è«–æ–‡, 2012. 
[22] Chiuyun Hung, Hsin I Lin, Desheng Chen, and Yiwen Wang, â€œApplication Specific Instruction set Processor with 
Implicit Registers to Improve Register Bandwidth,â€ in 2012 International Workshop on Highly-Efficient Accelerators 
and Reconfigurable Technologies (HEART 2012) 
[23] Ginhsuan Li, Chiuyun Hung, Desheng Chen, and Yiwen Wang, â€œApplication Specific Instruction set Processor with 
Implicit Registers to Improve Register Bandwidth,â€ in World Academy of Science Engineering and Technology, June 
24-26, 2011. 
RDT05 
è¡Œæ”¿é™¢åœ‹å®¶ç§‘å­¸å§”å“¡æœƒè£œåŠ©åœ‹å…§ç ”ç©¶ç”Ÿå‡ºå¸­åœ‹éš›å­¸è¡“æœƒè­°å ±å‘Š 
101å¹´  6  æœˆ  4  æ—¥ 
å ±å‘Šäºº 
å§“  å 
æ´ªç§‹éŸ» å°±è®€æ ¡é™¢ 
ï¼ˆç§‘ç³»æ‰€ï¼‰ 
é€¢ç”²å¤§å­¸  è³‡é›»å­¸é™¢  è³‡è¨Šå·¥ç¨‹ç³»(æ‰€) 
â– åšå£«ç­ç ”ç©¶ç”Ÿ 
â–¡ç¢©å£«ç­ç ”ç©¶ç”Ÿ 
æœƒè­°æ™‚é–“ 
åŠåœ°é» 
101å¹´ 5æœˆ 31æ—¥è‡³ 101å¹´ 6æœˆ 1 æ—¥ 
åœ‹åˆ¥ï¼šæ—¥æœ¬ 
åŸå·¿ï¼šæ²–ç¹© 
æœ¬æœƒæ ¸å®š 
è£œåŠ©æ–‡è™Ÿ 
å¹´  æœˆ  æ—¥è‡ºæœƒåˆå­—ç¬¬          è™Ÿ 
æœƒè­°åç¨± 
(ä¸­æ–‡) 2012åœ‹éš›é«˜æ•ˆèƒ½åŠ é€Ÿèˆ‡å¯é‡çµ„å¼æŠ€è¡“ç ”è¨æœƒ 
(è‹±æ–‡) 2012 International Workshop on Highly-Efficient Accelerators and 
Reconfigurable Technologies (HEART 2012) 
ç™¼è¡¨è«–æ–‡ 
é¡Œç›® 
(ä¸­æ–‡) åœ¨ç·¨ç¢¼ç©ºé–“é™åˆ¶ä¸‹çš„é«˜æ•ˆèƒ½å®¢è£½åŒ–æŒ‡ä»¤é¸å– 
(è‹±æ–‡) ASIP Instruction Selection with the Encoding-Space Constraint for High 
Performance 
å ±å‘Šå…§å®¹æ‡‰åŒ…æ‹¬ä¸‹åˆ—å„é …ï¼š 
ä¸€ã€åƒåŠ æœƒè­°ç¶“é 
ä»Šå¹´ HEARTç ”è¨æœƒè­°æ™‚é–“æ˜¯åœ¨ 2012å¹´ 5æœˆ 31è‡³ 6æœˆ 1æ—¥æœŸé–“å±•é–‹ï¼Œå…¶åœ°é»ç‚ºæ—¥æœ¬æ²–ç¹©ã€‚ 
æˆ‘é¸æ“‡äº†ç›´èˆªçš„ä¸­è¯èˆªç©ºã€‚ä¸¦æ–¼ 5æœˆ 30æ—¥æ­ä¹˜è¯èˆªç­æ©Ÿ CI120æ–¼æ—©ä¸Š 8é» 15åˆ†ç”±æ¡ƒåœ’æ©Ÿå ´ç¬¬äºŒèˆª
å»ˆèµ·é£›ï¼Œç¶“éä¸€å°æ™‚åŠå·¦å³ï¼Œå³ç•¶åœ°æ™‚é–“ 10é» 45åˆ†æŠµé”æ²–ç¹©é‚£éœ¸æ©Ÿå ´ã€‚æ–¼ 31è™Ÿæ—©ä¸Š 9 é»å‰å¾€æœƒ
å ´å ±åˆ°è¨»å†Šï¼Œä¸¦å±•é–‹ç‚ºæœŸå…©å¤©çš„ç ”è¨æœƒã€‚ 
 æ­¤æ¬¡æœƒè­°æˆ‘å€‘ç™¼è¡¨ä¸€ç¯‡æµ·å ±è«–æ–‡ï¼Œå…¶è«–æ–‡è¢«å®‰æ’åœ¨ 5æœˆ 31æ—¥ä¸‹åˆ 4é»è‡³ 5é» 40åˆ†æœŸé–“ç¬¬ä¸ƒä½
å£é ­å ±å‘Šè€…ï¼Œåœ¨ Session 3 Poster Short Presentationsï¼Œä¸Šå°å ±å‘Šäº”åˆ†é˜çš„ presentationä»¥åŠ
ä¸€å°æ™‚çš„æµ·å ±å±•ç¤ºã€‚æœƒè­°å›ç¨‹æ­ä¹˜è¯èˆªç­æ©Ÿ CI121å›åˆ°å°ç£ï¼ŒçµæŸæ­¤æ¬¡çš„æœƒè­°è¡Œç¨‹ã€‚ 
 
äºŒã€èˆ‡æœƒå¿ƒå¾— 
åœ‹éš›é«˜æ•ˆèƒ½åŠ é€Ÿèˆ‡å¯é‡çµ„å¼æŠ€è¡“ç ”è¨æœƒ(International Workshop on Highly-Efficient 
Accelerators and Reconfigurable Technologies)æ˜¯ä¸€å€‹ä¸»è¦ç ”è¨æ–¹å‘æœ‰é—œé«˜æ•ˆèƒ½åŠ é€Ÿå’Œå¯é‡çµ„
åŒ–æŠ€è¡“ç ”ç©¶çš„æœƒè­°ï¼Œæ‰€æ¥å—çš„è«–æ–‡ç›¸ç•¶å°ˆæ¥­ï¼Œä¾‹å¦‚ç³»çµ±è»Ÿé«”ã€æ‡‰ç”¨ã€åŠ é€Ÿå™¨çš„å¹³å°åŠæ¶æ§‹èˆ‡å‰µæ–°çš„
åŠ é€Ÿè£ç½®ã€‚é€™æ¬¡é¦–åº¦åƒåŠ  2012 HEART æœƒè­°ä¹‹ä¸­é€éå£é ­èˆ‡æµ·å ±å±•ç¤ºçš„å•ç­”æ–¹å¼ï¼Œå¯ä»¥å¿«é€Ÿäº†è§£ç›®
å‰ä¸åŒé ˜åŸŸçš„ç ”ç©¶æˆæœï¼Œä¸¦è—‰æ­¤å¸å–ä»–äººèˆ‡æˆ‘å€‘çš„ç›¸é—œç ”ç©¶é ˜åŸŸçš„å»ºè­°èˆ‡ç¶“é©—ï¼Œé™¤äº†ç²ç›Šè‰¯å¤šä¹‹å¤–
ä¹Ÿæ„Ÿè¬åœ‹ç§‘æœƒåœ¨ç¶“è²»ä¸Šçš„è£œåŠ©ã€‚ 
 
ä¸‰ã€å»ºè­° 
åƒåŠ æ­¤é¡åœ‹éš›çŸ¥åå¤§å‹ç ”è¨æœƒï¼Œä¸åƒ…å¯ä»¥äº†è§£ä¸–ç•Œä¸Šç›¸åŒé ˜åŸŸçš„ç ”ç©¶æ–¹å‘ä»¥åŠç ”ç©¶æ·±åº¦ä¹‹å¤–ï¼Œ 
ä¸¦ä¸”èƒ½æå‡ç ”ç©¶æ°´æº–èˆ‡æ‹“å±•åœ‹éš›è¦–é‡ï¼Œå› æ­¤æœ‰å¿—æ–¼é•·æœŸç ”ç©¶çš„å­¸è€…æˆ–æ˜¯ç ”ç©¶ç”Ÿæ›´æ‡‰é¼“å‹µå¤šåƒèˆ‡åœ‹éš›
æ€§çš„ç ”è¨æœƒã€‚æ‰€ä»¥ï¼Œè‹¥èƒ½å¤ æŒçºŒåœ¨ç¶“è²»ä¸Šå¾—åˆ°åœ‹ç§‘æœƒçš„é©ç•¶è£œåŠ©ï¼Œå°æ–¼ç ”ç©¶å­¸è€…æˆ–æ˜¯ç ”ç©¶ç”Ÿå°‡æœƒæœ‰
æ¥µå¤§çš„å¹«åŠ©ã€‚ 
 
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•«è¡ç”Ÿç ”ç™¼æˆæœæ¨å»£è³‡æ–™è¡¨
æ—¥æœŸ:2012/09/19
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•«
è¨ˆç•«åç¨±: åµŒå…¥å¼ç³»çµ±ä¹‹ç‰¹å®šæ‡‰ç”¨æ¶æ§‹ç ”ç©¶(III)
è¨ˆç•«ä¸»æŒäºº: ç‹ç›Šæ–‡
è¨ˆç•«ç·¨è™Ÿ: 100-2221-E-035-102- å­¸é–€é ˜åŸŸ: ç©é«”é›»è·¯åŠç³»çµ±è¨­è¨ˆ
ç„¡ç ”ç™¼æˆæœæ¨å»£è³‡æ–™
å…¶ä»–æˆæœ 
(ç„¡æ³•ä»¥é‡åŒ–è¡¨é”ä¹‹æˆ
æœå¦‚è¾¦ç†å­¸è¡“æ´»å‹•ã€ç²
å¾—çé …ã€é‡è¦åœ‹éš›åˆ
ä½œã€ç ”ç©¶æˆæœåœ‹éš›å½±éŸ¿
åŠ›åŠå…¶ä»–å”åŠ©ç”¢æ¥­æŠ€
è¡“ç™¼å±•ä¹‹å…·é«”æ•ˆç›Šäº‹
é …ç­‰ï¼Œè«‹ä»¥æ–‡å­—æ•˜è¿°å¡«
åˆ—ã€‚) 
The SoC or VLSI design engineers were trained with the best analysis and 
design capability. 
 æˆæœé …ç›® é‡åŒ– åç¨±æˆ–å…§å®¹æ€§è³ªç°¡è¿° 
æ¸¬é©—å·¥å…·(å«è³ªæ€§èˆ‡é‡æ€§) 0  
èª²ç¨‹/æ¨¡çµ„ 0  
é›»è…¦åŠç¶²è·¯ç³»çµ±æˆ–å·¥å…· 0  
æ•™æ 0  
èˆ‰è¾¦ä¹‹æ´»å‹•/ç«¶è³½ 0  
ç ”è¨æœƒ/å·¥ä½œåŠ 0  
é›»å­å ±ã€ç¶²ç«™ 0  
ç§‘ 
æ•™ 
è™• 
è¨ˆ 
ç•« 
åŠ  
å¡« 
é … 
ç›® è¨ˆç•«æˆæœæ¨å»£ä¹‹åƒèˆ‡ï¼ˆé–±è½ï¼‰äººæ•¸ 0  
 
