 1
ï¨ˆæ”¿é™¢åœ‹å®¶ç§‘å­¸å§”å“¡æœƒè£œåŠ©å°ˆé¡Œç ”ç©¶è¨ˆç•«æœŸä¸­æˆæœå ±å‘Š 
åµŒå…¥å¼ DVB-H æ¥æ”¶ç³»çµ±ä¹‹é–‹ç™¼ 
å­è¨ˆç•«å››ï¼šDVB-H å‚³è¼¸ï¤…ï§Šè§£ç¢¼è»Ÿé«”ä¹‹é–‹ç™¼(1/2) 
è¨ˆç•«ç·¨è™Ÿï¼šNSC 98-2220-E-027-005 
åŸ·ï¨ˆæœŸé–“ï¼š98 ï¦ 8 æœˆ 1 æ—¥è‡³ 99 ï¦ 7 æœˆ 31 æ—¥ 
è¨ˆç•«ä¸»æŒäººï¼šé™³å‰å‡± 
 
è¨ˆç•«ï¥«èˆ‡äººå“¡ï¼šæœç§‰ç©ã€ï§¡è¯èˆˆã€ï¥²æ”¿æ–‡ã€ç‹æ¦®éº’ 
é»ƒç®è–ã€å€ªæ—»æš„ã€ï§¡å®—ç¿°ã€ç‹å‰ç„± 
ç‹æ­£èª ã€è˜‡æ—­æ˜± 
åœ‹ï§·å°ï¥£ç§‘æŠ€å¤§å­¸è³‡è¨Šå·¥ç¨‹ç³» 
 
æ‘˜è¦ 
ï¨ˆå‹•ï¥©ä½é›»è¦–æŠ€è¡“ DVB-H åœ¨å…¨çƒåŠå°ç£ï¨¦æ˜¯ç›®å‰çœ¾æ‰€çŸšç›®çš„ç„¦é»ï¼Œæœ‰é‘‘æ–¼
å…¶é‡è¦æ€§ï¼Œæœ¬è‡ªç”±è»Ÿé«”è¨ˆåŠƒè¨­è¨ˆèˆ‡å¯¦ä½œ DVB-H æ¥æ”¶ç³»çµ±ä¸­æ‰€éœ€ä¹‹å‚³è¼¸ï¤…ï§Š
(Transport stream)è§£ç¢¼è»Ÿé«”ã€‚åœ¨ DVB-H æ¥æ”¶ç³»çµ±ä¸­ï¼Œå‚³è¼¸ï¤…ï§Šå±¤ä»‹æ–¼æ¥æ”¶å™¨ä¹‹ç¡¬
é«”èˆ‡éˆçµ(LINK)å±¤ä¹‹é–“ï¼Œä¾æ“š MPEG-2 èˆ‡ DVB-H å‚³è¼¸ï¤…ï§Šæ¨™æº–ï¼Œå‰–æå‚³è¼¸ï¤…ï§Š
ä¸­çš„ç¯€ç›®ç‰¹å®šè³‡è¨Š(PSI)èˆ‡æœå‹™è³‡è¨Š(SI)ï¼Œä¸¦å°‡æŒ‡å®šçš„ç¯€ç›®è§£å¤šå·¥(Demux)å¾Œå‚³é€
è‡³éˆçµå±¤ï¼Œåš MPE èˆ‡ MPE-FEC çš„è§£ç¢¼ã€‚æœ¬å­è¨ˆåŠƒé…åˆç¸½è¨ˆåŠƒæ“¬å®šçš„é€²ï¨ï¼Œå·²
å¯¦ä½œé©ç”¨æ–¼ Android å¹³å°çš„å‚³è¼¸ï¤…ï§Šè§£ç¢¼è»Ÿé«”ã€‚æœ¬å­è¨ˆç•«ä»¥è‡ªç”±è»Ÿé«”æ–¹å¼é–‹ç™¼èˆ‡
æ¨å»£ï¼Œä¸¦å°‡é–‹ç™¼ç¶“é©—èˆ‡éç¨‹æä¾›çµ¦æ¥­ç•Œä½œç‚ºé–‹ç™¼ DVB-H ç›¸é—œç”¢å“çš„ï¥«è€ƒæ¨¡å‹ã€‚ 
 
é—œéµè©ï¼šè‡ªç”±è»Ÿé«”ã€DVB-Hã€MPEG Transport Stream 
 
Abstract 
DVB-H is currently one of the most popular digital mobile television 
technologies around the world. This project develops a DVB-H transport stream 
software decoder that can be used in a DVB-H receiver. The decoder decodes the 
received DVB-H transport stream from the hardware module. Based on the standard, 
the decoder parses PSI (program specific information) and SI (service information) 
tables and de-multiplexes the target program to DVB-H LINK layer for MPE and 
MPE-FEC decoding. This project implements the decoder on the Android platform 
and the decoder is released and popularized as an open-source software component. 
The experiences serve as a reference model for industries to develop DVB-H related 
products. 
 3
ç”± MPEG-2 ç³»çµ±æ¨™æº–[13]æ‰€å®šç¾©çš„ï¼Œæä¾›å‚³è¼¸ï¤…ï§Šè§£ç¢¼æ™‚æ‰€éœ€çš„ç›¸é—œè³‡è¨Šï¼Œå¦‚ç¯€
ç›®ï¥©ï¥¾ã€è¦–è¨Šèˆ‡éŸ³è¨Šå°åŒ…çš„ PIDã€è§£å¯†è³‡è¨Šç­‰ï¼›è€Œæœå‹™è³‡è¨Šå‰‡æ˜¯ç”± DVB-H æ¨™æº–
[7]æ‰€å®šç¾©çš„ï¼Œæä¾›ç¶²ï¤·è³‡è¨Šã€IP/MAC ç­‰å…¶ä»–è§£ç¢¼æ‰€éœ€çš„è³‡è¨Šã€‚DVB-H ä½¿ç”¨ 10
å€‹ç¯€ç›®ç‰¹å®šè³‡è¨Šèˆ‡æœå‹™è³‡è¨Šè¡¨æ ¼ï¼Œå¦‚è¡¨ 1 æ‰€ç¤ºã€‚ 
DVB-H é‡å°è§£ç¢¼çš„éœ€è¦ï¼Œåœ¨å„ç¨®è¡¨æ ¼ä¸­ä½¿ç”¨ï¦ºè¨±å¤šçš„æè¿°å™¨(Descriptor) 
[2][7]ï¼Œç”¨ï¤­ï¨ç¢ºåœ°æè¿°å„ç¨®è³‡è¨Šã€‚ï¦µå¦‚ç¶²ï¤·åç¨±æè¿°å™¨(network_name_descriptor)
å‡ºç¾åœ¨ NIT è¡¨æ ¼ä¸­ï¼Œæè¿°å¯¦é«”ç¶²ï¤·çš„åç¨±(ï¦µå¦‚ï¼šå…¬è¦–)ï¼Œåˆå¦‚ PMT è¡¨æ ¼ä¸­æœƒå‡º
ç¾è³‡ï¦¾å»£æ’­ï§¼åˆ¥æè¿°å™¨(data_broadcast_id_descriptor)ï¼Œè€Œè©²æè¿°å™¨å‰‡æœƒæŒ‡å‡º INT
è¡¨æ ¼çš„ PIDï¼Œä¾›é€²ä¸€æ­¥çš„è§£ç¢¼ä¹‹ç”¨ã€‚DVB-H ä½¿ç”¨çš„æè¿°å™¨æœ‰ 20 å€‹ï¼Œé€™äº›æè¿°å™¨
ä¸¦ï¥§æ˜¯å¯ä»¥ä»»æ„å‡ºç¾åœ¨è¡¨æ ¼ä¸­çš„ï¼Œå› æ­¤ï¼Œå‚³è¼¸ï¤…ï§Šçš„è§£ç¢¼å™¨å¿…é ˆé‡å°ç‰¹å®šçš„è¡¨æ ¼
è™•ï§¤ç‰¹å®šçš„æè¿°å™¨ï¼Œä»¥æå‡è§£ç¢¼å™¨çš„ç©©å®šæ€§èˆ‡å¯é æ€§ï¼Œé¿å…ç•¶å‚³è¼¸ï¤…ï§Šæœ‰èª¤æ™‚ï¼Œ
è§£ç¢¼è»Ÿé«”åšå‡ºï¥§æ­£ç¢ºçš„åæ‡‰ï¼Œç”šè‡³å°è‡´ç•¶æ©Ÿã€‚ 
 
è¡¨ 1 æä¾›ç¯€ç›®ç‰¹å®šè³‡è¨Šèˆ‡æœå‹™è³‡è¨Šçš„è¡¨æ ¼ 
ï§åˆ¥ PID è¡¨æ ¼ç¸®å¯« è¡¨æ ¼å…¨å 
0x0000 PAT Program Association Table 
0x0001 CAT Conditional Access Table 
0x0002 TSDT Transport Stream Description Table 
ç¯€ç›®ç‰¹å®šè³‡è¨Š 
(MPEG-2) 
0x0010â€¦0x1FFE PMT Program Map Table 
0x0010 NIT Network Information Table 
0x0011 BAT Bouquet Association Table 
0x0011 SDT Service Description Table 
0x0014 TDT Time and Date Table 
0x0014 TOT Time Offset Table 
æœå‹™è³‡è¨Š 
(DVB-H) 
ç”±PMTæŒ‡å®š INT IP/MAC Notification Table 
 
æœ¬ï¦ï¨ç‚ºæœ¬è¨ˆåŠƒçš„ç¬¬ä¸€ï¦ï¼Œç›®æ¨™ä»¥è§£ç¢¼è»Ÿé«”åœ¨ Android å¹³å°çš„å¯¦ç¾ç‚ºä¸»ï¼Œåœ¨
æš«æ™‚ï¥§è€ƒæ…®æ¥æ”¶å™¨ç¡¬é«”çš„æƒ…æ³ä¸‹ï¼Œå…ˆå®Œæˆå‚³è¼¸ï¤…ï§Šè§£ç¢¼å™¨çš„ä¸»è¦åŠŸèƒ½ï¼Œå°æ–¼è§£ç¢¼
åŠŸèƒ½çš„æ¸¬è©¦ï¼Œå‰‡ä»¥é ï¤¿çš„å‚³è¼¸ï¤…ï§Šæª”æ¡ˆ(å°ç£åœ°å€è©¦æ’­çš„ DVB-H å‚³è¼¸ï¤…ï§Š)ä½œç‚º
è¼¸å…¥ï¼Œé©—è­‰è§£ç¢¼å™¨çš„æ­£ç¢ºæ€§ã€‚ç¬¬äºŒï¦èµ·æœ¬è¨ˆç•«æœƒæŠŠé‡é»è½‰ç§»åˆ°ç¡¬é«”æ¨¡çµ„çš„ä»‹æ¥ï¼Œ
æ¥æ”¶å¯¦éš›çš„ DVB-H è¨Šè™Ÿï¼Œé€™éƒ¨åˆ†ç‰½æ¶‰åˆ°é©…å‹•ç¨‹å¼è¨­è¨ˆã€ç¡¬é«”èˆ‡æ™‚åºæ§åˆ¶ï¼Œæ˜¯æ¯”
è¼ƒå›°é›£çš„åœ°æ–¹ã€‚ä»¥ä¸‹ä»¥æ¢ï¦œçš„æ–¹å¼æ•˜è¿°æœ¬è¨ˆåŠƒçš„ç›®çš„ï¼š 
Â¾ è¨­è¨ˆèˆ‡å¯¦ä½œå‚³è¼¸ï¤…ï§Šè§£å¤šå·¥å™¨çš„æ¶æ§‹ 
Â„ åŒæ­¥ä½å…ƒçµ„(sync byte)ä¹‹æœå°‹æ©Ÿåˆ¶ 
Â„ å‚³è¼¸å°åŒ…éºå¤±æ™‚ä¹‹è™•ï§¤æ–¹å¼ 
Â¾ ä¾æ“šå‚³è¼¸ï¤…ï§Šçš„æ¨™æº–ï¼Œå‰–æå‚³è¼¸ï¤…ï§Šä¸­çš„è¡¨æ ¼ 
Â„ è¨­è¨ˆèˆ‡å¯¦ä½œç¯€ç›®ç‰¹å®šè³‡è¨Š(PSI)æ‰€éœ€çš„ PAT, PMT, CAT, TSDT ç­‰å››å€‹
è¡¨æ ¼è§£ç¢¼å™¨ 
 5
å…ƒæ¸¬è©¦ã€æ•´åˆæ¸¬è©¦èˆ‡é©—æ”¶æ¸¬è©¦ï¼Œç‚ºæ±‚ç¨‹å¼çš„åŸ·ï¨ˆæ•ˆï¥¡ï¼Œæœ¬å­ç³»çµ±æ‰€æœ‰ç¨‹å¼å‡ä»¥
C/C++é–‹ç™¼ã€‚ 
 
ä¸‰ã€ ç³»çµ±æ•´åˆèˆ‡ç›£æ§ 
æœ¬è¨ˆç•«ä½¿ç”¨ç¬¦åˆ CMMI ML2 çš„ Scrum å°ˆæ¡ˆï§Šç¨‹ï¼Œå› æ­¤æ‰€æœ‰ç”¢å‡ºç‰©ï¼Œå¦‚ç¨‹å¼
ç¢¼åŠæ–‡ä»¶ç­‰ï¨¦éœ€è¦ç‰ˆæœ¬æ§ç®¡(ä½¿ç”¨ Subversion)ï¼Œä¸¦æ¡ç”¨ç¸½è¨ˆç•«è¦ç¯„çš„ç°½å…¥èˆ‡ç°½å‡º
æ¨™æº–ï¼Œä¸¦ä½œç‚º Sprint Demo æ™‚åˆ¤æ–· Story åŠ Task æ˜¯å¦å®Œæˆçš„ä¾æ“šã€‚åœ¨æ–‡ä»¶èˆ‡ç¨‹å¼
ç¢¼çš„æ’°å¯«ä¹Ÿæ¡ç”¨ç¸½è¨ˆç•«è¦ç¯„çš„æ¨™æº–èˆ‡è¦ç¯„ï¼Œä¸¦å°‡æ–‡ä»¶èˆ‡ç¨‹å¼ç¢¼çš„ Review åŠ åˆ°
Technical Backlog ä¸­ï¼Œæ–¼æ¯å€‹ Sprint çš„åŸ·ï¨ˆä¸­ç›£æ§æ‰€æœ‰çš„ç”¢å‡ºç‰©ã€‚å°ˆæ¡ˆåˆæœŸï¼Œæ­
é…ç¸½è¨ˆç•«çš„ä»‹é¢è¨ï¥æœƒè­°ï¼Œå®šç¾©æ¨¡çµ„é–“çš„å…§éƒ¨ä»‹é¢èˆ‡å…¶ä»–å­è¨ˆç•«é–“çš„å¤–éƒ¨ç•Œé¢
(Interface)ï¼Œå› æ­¤æ¨¡çµ„çš„å–®å…ƒèˆ‡æ•´åˆæ¸¬è©¦å¿…é ˆæ¶µè“‹æ‰€æœ‰å…§éƒ¨ä»‹é¢ï¼Œåœ¨å­ç³»çµ±çš„é©—
æ”¶æ¸¬è©¦é ˆæ¶µè“‹æ‰€æœ‰å¤–éƒ¨ä»‹é¢ã€‚ 
å››ã€ æˆæœ 
æœ¬è¨ˆç•«æ¡ç”¨ Scrum ï§Šç¨‹ï¼Œæ¯æœˆçš„ Sprint planning é…åˆç¸½è¨ˆç•«æ•´åˆé€²ï¨ï¼Œå»ºï§·
Sprint Backlogï¼Œå› æ­¤é–‹ç™¼èˆ‡æ¸¬è©¦æ˜¯äº¤éŒ¯é€²ï¨ˆçš„ã€‚è¨ˆç•«åŸ·ï¨ˆè‡³ 2010 ï¦ 5 æœˆï¼Œ
Information Retriever æ¨¡çµ„å·²ç¶“å®Œæˆæ•´å€‹è§£ç¢¼ï§Šç¨‹æ‰€éœ€çš„å››å€‹è¡¨æ ¼è§£ç¢¼å™¨(PATã€
PMTã€NIT èˆ‡ INT)åŠåå››å€‹æè¿°å™¨è§£ç¢¼å™¨(è¡¨ 2)ï¼Œä¸¦é€šéå–®å…ƒæ¸¬è©¦ï¼ŒInput Streamer
å·²ç¶“é€šéï¥šå–æª”æ¡ˆçš„æ¸¬è©¦ï¼ŒInput Stream Buffer èˆ‡ Output Stream Buffer ä¹Ÿå·²ç¶“é€š
éåœ¨ Multi-thread æƒ…å¢ƒä¸‹çš„æ¸¬è©¦ï¼ŒSection Parser å·²ç¶“å¯ä»¥å¾ Information Retriever
å»ºï§·çš„ PSI èˆ‡ SI è³‡è¨Šéï¦„ä¸¦é‡çµ„ Section çµ¦ LINK å­ç³»çµ±ï¼›FaÃ§ade æ¨¡çµ„å·²å®Œæˆä¸¦
é€šéç°¡å–®çš„é©—æ”¶æ¸¬è©¦ã€‚ 
è¡¨ 2 å·²å®Œæˆçš„æè¿°å™¨è§£ç¢¼å™¨ 
time_slice_fec target_ip_slash ip_mac_stream_location 
data_broadcast_id ip_mac_platform_name ip_mac_platform_provider_name
network_name terrestrial_delivery_system linkage 
call_list cell_frequency_link service 
data_broadcast stream_identifier  
 
è‡³ç›®å‰ç‚ºæ­¢ï¼Œé›–ç„¶é‚„æœ‰ï§‘å€‹è¡¨æ ¼è§£ç¢¼å™¨èˆ‡ï§‘å€‹æè¿°å™¨è§£ç¢¼å™¨å°šæœªå¯¦ä½œå®Œç•¢ï¼Œ
ä½†ä¸¦ï¥§å½±éŸ¿ä¸€èˆ¬æ’­æ”¾æ‰€éœ€çš„åŠŸèƒ½ï¼Œä¸” Information Retriever å·²ç¶“èƒ½æ­£ç¢ºè™•ï§¤å‚³è¼¸
ï¤…ï§Šï¼Œï¥§æœƒå› ç‚ºç„¡æ³•è¾¨ï§¼çš„è¡¨æ ¼è§£ç¢¼å™¨æˆ–æè¿°å™¨è€Œé€ æˆç³»çµ±ï¥§æ­£å¸¸çµæŸ(Crash)ã€‚
åœ¨æœªï¤­å‰©é¤˜çš„æ™‚é–“ï¼Œå°‡ç¹¼çºŒå®Œæˆæœªå®Œæˆçš„è§£ç¢¼å™¨ï¼Œèˆ‡å…¶ä»–å­ç³»çµ±é€²ï¨ˆæ•´åˆï¼Œä¸¦æ’°
å¯«ï¤å¤šæ¸¬è©¦æ¡ˆï¦µ(ç›®å‰æœ‰ 21 å€‹æ¸¬è©¦æ¡ˆï¦µ)ä»¥å¢åŠ ç¨‹å¼çš„å¯é ï¨ã€‚ 
 7
ETSI TS 102 471 v1.2.1 (2006-11) (ESG) 
[9] Digital Video Broadcasting (DVB); IP Datacast over DVB-H: Content Delivery Protocols, ETSI 
TS 102 472 v1.2.1 (2006-12) (RTP/FLUTE) 
[10] Digital Video Broadcasting (DVB); IP Datacast over DVB-H: Content Delivery Protocols (CDP) 
Implementation Guidelines, ETSI TS 102 591 V1.1.1 (2007-10) 
[11] G. Faria, J. A. Henriksson, E. Stare, and P. Talmola, â€œDVB-H: digital broadcast services to 
handheld devices,â€ Proceedings of the IEEE, vol. 94, no. 1, pp. 194 - 209, Jan. 2006. 
[12] ISO/IEC International Standard 11172-1, Information technology â€“ Coding of moving pictures 
and associated audio for digital storage media up to about 1.5 Mbits/s â€“ Part 1: Systems, first 
edition, Aug. 1993. 
[13] ISO/IEC 13818-1, Information technology â€“ Generic coding of moving pictures and associated 
audio information: Systems, Part 1, April 1996. 
[14] ISO/IEC 13818-2, Information technology - Generic coding of moving pictures and associated 
audio information: Video. 
[15] ISO/IEC 13818-3, Information technology - Generic coding of moving pictures and associated 
audio information - Part 3: Audio. 
[16] ISO/IEC 10646-1, Information technology - Universal Multiple-Octet Coded Character Set (UCS) 
- Part 1: Architecture and Basic Multilingual Plane. 
[17] M. Kornfeld and G. May, â€œDVB-H and IP datacastï¼broadcast to handheld devices,â€ IEEE Trans. 
Broadcasting, vol. 53, no. 1, pp.161- 170, March 2007. 
[18] æ¥Šå£«è±ã€å°¤ä¿¡ç¨‹ã€é™³å‰å‡±ï¼Œã€Œï¥©ä½é›»è¦–ä¹‹å¤šåª’é«”æŠ€è¡“ã€ï¼Œå…¨è¯åœ–æ›¸ï¼Œ 2007ã€‚ ISBN 
978-957-21-5914-9ã€‚ 
è¡¨ Y04 
è¡Œæ”¿é™¢åœ‹å®¶ç§‘å­¸å§”å“¡æœƒè£œåŠ©åœ‹å…§å°ˆå®¶å­¸è€…å‡ºå¸­åœ‹éš›å­¸è¡“æœƒè­°å ±å‘Š 
                                                          99 å¹´ 6 æœˆ 25 æ—¥ 
å ±å‘Šäººå§“å æ²ˆæ”¿æ–‡ æœå‹™æ©Ÿæ§‹ åŠè·ç¨± 
åœ‹ç«‹å°åŒ—ç§‘æŠ€å¤§å­¸ 
è³‡è¨Šå·¥ç¨‹ç ”ç©¶æ‰€åšå£«ç­äº”å¹´ç´š 
æ™‚é–“ 2010/06/23 â€“ 2010/06/25 æœƒè­° åœ°é» Chengdu, China 
æœ¬æœƒæ ¸å®š 
è£œåŠ©æ–‡è™Ÿ  
æœƒè­°åç¨± 2nd International Conference on Software Engineering and Data Mining (SEDM2010) 
ç™¼è¡¨è«– 
æ–‡é¡Œç›® GUI Test-Case Generation with Macro-Event Contracts 
 
ä¸€ã€ åƒåŠ æœƒè­°ç¶“é 
ICIS 2010 (International Conference on Information Sciences and Interaction 
Sciences) & SEDM 2010 (2nd International Conference on Software Engineering and 
Data Mining )æ˜¯ç”±éŸ“åœ‹ä¸»è¾¦ã€å››å·å”è¾¦çš„ç¬¬äºŒå±†åœ‹éš›è»Ÿé«”å·¥ç¨‹èˆ‡è³‡æ–™æŒ–æ˜å­¸è¡“ç ”è¨
æœƒ (http://www.aicit.org/icis2010/)ï¼Œä¸»è¦æ”¶éŒ„ Software Engineering (å¦‚ software 
developmentã€ software testing, test case selection)ã€åŠ Data Mining (å¦‚ business 
intelligenceã€fuzzy neural networkã€genetic algorithm ç­‰)ç›¸é—œè«–æ–‡ï¼Œå ±å‘Šæ–¹æ³•åˆ†ç‚º oral
åŠ posterï¼Œè«–æ–‡é›†ç‚ºç”± IEEE å‡ºç‰ˆ (http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=5510904)ï¼Œ
æä¾› EI å’Œ ISTP æª¢ç´¢ã€‚ 
SEDM 2010 æœƒ è­° å ´ æ‰€ èˆ‰ è¾¦ åœ¨ å›› å· çœ æˆ éƒ½ å¸‚ ä¸‰ ç’° è·¯ ä¸Š çš„ æœ› æ±Ÿ è³“ é¤¨ 
(http://www.wangjianghotel.com/)ï¼Œç‚ºä¸€é–“äº”æ˜Ÿç´šçš„é£¯åº—ï¼Œä½æ–¼æˆéƒ½å¸‚æ±éš…ï¼Œè·å¸‚ä¸­
å¿ƒå¤©åºœå»£å ´ 5 å…¬é‡Œï¼Œç«è»Šç«™ 9 å…¬é‡Œï¼Œé£›æ©Ÿå ´ 15 å…¬é‡Œã€‚é€™ä¸‰å¤©è¡Œç¨‹çš„åƒä½éƒ½æ˜¯åœ¨æœ›
æ±Ÿè³“é¤¨ï¼Œä¸»è¦æä¾›ä¸­å¼çš„è‡ªåŠ©é¤ï¼Œå£å‘³èˆ‡å°ç£çš„é‚„ç®—ç›¸ä¼¼ï¼Œå€’ä¹Ÿåƒçš„ç¿’æ…£ã€‚ 
æˆ‘æ˜¯å¾ 06/23 æ—©ä¸Šå…­é»å¤šç”±æ¡ƒåœ’æ©Ÿå ´å‡ºç™¼ï¼Œåˆ°é¦™æ¸¯ç­‰å€™è½‰æ©Ÿï¼Œä¹‹å¾Œæ‰é£›åˆ°æˆéƒ½
æ©Ÿå ´ï¼Œåœ¨æ©Ÿå ´æ­ä¹˜è¨ˆç¨‹è»Šè‡³æœ›æ±Ÿè³“é¤¨ï¼Œåˆ°é”æœƒå ´å·²ç¶“æ˜¯ä¸­åˆçš„æ™‚é–“ï¼Œæ­¤æ™‚å¤§æœƒå·²èˆ‰
è¡Œå®Œé–‹å¹•å„€å¼ï¼Œå·²ç¶“æ˜¯å„é ˜åŸŸå…ˆé€²çš„ keynote æ¼”è¬›ã€‚keynote æ¼”è¬›çµæŸä¹‹å¾Œï¼Œå·²ç¶“æ˜¯
æ™šé¤æ™‚é–“ï¼Œä¹‹å¾Œ check-in å…¥ä½æˆ¿é–“ä¼‘æ¯ï¼ŒçµæŸç¬¬ä¸€å¤©çš„è¡Œç¨‹ã€‚ç¬¬äºŒåŠç¬¬ä¸‰å¤©å‰‡æ˜¯åƒ
èˆ‡æœ‰èˆˆè¶£çš„å ´æ¬¡ï¼Œæˆ‘çš„è«–æ–‡å ±å‘Šæ˜¯å®‰æ’åœ¨ç¬¬ä¸‰å¤©æ—©ä¸Š Session B6 (09:00~10:30)ï¼Œé€²
è¡Œ 15 åˆ†é˜çš„ç°¡å ±ã€‚ç”±æ–¼å›ç¨‹ç­æ©Ÿçš„æ™‚é–“é—œä¿‚ï¼Œå› æ­¤æˆ‘å ±å‘Šå®Œè‡ªå·±çš„è«–æ–‡ä¹‹å¾Œï¼Œå°±
ç›´æ¥ check-out é›¢é–‹æœ›æ±Ÿè³“é¤¨ï¼Œå»æˆéƒ½æ©Ÿå ´æ­æ©Ÿè‡³é¦™æ¸¯è½‰æ©Ÿï¼Œå†å›ä¾†å°ç£æ¡ƒåœ’æ©Ÿå ´
å·²ç¶“æ˜¯æ™šä¸Šä¸ƒé»å¤šäº†ï¼Œè‡³æ­¤çµæŸé€™ä¸‰å¤©çš„è¡Œç¨‹ã€‚ 
 
äºŒã€ èˆ‡æœƒå¿ƒå¾— 
åƒèˆ‡ç ”è¨æœƒçš„è«–æ–‡ä½œè€…ä¸»è¦æ˜¯ä¾†è‡ªå°ç£ã€ä¸­åœ‹ã€éŸ“åœ‹ã€æ—¥æœ¬ã€å°åº¦ï¼Œç”±æ–¼å¤§æœƒ
å·¥ä½œäººå“¡ç‚ºæˆéƒ½ã€Œé›»å­ç§‘æŠ€å¤§å­¸ã€å­¸ç”Ÿï¼Œè¬›çš„æ˜¯ä¸­æ–‡ï¼Œæ‰€ä»¥èªè¨€æºé€šä¸Šä¹Ÿå°±æ–¹ä¾¿è¨±
é™„ä»¶ä¸‰
 
è¡¨ Y04 
é©—ã€‚ 
 
ä¸‰ã€ è€ƒå¯Ÿåƒè§€æ´»å‹•(ç„¡æ˜¯é …æ´»å‹•è€…çœç•¥) 
ç„¡ 
 
å››ã€ å»ºè­° 
ç„¡ 
 
äº”ã€ æ”œå›è³‡æ–™åç¨±åŠå…§å®¹ 
ï¬ SEDM 2010 ç ”è¨æœƒè«–æ–‡é›†é›»å­æª”ä¸€ä»½ 
ï¬ 4 GB USB éš¨èº«ç¢Ÿä¸€ä»½ã€‚ 
 
å…­ã€ å…¶ä»– 
ç„¡ 
 
 
GUI Test-Case Generation with Macro-Event Contracts
Woei-Kae Chen and Zheng-Wen Shen
Department of Computer Science and Information Engineering
National Taipei University of Technology
Taipei, Taiwan
Email: {wkchen, s4599003}@ntut.edu.tw
Abstractâ€”To perform a comprehensive GUI testing, a large
number of test cases are needed. This paper proposes a GUI
test-case generation approach that is suitable for system testing.
The key idea is to extend high-level GUI scenarios with contracts
and use the contracts to infer the ordering dependencies of
the scenarios. From the ordering dependencies, a state machine
of the system is constructed and used to generate test cases
automatically. A case study is conducted to investigate the quality
of the test cases generated by the proposed approach. The results
showed that, in comparison to creating test cases manually, the
proposed approach can detect more faults with less human effort.
Keywordsâ€”GUI testing, test-case generation, contract-based
testing, event contract, system testing
I. INTRODUCTION
GUI (Graphical User Interface) testing plays an important
role in ensuring the correctness of GUI-based applications [1]â€“
[5]. A GUI is driven by events. A primitive event is triggered
when a user interacts with a GUI widget such as a button,
textï¬eld, etc. Typical primitive events are clicking a button,
selecting an item from a list, etc. In general, testing a GUI is
accomplished by developing a set of GUI test cases (or test
scripts), which are composed of sequences of primitive events
and assertions. The test cases can be automatically executed
to test whether the GUI behaves correctly [6]â€“[9].
For an application with GUI, it is important to test the GUIâ€™s
use-case operation scenarios thoroughly, because use cases are
high-level functions of the application and are a good basis for
system testing [10]. A sophisticated GUI has a large number
of widgets and usually supports a lot of use-case operation
scenarios. In general, testing the correctness of a particular
operation scenario is accomplished by developing a test case
that exercises the scenario. However, given ğ‘› distinct operation
scenarios, the number of legal execution orders of all the
scenarios can be as large as ğ‘›!. It is very difï¬cult to create all
different combinations of execution orders by hand. Therefore,
automatic test-case generation approaches are desired.
Nebut et al. [10] proposed a contract-based approach for
automatic system testing. The idea is to extend use cases
with contracts (preconditions and postconditions) so that the
execution order of the use cases can be inferred automatically.
They used the ordering information to build UCTS (Use Case
Transition System), which represents the transitions between
use cases. A UCTS is like a use-case-level state diagram of the
software application. It can be used to generate test cases for
all the valid sequences of use cases to check their consistency
and correctness.
This paper extends Nebut et al.â€™s approach to the case
of system-level GUI testing. The idea is to replace use-case
contracts with GUI event contracts, i.e., deï¬ne contracts for
GUI events, infer the ordering of events, build ETS (Event
Transition System), and then use ETS to generate GUI test
cases. However, a primitive event is not a good candidate for
the extension of contracts, because a system testing focuses on
high-level operation scenarios, not low-level primitive events.
Fortunately, an earlier work of our research proposed the
concept of component abstraction [8], which can encapsulate
high-level GUI operation scenarios in macro events. Therefore,
extending macro events with contracts becomes an attractive
approach.
We propose a method to extend macro events with the
support of contract deï¬nitions, and describe the algorithms
that can generate ETS and test cases. We use three GUI-
based applications to study the quality of the test cases
generated by the proposed approach. The results showed that
automatic GUI test-case generation with macro-event contracts
is feasible, and, in comparison to creating test cases manually,
the proposed approach can detect more faults with less human
effort.
The rest of the paper is organized as follows. Section II
describes the proposed approach. Section III uses three GUI-
based applications to study the test cases generated by the
proposed approach. Section IV discusses related work and
Section V concludes the paper.
II. THE PROPOSED APPROACH
We will introduce component abstraction, macro-event con-
tracts proposed in this paper, the algorithm that builds ETS,
and test-case generation algorithms.
A. Component Abstraction
Component abstraction [8] is a way of organizing GUI test
cases (scripts). With component abstraction, an applicationâ€™s
GUI is modeled as a macro model consisting of hierarchical
objects (called macro components), which have attributes
(states of widgets) and behaviors (called macro events). An
important characteristic of component abstraction is that high-
level GUI operation scenarios can be modeled as macro
events. Therefore, macro events are perfect for the extension
of contracts. To save space, we will only brieï¬‚y describe
component abstraction. Please refer to [8] for more details.
A group of strongly related widgets in a GUI is considered
a macro component. For example, the menu of Crossword
145
the targets for the deï¬nition of contracts. In general, a tester
can break an operation scenario into a series of sub-scenarios
and, conversely, group a few consecutive scenarios into a
bigger one. Therefore, the number of top-level macro events
(scenarios) is adjustable. For example, instead of AddWord
(line 43), BeginAddWord (line 44), SelectSqaure (line
45), SelectWord (line 46), and AddClue (line 47) can be
promoted to the top-level and considered as use-case operation
scenarios. Such a promotion will increase the number of
top-level macro events and, thus, the number of contracts.
In Section III, we will study how the number of contracts
inï¬‚uences the quality of the test cases generated by the
proposed approach.
B. Macro-Event Contracts
We now present a technique to express the ordering con-
straints existing between macro events. Each macro event is
given a contract (i.e., precondition and postcondition) in the
form of logical expressions, which can be used to infer the
ordering of the macro events. The technique is similar to the
use-case contract proposed in [10], but is adapted so that it is
suitable for GUI testing.
In a GUI, whether a macro event is executable depends
on the state of the application. For example, the macro event
SelectSquare (line 16 of Fig. 3) can only be executed after
BeginAddWord (line 25). The condition (state) that allows
the execution of a macro event is called the precondition of
the macro event. After the macro event is executed, the state
of the application is changed. The condition of the new state is
called the postcondition of the macro event. Formally, a macro
event contract is deï¬ned as follows.
Deï¬nition 1 (Macro event contract): Let ğ¸ be a macro
event. The contract of ğ¸ is the precondition ğ‘ƒ and postcondi-
tion ğ‘„ such that the execution of ğ¸ must start in a state where
ğ‘ƒ holds and will terminate in a state where ğ‘„ holds.
When the precondition of a macro event ğ‘¥ satisï¬es the
postcondition of another macro event ğ‘¦, ğ‘¥ can be executed
after ğ‘¦. We call such a relationship an ordering dependency
between macro events.
To simplify the development of event contracts, we use a
set of state attributes to represent the state of a GUI. A state
attribute is an identiï¬er (string) used to indicate a particular
condition (fact) of a state. For example, the state set {START}
can be used to represent the initial state of Crossword Sage,
where START is a state attribute indicating that the application
has been started. Suppose the macro event AddWord_FOUL
(line 6 of Fig. 4) is executed to add the word â€œFOULâ€ to the
puzzle, then the state set becomes {START, WORD_FOUL},
indicating that the application has been started and the word
â€œFOULâ€ has been added. In other words, when a macro event
is executed and the applicationâ€™s state is changed, the state
change is expressed by adding and/or removing state attributes.
A precondition or postcondition is written in a ï¬rst-order
logical expression combining predicates with logical operators
(AND, OR, and NOT). A predicate can be used to assert
the existence of a particular state attribute. For example,
1 Component CrosswordSage {
2 . . .
3 @PRE e x i s t (NEW PUZZLE) && ! e x i s t (WORD FOUL)
4 @ACT add (WORD FOUL)
5 @POST e x i s t (WORD FOUL)
6 Event AddWord FOUL ( ) {
7 // Add the word "FOUL" (puzzle of Fig. 1)
8 AddWord ("5_2_5_5" , "FOUL" ,
9 "A ball hit out of bounds." ) ;
10 }
11 . . .
12 }
Fig. 4. The contract of AddWord_FOUL macro event
TABLE I
EXAMPLE MACRO-EVENT CONTRACTS FOR CROSSWORD SAGE
Macro Event Precondition Action Postcondition
NewPuzzle !exist(S1) add(S1) exist(S1)
PrintPuzzle exist(S1) exist(S1)
AddWord BASE exist(S1) && !exist(S2) add(S2) exist(S2)
AddWord FOUL exist(S1) && !exist(S3) add(S3) exist(S3)
Note: S1 â‰¡ NEW PUZZLE; S2 â‰¡ WORD BASE; S3 â‰¡ WORD FOUL
the predicate exist(C) evaluates to true if the current
state of the application contains the state attribute C. Fig. 4
shows an example contract (lines 3-5) for the macro event
AddWord_FOUL. In the example, the precondition (@PRE)
is that the state attribute NEW_PUZZLE must exist and the state
attribute WORD_FOUL does not, i.e., a puzzle has been created
and the word â€œFOULâ€ has not been added yet. The postcon-
dition (@POST) requires that the state attribute WORD_FOUL
exists, i.e., after the execution of AddWord_FOUL, the word
â€œFOULâ€ has been added to its target position.
The precondition and postcondition of a contract specify
the state attributes that are required before and after a macro
event is executed. In order to make the transition from a
certain precondition to its postcondition explicit, a macro event
contract also includes an action (@ACT) statement, which uses
add and remove operators to manipulate state attributes.
For example, the ACT statement (line 3) in Fig. 4 means
that when AddWord_FOUL is executed, a new state attribute
WORD_FOUL is added to the state set of the application.
Therefore, the postcondition is satisï¬ed.
Table I shows the contracts of four macro-events for Cross-
word Sage. The contracts are very simple, but enough to reveal
the ordering dependencies between these macro events. For
example, no macro events can be executed before the execution
of NewPuzzle; PrintPuzzle can be executed even if no
words have been added (an empty puzzle can be printed); the
same word can not be added twice. A directed graph showing
the ordering dependencies of the macro events is given in
Fig. 5. The algorithm that produces such a graph will be
described in the next subsection.
C. ETS: Event Transition System
Deï¬ning contracts for each macro event allows the ordering
dependencies among macro events to be inferred. A represen-
tation of the valid transitions of the macro events can be built
147
TABLE II
BASIC INFORMATION AND TEST CASES OF THE AUTS
WP CS SM
Basic Information
LOC 1508 7991 12796
Primitive Events 81 126 302
Manual (test cases prepared manually)
Test Cases 44 39 430
Total Size 1046 656 4996
High (test cases generated from High model)
Operation Scenarios 27 28 33
ETS States 1024 2337 609
ETS Transitions 768 13394 91033
Test Cases 512 1168 3024
Total Size 24576 33872 347088
Low (test cases generated from Low model)
Operation Scenarios 5 7 13
ETS States 32 48 144
ETS Transitions 80 128 416
Test Cases 16 24 72
Total Size 2352 2736 20708
ETS. The results, called High test cases and Low test cases,
are shown in Table II. For example, SMâ€™s High test cases has
33 operation scenarios (contracts), from which an ETS with
609 states and 91033 transitions is produced; and the ETS is
used to generate 3024 test cases that contains a total of 347088
primitive events.
From Table II, a High model ETS is signiï¬cantly larger
than a corresponding Low model ETS and, not surprisingly,
the size of the generated test cases shares the same trend. In
comparison to Manual test cases, both High and Low test cases
have a much larger size. For example, the total size of SMâ€™s
High test cases is 63 (347088 Ã· 4996) times larger than its
Manual test cases. Therefore, in terms of size, the proposed
approach does produce larger test cases, and to manually create
test cases of comparable size is obviously expensive.
The results of Table II indicated that using the proposed
approach is practical and a large number of GUI test cases
can be generated. However, do the test cases detect faults?
We will address this question in the next subsection.
B. Fault Detection
We use mutation [22], [23] technique to evaluate the quality
of each set of test cases. The process is outlined in Fig. 6. A
mutant generator is used to generate a number of mutants from
each AUT. Each mutant is a copy of the AUT with an injected
fault. The original AUT is considered a defect-free (golden)
version and its mutants are defective ones. We use the original
AUT to obtain the test oracle (expected results) of the test
cases. Each test case is executed on each mutant. A mutant
is killed if there is a mismatch between the mutantâ€™s GUI
state and the corresponding test oracle. Therefore, a set of test
cases is considered better when it can kill more mutants. The
number of killed mutants for each set of test cases is recorded.
The fault-detection rate for a set of test cases is computed as:
fault-detection rate =
number of killed mutants
total number of mutants
Fig. 6. The process of mutation analysis
TABLE III
THE NUMBER OF MUTANTS FOR EACH AUT
Mutation type WP CS SM
AODU 10 NA NA
AOIS 10 10 10
AOIU 10 10 10
AORB 10 10 10
AORS 10 10 10
ASRS 10 NA 10
COI 10 10 10
COR 10 NA 10
LOI 10 10 10
ROR 10 10 10
TOTAL 100 70 90
We use MuJava [24], a popular mutant generator, to produce
mutants. To keep the overall test-case execution time within a
reasonable time period, the total number of mutants must be
limited. Our choice was to randomly take 10 mutants from all
the different mutation types supported by MuJava. However,
depending on the nature of the AUTâ€™s source code, some types
of mutants are not available. Overall, a total of 100, 70, and
90 mutants are generated for WP, CS, and SM, respectively.
Table III shows the types and the number of mutants used in
our experiments.
Table IV shows the experimental results, including the
number of mutants that are killed and the fault-detection rate
for each set of test cases. For example, CSâ€™s High test cases
killed 63 out of 70 mutants, i.e., a fault-detection rate at about
90% (63/70). From Table IV, for all three AUTs, Manual
test cases detected less faults. Fig. 7 uses Venn diagrams to
illustrate the relationships of the faults detected by the three
sets of test cases. From Fig. 7, a mutant killed by Manual
test cases is always killed by High test cases, and almost
always killed by Low test cases (with two exceptions shown
in Fig 7(a)). The results suggested that, in comparison to
preparing test cases manually, the proposed approach is highly
effective in detecting faults.
In the experiments, all faults detected by Low test cases
149
