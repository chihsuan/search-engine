 2
ä¸€ã€ç°¡ä»‹ 
åœ¨æ™®åŠè¨ˆç®—(Pervasive computing)ã€ç„¡æ‰€ï¥§åœ¨è¨ˆç®—(Ubiquitous computing)æˆ–ç’°å¢ƒæ™ºæ…§
(Ambient intelligence)ç­‰ç ”ç©¶ï¦´åŸŸä¸­ï¼Œæƒ…å¢ƒæ„ŸçŸ¥è¨ˆç®—(Context-aware computing)æ˜¯ä¸€é …ç›¸ç•¶é‡
è¦çš„ç ”ç©¶ä¸»é¡Œã€‚æƒ…å¢ƒæ„ŸçŸ¥ç³»çµ±(Context-aware system)çš„ä¸»è¦ç›®çš„æ˜¯å¸Œæœ›é”åˆ°è‡ªå‹•æ„ŸçŸ¥ä½¿ç”¨è€…
çš„å³æ™‚åœ°é»ã€ï§ºæ³ï¼Œç”¨ä»¥é æ¸¬æˆ–åˆ¤æ–·ä½¿ç”¨è€…çš„æ„åœ–æˆ–éœ€æ±‚ï¼Œç„¶å¾Œé©æ™‚ã€é©åœ°çš„æä¾›é©ç•¶å¯
ï¨ˆçš„æœå‹™ã€‚åœ¨æ‡‰ç”¨æ–¹é¢ï¼Œä¸»è¦çš„æƒ…å¢ƒæ„ŸçŸ¥ç³»çµ±åŒ…æ‹¬æœ‰å®¶åº­ç”Ÿæ´»(Smart home)ã€å±…å®¶å®‰å…¨(Home 
security)ã€è¾¦å…¬ç’°å¢ƒ(Smart Office)ã€å¥åº·ç…§è­·(Health care)ã€è³¼ç‰©å¨›ï¤”ã€æ–‡åŒ–è—è¡“å±•æ¼”èˆ‡æ¬£è³
åŠï¨ˆå‹•å­¸ç¿’(Mobile e-learning)ç­‰ï¨¢å¤šï¦´åŸŸã€‚ 
ç‚ºï¦ºè§£æ±ºç³»çµ±å»ºæ§‹ï¥§ï§ ï¼Œä»¥åŠé¿å…ç‰¹å®šç¡¬é«”è¨­å‚™èˆ‡é–‹ç™¼è»Ÿé«”çš„ç›¸å®¹æ€§å•é¡Œï¼Œä¸€èˆ¬åŒ–æƒ…
å¢ƒæ„ŸçŸ¥ç³»çµ±æœå‹™å¹³å°(Generalized Service platform)æ˜¯è¿‘ï¦ï¤­çš„ä¸»è¦ç ”ç©¶è­°é¡Œä¹‹ä¸€ï¼›è€Œæœ‰é—œæƒ…
å¢ƒæ„ŸçŸ¥ç³»çµ±æœå‹™å¹³å°çš„å•é¡Œä¸­ï¼Œæˆ‘å€‘ç™¼ç¾ç„¡ï¥æœ‰é—œæƒ…å¢ƒè³‡ï¦¾çš„æ“·å–(Context extraction)èˆ‡è§£
è­¯(Context interpretation)ã€ç³»çµ±æœå‹™çš„é©…å‹•(Service activation)èˆ‡è§¸ç™¼(Trigger)ï¼Œæˆ–æ˜¯ç³»çµ±ä¸­
æƒ…å¢ƒè¡çª(Context conflict)çš„æ„ŸçŸ¥åµæ¸¬èˆ‡å„ç¨®æƒ…å¢ƒï¥§ä¸€è‡´(Context inconsistency)çš„èªçŸ¥ç­‰ç ”
ç©¶å­é¡Œï¼Œå‡æ˜¯éå¸¸å€¼å¾—æ·±å…¥æ¢è¨çš„è­°é¡Œã€‚æœ¬è¨ˆç•«æ–¼ 98 ï¦ï¨è¨ˆç•«ä¸­ï¼Œæå‡ºã€Œä¸€èˆ¬åŒ–æ™ºæ…§å‹æƒ…
å¢ƒæ„ŸçŸ¥ç³»çµ±æ¶æ§‹ã€(åœ– 1)ï¼Œä¸¦æå‡ºç¢ºå¯¦æœ‰æ•ˆæ”¹é€²æƒ…å¢ƒè§£è­¯å™¨çš„å»ºæ§‹å·¥å…·èˆ‡æ–¹æ³•ã€‚æœ¬ï¦ï¨è¨ˆç•«
å»¶çºŒæ‰€æå‡ºçš„æ¶æ§‹ä¸­æœªå®Œæˆçš„æƒ…å¢ƒç®¡ï§¤(Context manager)éƒ¨ä»½ï¼Œæ§‹å»ºï¥§ä¸€è‡´æƒ…å¢ƒçš„ç®¡ï§¤æ¨¡
çµ„ã€‚ 
 
 
åœ– 1: ä¸€èˆ¬åŒ–æƒ…å¢ƒæ„ŸçŸ¥æœå‹™ç³»çµ±å¹³å° 
 
äºŒã€ç ”ç©¶ç›®çš„ 
æœ¬è¨ˆç•«ç‚ºå»¶çºŒ 98 ï¦ï¨ä¹‹è¨ˆç•«æ¡ˆï¼Œä»¥ç”¨å®Œæˆæ‰€æå‡ºçš„ã€Œä¸€èˆ¬åŒ–æ™ºæ…§å‹æƒ…å¢ƒæ„ŸçŸ¥ç³»çµ±æ¶æ§‹ã€
(åœ– 1)ç‚ºä¸»è¦ç›®æ¨™ï¼›æœ¬ç¬¬äºŒï¦è¨ˆç•«çš„ä¸»è¦ç›®çš„å‰‡æ˜¯ç ”ç©¶æœ‰é—œæƒ…å¢ƒå”èª¿èˆ‡ç®¡ï§¤çš„ä¸»é¡Œã€‚æƒ…å¢ƒå”
èª¿èˆ‡ç®¡ï§¤çš„å¿…è¦æ€§åœ¨æ–¼éš¨è‘—ç’°å¢ƒä¸­æ„ŸçŸ¥å™¨çš„ï§åˆ¥èˆ‡ï¥©ç›®å¢åŠ ï¼Œæœƒé€ æˆå¯¦éš›æƒ…å¢ƒèˆ‡æƒ…å¢ƒè³‡è¨Š
çš„ï¥§ä¸€è‡´ï¼Œå°è‡´æƒ…å¢ƒæ„ŸçŸ¥ç³»çµ±ä¸­æƒ…å¢ƒè³‡è¨Šçš„æ­£ç¢ºæ€§åŠå¯é æ€§ï¨‰ä½ï¼›é™¤æ­¤ä¹‹å¤–ï¼Œç³»çµ±åŒä¸€æ™‚
é–“ä¹Ÿå¯èƒ½ç™¼ç”Ÿï¥©å€‹æƒ…å¢ƒåŒæ™‚éœ€è¦è§¸ç™¼ç›¸åŒæœå‹™çš„ï§ºæ³ï¼Œæ­¤æ™‚æœƒç™¼ç”Ÿæƒ…å¢ƒè¡çªçš„å•é¡Œã€‚æœ¬è¨ˆ
ç•«ä¸»è¦æå‡ºä¸€åˆ†å±¤å¼æƒ…å¢ƒç®¡ï§¤æ¶æ§‹ï¼Œé‡å°ï¥§åŒçš„æƒ…å¢ƒè³‡è¨Šå±¤æ¬¡ï¼Œæå‡ºï¥§åŒçš„ï¥§ä¸€è‡´æƒ…å¢ƒè³‡
è¨Šè§£æ±ºç­–ï¥¶ï¼Œç”¨ä»¥æ”¹å–„ç³»çµ±å¯èƒ½ç™¼ç”Ÿï¥§ä¸€è‡´æƒ…å¢ƒæ™‚ æ‰€å°è‡´çš„ç³»çµ±æ­£ç¢ºæ€§èˆ‡å¯é æ€§çš„å•é¡Œï¼Œ
æå‡æƒ…å¢ƒæ„ŸçŸ¥æœå‹™çš„å“è³ªèˆ‡æ”¹é€²æœå‹™ç³»çµ±çš„æ•ˆèƒ½ï¼Œé”æˆæ™ºæ…§å‹æƒ…å¢ƒæ„ŸçŸ¥æœå‹™å¹³å°çš„ç›®æ¨™ã€‚ 
 
Service constructor  Context 
Interpreter 
Sensor Actuator Actuator Sensor
Service Provider 
Context constructor 
 
DeviceUsers Location
Domain 
knowledge 
Context 
Database 
Application 
Service 
Context Editor 
Service Editor 
 
 
Context 
Recognizer
Interpreter 
Generator 
Schema 
Mapper 
 
User 
Behavior 
Prediction 
Context Manager 
Context conflict detector
Context inconsistency 
detection/resolution 
 
Service  
Adaptor 
Generic Interpreter
 4
ç¤ºæ³•ï¼Œï¥´æœªï¤­ç³»çµ±é‡åˆ°ç›¸ä¼¼çš„æ¡ˆï¦µï¼Œå³å¯è‡ªå‹•åµæ¸¬å‡ºæƒ…å¢ƒè¡çªã€‚ 
ï® åŸºæ–¼åœ–å½¢(Graph-Based)çš„åµæ¸¬æ–¹å¼ï¼šå°‡è¦å‰‡èˆ‡é™åˆ¶æè¿°æˆåœ–å½¢ï¼Œæ‡‰ç”¨åœ–å‹æ¯”å°çš„æ–¹
å¼åˆ¤æ–·æ˜¯å¦æœ‰è¡çªçš„ï§ºæ³ã€‚ 
ï‚— æƒ…å¢ƒè¡çªè§£æ±ºç­–ï¥¶(Resolution): 
ï® æ¬Šé‡æ³•(Weight value): æ¬Šé‡æ³•æ˜¯é å…ˆé€éæ©Ÿå™¨å­¸ç¿’æˆ–äººç‚ºè¨­å®šæ¯å€‹æƒ…å¢ƒè³‡ï¦¾çš„æ¬Š
é‡ï¼Œï¦µå¦‚:ç™¼ç”Ÿé »ï¥¡é«˜ã€å–æ¨£é–“éš”å°ï¼Œå‰‡å¯èƒ½çµ¦äºˆé«˜æ¬Šé‡å€¼ï¼Œä¸¦è—‰æ­¤æ¬Šé‡ï¤­åˆ¤æ–·æ‡‰å¦‚
ä½•èª¿æ•´æœå‹™çš„æä¾›ã€‚ 
ï® å„ªå…ˆæ¬Š(Priority): å„ªå…ˆæ¬Šæ˜¯å°æ„ŸçŸ¥ç³»çµ±ä¸­ï¼Œæ¯ä¸€ä½å—æœå‹™çš„å°è±¡è¨­å®šæä¾›æœå‹™çš„å„ªå…ˆ
æ¬¡åºï¼Œï¦µå¦‚: ä¸€å€‹å®¶åº­çš„çˆ¶æ¯è¦ªæœƒæ¯”å°å­©æœ‰ï¤é«˜çš„å„ªå…ˆæ¬Šä½¿ç”¨æ„ŸçŸ¥ç³»çµ±æä¾›çš„æœå‹™ã€‚ 
ï® ä½¿ç”¨è€…é©…å‹•(User-driven): ç•¶ç³»çµ±ç„¡æ³•åˆ¤æ–·è©²å¦‚ä½•æä¾›æœå‹™æ™‚ï¼Œæ„ŸçŸ¥ç³»çµ±æœƒæä¾›ä½¿ç”¨
è€…å¹¾å€‹å•é¡Œé¸é …ï¼Œè®“ä½¿ç”¨è€…è‡ªï¨ˆåˆ¤æ–·è©²å¦‚ä½•èˆ‡å…¶ä»–ä½¿ç”¨è€…åšå‡ºå”èª¿æˆ–ä»¥å¤šï¥©æ±ºå®šã€‚ 
è¡¨ 1 èˆ‡è¡¨ 2 åˆ†åˆ¥ç‚ºæƒ…å¢ƒè¡çªåµæ¸¬èˆ‡æƒ…å¢ƒè¡çªè§£æ±ºæ–¹æ³•çš„å„ªç¼ºé»æ¯”è¼ƒã€‚ 
 
è¡¨ 1: æƒ…å¢ƒè¡çªåµæ¸¬æ–¹æ³•çš„å„ªç¼ºé» 
æƒ…å¢ƒè¡çªåµæ¸¬ å„ªé» ç¼ºé» 
Rule-Based 
ï¬ ï§ æ–¼ï§¤è§£èˆ‡è§£é‡‹æ¨å°å‡ºï¤­çš„ç­”æ¡ˆ ï¬ è€—è²»æ™‚é–“å»ºï§·è¦å‰‡ 
ï¬ è€—è²»é¾å¤§é‹ç®—æ™‚é–“ 
ï¬ è¦å‰‡åº«å¤§å°å½±éŸ¿ç³»çµ±æ•ˆï¥¡ 
Case-Based 
ï¬ æ ¹æ“šéå¾€çš„ç¶“é©—ï¼Œæ‡‰ç”¨é€™äº›ç¶“é©—
ï¤­è§£æ±ºç›¸ä¼¼å•é¡Œï¼Œï§ä¼¼ç¶“é©—æ³•å‰‡ 
ï¬ éœ€è¦æœ‰å¤§ï¥¾çš„æ¡ˆï¦µ 
Graph-Based 
ï¬ è¦–è¦ºåŒ– 
ï¬ ï§ æ–¼ï§¤è§£å•é¡Œ 
ï¬ éœ€è€—è²»é¾å¤§æ™‚é–“å»ºï§· Graph
ï¬ æ–°å¢ã€åˆªé™¤ç¯€é»çš„æˆæœ¬å¤ªé«˜
 
è¡¨ 2: æƒ…å¢ƒè¡çªè§£æ±ºç­–ï¥¶çš„å„ªç¼ºé» 
æƒ…å¢ƒè¡çªè§£æ±º å„ªé» ç¼ºé» 
Weight value 
ï¬ ä¾æ“šä½¿ç”¨è€…å–œå¥½å®šç¾© 
ï¬ å…·èª¿é©æ€§ï¼Œç›¡å¯èƒ½æœ€å¤§åŒ–åˆ†é…ç³»çµ±
è³‡æº 
ï¬ æ¬Šé‡å€¼é›£ä»¥æ‹¿æ 
ï¬ è³‡æºå¿…é ˆæœ‰æ‰€å–æ¨ï¼Œå¯èƒ½å°
è‡´æ‰€æœ‰ä½¿ç”¨è€…ï¨¦ï¥§æ»¿æ„ï§ºæ³
ç”¢ç”Ÿ 
Priority ï¬ ç°¡æ½” 
ï¬ æœ‰æ•ˆï¥¡ 
ï¬ ç¼ºä¹æ­£è¦çš„èªæ„è¡¨é” 
ï¬ ï¥§å…·å”èª¿èƒ½ï¦Š 
User-driven 
ï¬ ç¶“éäººï§æºé€šå”èª¿ï¼Œå¯å¾—åˆ°æœ€ä½³çµ
æœ 
ï¬ é•åæƒ…å¢ƒæ„ŸçŸ¥ç³»çµ±å¼·èª¿ç³»çµ±
ï¥§å¹²é ä½¿ç”¨è€…çš„åŸå‰‡ 
 
å››ã€ç ”ç©¶æ–¹æ³• 
æœ¬ç ”ç©¶æå‡ºä¸€åˆ†å±¤å¼æƒ…å¢ƒç®¡ï§¤æ¶æ§‹ï¼Œå¦‚åœ– 2 æ‰€ç¤ºã€‚ä¸»è¦çš„æƒ³æ³•æ˜¯ä½éšæƒ…å¢ƒè³‡è¨Šæœªè¢«åŒ¯
é›†æˆé«˜éšæƒ…å¢ƒå‰ï¼Œå¸¸å› è¨Šè™Ÿå¹²æ“¾æˆ–æ˜¯æ“ä½œèª¤å¤±é€ æˆä½éšæƒ…å¢ƒçš„ï¥§ä¸€è‡´ï¼Œå› æ­¤æ“šæ­¤åµæ¸¬å‡ºå…¶
ä¸­çš„ï¥§ä¸€è‡´æƒ…å¢ƒä¸¦äºˆä»¥è§£æ±ºï¼Œè€Œéåœ¨ä½éšæƒ…å¢ƒè³‡è¨Šè¢«åŒ¯é›†æˆé«˜éšæƒ…å¢ƒå¾Œæ‰ä¸€ä½µè™•ï§¤ã€‚å› ç‚º
ç•¶æƒ…å¢ƒè³‡è¨Šå±¤ç´šæ„ˆé«˜ï¼Œå…¶æŠ½è±¡åŒ–ç¨‹ï¨ä¹Ÿæ„ˆé«˜ï¼Œç¶­æŒä¸€è‡´æ€§éœ€è€—è²»çš„æˆæœ¬ä¹Ÿç›¸å°æå‡ã€‚è€Œåˆ†
å±¤è™•ï§¤çš„å„ªé»é™¤ï¦ºå‰è¿°çš„éƒ¨åˆ†å¤–ï¼Œäº¦å¯åˆ†æ•£å‚³çµ±é›†ä¸­å¼è¦å‰‡åº«çš„è² æ“”ï¼Œæ¸›å°‘å–®ä¸€è¦å‰‡åº«éœ€
æª¢æŸ¥çš„è¦å‰‡ï¥©ï¥¾ã€‚æ­¤æ¶æ§‹ä¸»è¦åŒ…å«ä¸‹ï¦œæ¨¡çµ„ï¼š 
ï¬ æƒ…å¢ƒè³‡è¨Šè§£è­¯å™¨(Context interpreter) 
ï¬ ä½éšä¸€è‡´æ€§ç®¡ï§¤æ¨¡çµ„(Low-Level consistency module) 
ï¬ é«˜éšä¸€è‡´æ€§ç®¡ï§¤æ¨¡çµ„(High-Level consistency module) 
ï¬ è¡çªé¿å…æ¨¡çµ„(Conflict-Free module) 
ï¬ å‘½ï¦¨è§£è­¯å™¨(Command interpreter) 
ä¸Šè¿°å„æ¨¡çµ„ä¹‹é‹ä½œï§Šç¨‹å¦‚ä¸‹ï¼š 
 6
ï¬ æœå‹™å±¤ä¹‹ä¸€è‡´æ€§ç®¡ï§¤æ¨¡å‹ï¼šè™•ï§¤å°è±¡æ˜¯ä»¥æœå‹™æƒ…å¢ƒè³‡è¨Šç‚ºä¸»ï¼Œä¸»è¦æ˜¯è§£æ±ºæœå‹™æƒ…å¢ƒèˆ‡
è³‡æºç™¼ç”Ÿè¡çªæ™‚çš„è§£æ±ºæ–¹å¼ã€‚ 
 
å››ã€å¯¦é©—çµæœèˆ‡è¨ï¥ 
ç‚ºï¦ºé©—è­‰æ‰€æå‡ºåˆ†å±¤å¼ï¥§ä¸€è‡´æƒ…å¢ƒæ¨¡å‹åŠæ–¹æ³•ä¹‹å¯ï¨ˆæ€§èˆ‡æ•ˆèƒ½ï¼Œæˆ‘å€‘è¨­è¨ˆï¥¸å€‹å¯¦é©—åˆ†
åˆ¥é‡å°æ„Ÿæ¸¬å±¤æƒ…å¢ƒè³‡è¨ŠåŠäº‹ä»¶å±¤æƒ…å¢ƒè³‡è¨Šçš„ä¸€è‡´æ€§ç®¡ï§¤é€²ï¨ˆè©•ä¼°èˆ‡æ¯”è¼ƒã€‚ç¬¬ä¸€å€‹å¯¦é©—æ˜¯æ„Ÿ
æ¸¬å±¤æƒ…å¢ƒè³‡è¨Šçš„ä¸€è‡´æ€§å¯¦é©—ã€‚ç¬¬äºŒå€‹å¯¦é©—æ˜¯äº‹ä»¶å±¤æƒ…å¢ƒè³‡è¨Šçš„ä¸€è‡´æ€§å¯¦é©—ï¼Œæ­¤å¯¦é©—é™¤æ„Ÿæ¸¬
å±¤æƒ…å¢ƒè³‡è¨Šå¤–ï¼ŒåŒæ™‚è€ƒæ…®äº‹ä»¶æƒ…å¢ƒè³‡è¨Šä¹‹ï¥§ä¸€è‡´çš„è§£æ±ºæ¼”ç®—æ³•ã€‚ 
ç¬¬ä¸€å€‹å¯¦é©—ä¸­ä½¿ç”¨ï¥¸çµ„äºŒå…ƒå‹æ…‹è³‡ï¦¾é›†ï¼Œè³‡ï¦¾é›†çš„ç›¸é—œç‰¹æ€§ï¥¯æ˜å¦‚ä¸‹ï¼š 
(1) åˆæˆè³‡ï¦¾é›†(Synthesized dataset, SD)ï¼šæ­¤è³‡ï¦¾é›†æ˜¯é€éè¯ç››é “å·ï§·å¤§å­¸äººå·¥æ™ºæ…§å¯¦é©—å®¤
å­¸è€… Cook æ’°å¯«çš„ Synthetic Data Generator æ‰€ç”¢ç”Ÿï¼Œå…§å®¹æ˜¯æ¨¡æ“¬ä¸€ä½ä½¿ç”¨è€…ç”Ÿæ´»åœ¨ä½ˆæœ‰
10 å€‹ï§ºæ…‹æ„Ÿæ¸¬å™¨çš„ç©ºé–“ä¸­ï¼Œæ„Ÿæ¸¬å™¨è¨˜ï¤¿ä½¿ç”¨è€…èˆ‡ç’°å¢ƒçš„äº’å‹•æƒ…å½¢å¾Œç”¢ç”Ÿçš„æ„Ÿæ¸¬å€¼ï¼ŒåŒ
æ™‚ï¼Œä¸¦æ¨™è¨˜(Annotate)ä½¿ç”¨è€…æ­£åœ¨é€²ï¨ˆçš„æ´»å‹•äº‹ä»¶ã€‚è³‡ï¦¾é›†çš„å–æ¨£æ™‚é–“ç‚º 1 åˆ†é˜ï¼ŒåŒ…å«
Breakfastã€Leaving homeã€Dinnerã€Watching TVã€Readingã€Sleepingï¼Œèˆ‡ Others ç­‰å…± 7
å€‹æ´»å‹•äº‹ä»¶ã€‚æ¯å€‹æ´»å‹•äº‹ä»¶å‡æœ‰ 28 å€‹æƒ…å¢ƒå¯¦ï¦µï¼Œä¸”å„æ´»å‹•äº‹ä»¶å°æ•´é«”çš„æ™‚é–“ä½”æœ‰ï¥¡å‡
ï¥§ç›¸åŒï¼Œæ¨¡æ“¬æœŸé–“å…± 28 å¤©ã€‚ 
(2) Kasteren è³‡ï¦¾é›†(Kasteren dataset, KD)ï¼šæ­¤è³‡ï¦¾é›†æ˜¯ç”±é˜¿å§†æ–¯ç‰¹ï¥å¤§å­¸æ™ºæ…§ç³»çµ±å¯¦é©—å®¤
å­¸è€… Kasteren æ‰€æä¾›ï¼Œç‚ºä¸€çœŸå¯¦æ´»å‹•è³‡ï¦¾ï¼Œå…§å®¹è¨˜ï¤¿ä¸€ä½ 26 æ­²çš„ç”·æ€§ç¨è‡ªç”Ÿæ´»åœ¨ä¸€å±¤
ä¸‰æˆ¿çš„å…¬å¯“ï¼Œç©ºé–“ä¸­ä½ˆæœ‰ 14 å€‹ï§ºæ…‹æ„Ÿæ¸¬å™¨è¨˜ï¤¿ä½¿ç”¨è€…èˆ‡ç’°å¢ƒçš„äº’å‹•æƒ…å½¢å¾Œç”¢ç”Ÿçš„æ„Ÿæ¸¬
å€¼ã€‚æ­¤è³‡ï¦¾é›†çš„å–æ¨£æ™‚é–“ç‚º 1 ç§’é˜ï¼ŒåŒ…å«æœ‰ Leavingã€Toiletingã€Showeringã€Sleepingã€
Breakfastã€Dinnerã€Drinkï¼Œèˆ‡ Others ç­‰å…± 8 å€‹æ´»å‹•äº‹ä»¶ï¼Œæ¯å€‹æ´»å‹•äº‹ä»¶çš„æƒ…å¢ƒå¯¦ï¦µï¥©
ï¥¾èˆ‡å°æ•´é«”çš„æ™‚é–“ä½”æœ‰ï¥¡äº¦ï¥§ç›¡ç›¸åŒï¼Œè³‡ï¦¾è¨˜ï¤¿æœŸé–“ç‚º 28 å¤©ã€‚ 
æˆ‘å€‘å°‡åˆ†åˆ¥æ¯”è¼ƒåŸå§‹è³‡ï¦¾(Raw data)èˆ‡ä½¿ç”¨ ÄˆRã€ÄˆLPï¼Œä»¥åŠ ÄˆCPé¿å…æ–¹æ³•æ–¼ SD èˆ‡ KD è³‡ï¦¾
é›†ä¸Šçš„ï¨ç¢ºï¨ï¼ŒåŠå„é¿å…æ–¹æ³•åœ¨ï¥§åŒé›œè¨Šä¸‹çš„ï¨ç¢ºï¨å¹³å‡å€¼(å…¶ä¸­ ÄˆR èˆ‡ ÄˆLPæ˜¯å–ï¥§åŒï¥«ï¥©ä¸‹
çš„ï¨ç¢ºï¨å¹³å‡å€¼)ã€‚ 
 
è¡¨ 3ï¼šå¯¦é©— 1 ä¹‹äºŒå…ƒå‹æ…‹ï¥§ä¸€è‡´æƒ…å¢ƒé¿å…æ–¹æ³•ä¹‹ï¥«ï¥©è¨­å®š 
Datasets ÄˆR ÄˆLP 
SD tmin = 1 sec     tmax = 1~10 secs tleast =1~10 secs 
KD tmin =100 ms   tmax = 100~1000 ms tleast =100~1000 ms 
 
æƒ…å¢ƒè³‡è¨Šçš„æ­£ç¢ºæ€§èˆ‡å¯é æ€§çš„è©•ä¼°æ–¹æ³•ä¸Šï¼Œæˆ‘å€‘æ¡ä½¿ç”¨æ™‚é–“ç‰‡æ®µï¨ç¢ºï¨(Time slice accuracy, 
AccT)èˆ‡ï§åˆ¥ï¨ç¢ºï¨(Class accuracy, AccC)ï¤­ä¼°ï¥¾ã€‚å…¶å®šç¾©å¦‚ä¸‹ï¼š 
N
tLtInferred
Acc
N
t
T
ïƒ¥
ï€½
ï€½
ï€½ 1
|)()(|
,   ïƒ¥ ïƒ¥
ï€½
ï€½
ï€½
ï€½
C
c c
N
t
c
C N
tLtInferred
C
Acc
c
1
1 )
|)()(|
(1 ; 
N ç‚ºæ™‚é–“ç‰‡æ®µçš„ç¸½ï¥©ï¥¾ï¼ŒInferred(t)ç‚ºç¬¬ t å€‹æ¨ï¥æ´»å‹•äº‹ä»¶ï¼ŒL(t)ç‚ºç¬¬ t å€‹æ­£ç¢ºæ´»å‹•äº‹ä»¶ï¼›C
ç‚ºï§åˆ¥ï¥©ï¥¾ï¼ŒNcç‚ºå„ï§æ´»å‹•äº‹ä»¶çš„æ™‚é–“ç‰‡æ®µï¥©ï¥¾ï¼ŒLc(t)ç‚ºç¬¬ c ï§çš„ç¬¬ t å€‹æ­£ç¢ºæ´»å‹•äº‹ä»¶ã€‚ 
 
å¯¦é©—çµæœï¼šéƒ¨åˆ†ç›¸é—œå¯¦é©—çš„æ™‚é–“ç‰‡æ®µï¨ç¢ºï¨(AccT)èˆ‡ï§åˆ¥ï¨ç¢ºï¨(AccC)çµæœå¦‚åœ– 3ã€åœ– 4ã€åœ–
5 æ‰€ç¤ºï¼Œè€Œå„ï¥§åŒé›œè¨Šæ¯”çš„å¹³å‡å€¼æ•´ï§¤å¦‚è¡¨ 4ã€‚å°æ–¼ç”±æ„ŸçŸ¥å™¨å±¤ä¹‹é›œè¨Šæ‰€ç”¢ç”Ÿçš„ï¥§ä¸€è‡´æƒ…
å¢ƒï¼Œç”±å¯¦é©—çµæœå¯ä»¥ç™¼ç¾ï¼Œç„¡ï¥åœ¨ SD èˆ‡ KD è³‡ï¦¾é›†ä¸­ï¼ŒÄˆRã€ÄˆLPï¼Œä»¥åŠ ÄˆCPåœ¨ï¨ç¢ºï¨å¹³å‡
å€¼ä¸Šçš„è¡¨ç¾ä»¥ ÄˆLPæœ€ä½³ï¼Œè€Œ ÄˆRèˆ‡ ÄˆCPçš„è¡¨ç¾åƒ…æœ‰äº›å¾®çš„å·®è·ï¼ŒåŸå› æ˜¯ ÄˆLPèƒ½æŠµæŠ—é›œè¨Šï¼Œä½†
ÄˆR èˆ‡ ÄˆCP ç„¡æ³•æŠµæŠ—é›œè¨Šã€‚ï¥´ç•¶ SD èˆ‡ KD è³‡ï¦¾é›†ï¥§åŒ…å«é›œè¨Šæ™‚ï¼Œå‰‡ä»¥ ÄˆCP æœ€ä½³ï¼Œè€Œ ÄˆR èˆ‡
ÄˆLPæœƒç›´æ¥å—å–æ¨£æ™‚é–“èˆ‡æ´»å‹•äº‹ä»¶æ™‚é–“é•·çŸ­æ‰€å½±éŸ¿ï¼Œå°è‡´ ÄˆRèˆ‡ ÄˆLPé ˆåˆ†åˆ¥åœ¨ SD èˆ‡ KD ä¸Šæ–¹
èƒ½ç²å¾—è¼ƒå¥½çš„çµæœã€‚ 
 
 8
ï¦¾æœ‰ 57,600 ç­†((24Ã—60Ã—60)/150Ã—100)ã€‚æ¯ç­†è³‡ï¦¾åŒ…å« 5 ç¨®æƒ…å¢ƒè³‡è¨Šï¼Œåˆ†åˆ¥æ˜¯äººå“¡å§“åã€ä½ç½®
æƒ…å¢ƒè³‡è¨Šã€æ´»å‹•æƒ…å¢ƒè³‡è¨Šã€å€‹äººè³‡ï¦¾èˆ‡ç’°å¢ƒæƒ…å¢ƒè³‡è¨Šï¼Œæ•…ç¸½æƒ…å¢ƒè³‡è¨Šï¥©ï¥¾ç‚º 288,000 ç­†
(57,600Ã—5)ã€‚åŒæ™‚ä¹Ÿè¨­å®š 8 ç¨®æœå‹™æƒ…å¢ƒï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 
S1ï¼šï¦æ€§ä½¿ç”¨è€…æ™šé–“ 7 é»å¾Œåœ¨å›å®¶ï¤·ä¸Šï¼Œï¥´ç¶“éçŠ¯ç½ªï¥¡é«˜çš„å€åŸŸï¼Œå‰‡çµ¦äºˆä¸€å€‹è­¦å‘Šã€‚ 
S2ï¼šä½¿ç”¨è€…åœ¨ pub é‡ï¨Šæœ‹å‹ï¼Œå‰‡é¡¯ç¤ºä¸€å€‹é‚€è«‹è¨Šæ¯ã€‚ 
S4ï¼šå°‹æ‰¾é™„è¿‘æ˜¯å¦æœ‰åç‚º Sandy çš„ä½¿ç”¨è€…ã€‚ 
S5ï¼šå°‹æ‰¾é™„è¿‘æ˜¯å¦æœ‰åç‚º Josephine çš„ä½¿ç”¨è€…èˆ‡ä½¿ç”¨è€…æ­£é€²ï¨ˆçš„æ´»å‹•æƒ…å¢ƒã€‚ 
S6ï¼šç•¶ä½¿ç”¨è€… Winifred åœ¨è¾¦å…¬å®¤æ™‚ï¼Œæé†’ä»–è¦å¯„å‡ºï¦çµ‚å ±å‘Šã€‚ 
S8ï¼šå°‹æ‰¾ Office-638.225 è¾¦å…¬å®¤ä¸­äººçš„ï¥©ï¥¾ã€‚ 
S14ï¼šï¥´ Dominic çš„ä½ç½®æƒ…å¢ƒæ˜¯åœ¨è¾¦å…¬å®¤ï¼Œå‰‡å°‡é¬§ï¦±è½‰ç‚ºéœ‡å‹•æ¨¡å¼ã€‚ 
S15ï¼šå°‹æ‰¾ä½¿ç”¨è€… Ida ç›®å‰ä½ç½®ä¸€ç™¾å…¬å°ºå…§ï¼Œï¤‚ä¸Šæœ‰å£…ï¥¬è­¦å‘Šçš„äººå“¡ä½ç½®ã€‚ 
å¯¦é©—è¨­å®šå¦‚ä¸‹ï¼šç‚ºï¦ºæ–¼ä»¥ä¸Šæ¸¬è©¦æ¨¡æ“¬ç’°å¢ƒä¸­ï¼Œï¦ºè§£ç™¼ç”Ÿï¥§ä¸€è‡´äº‹ä»¶ä¹‹æ™‚ï¼Œå°æœå‹™å“è³ªèˆ‡æ­£
ç¢ºæ€§çš„å½±éŸ¿ï¼Œä»¥åŠä½¿ç”¨æœ¬ï¥æ–‡ä¸­çš„è§£æ±ºæ–¹æ³•æ˜¯å¦èƒ½æœ‰æ•ˆè§£æ±ºï¥§ä¸€è‡´æƒ…å¢ƒä»¥æå‡æœå‹™å“è³ªèˆ‡
æ­£ç¢ºæ€§ï¼Œå‡è¨­æƒ…å¢ƒè³‡ï¦¾é›†æœ‰ä»¥ä¸‹çš„ï¥§ä¸€è‡´æƒ…å¢ƒåµæ¸¬è¦å‰‡ï¼š 
C1ï¼šä½¿ç”¨è€…ï¥§èƒ½åœ¨å·¥ä½œæ™‚é–“å…§ï§ªé–‹å·¥ä½œå ´æ‰€ã€‚ 
C2-C4ï¼šä½¿ç”¨è€…çš„æ´»å‹•æƒ…å¢ƒè³‡è¨Šå¿…é ˆç¬¦åˆåœ°é»æƒ…å¢ƒè³‡è¨Š Homeã€Office èˆ‡ Entertainmentã€‚ 
C5ï¼šä½¿ç”¨è€…ï¥§èƒ½åœ¨å¾ˆçŸ­çš„æ™‚é–“å…§ç”±ä¸€å€‹åœ°é»ç§»å‹•åˆ°å¦ä¸€åœ°é»ã€‚ 
C6-C12ï¼šä½¿ç”¨è€…æ´»å‹•æƒ…å¢ƒè³‡è¨Šçš„é€²ï¨ˆçš„é †åºï¼šC6 (Asleep to Working)ã€C7 (Working to 
Walking on the street)ã€C8 (Walking on the street to Going to work)ã€C9 (Going to 
work to At home)ã€C10 (At home to Going to a party)ã€C11 (Going to a party to At a 
party)èˆ‡ C12 (At a party to Going home)ã€‚ 
ä¸Šè¿° 12 æ¢ï¥§ä¸€è‡´åµæ¸¬è¦å‰‡ä¾åˆ†å±¤å¼æ¶æ§‹æ–¹æ³•ï¼Œåˆ†ç‚ºæ„Ÿæ¸¬å±¤èˆ‡äº‹ä»¶å±¤ï¥§ä¸€è‡´æ€§åµæ¸¬è¦å‰‡ï¼Œå…¶
ä¸­ C5 è‡³ C12 åµæ¸¬è¦å‰‡ç½®æ–¼æ„Ÿæ¸¬å±¤ï¼›C1 ç½® C4 å‰‡ç‚ºäº‹ä»¶å±¤ä¹‹ï¥§ä¸€è‡´åµæ¸¬ã€‚æ„Ÿæ¸¬å±¤ï¥§ä¸€è‡´æ€§
åµæ¸¬è¦å‰‡ä¸­ï¼ŒC5 æª¢æŸ¥çš„ä½ç½®(Location)æƒ…å¢ƒè³‡è¨Šç‚ºï¥©å€¼å‹æ…‹ï¼Œä½¿ç”¨ ÄˆBï¼›C6 è‡³ C12 æª¢æŸ¥çš„æ´»
å‹•(Activity)æƒ…å¢ƒè³‡è¨Šç‚ºï¥©å€¼å‹æ…‹ï¼Œé¸ç”¨ ÄˆCã€‚è€Œäº‹ä»¶å±¤ï¥§ä¸€è‡´æ€§åµæ¸¬è¦å‰‡ä¸­ï¼ŒC1 è‡³ C4 æª¢æŸ¥
çš„ä½ç½®èˆ‡æ´»å‹•æƒ…å¢ƒè³‡è¨Šï¼Œæ¡ç”¨ ÄˆFPRï¼Œç•¶ï¥§ä¸€è‡´æƒ…å¢ƒç™¼ç”Ÿæ™‚ï¼ŒÄˆFPRå°‡å–æ¶ˆä½ç½®èˆ‡æ´»å‹•æƒ…å¢ƒè³‡
è¨Šï¼Œå› ç‚ºä½ç½®èˆ‡æ´»å‹•æƒ…å¢ƒçš„æŒä¹…ç¨‹ï¨èˆ‡æ–°èˆŠç¨‹ï¨çš†ç›¸åŒã€‚ 
å¯¦é©—çµæœï¼šæœ‰é—œå››ç¨®ï¥§åŒå±¤æ¬¡çµ„åˆçš„ï¥§ä¸€è‡´æƒ…å¢ƒåµæ¸¬èˆ‡è§£æ±ºç­–ï¥¶ã€‚è¡¨ 5 ç‚ºå››ç¨®ï¥§ä¸€è‡´æƒ…å¢ƒ
åµæ¸¬èˆ‡è§£æ±ºç­–ï¥¶åœ¨ï¥§åŒæœå‹™ä¸‹ 24 å°æ™‚çš„æœå‹™è§¸ç™¼ï¥¡ã€‚è¡¨ 6 ç‚ºå››ç¨®ï¥§ä¸€è‡´æƒ…å¢ƒåµæ¸¬èˆ‡è§£æ±ºç­–
ï¥¶åœ¨ 24 å°æ™‚ä¸­æ¯ä¸‰å°æ™‚ç‚ºé–“éš”çš„æœå‹™è§¸ç™¼ï¥¡ã€‚è¡¨ 7 ç‚ºå››ç¨®ï¥§ä¸€è‡´æƒ…å¢ƒåµæ¸¬èˆ‡è§£æ±ºç­–ï¥¶çš„å¬
å›ï¥¡èˆ‡æº–ç¢ºï¥¡ã€‚æˆ‘å€‘ç™¼ç¾ä½¿ç”¨æ„Ÿæ¸¬å±¤ï¥§ä¸€è‡´é¿å…æ–¹æ³•åœ¨è§¸ç™¼ï¥¡ã€å¬å›ï¥¡èˆ‡æº–ç¢ºï¥¡çš„è©•ä¼°è¡¨
ç¾å‡æ¯”ä½¿ç”¨äº‹ä»¶å±¤èˆ‡å¤šå±¤å¼çš„æ–¹æ³•ï¤­å¾—å¥½ï¼ŒåŸå› åœ¨æ–¼æ„Ÿæ¸¬å±¤ï¥§ä¸€è‡´é¿å…æ–¹æ³•ä¸­èƒ½ä¿®ï¥¦å¤§ï¥¾
ç”±æ„Ÿæ¸¬å™¨é€ æˆçš„ï¥§ä¸€è‡´æƒ…å¢ƒã€‚ç„¶è€Œèˆ‡å‚³çµ±æ–¹æ³•ï§ä¼¼çš„äº‹ä»¶å±¤ï¥§ä¸€è‡´åµæ¸¬èˆ‡è§£æ±ºæ–¹æ³•ï¼Œå…¶è¡¨
ç¾å‰‡æ˜¯æœ€å·®ï¼Œå› ç‚ºåƒ…èƒ½ä½¿ç”¨å–æ¶ˆçš„æ–¹å¼ï¤­è§£æ±ºï¥§ä¸€è‡´æƒ…å¢ƒã€‚è€Œå¤šå±¤å¼çš„æ–¹æ³•èˆ‡ä½¿ç”¨æ„Ÿæ¸¬å±¤
æ–¹æ³•åœ¨å„è©•ä¼°ä¸Šåƒ…æœ‰äº›å¾®å·®è·ï¼ŒåŸå› äº¦æ˜¯å› ç‚ºå·²ä¿®ï¥¦å¤§ï¥¾æ„Ÿæ¸¬å™¨é€ æˆçš„ï¥§ä¸€è‡´æƒ…å¢ƒï¼Œæ•…å¤š
å±¤å¼æ–¹æ³•åœ¨äº‹ä»¶å±¤çš„æ•ˆæœå‰‡ï¥§æ˜é¡¯ï¼Œä½†å¤šå±¤å¼æ–¹æ³•èƒ½æ¯”æ„Ÿæ¸¬å±¤ï¥§ä¸€è‡´é¿å…æ–¹æ³•è§¸ç™¼ï¤å°‘çš„
éŒ¯èª¤äº‹ä»¶ã€‚å› æ­¤ï¼Œï¥´æ˜¯ç‚ºï¦ºç¢ºä¿ç³»çµ±çš„å¯é æ€§ï¼Œäº‹ä»¶å±¤ï¥§ä¸€è‡´æƒ…å¢ƒåµæ¸¬èˆ‡è™•ï§¤ä»æœ‰å…¶åƒ¹å€¼
å­˜åœ¨ã€‚ 
è¡¨ 5ï¼š24 å°æ™‚æœå‹™è§¸ç™¼ï¥¡ 
Services No. Noise Sensor Event Sensor + Event 
S1 100.00  96.49 100.00  91.54 
S2 69.54 100.00  70.81  99.96 
S4 94.27 100.00  71.61 100.00 
S5 54.36  95.47  42.20  95.07 
S6 73.96  99.75  73.50  99.83 
S8 73.40 100.00  74.59 100.00 
S14 73.96  99.75  73.50  99.83 
S15 47.97  97.18  36.52  97.23 
Average 73.43  98.58  67.84  97.93 
 
Initiative Prevention Strategy for Context Inconsistency in Smart Home 
 
Been-Chian Chien 
Dept. of Computer Sci. and Information Eng. 
National University of Tainan 
Tainan, Taiwan  
Email: bcchien@mail.nutn.edu.tw 
Yuen-Kuei Hsueh 
Dept. of Computer Sci. and Information Eng. 
National University of Tainan 
Tainan, Taiwan  
Email: ph.study@msa.hinet.net
 
 
Abstractâ€”A context-aware system generally integrates many 
different kinds of information techniques to build a computing 
environment for serving users anytime, anywhere. For a 
complicated context-aware system with large number of users, 
the interference among devices and users usually decreases the 
correctness and reliability of context. The incorrect context 
may cause context inconsistency and lead a context-aware 
system to trigger abnormal reactions and wrong decisions. In 
this paper, the prevention strategy is proposed for resolving 
context inconsistency. The context consistency constraints for 
different sensor data types are proposed and developed to 
prevent the context inconsistency caused by imprecise sensing 
devices and environmental noises. The experimental results 
show that the proposed consistency constraints and resolution 
rules can eliminate incorrect contexts effectively and improve 
the quality of a context-aware system in the application of 
smart living space. 
Keywords-context aware; context inconsistency; inconsisency 
prevention; smart home; 
I.  INTRODUCTION  
The applications from the issue of smart living space 
have drawn much technical investigation in many research 
areas like pervasive computing, context-aware computing 
and ambient intelligence.  A smart living space is basically 
based on a context-aware environment that can provide 
intelligent living services for daily life. The famous research 
projects of smart-living in academic area include Aware 
Home  [2] of Georgia Tech., Aura  [5] of Carnegie-Mellon 
University, Adaptive House  [1] of University of Colorado, 
House_n  [3] and Oxygen  [4] of MIT, and Smart Home  [6] of 
Duke University.  
Though context-aware computing has been studied over 
a decade, most of the research issues focused on system 
frameworks, context representations, context reasoning and 
security of application services.  Many prototypes and tools 
were proposed and developed. Some practical systems have 
also been built in many applications recently. However, the 
performance and reliability of context-aware systems are 
getting low while system components and operating 
environments are getting complicated.  
To improve the effectiveness of a context-aware system, 
recognizing context correctly is an important task. Since 
context-aware systems may cause improper reactions due to 
the incorrect sensing context, the low qualified context will 
decrease the effectiveness of a context-aware system directly. 
Generally, incorrect contexts may cause two main problems: 
context inconsistency and context conflict. If a contradiction 
among the contexts exists while computing services in a 
context-aware system, the situation is called context 
inconsistency. If the resources can not satisfy different 
context services at the same time, it is called context conflict. 
In the previous researches, most of the solutions used the 
strategy of inconsistency detection and resolution for the 
context inconsistency problem. However, it is difficult to 
identify all problematic contexts completely using 
consistency constraints. The inconsistency detection is also 
an extra overhead for the system. 
In this paper, the prevention strategy is proposed and 
discussed for the context inconsistency problem. Instead of 
detecting and resolving inconsistency cases after context 
inconsistency occurring, the prevention strategy involves 
specific constraints and rules for each sensor context. The 
context consistency constraints for different sensor data 
types are proposed and developed to prevent the possible 
context inconsistency caused by imprecise sensing devices 
and environmental noises. The proposed approaches are 
tested on two ADL (Activities of daily living) datasets. The 
experimental results show that the proposed consistency 
constraints and resolution rules can eliminate incorrect 
contexts effectively and improve the quality of a context-
aware system in the application of smart living space. 
The remainder of this paper is organized as follows. 
Section 2 reviews the previous technologies of context 
inconsistency detection and resolution. Section 3 depicts the 
idea of prevention strategy and proposes the consistency 
constraints and prevention rules for different sensor data 
types. The experimental results are shows in Section 4. 
Finally, we give a conclusion for this work in Section 5. 
II. RELATED WORK  
The problem of context inconsistency was firstly 
mentioned by Henricksen et al in 2004. In  [8], the authors 
analyzed and summarized several reasons of mismatching 
between sensed contexts and real-world activities. The 
representation method of describing imprecise context is 
proposed in their article, but the resolution for imprecise 
context was not discussed.  
Context inconsistency is possibly caused by either 
imprecise, incorrect context, or the contradiction of context 
definitions. The related research and solution strategy for 
â€œONâ€ is triggered. The consistency prevention rule for the 
least persistence constraint ÄˆLP(tleast) is described as  
IF [ t â€“ start_time(xsignal = 1) ] â‰¥ tleast 
THEN xcontext(t)= ON ; 
ELSE xcontext(t) = OFF ; 
The context is kept â€œOFFâ€ if the raw signal was not sensed 
as â€œ1â€ for tleast time continuously. Example 2 shows an 
instance of executing the consistency prevention rule for the 
least persistence constraint ÄˆLP. 
 
Example 2. Let the parameter of constraint ÄˆLP(tleast), tleast 
be set to be 5 seconds. As shown in Fig. 2, the raw sensor 
signal is triggered between the durations of the 5th and the 
14th seconds, and the 18th and the 20th seconds. The least 
persistence constraint ÄˆLP(5) will first check if the sensor 
signal is persisted 5 seconds at least before the sensor 
context being triggered. The first duration of â€œONâ€ signal 
keeps 9 seconds. It satisfies the constraint ÄˆLP(5), the 
prevention rule thus triggers the context to be â€œONâ€ from 
the 10th second. On the other hand, the second duration of 
â€œONâ€ signal keeps only two seconds. It does not satisfy the 
constraint ÄˆLP(5), the context will not be triggered. 
 
Figure 2.  Example for the least persistence constraint ÄˆLP. 
(3) The change-point constraint ÄˆCP: 
The change-point constraint ÄˆCP  referred to the state 
correction method proposed by Kasteren et al. in 2008 [16]. 
Here, we modified the method to be the consistency 
prevention rule for the change-point constraint ÄˆCP. The rule 
is described as follows. 
IF [ xsignal(t) XOR  xsignal(t-1) ] = 1 
THEN xcontext(t) = ON ; 
ELSE xcontext(t) = OFF;. 
where xsignal(t) is the raw signalâ€™s value at current sampling 
time t for the sensor x. The context of sensor x is only set to 
â€œONâ€ while the signal is changing at the sampling point. 
Example 3 shows the result of executing the consistency 
prevention rule for the change-point constraint ÄˆCP. 
 
Example 3. As shown in Fig. 3, the raw signal changes its 
state at the time point of the 5th, 14th, 18th, and the 20th 
second. The change-point constraint ÄˆCP will trigger the 
context to be â€œONâ€ until the next sampling time point. The 
sampling points without value changing keep â€œOFF.â€ 
 
Figure 3.  Example of Change-Point constraint. 
B. Binary data type 
For numerical sensor data, we propose a context 
inconsistency prevention constraint called the bound 
constraint and denoted as ÄˆB. 
The bound constraint ÄˆB(vmax) contains one parameter vmax 
which is the maximal variation of signal values. The rule of 
consistency prevention for the constraint ÄˆB(vmax) is 
described as 
IF [ xsignal(t) â€“ xcontext(t-1) ] > vmax 
THEN xcontext(t) = xsignal(t-1) + vmax ; 
IF [ xcontext(t-1) â€“ xsignal(t) ] > vmax 
THEN xcontext(t) = xsignal(t-1) â€“ vmax ; 
ELSE xcontext(t) = xsignal(t). 
Since the context returns a value with numerical data 
type, the sensorâ€™s signal exceeding the maximal variation 
vmax is not allowed. The continuous sampling signals 
violates the bound constraint ÄˆB(vmax) will be restricted by 
the rule of consistency prevention. An example in Example 
4 shows the correcting of the consistency prevention rule for 
the bound constraint ÄˆB. 
 
 
 
Figure 4.  Example of the bound constraint. 
Example 4. Let the parameter of constraint ÄˆB(vmax), vmax, 
be set to be 10. As shown in Fig. 4, the raw sensor signal 
value sequence is <29, 38, 13, 20, 45, 42>. The values at the 
second sampling point and the third sampling point are 38 
and 13, respectively. The difference between the two 
neighbor values is larger than vmax=10. The value of the 
third sampling point will be fixed into 28. The fifth 
sampling point is another value in this example needed to be 
fixed. Since the value at the fourth sampling point is 20, the 
value at the fifth sampling point should be corrected to be 
Time 
ON
OFF
1
0
2510 15 
State
0 5 20 
raw
ÄˆCP
250 5 10 15 20
Time
State
ON 
OFF 
1 
0 raw
ÄˆLP(5)
out the noise effectively when the noise rate are high and the 
time tleast  is larger. Fig. 10 and Fig. 11 show the time slice 
accuracy and the class accuracy of ÄˆCP, respectively. This 
constraint is not suitable for the case of large sampling time 
and unstable signals. 
. 
V. CONCLUSION 
In this paper, we initiate the prevention strategy for 
solving the context inconsistency problem. The context 
consistency constraints for different sensor data types 
include binary, numerical, and nominal data types. Five rules 
of consistency constraints, ÄˆR, ÄˆLP, ÄˆCP, ÄˆB, and ÄˆC, are 
proposed and developed to prevent the possible context 
inconsistency caused by imprecise sensing devices and 
environmental noises. The experimental results of the 
proposed approaches are show that the proposed consistency 
constraints and resolution rules can eliminate incorrect 
contexts effectively if a proper consistency constraint is 
applied to the corresponding sensor. 
ACKNOWLEDGMENT 
This research was supported in part by National Science 
Council of Taiwan, R. O. C. under contract NSC 99-2221-E-
024-015. 
 
REFERENCES 
[1] The Adaptive House, http://www.cs.colorado.edu/ ~mozer/ 
house/. 
[2] The Aware Home Research Initiative, http://awarehome. 
imtc.gatech.edu/. 
[3] MIT House_n, http://architecture.mit.edu/house_n/. 
[4] MIT Project Oxygen,  http://www.oxygen.lcs.mit.edu/. 
[5] Project Aura, http://www.cs.cmu.edu/~aura/. 
[6] Smart Home, http://smarthome.duke.edu/. 
[7] Y. Bu, S. Chen, J. Li, X. Tao, and J. Lu, â€œContext 
Consistency Management Using Ontology Based Model,â€ in 
Proceedings of the 10th Workshops-Current Trends in 
Database Technology, Munich, Germany, pp. 741-755, 
March 2006. 
[8] K. Henricksen, and J. Indulska, â€œModelling and Using 
Imperfect Context Information,â€ in Proceedings of the 2nd 
IEEE International Conference on Pervasive Computing and 
Communications, Orlando, Florida, pp. 33-37, March 2004. 
[9] R. Mayrhofer, â€œContext Prediction based on Context 
Histories: Expected Benefits, Issues and Current State-of-the-
Art,â€ in Proceedings of the 1st International Workshop on 
Exploiting Context Histories in Smart Environments, Munich, 
Germany, pp. 31-36, May 2005. 
[10] L. R. Rabiner, â€œA tutorial on hidden Markov models and 
selected applications in speech recognition,â€ Proceedings of 
the IEEE, 77, (2), pp. 257-286, February 1989. 
[11] C. Xu, â€œInconsistency Detection and Resolution for Context-
Aware Pervasive Computing,â€ Computer Science and 
Engineering, Hong Kong University of Science and 
Technology, Hong Kong, August 2008. 
[12] C. Xu, and S. C. Cheung, â€œInconsistency Detection and 
Resolution for Context-Aware Middleware Support,â€ in 
Proceedings of the 4th Joint Meeting of the European 
Software Engineering Conference and the ACM SIGSOFT 
International Symposium on the Foundations of Software 
Engineering, Lisbon, Portugal, pp. 336-345, September 2005. 
[13] C. Xu, S. C. Cheung, W. K. Chan, and C. Ye, â€œOn 
Impact-Oriented Automatic Resolution of Pervasive 
Context Inconsistency,â€ in Proceedings of the 6th Joint 
Meeting of the European Software Engineering 
Conference and the ACM SIGSOFT International 
Symposium on the Foundations of Software 
Engineering, Dubrovnik, Croatia, pp. 569-572, 
September 2007. 
[14] S. Szewcyzk, K. Dwan, B. Minor, B.Swedlove, and D. 
Cook, â€œAnnotating Smart Environment Sensor Data for 
Activity Learning,â€ Methods of Information in 
Medicine, 48, (5), pp. 480-485, May 2009. 
 
 
 
 
 
 
Figure 6.  Time-slice accuracy for ÄˆR(1,1) to ÄˆR(1,5). 
 
 
 
 
 
Figure 7.  Class accuracy for ÄˆR(1,1) to ÄˆR(1,5). 
 å‡ºå¸­ã€Œ2010 ç¬¬ 10 å±†åœ‹éš›æ™ºæ…§å‹ç³»çµ±è¨­è¨ˆèˆ‡æ‡‰ç”¨å­¸è¡“æœƒè­°ã€å ±å‘Š 
The 10th International Conference on Intelligent Systems Design and 
Applications (ISDA 2010) 
 
Nov. 29 â€“Dec. 1, 2010, Cairo, Egypt 
 
 
è¨ˆç•«ç·¨è™Ÿ NSC 99-2221-E-024 -015 
è¨ˆç•«åç¨± æ•´åˆæ©Ÿå™¨å­¸ç¿’æ–¹æ³•æ–¼æƒ…å¢ƒæ„ŸçŸ¥æœå‹™å¹³å°æŠ€è¡“ä¹‹ç ”ç©¶(II) 
å‡ºåœ‹äººå“¡å§“å 
æœå‹™æ©Ÿé—œåŠè·ç¨± 
éŒ¢ç‚³å…¨  æ•™æˆ 
åœ‹ï§·è‡ºå—å¤§å­¸è³‡è¨Šå·¥ç¨‹å­¸ç³» 
æœƒè­°æ™‚é–“åœ°é» 2010 ï¦ 11 æœˆ 29 æ—¥~12 æœˆ 1 æ—¥ï¼ŒåŸƒåŠï¼Œé–‹ï¤ (Cairo, Egypt) 
æœƒè­°åç¨± 2010 ç¬¬ 10 å±†åœ‹éš›æ™ºæ…§å‹ç³»çµ±è¨­è¨ˆèˆ‡æ‡‰ç”¨å­¸è¡“æœƒè­° (ISDA2010) 
The 10th International Conference on Intelligent Systems Design and Applications 
ç™¼è¡¨ï¥æ–‡é¡Œç›® An Intelligent Context Interpreter based on XML Schema Mapping 
 
 åœ‹ï§·é«˜é›„å¤§å­¸è³‡å·¥ç³»æ´ªå®—è²æ•™æˆåœ¨æœ¬ç ”è¨æœƒä¸­å—é‚€ç‚ºå…±åŒè­°ç¨‹ä¸»å¸­(Technical Program 
Co-Chair)ï¼Œå€‹äººå‰‡æ˜¯æ“”ä»»å®£å‚³å…±åŒä¸»å¸­(Publicity Co-Chairs)ï¼Œï¥¸äººä¸¦åŒæ™‚åœ¨æœ¬ç ”è¨æœƒä¸­åˆçµ„
ä¸€ç‰¹åˆ¥è­°é¡Œï¼Œä¸»é¡Œåç¨±ç‚º Data Mining and Learning Techniques in Intelligent Systemsï¼Œæœ¬ç‰¹åˆ¥
è­°é¡Œå…±æœ‰ 12 ç¯‡ï¥æ–‡ï¼Œç¨¿ä»¶ï¤­è‡ª 6 å€‹ï¥§åŒåœ‹å®¶ï¼Œåˆ†ç‚ºï¥¸å€‹å ´æ¬¡ç™¼è¡¨ã€‚æœ¬ç ”è¨æœƒï¥æ–‡é›†è’ï¤¿æ–¼ IEEE 
Digital Library ï¥æ–‡é›†ä¸­ï¼Œç‚º EI ï¥ªå¼•æ–‡ç»ä¹‹ä¸€ã€‚ 
 
ï¥«åŠ æœƒè­°ç¶“éï¼š 
æœ¬æ¬¡æœƒè­°åœ°é»ä½æ–¼åŸƒåŠé¦–ï¨¦é–‹ï¤ï¼Œè·ï§ªé™é ï¼Œç„¡ç›´èˆªç­æ©Ÿï¼Œå¿…é ˆé€éç¬¬ä¸‰åœ‹è½‰æ©Ÿå‰å¾€ï¼Œ
å°ç£åœ°å€é›–æœ‰å¤šäººæŠ•ç¨¿ç™¼è¡¨ï¥æ–‡ï¼Œä½†å¤šå› æ™‚é–“ç·Šæ¹ŠåŠäº¤é€šä½å®¿ç­‰ï¥§ï§ å®‰æ’ç­‰å› ç´ ï¼Œå› è€Œæœ€å¾Œ
æ±ºå®šç„¡æ³•å‰å¾€ã€‚åªæœ‰å€‹äººèˆ‡å°å—æ‡‰ç”¨ç§‘æŠ€å¤§å­¸ï§¡ä¿Šé”æ•™æˆï¼Œç”±æ¡ƒåœ’æ©Ÿå ´æ­ä¹˜è¯èˆªç¶“éŸ“åœ‹ä»å·ï¼Œ
è½‰æ­éŸ“èˆªï¼Œä¸­é–“å†åœæ©Ÿæ–¼çƒèŒ²åˆ¥å…‹é¦–ï¨¦å¡”ï§½å¹²åŠ æ²¹ï¼Œå†æ¥çºŒé£›è‡³ç›®çš„åœ°åŸƒåŠé–‹ï¤ã€‚ç¸½é£›ï¨ˆæ™‚
ï¥©è¶…é 18 å°æ™‚ã€‚ 
æœƒå ´å­¸ä½æ–¼é–‹ï¤å¸‚å€çš„é–‹ï¤å¤§å­¸åœ‹éš›æœƒè­°ä¸­å¿ƒèˆ‰ï¨ˆï¼Œé–‹ï¤å¸‚å€äº¤é€šæ“æ“ è¤‡é›œï¼Œåˆç„¡äº¤é€š
è™ŸèªŒï¼Œå°æ–¼æ…£æ–¼äº¤é€šè™ŸèªŒçš„åœ‹äººè€Œè¨€ï¼Œï¦šéé¦¬ï¤·ï¨¦æˆå•é¡Œï¼Œå¯¦åœ¨ï¦¨äººå¤§é–‹çœ¼ç•Œã€‚æˆ‘å€‘å› äº‹å‰
è€³èç•¶åœ°äº¤é€šï§ºæ³ï¼Œæ•…äº‹å…ˆææ—©ç´„ 5 æ—¥å‰æŠµé”ã€‚é™¤ï¦ºè§£ç•¶åœ°ï§ºæ³å¤–ï¼Œä¸¦é †ï¥¥å…ˆåˆ°åŸƒåŠåšç‰©ï¨¬ï¼Œ
èˆ‡é–‹ï¤é™„è¿‘çš„ï¤Šå­—å¡”æ™¯é»ï¥«è§€ã€‚11 æœˆ 29 æ—¥æ­£å¼æœƒè­°é–‹å§‹ï¼Œç¬¬ä¸€å¤©æ—©ä¸Šå®‰æ’ Prof. Janusz 
Kacprzyk åš Keynote speechã€‚ä¸‹åˆå‰‡å®‰æ’æœ‰ä¸‰å ´ Tutorialsï¼Œä½†æ˜¯å› ç‚ºåœ¨åŒä¸€æ™‚é–“ï¼Œåªèƒ½æ“‡ä¸€å‚
èˆ‡ã€‚å…¶ä¸­ä¸€å ´ç”± Prof.Vasudha Bhatnagarn æ‰€ä¸»è¬›ï¼Œé¡Œç›®ç‚ºâ€Modeling Changes in Evolving Dataâ€ï¼Œ 
è¨ï¥æœ‰é—œè³‡ï¦¾ï¤…ï§Š(Data Stream)çš„è™•ï§¤èˆ‡å­¸ç¿’æ¨¡å‹çš„æ¦‚ï¦£è½‰ç§»(Concept Drift)ç­‰å•é¡Œï¼Œèˆ‡æˆ‘å€‹
äººå¾ŒçºŒè¨ˆç•«å…·æœ‰ç›¸ç•¶å¯†ï¨€çš„é—œä¿‚ï¼Œé€™å€‹å•é¡Œä¹Ÿæ˜¯æœªï¤­ç›¸ç•¶å—åˆ°çŸšç›®çš„ç ”ç©¶è­°é¡Œã€‚Tutorials çµ
æŸå¾Œï¼Œå¤§æœƒå®‰æ’åˆ°å‰è–©(Giza)ï¤Šå­—å¡”å€ï¥«è§€å¤œæ™šï¤Šå­—å¡”ç‡ˆå…‰è¡¨æ¼”ï¼Œæ™šä¸Šçš„ï¤Šå­—å¡”é…ä¸Šç‡ˆå…‰æœ‰å…¶
ï¨™ç§˜æ„Ÿï¼Œä¹Ÿï¥§æœƒé‚£éº¼ç‚ç†±ã€‚ç¬¬äºŒå¤©èˆ‡ç¬¬ä¸‰å¤©ä¸Šåˆå‡å®‰æ’æœ‰ä¸€å ´ Plenary Talkï¼Œåæ™‚ä¸‰ååˆ†ä¹‹å¾Œ
ä»¥åŠä¸‹åˆæ‰é–‹å§‹å®‰æ’ï¥æ–‡ç™¼è¡¨å ´æ¬¡ï¼Œç¬¬äºŒå¤©æ™šä¸Šåœ¨ï¥æ–‡ç™¼è¡¨å®Œå¾Œçš„æ™šå®´å‰‡è¢«å®‰æ’åœ¨å°¼ï¤æ²³éŠ
ï§—ä¸Šèˆ‰ï¨ˆã€‚ 
å€‹äººèˆ‡æ´ªæ•™æˆæ‰€çµ„çš„ç‰¹åˆ¥è­°é¡ŒäºŒå€‹å ´æ¬¡å®‰æ’æ–¼æœ€å¾Œä¸€å¤©ä¸‹åˆï¼Œå€‹äººæ‰€ç™¼è¡¨çš„ï¥æ–‡é¡Œç›®ç‚º 
â€œAn Intelligent Context Interpreter based on XML Schema Mappingï¼‚ï¼Œå®‰æ’æ–¼ç¬¬ä¸‰å¤©ä¸‹åˆç¬¬äºŒå ´
æ¬¡ç™¼è¡¨ï¼Œç”±å€‹äººæ“”ä»»ä¸»æŒäººã€‚åŒä¸€å ´æ¬¡ç¸½å…±æœ‰ï§‘ç¯‡ï¥æ–‡ç™¼è¡¨ï¼Œå ´æ¬¡ä¸»é¡Œç‚ºæ™ºæ…§å‹ç³»çµ±çš„è³‡ï¦¾
æ¢å‹˜èˆ‡å­¸ç¿’æŠ€è¡“(Data Mining and Learning Techniques in Intelligent Systems)ã€‚ç™¼è¡¨å­¸è€…ï¤­è‡ªåŸƒ
æ¨¡å‹ç„¡æ³•æœ‰ç›¸ç•¶å¥½çš„å›æ‡‰èˆ‡æ•ˆï¥¡ã€‚å¦‚ä½•åµæ¸¬ç³»çµ±è³‡ï¦¾æ¨¡å¼çš„è®ŠåŒ–ï¼Œä»¥åŠæœ‰æ•ˆï¥¡çš„å­¸ç¿’å‡ºæ–°
çš„é«˜æº–ç¢ºï¥¡è³‡ï¦¾æ¨¡å‹ï¼Œæ˜¯æœ¬å•é¡Œçš„ï¥¸å¤§ä¸»è¦è­°é¡Œã€‚åœ¨æ‡‰ç”¨å±¤æ¬¡ä¸Šï¼Œè¨±å¤šçš„æ™ºæ…§å‹ç³»çµ±èˆ‡æ‡‰
ç”¨ä¸­ï¼Œå¦‚ä½•æ‡‰ç”¨åµæ¸¬ç³»çµ±æ¨¡å‹çš„è½‰è®Šã€ä½•æ™‚è½‰è®Šçš„æ±ºç­–ã€ä»¥åŠå¦‚ä½•å› æ‡‰è½‰è®Šéç¨‹ï¼Œè­°æ˜¯åœ¨
æ‡‰ç”¨è­°é¡Œä¸Šå€¼å¾—æ¢è¨çš„è­°é¡Œã€‚åœ¨æœ¬æ¬¡çš„æœƒè­°ä¸­ï¼Œä¹Ÿæœ‰ä¸€äº›å ´æ¬¡è¨ï¥åˆ°æ‡‰ç”¨çš„è­°é¡Œï¼Œå€‹äººèª
ç‚ºæ­¤ä¸€ä¸»é¡Œåœ¨æœªï¤­ï¥©ï¦ç•¶ä¸­ï¼Œæ˜¯å¾ˆå€¼å¾—æœŸå¾…èˆ‡æŠ•å…¥çš„ç ”ç©¶ä¸»é¡Œã€‚ 
2. æœ¬æ¬¡æœƒè­°å› ç‚ºåœ¨å­¸æœŸä¸­ï¼Œä¸”å› ï¤·é€”é™é è½‰æ©Ÿï¥§è®Šçš„å› ç´ ï¼Œå°è‡´åœ‹å…§å­¸è€…å‰å¾€èˆ‡æœƒäººï¥©ä¸¦ï¥§
ååˆ†è¸´èºã€‚ä½†ï¨ŠåŸƒåŠé›–ç„¶ååˆ†é‡è¦–è§€å…‰ï¼Œä½†ç›¸å°çš„åŸºç¤å»ºè¨­èˆ‡ç§‘æŠ€ç™¼å±•ä¸¦ï¥§ååˆ†çªå‡ºï¼ŒåŸ
é„‰å·®è·å°¤å…¶å·¨å¤§ã€‚ç„¶è€ŒæŒ¾å…¶é¾å¤§æ–‡åŒ–è³‡ç”¢ï¼Œä»èƒ½å¸å¼•è¨±å¤šæ­ç¾äººå£«å‰å¾€ï¥«åŠ ï¼Œé¡¯ï¨Šè§€å…‰åŠ
åœ‹ï¦Šä¸¦éåªæœ‰ç¶“æ¿Ÿæˆ–é«˜ç§‘æŠ€ï¼Œæ–‡åŒ–è»Ÿå¯¦ï¦Šäº¦ç›¸ç•¶é‡è¦ã€‚åœ¨æˆ‘å€‘é–‹æœƒæœŸé–“ï¼Œæ­£æ˜¯åŸƒåŠåœ‹å®¶è­°
æœƒæ”¹é¸çš„æ™‚åˆ»ï¼Œå…¶é¸èˆ‰ï¤›è±¡æ¯”ä¹‹å°ç£äº¦ï¥§é‘å¤šè®“ã€‚è¡—é ­å……æ»¿ç«¶é¸æ——å¹Ÿèˆ‡æµ·å ±ï¼Œå®£å‚³ï¤‚äº¦çµ¡
ç¹¹æ–¼é€”ã€ï¥§çµ•èˆ‡è€³ã€‚å›å°äºŒé€±å¾Œï¼ŒåŸƒåŠé©šå‚³å‡ºç¾åæ”¿åºœåè²ªæ±¡ç¤ºå¨ï¼Œå°è‡´æ©Ÿå ´é—œé–‰ï¼Œæ”¿æƒ…
å‹•ç›ªï¼Œæœ€å¾Œä½¿å¾—åŸ·æ”¿è¿‘ä¸‰åï¦çš„ç©†å·´ï¤¥å…‹å®å°ã€‚è¶³ï¨Šè­‰è‡³ä¹‹æ¸…æ˜ä¹Ÿæ˜¯è¶³ä»¥å½±éŸ¿åœ‹å®¶å„é …å»º
è¨­èˆ‡æ°‘ç”Ÿçš„é‡è¦å› ç´ ã€‚ 
 
æ”œå›è³‡ï¦¾åç¨±èˆ‡å…§å®¹ï¼š 
ç ”è¨æœƒï¥æ–‡é›†å¦‚ä¸‹ï¼š 
1.ï¥æ–‡å…‰ç¢Ÿ IEEE Catalog No.:CFP10394-CDR, ISBN: 978-1-4244-8135-4. 
An Intelligent Context Interpreter based on XML Schema Mapping 
Been-Chian Chien 
Dept. of Computer Science and Information Engineering 
National University of Tainan,  
Tainan, Taiwan, R. O. C. 
e-mail: bcchien@mail.nutn.edu.tw 
Shiang-Yi He 
Dept. of Computer Science and Information Engineering 
National University of Tainan,  
Tainan, Taiwan, R. O. C.  
e-mail: tkuchris@hotmail.com 
Abstractâ€”Context-aware computing is one of the attractive 
research topics in pervasive computing. Context-aware systems 
can react to usersâ€™ preferences according to context including 
location, time and other environment conditions. Context is 
generated by context interpreters or aggregated by context 
aggregators from the signals of sensors. A traditional context 
interpreter is usually built as an executable hard code called 
widget. It is difficult for the system manager to construct and 
maintain the large collections of context. In this paper, we 
propose an intelligent generic context interpreter using context 
scripts to overcome the hard code dependency between context 
and hardware devices. The generic context interpreter imports 
sensor data from sensor devices as an XML schema. Then, the 
schema matching approach is used to help system manager 
generating context scripts instead of widgets easily. The system 
was built and evaluated by different sensor schemas. The 
results show that the schema matching algorithm can match 
correct sensor types effectively and provide efficient context 
generation and maintenance. 
Keywords-context-aware system; context interpreter; schema 
matching; intelligent system 
I. INTRODUCTION
A context-aware system is a mobile environment in 
which applications can discover and make use of context 
information including user location, time, date, nearby 
devices and other environmental activities to adapt their 
operations and behavior [5]. A number of context-aware 
architectures were proposed and employed for a wide 
spectrum of systems and applications [3]. However, since 
each individual system focuses on its specific application 
domain, current context-aware systems are heterogeneous in 
all aspects, such as hardware, mobile resources, operating 
systems, application software, and platforms [15]. The 
serious heterogeneous characteristics of context-aware 
computing are especially important and become significant 
drawbacks while developing context interpreters for building 
context-aware services [4][14]. 
In general, context-aware systems use context to archive 
the objectivity of controlling services. Context is generated 
by context interpreters or aggregated by context aggregators 
from the signals of sensor devices in the mobile environment. 
A traditional context interpreter is usually built as a type of 
execution codes called widget [8]. Since a widget is usually 
designed by system programmers as a hard code to translate 
sensors data into a semantic representation called context, it 
is dependent upon the sensor devices and the application 
domains of context-aware systems. It is hard to maintain if 
some sensors were upgraded or renewed, and it is difficult 
for the system manager to construct new services for new 
devices. The extendibility of the systems thus will be 
restricted and lack of flexibility. 
In this paper, we propose an intelligent generic context 
interpreter based on XML context scripts generator and 
XML schema matching schemes. The proposed generic 
context interpreter architecture consists of two modules: the 
context script generator and the generic script interpreter. We 
use context scripts to replace hard code widgets for solving 
the dependency problem between context and hardware 
devices. The context script generator imports sensor data 
from sensor devices as an XML schema. Then, the schema 
matching scheme is applied to help the system manager 
generating context scripts instead of widgets easily. The 
generic script interpreter can translate various context scripts 
into the corresponding contexts used in the application. The 
generic interpreter was implemented and evaluated by 
various sensors schemas. The results show that the intelligent 
context script generator can effectively recognize correct 
sensor types by the support of schema matching scheme and 
the context interpreter provides efficient context generation 
and maintenance.  
This paper is organized as follows. In Section 2, we 
introduce the framework of context-aware systems.. The 
generic context interpreter is described in Section 3. Section 
4 presents the schema matching method for an intelligent 
context interpreter. The results of experiments and evaluation 
are shown in Section 5. Finally, conclusion is made in 
Section 6.
II. FRAMEWORK OF CONTEXT-AWARE SYSTEMS
The conceptual framework of context-aware systems 
consists of five layers as shown in Fig. 1 [4]. The contents of 
each layer are described as follows briefly. 
Figure 1 The five-layer conceptual framework.
Application layer 
Storage layer 
Context layer 
Interpretation layer 
Device layer 
1308978-1-4244-8136-1/10/$26.00 cÂ©2010 IEEE
We first introduce and define the symbols used in the 
SYM approach. 
S : Source schema. 
s : an element node in source schema S.
T : Target schema. 
t : an element node in target schema T.
Lsim(s, t): the linguistic similarity between nodes s and t.
DTcom(s, t): the data type compatibility between s and t.
Ssim(s, t): the structure similarity between rooted at s and t.
Wsim(s, t): the weighted similarity between rooted at s and t.
thhigh : the threshold for increasing Wsim(s, t).
thlow : the threshold for decreasing Wsim(s, t). 
thaccept : the threshold for acceptance of valid mapping. 
Cinc : the multiplicative factor for increasing Wsim(s, t).
Cdec : the multiplicative factor for decreasing Wsim(s, t). 
Wstruct : the weight of structure similarity for Wsim(sâ€™, tâ€™).
leaves(s) : the set of leaves in the subtree rooted at s.
level(s) : the depth of node s, the depth of root is 1. 
StrongLink(s, t): the weight similarity Wsim(s, t) t thaccept.
The main similarity measure of matching schemas in SYM is 
the weighted similarity Wsim. For any two element nodes s
and t belonging two schemas S and T, respectively, the 
computation of Wsim(s, t) contains two phases: the linguistic 
matching and the schema structure matching. The goal of the 
linguistic matching phase is to find the linguistic similarity 
Lsim(s, t) between two element nodes s and t. In the schema 
structure matching phase, we first compute the compatibility 
of data type DTcom(s, t) and the structure similarity Ssim(s,
t). Then, the weighted similarity Wsim(s, t) is measured by 
combining Lsim(s, t) with DTcom(s, t) or Ssim(s, t). The 
detailed matching algorithm is described in the following 
subsections. 
B. Linguistic Matching 
The matching of element names in schemas is first step 
for most of the schema matching methods. A good name 
matcher can identify correct linguistic matching of element 
names effectively. An accurate name matching also helps to 
accomplish the element-level matching problem. However, a 
single name matcher with simple similarity measure cannot 
perform effective matching results in general. Here, we 
proposed a linguistic matching method based on four name 
matchers: Levenshtein, 3-grams, Jaro-distance and WordNet.
The computation of linguistic similarity for Levenshtein, 3-
grams, Jaro-distance are listed in [1]. For two strings s and t,
the similarity values between s and t are denoted as simlev,(s,
t), simtri(s, t), and simJaro(s, t), respectively.
WordNet was developed by Miller et al.[18]. The 
relations of words like, hyponyms, synonym and antonym 
are also computed by the levels of semantic hierarchy in the 
groups of words called synsets. Two words s and t are first 
stemmed. Then, the similarity of two words is computed by 
the depth of the different Lexiconâ€™s hierarchies [13], as 
follows: 
2
2
2
1
1
depth
depthdepth
depth
depthdepth
Distance



 
,   (1) 
2-1),( DistancetssimWordnet  
,      (2)
where depth is the common parental depth, depth1 is the 
depth of s and depth2 is the depth of t from the root of the 
hierarchy. 
Although we just introduce the four different name 
matchers, they are usually not used at the same time while 
computing the linguistic similarity Lsim(s, t) of element 
names s and t. One of the reasons not using all name 
matchers is that these name matchers include implicit 
similarity hierarchy of each other. For instance, the 3-grams 
matcher has a high similarity when the Levenshtein matcher 
gets high similarity. Another reason is to reduce the 
computation time. Since the more matchers are operated, 
more computation cost is needed. Especially, WordNet 
spends a lot of time on searching dictionary for computing 
the similarity in their synsets. It is not a great idea to often 
execute WordNet. Hence, a decision tree of combining name 
matchers [10] is designed. The decision steps are listed as 
follows: 
Step 1. For two input element names s and t, we check 
whether the two strings are the same or not. If they 
are identical, the linguistic similarity is set to be one 
and the processing is halt; otherwise, the above 
name matchers are used to compute the linguistic 
similarity as the next step. 
Step 2. The simedit(s, t) are first computed and tested. Then, 
one of the following three cases will happen:  
1) If the value simedit(s, t) is larger than 0.55, the 
linguistic similarity is set to the value simedit(s, t).
2) If the value simedit(s, t) is less than 0.25, WordNet 
is used and the linguistic similarity is set to the 
value simwordnet(s, t).  
3) If the value simedit(s, t) is between 0.25 and 0.5, 
the 3-gram and Jaro-distance matchers are used 
as Step 3. 
Step 3. The average value of simtri(s, t) and simjaro(s, t) are 
computed. If the average of the two matchers is 
larger than 0.15, the linguistic similarity is set to the 
average; otherwise, WordNet is finally used and the 
linguistic similarity is set to the value simwordnet(s, t). 
Since WordNet matcher is time-consuming, it will not be 
started until no proper linguistic similarity is produced by the 
other matchers. 
C. Schema Structure Matching 
The goal of the schema structure matching phase is to 
find the weighted similarity Wsim(s, t) between two nodes s
and t belonging to schema S and T, respectively. The 
weighted similarity is calculated by a combination of the 
linguistic similarity (Lsim) and the structure similarity (Ssim).
Without loss generality, we suppose that a node in a 
schema would be an internal node or a leaf node. Hence, the 
structure matching in schemas may perform on two leaf 
nodes, two internal nodes and one leaf node vs. one internal 
node. We regard matching two leaf nodes as the leaf-
structure similarity matching. By contrast, the nonleaf-
structure matching includes the cases of matching two 
internal nodes and matching one leaf with one internal node.  
1310 2010 10th International Conference on Intelligent Systems Design and Applications
D. Schema Similarity 
After the computation of all values of Wsim(s, t) for the 
source schema S and the target schema T, the match pairs of 
the two schemas are generated by the Wsim(s, t) of the leaf 
nodes s in S and t in T. The match pairs generating algorithm 
is described as follows: 
Step 1. Consider the matching from S to T. For each leaf 
node s in S, the matched node t in T must satisfy the 
conditions of maximizing Wsim(s, t) and Wsim(s, t)
t thaccept. Let the set of selected match pairs be ST.
Step 2. Consider the matching from T to S. For each leaf 
node t in T, the matched node s in S must also 
satisfy the conditions of maximizing Wsim(s, t) and 
Wsim(s, t) t thaccept. Let the set of selected match 
pairs be TS.
Step 3. The final match results are the match pairs in the set 
STÄ£TS.
After generating the matching pairs, the schema similarity 
between two schemas S and T is defined as   
|)(|
),(
),(
,
Sleaves
tsWsim
TSScSim
TtSs
matchedÂ¦
ÂÂ .                 (8) 
V. EXPERIMENTAL RESULTS
The generic context interpreter proposed in this paper 
used Mapforce API to develop the context mapping in the 
context mapping editor. The initial blank system needs build 
context mapping manually. Once more mapping datasets 
were accumulated in the mapping history, Users will be able 
to refer to the existing schema mapping cases and a similar 
sensor schema mapping was selected to modify as a new 
context mapping. 
The test schema sets include seven different sensor 
schemas listed in Table I. The depths of schema structures 
are four levels. The number of leaves is between the range 
four and six. The number of nodes is in the range of seven to 
ten. We first ranked the similarity degree of each schema by 
experts as shown in Table II. Then the proposed schema 
matching algorithms, Cupid [11] and COMA++ [2][8] are 
tested on each schema. To evaluate the schema matching 
performance of ranking, we refer to Rnorm [11] values as the 
criterion of effectiveness. The matching results of similarity 
are evaluated and ranked, as shown in Table III. 
TABLE I. THE STRUCTURE UINFORMATION OF SENSOR SCHEMAS.
Schema Leaves Nodes Depth 
GPSData (GPS) 5 9 4 
HumidityData (Humid) 5 9 4 
IRData (IR) 5 9 4 
LightData (Light) 5 9 4 
RFIDData (RFID) 5 8 4 
SensorData (Sensor) 6 10 4 
Temp2Data (Temp2) 4 7 4 
The two methods SYM and SYM-Dict represents the 
proposed schema matching algorithms. The difference 
between them is that SYM-Dict used the full algorithm of 
the four linguistic matchers, whereas SYM sets the Lsim(s, t)
to be 0.4 instead of using WordNet searching and similarity 
computing.  
The experimental results show that the SYM leads in four 
schemas and COMA++ is generally superior to others in 
three schemas. The Rnorm values of COMA++ are better than 
Cupid for 5 schemas except S5:RFID and S6:Sensor. The 
reason is that the type of value(xs:decimal) in S7:Temp 
matched the type of value(xs:string) in S5 and S6. This 
mistake causes the higher rank of S7:Temp. It shows that 
COMA++ is relatively weak in the matching of types on 
leaves. The SYM-Dict is surprisingly the worst in the four 
methods. The main reason is that the matching of WordNet 
did not perform proper linguistic similarity matching results. 
The WordNet may give relative high similarity for two 
different terms. On the contrary, the SYM directly sets the 
values as 0.4 is a good similarity since the linguistic 
similarity is generally less than 0.5 if the three linguistic 
matchers are not used. The average Rnorm values show that 
the SYM has the best ranking. The COMA++ combines 
different matchers and gains the second place. Generally 
speaking, SYM-Dict and Cupid is not recommended to be 
used in this application. 
VI. CONCLUSION
The main contribution of this paper is to propose an 
intelligent context interpreter to get context independence. A 
context interpretation script is proposed to replace hard code-
based context interpreter. We design a generic context 
interpreter consisting of the context script generator and the 
generic script interpreter. We also design a context editing 
tool for support the context mapping operation and devices 
maintenance. By employing schema matching approaches, 
the generic context interpreter performs a more intelligent 
operating interface for users. The heterogeneity in pervasive 
context-aware computing will gain a graceful solution. 
The proposed schema matching methods also show their 
effectiveness on the matching rank. The SYM method is 
superior to SYM-Dict, Cupid and COMA++. 
The heterogeneity is a series problem while developing 
and extending context-aware applications in an environment 
of pervasive computing. This work is intended as a starting 
point of further investigating on context-aware computing. 
The problems of context management for context-aware 
computing will be paid more attention in the future.  
ACKNOWLEDGMENT
This research was supported in part by the National 
Science Council of Taiwan, R.O.C. under contract NSC 98-
2221-E-024-012. 
REFERENCES
[1] A. Algergawy, E. Schallehn, G. Saake, â€œA Sequence-based Ontology 
Matching Approach,â€ in Proceedings of 18th European Conference 
on Artificial Intelligence Workshops, pp 26-30, Patras, Greece, July, 
2008. 
1312 2010 10th International Conference on Intelligent Systems Design and Applications
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•«è¡ç”Ÿç ”ç™¼æˆæœæ¨å»£è³‡æ–™è¡¨
æ—¥æœŸ:2011/09/02
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•«
è¨ˆç•«åç¨±: æ•´åˆæ©Ÿå™¨å­¸ç¿’æ–¹æ³•æ–¼æƒ…å¢ƒæ„ŸçŸ¥æœå‹™å¹³å°æŠ€è¡“ä¹‹ç ”ç©¶(II)
è¨ˆç•«ä¸»æŒäºº: éŒ¢ç‚³å…¨
è¨ˆç•«ç·¨è™Ÿ: 99-2221-E-024-015- å­¸é–€é ˜åŸŸ: äººå·¥æ™ºæ…§
ç„¡ç ”ç™¼æˆæœæ¨å»£è³‡æ–™
å…¶ä»–æˆæœ 
(ç„¡æ³•ä»¥é‡åŒ–è¡¨é”ä¹‹æˆ
æœå¦‚è¾¦ç†å­¸è¡“æ´»å‹•ã€ç²
å¾—çé …ã€é‡è¦åœ‹éš›åˆ
ä½œã€ç ”ç©¶æˆæœåœ‹éš›å½±éŸ¿
åŠ›åŠå…¶ä»–å”åŠ©ç”¢æ¥­æŠ€
è¡“ç™¼å±•ä¹‹å…·é«”æ•ˆç›Šäº‹
é …ç­‰ï¼Œè«‹ä»¥æ–‡å­—æ•˜è¿°å¡«
åˆ—ã€‚) 
1.æ–¼ the 2011 IEEE International Conference on Granular Computing ç±Œ
çµ„ç‰¹åˆ¥è­°ç¨‹ (Special Session), æ“´å¤§åœ‹éš›å½±éŸ¿åŠ› 
2.ç¬¬ä¸€å±†ã€Œæ™ºæ…§æ„ŸçŸ¥èˆ‡è¾¨è­˜ã€é ˜åŸŸå°ˆé¡Œæˆæœè¡¨è§€æ‘©æœƒï¼Œå¤šåª’é«”æ‡‰ç”¨çµ„ï¼Œç¬¬ä¸€åï¼›
Apr. 13, 2011 
 æˆæœé …ç›® é‡åŒ– åç¨±æˆ–å…§å®¹æ€§è³ªç°¡è¿° 
æ¸¬é©—å·¥å…·(å«è³ªæ€§èˆ‡é‡æ€§) 0  
èª²ç¨‹/æ¨¡çµ„ 0  
é›»è…¦åŠç¶²è·¯ç³»çµ±æˆ–å·¥å…· 0  
æ•™æ 0  
èˆ‰è¾¦ä¹‹æ´»å‹•/ç«¶è³½ 0  
ç ”è¨æœƒ/å·¥ä½œåŠ 0  
é›»å­å ±ã€ç¶²ç«™ 0  
ç§‘ 
æ•™ 
è™• 
è¨ˆ 
ç•« 
åŠ  
å¡« 
é … 
ç›® è¨ˆç•«æˆæœæ¨å»£ä¹‹åƒèˆ‡ï¼ˆé–±è½ï¼‰äººæ•¸ 0  
 
