and nondeterministic properties. We studied how to 
implement an execution environment in the Android 
platform. In order to effectively the Android-based 
operating system, we intended to import the 
technologies of Markov decision processes and 
probabilistic computation tree logic to verify the 
system behavior.  
 
è‹±æ–‡é—œéµè©ï¼š Markov Chains, Markov decision processes, 
probabilistic model checking, probabilistic 
computation tree logic, and formal verification. 
 
 2 
ä¸­æ–‡æ‘˜è¦ 
äººå€‘ç”Ÿæ´»å¾éå»ç”±è¾²æ‘å‹æ…‹è½‰è®Šæˆç”¨æ™ºæ…§ç”Ÿæ´»ç§‘æŠ€æ‰€æ‰“é€ çš„æ™ºæ…§åŒ–åŸå¸‚ï¼Œ
å› æ­¤å¦‚ä½•ç™¼å±•å®‰å…¨è€Œæœ‰æ•ˆç‡åˆç©©å®šçš„è³‡é€šè¨Šç›¸é—œç³»çµ±æ˜¯éå¸¸é‡è¦çš„ã€‚é›–ç„¶ç›®å‰å·¥
æ¥­ç•Œéƒ½æ˜¯æ¡ç”¨ã€Œå¾Œç³»çµ±é©—è­‰æ³•ã€ä¾†æª¢æŸ¥ç³»çµ±ï¼Œå¦‚è»Ÿé«”é©—è­‰å¸¸ç”¨çš„åŒå„•è©•å¯©å’Œè»Ÿé«”
æ¸¬è©¦ï¼Œä½†é€™äº›æ–¹æ³•å¤§å¤šæ•¸ç”¨æ–¼ç³»çµ±è¨­è¨ˆå®Œæˆå¾Œï¼Œå› æ­¤æœ‰è¼ƒé«˜çš„æˆæœ¬ï¼Œè€Œä¸”ä¸æ˜“æ‰¾
å‡ºç³»çµ±å…§çš„å…¨éƒ¨éŒ¯èª¤ã€‚æœ‰é‘‘æ–¼æ­¤ï¼Œæœ¬ç ”ç©¶è¨ˆç•«çš„ä¸»è¦ç›®çš„æ˜¯ä»¥ä¸€ç¨®æ­£è¦åŒ–é©—è­‰æ–¹
æ³•ç¨±æˆ–ç„¶ç‡æ¨¡å‹æª¢æŸ¥æ³•ä¾†å”åŠ©è¨­è¨ˆé«˜æ•ˆç‡ã€é«˜ç©©å®šåº¦çš„è³‡é€šè¨Šç³»çµ±ã€‚ 
æœ¬è¨ˆç•«çš„ä¸»è¦ç›®çš„ä»¥ Android ç‚ºåŸºç¤çš„é«˜éšåµŒå…¥å¼ç³»çµ±å»ºæ§‹æˆ–ç„¶æ€§æ¨¡å‹æª¢
æŸ¥æ³•è¡Œå‹•è£ç½®æ¸¬è©¦ç’°å¢ƒä»¥åŠæ•´åˆ CAN Busã€ IEEE 802.11p ç­‰é€šè¨Šä»‹é¢ã€‚æˆ‘å€‘å°‡
åˆ©ç”¨æ­¤æ¨¡å‹ä¾†åˆ†æä»¥ Android ç‚ºåŸºç¤çš„è³‡é€šè¨Šç”¢å“åœ¨æˆ–ç„¶æ€§é¸æ“‡åŠéæ±ºå®šæ€§ç­‰
ç‰¹è³ªçš„è¡Œç‚ºæ¨¡å¼ã€‚ç‚ºäº†èƒ½æœ‰æ•ˆåœ°é©—è­‰ Android ä½œæ¥­ç³»çµ±ï¼Œæˆ‘å€‘å°å…¥é¦¬å¯å¤«æ±ºç­–é
ç¨‹çš„æŠ€è¡“ï¼Œä¸¦ä»¥æˆ–ç„¶æ€§è¨ˆç®—æ¨¹ç‹€é‚è¼¯(PCTL)ä¾†æè¿°ç³»çµ±ç‰¹æ€§ï¼Œé€²è€Œä»¥ PCTL æ¨¡å‹
æª¢æŸ¥ä¾†é©—è­‰ç³»çµ±çš„è¡Œç‚ºã€‚ 
é—œéµè©ï¼šé¦¬å¯å¤«éˆã€é¦¬å¯å¤«æ±ºç­–éç¨‹ã€æˆ–ç„¶æ€§æ¨¡å‹æª¢æŸ¥ã€æˆ–ç„¶æ€§è¨ˆç®—æ¨¹ç‹€é‚è¼¯ã€
æ­£è¦åŒ–é©—è­‰ã€‚ 
Abstract 
People living from in the past in the rural areas into intelligent city developed by 
intelligent life technologies, how to develop safe, efficient, and stable information 
communication systems is very important. Although the industry used posteriori 
system verification methods to check systems, such as software validation and peer 
review commonly used in software testing, but most of these methods used in after 
completing system design have a higher cost and not easy to find all the errors. In 
view of this, the main purpose of this project is to use a formal verification method 
called probabilistic model checking to help that we design high efficient and high 
reliability information communication systems. 
The purpose of this project is to construct an environment of probabilistic model 
checking based on an Android-based embedded system with integrating several 
communication interfaces, including CAN Bus, IEEE 802.11p. We used this model 
to analyze the behaviors of Android-based information and communication products 
in the probabilistic selection and nondeterministic properties. We studied how to 
implement an execution environment in the Android platform. In order to effectively 
the Android-based operating system, we intended to import the technologies of 
Markov decision processes and probabilistic computation tree logic to verify the 
system behavior.  
Keywords: Markov Chains, Markov decision processes, probabilistic model 
checking, probabilistic computation tree logic, and formal verification. 
 4 
å»ºæ¨¡ä½œæ¥­ï¼Œä»¥ä¾¿ç²å¾—ç”¢å“ç‰¹æ€§è¦æ ¼åŠç³»çµ±æ¨¡å‹ï¼Œç„¶å¾Œå†åˆ©ç”¨é€™å…©é …è³‡è¨Šé€²
è¡Œæ¨¡å‹æª¢æŸ¥ï¼Œé©—è­‰ç³»çµ±æ¨¡å‹æ˜¯å¦æ»¿è¶³ç³»çµ±ç‰¹æ€§ï¼Œè‹¥ç„¡æ³•æ»¿è¶³æ¨¡å‹æª¢æŸ¥æ³•å¯
ä»¥å”åŠ©æˆ‘å€‘æ‰¾åˆ°åä¾‹ï¼Œæœ€å¾Œå†åˆ©ç”¨æ¨¡æ“¬æ–¹å¼æ‰¾åˆ°éŒ¯èª¤çš„æ‰€åœ¨åœ°ã€‚ 
 
åœ– 2 æ¨¡å‹æª¢æŸ¥æ³•é©—è­‰çš„ç¤ºæ„åœ– 
æœ¬è¨ˆç•«é‡é»æ”¾åœ¨å»ºæ§‹æ¨¡å‹æª¢æŸ¥æ³•è¡Œå‹•è£ç½®æ¸¬è©¦ç’°å¢ƒä»¥åŠå°å…¥ã€Œé¦¬å¯å¤«æ±º
ç­–éç¨‹ï¼ˆMarkov Decision Processesï¼‰ã€æ¨¡å‹ï¼Œé¦–å…ˆæˆ‘å€‘æ¡ç”¨é«˜éšåµŒå…¥å¼ç³»çµ±
æ­é…é–‹æ”¾å¼è¡Œå‹•å¹³å°Androidä½œæ¥­ç³»çµ±ï¼Œä»¥åŠæ•´åˆå¸¸ç”¨çš„é€šè¨Šä»‹é¢ï¼Œå¦‚RS232ã€
CAN Busã€Bluetoothã€ZigBeeã€IEEE 802.11pã€GPRSã€GPS ç­‰ã€‚ç”±æ–¼è³‡é€šè¨Š
ç”¢å“å¤§å¤šæ•¸ å…·å‚™ æˆ–ç„¶æ€§é¸æ“‡ ï¼ˆ Probabilistic Choices ï¼‰åŠéæ±ºå®šæ€§
ï¼ˆNondeterminismï¼‰ç‰¹è³ªéå¸¸é©åˆä½¿ç”¨é¦¬å¯å¤«æ±ºç­–éç¨‹æ¨¡å‹ä¾†é€²è¡Œè¡Œç‚ºåˆ†æã€‚
æˆ‘å€‘å°‡åˆ©ç”¨æ­¤æ¨¡å‹ä¾†åˆ†æä»¥ Android ç‚ºåŸºç¤çš„è³‡é€šè¨Šç”¢å“åœ¨é€šè¨Šéç¨‹ä¸­çš„è¡Œ
ç‚ºæ¨¡å¼ã€‚ä¸¦ä»¥æˆ–ç„¶æ€§è¨ˆç®—æ¨¹ç‹€é‚è¼¯ï¼ˆProbabilistic Computation Tree Logicï¼Œç°¡
ç¨± PCTLï¼‰ä¾†æè¿°ç³»çµ±ç‰¹æ€§ï¼Œé€²è€Œä»¥ PCTL æ¨¡å‹æª¢æŸ¥ä¾†é©—è­‰ç³»çµ±çš„è¡Œç‚ºã€‚ 
äºŒã€ç³»çµ±æ¶æ§‹ 
ä¸€éƒ¨æ±½ï¤‚æœ‰è¨±å¤šè³‡é€šè¨Šè¨­å‚™ï¼Œé€™äº›è¨­å‚™å¤§å¤šæ•¸æ¡ç”¨åµŒå…¥å¼ç³»çµ±ä¾†è¨­è¨ˆï¼Œ
ä¾‹å¦‚ï¼šï¤‚è¼‰é–˜é“å™¨åŠé›»å­æ§åˆ¶å–®å…ƒç­‰éƒ½æ˜¯å±¬æ–¼åµŒå…¥å¼ç³»çµ±ã€‚ï¤‚è¼‰é–˜é“å™¨æ˜¯ç”±
ç¡¬é«”å’Œè»Ÿé«”çµ„æˆï¼Œç¡¬é«”æ˜¯ç”±ä¸€äº›å¯¦é«”è¨­å‚™æ‰€çµ„æˆï¼Œå¦‚ï¼šæ§åˆ¶æ»™æµæ’ï¼ˆCANï¼‰ã€
ä¸²åˆ—åŸ ï¼ˆCOMï¼‰ç­‰ã€‚åœ¨é©…å‹•ç¨‹å¼æ–¹é¢ï¼Œå¯ä»¥åˆ†æˆä¸‰é¡ï¼šå­—å…ƒå‹é©…å‹•ï¼ˆChar Driverï¼‰ã€
å€å¡Šå‹é©…å‹•ï¼ˆBlock Driverï¼‰ã€ç¶²è·¯å‹é©…å‹•ï¼ˆNetwork Driverï¼‰ã€‚ï¤‚èº«é›»å­ç¶²è·¯
CAN æ˜¯å’Œå¸¸ç”¨çš„ä¸²åˆ—é€šè¨Šï¼ˆCOMï¼‰éƒ½æ˜¯å±¬æ–¼å­—å…ƒå‹é©…å‹•ç¨‹å¼ï¼Œå¦‚ä¸‹åœ–æ‰€ç¤ºã€‚
ä¸€èˆ¬ç£ç¢Ÿè¨­å‚™éƒ½æ˜¯æ¡ç”¨å€å¡Šå‹é©…å‹•ï¼›ç¶²è·¯è¨­å‚™å‰‡ä½¿ç”¨ç¶²è·¯å‹é©…å‹•ã€‚ 
å¦‚åœ– 4 æ‰€ç¤ºï¼Œèªªæ˜ï¤‚è¼‰è³‡é€šè¨Šç³»çµ±ä¸­æœ€é‡è¦çš„å…©é …è¨­å‚™ï¤‚è¼‰é–˜é“å™¨å’Œé›»
å­æ§åˆ¶å–®å…ƒï¼Œç•¶é€™å…©é …è¨­å‚™ç¶“ç”±æ§åˆ¶å™¨å€åŸŸæ»™æµæ’é€£æ¥æ™‚ï¼Œä»–å€‘çš„è»Ÿç¡¬é«”çš„
å †ç–Šæ¨¡å‹åŒ…æ‹¬é‚£äº›å…ƒä»¶ã€‚ä¸€èˆ¬ä¾†èªªï¼Œé›»å­æ§åˆ¶å–®å…ƒéƒ½æ˜¯ä»¥ç³»çµ±æ™¶ç‰‡çš„è¨­è¨ˆæ–¹
å¼ï¼Œå°‡ CAN æ™¶ç‰‡å’Œå¾®æ§å™¨è£½åœ¨åŒä¸€é¡†æ™¶ç‰‡ä¸Šï¼Œè‹¥ CAN æ™¶ç‰‡å’Œå¾®æ§å™¨ä¹‹é–“é€£
ç³»çµ± éœ€æ±‚ 
ç‰¹æ€§è¦æ ¼ ç³»çµ±æ¨¡å‹ 
æ»¿è¶³ é•å+åä¾‹ å®šä½éŒ¯èª¤ 
æ­£è¦åŒ– å»ºæ¨¡ 
æ¨¡å‹æª¢æŸ¥ 
æ¨¡æ“¬ 
 6 
åŠå…¶å½¢ç‚ºé å…ˆå®šç¾©å¥½ï¼Œç•¶è¦é–‹ç™¼æ‡‰ç”¨ç¨‹å¼æ™‚ä¸ä½†å¯ä»¥æ›´å¿«é€Ÿåœ°ç”¢ç”Ÿæ‰€éœ€è¦
çš„ç¨‹å¼ç¢¼ï¼Œä¹Ÿå› é å…ˆè¨­è¨ˆå¥½çš„è—åœ–å¯ä»¥è®“æ‡‰ç”¨ç¨‹å¼åŸ·è¡Œèµ·ä¾†æ›´åŠ é †æš¢è€Œç©©
å®šã€‚ 
 
åœ– 5 ä»¥ Android ç‚ºåŸºç¤çš„ï¤‚è¼‰é–˜é“å™¨è»Ÿé«”å †ç–Š 
Linux æ ¸å¿ƒæä¾›è¨±å¤šï¤‚è¼‰ç›¸é—œçš„é©…å‹•ç¨‹å¼ï¼Œå¦‚ CANã€LINã€MOSTã€
DSRCã€WIFIã€GPRSã€åŠ Binder ç­‰ã€‚å…¶ä¸­ CAN é©…å‹•æä¾› CAN åŸç”Ÿæœå‹™å‡½
å¼åº«ä½¿ç”¨ï¼›è€Œ Binder å‰‡æ˜¯æä¾› IPC çš„åˆ†äº«è¨˜æ†¶é«”çš„é©…å‹•èƒ½åŠ›ã€‚CANã€LINã€
åŠ MOST æ˜¯å±¬æ–¼ï¤‚èº«é›»å­ç¶²è·¯è² è²¬æ”¶é›†ï¤‚èº«çš„è³‡è¨Šæˆ–æä¾›å¤šåª’é«”å¨›æ¨‚æœå‹™ï¼›
è€Œ DSRCã€WIFIã€åŠ GPRS å‰‡æ˜¯å»ºç«‹ï¤‚å­å’Œå¤–åœ¨ç’°å¢ƒçš„æºé€šç®¡é“ï¼Œå®ƒå€‘èƒ½
ä½¿ï¤‚ä¸Šæœå‹™çµåˆç’°å¢ƒï¼ŒåŒ…æ‹¬é€£çµç¶²éš›ç¶²è·¯ä¸Šçš„å„é …æœå‹™ã€‚ 
ä¸‰ã€æ•ˆèƒ½è©•ä¼° 
å°‡å±•ç¾å¦‚ä½•è©•ä¼°ç°¡åŒ–è™›æ“¬å„€å™¨è»Ÿä»¶æ¡†æ¶çš„æ€§èƒ½ã€‚å…¶ä¸­è»Ÿé«”çš„æ¡†æ¶æœ‰ 4
å±¤ï¼ŒåŒ…æ‹¬ï¼šï¤‚è¼‰æ‡‰ç”¨å±¤ï¼Œï¤‚è¼‰æ‡‰ç”¨æ¡†æ¶å±¤ï¼Œï¤‚è¼‰å‡½å¼åº«å±¤å’Œ Linux æ ¸å¿ƒå±¤ã€‚
é™¤äº† Linuxæ ¸å¿ƒå±¤åœ¨ç‰¹æ¬Šæ¨¡å¼é‹ä½œå¤–ï¼Œå…¶å®ƒä¸‰å±¤åŸ·è¡Œæ–¼ä½¿ç”¨è€…æ¨¡å¼ä¸‹åŸ·è¡Œã€‚
è‡ªå¾ 1950 å¹´é–‹å§‹ï¼Œé¦¬å¯å¤«éˆæ¨¡å¼å·²ç¶“è¢«å»£æ³›ç”¨ä¾†è©•ä¼°ç³»çµ±çš„æ•ˆèƒ½ã€‚é¦¬å¯å¤«
éˆæ¨¡å¼æ˜¯ä¸€ç¨® â€œç‹€æ…‹-ç©ºé–“â€åˆ†ææ¨¡å‹ï¼Œå®ƒæ˜¯ç”±ä¸€çµ„ç‹€æ…‹å’Œä¸€çµ„è½‰ç§»çŸ©é™£çµ„åˆ
è€Œæˆçš„å„ç¨®ç‹€æ…‹ã€‚æˆ‘å€‘ä½¿ç”¨æ­¤æ¨¡å‹ä¾†è©•ä¼°åµŒå…¥å¼ç³»çµ±çš„æ•ˆèƒ½ã€‚å¤§éƒ¨åˆ†çš„é€š
è¨Šç³»çµ±ä½¿ç”¨é¦¬å¯å¤«éˆä¾†è©•ä¼°æ•ˆèƒ½å’Œå¯é åº¦ï¼Œç”±å…¶æ˜¯ä½¿ç”¨é€£çºŒæ™‚é–“é¦¬å¤«éˆ
(CTMCs)ã€‚ æ ¹æ“š Kwiatkowska ç­‰å­¸è€…æ‰€æå‡ºçš„ CTMC å®šç¾©ï¼Œä¸€å€‹å…·æœ‰æ¨™è¨˜
çš„ CTMC æ˜¯ä¸€å€‹å…ƒç´ çš„çµ„åˆï¼Œ  (       )ç”±ä¸‹åˆ— 4 å€‹å…ƒç´ æ§‹æˆ: 
(1) S æ˜¯ä¸€å€‹ç‹€æ…‹çš„æœ‰é™é›†åˆã€‚ 
(2)  âˆˆ   ğ‘ æ˜¯å±¬æ–¼ S çš„èµ·å§‹ç‹€æ…‹ã€‚ 
(3)  :  Ã—  â†’ â„â‰¥0 æ˜¯ä¸€å€‹è½‰ç§»çŸ©é™£ã€‚ 
  
  
  
  CAN LIN MOST DSRC WiFi GPRS Binder å…¶ä»–é©…
å‹• 
Linux æ ¸å¿ƒ 
è™›æ“¬å„€éŒ¶ å®šä½å°èˆª å¤šåª’é«” é˜²ç›œä¿å…¨ è»Šèº«è¨ºæ–· è»Šè¼‰æ‡‰ç”¨ å…¶ä»–æ‡‰ç”¨ 
è»Šè¼‰æ‡‰ç”¨ç¨‹å¼ 
 
æ ¸å¿ƒå‡½å¼ 
Dalvikè™›æ“¬æ©Ÿ 
Android  
Runtime 
æ´»å‹•ç®¡
ç† 
è¦–çª—ç®¡
ç† 
ä½ç½®æœ
å‹™ 
åœ°åœ–æœ
å‹™ 
CANæœå‹™ 
å¤šåª’é«”
æœå‹™ 
å…¶ä»–æœ
å‹™ 
è»Šè¼‰æ‡‰ç”¨ç¨‹å¼æ¡†æ¶ 
ä»‹é¢ç®¡ç† 
å¤šåª’é«”æ¡†
æ¶ 
WebKit 
CANåŸ
ç”Ÿæœå‹™ 
Libc 
å…¶ä»–å‡½
å¼åº« 
è»Šè¼‰ç³»çµ±å‡½å¼åº« 
 8 
é‡å°æˆ‘å€‘è¨­è¨ˆçš„æ¨¡å‹æ™‚ï¼Œæ¯ä¸€å€‹åŸºç¤çš„ä»»å‹™å®šç¾©æ–¼æ¯ä¸€çµ„ç‹€æ…‹ä¸­ã€‚ä¾‹å¦‚ï¼š
é©—è­‰å±¬æ€§å¦‚â€ç³»çµ±æœ€çµ‚é”åˆ°é–’ç½®ç‹€æ…‹çš„æ©Ÿç‡ç­‰æ–¼ 1â€ã€‚é¦–å…ˆï¼Œæˆ‘å€‘å®£å‘Šå¸¸æ•¸ T
ç‚ºç³»çµ±åŸ·è¡Œæ™‚é–“ï¼Œç¬¬äºŒæ­¥é©Ÿè¨­å®š P ç‚ºæ©Ÿç‡äº‹ä»¶ç™¼ç”Ÿçš„æ¬¡æ•¸ã€‚å¦‚åœ– 8ï¼Œå±¬æ€§ P
å‘½ä»¤ï¼Œæè¿°ç‚º P>=1[G F ("Idle")]ï¼Œå¦‚ä¸Šè¿°çš„å®£å‘Šï¼Œå®šç¾©>=1æ˜¯ç•Œé™ï¼ŒG F (â€œIdleâ€)
æ˜¯è·¯å¾‘å±¬æ€§ã€‚G ç‚ºâ€alwaysâ€çš„æ„æ€ï¼Œæ–¼èªæ³•ä¸Šç¨±ç‚ºâ€globallyâ€ã€‚F æ˜¯â€eventuallyâ€
çš„æ„æ€ï¼Œæ–¼èªæ³•ä¸Šç¨±ç‚ºâ€futureâ€ã€‚å› æ­¤å±¬æ€§èªæ³• P>=1[G F ("Idle")]è¡¨ç¤ºç³»çµ±
ç¸½æ˜¯æˆ–æœ€çµ‚é”åˆ°é–’ç½®çš„ç‹€æ…‹å…¶æ©Ÿç‡å€¼ P å¤§æ–¼ç­‰æ–¼ 1ã€‚ç¸½ä¹‹æˆ‘å€‘ä½¿ç”¨å±¬æ€§å‘½
ä»¤çš„æ–¹å¼ä¾†åšç‚ºæª¢æ¸¬æˆ‘å€‘çš„æ¨¡å‹æ˜¯å¦åœ¨æ´»å‹•æƒ…æ³ä¸‹æˆ–è™•æ–¼é–’ç½®ç‹€æ…‹ã€‚ 
è¡¨ 1 è™›æ“¬å„€è¡¨çš„æ‡‰ç”¨ç¨‹å¼é¦¬å¯å¤«éˆç‹€æ…‹èªªæ˜è¡¨ 
ç‹€æ…‹ èªªæ˜ 
0 é–’ç½®ç‹€æ…‹ 
1 Andriod æ´»å‹•å…ƒä»¶ä½¿ç”¨ IPC å‘¼å«æœå‹™ 
2 Android æœå‹™å…ƒä»¶ä½¿ç”¨ JNI å‘¼å«åŸç”Ÿæœå‹™ 
3 åŸç”Ÿæœå‹™å‘¼å« CAN é©…å‹•ç¨‹å¼ä¸­çš„å‡½å¼ 
4 é©…å‹•å‘¼å« CAN å‡½å¼ 
5 CAN è¦æ±‚å‡½å¼ 
6 CAN å›è¦†å‡½å¼ 
7 é©…å‹•å°‡çµæœå‚³çµ¦ JNI å‡½å¼ 
8 JNI å‡½å¼å°‡çµæœå›å‚³çµ¦ CAN æœå‹™å…ƒä»¶ 
9 CAN æœå‹™å…ƒä»¶å›å‚³çµæœçµ¦æ´»å‹•å…ƒä»¶ 
10 æ´»å‹•å…ƒä»¶é¡¯ç¤ºçµæœä¸¦è¿”å›é–’ç½®æ¨¡å¼ 
æœ‰æ™‚å€™æˆ‘å€‘æ›´åœ¨ä¹æœ‰é—œæ–¼é•·æ™‚é–“åŸ·è¡Œæˆ–è€…ç¨±ä¹‹ç‚ºç©©å®šç‹€æ…‹çš„è¡Œç‚ºã€‚åœ¨
PRISM ä¸­ï¼Œå¦ä¸€ç¨® S çš„èªæ³•æ˜¯è¢«ä½¿ç”¨æ–¼è§€æ¸¬ç³»çµ±æœ€å¾Œæ–¼ç©©å®šç‹€æ…‹çš„è¡Œç‚ºã€‚
å±¬æ€§èªæ³• S=? [ ("Idle") ]å°±æ˜¯ç³»çµ±ç©©å®šç‹€æ…‹è¡Œç‚ºä¸‹è™•æ–¼é–’ç½®çš„æ©Ÿç‡ç‚ºå¤šå°‘?
æœ€çµ‚ï¼Œæˆ‘å€‘ä½¿ç”¨ R çš„å±¬æ€§èªæ³•ä¾†è©•ä¼°æˆ‘å€‘çš„ç³»çµ±å‚³é€è¨Šæ¯çš„æ¬¡æ•¸ã€‚ 
 
åœ– 7 ä½¿ç”¨ PRISM ç°¡æ˜“å¡‘æ¨¡è™›æ“¬å„€éŒ¶æ‡‰ç”¨ç¨‹å¼çš„é‹ä½œ 
ctmc 
const int poll; 
module VM 
 s:[0..10] init 0; 
 [] s=0->(1/poll):(s'=1); 
 [] s=1->0.01:(s'=2); 
 [] s=2->0.01:(s'=3); 
 [] s=3->0.01:(s'=4); 
 [] s=4->0.1:(s'=5); 
 [request] s=5->(1/260):(s'=6); 
 [] s=6->(1/260):(s'=7); 
 [] s=7->0.01:(s'=8); 
 [] s=8->0.01:(s'=9); 
 [] s=9->0.01:(s'=10); 
 [] s=10->0.1:(s'=0); 
endmodule 
 
label "Idle" = s=0; 
 
rewards "msgcnt" 
 [request]true:1; 
endrewards 
 10 
æ–¼ä¸åŒç³»çµ±ç‹€æ…‹æˆ‘å€‘å¯ä»¥çµ¦äºˆä¸åŒæ™‚é–“çè³å€¼ï¼Œé€™æ¨£å°±èƒ½è¼•æ˜“åœ°ç¶“ç”±
PRISM ç³»çµ±ä¾†å”åŠ©æ±‚å¾—ã€‚ 
5. Hybrid å¼•æ“ä¸èƒ½ç”¨æ–¼çè³å€¼é‹ç®— 
PRISM ç³»çµ±æä¾›ä¸‰ç¨®è¨ˆç®—å¼•æ“ï¼Œåˆ†åˆ¥æ˜¯ Hybridã€Sparseã€MTBDDï¼Œåœ¨
PRISM ä¸­ä½¿ç”¨é¦¬å¯å¤«æ±ºç­–éç¨‹æ¨¡å‹è¨ˆç®—çè³å€¼æ™‚åªèƒ½é¸ç”¨ Sparse æˆ–
MTBDDï¼Œä¸èƒ½é¸ç”¨ Hybridï¼Œç³»çµ±é è¨­å€¼æ˜¯ Hybridã€‚ 
å››ã€çµè«– 
æ­¤è¨ˆç•«ä¸­ï¼Œæˆ‘å€‘ä»¥ Android ç‚ºåŸºç¤ä¾†æ¢è¨çš„è¡Œå‹•è¼‰å…·ä¸ŠæˆåŠŸåœ°å¯¦ä½œè™›æ“¬å„€
å™¨çš„æ¡†æ¶åŠå…¶æ€§èƒ½è©•ä¼°ï¼Œå°æ–¼ Android è¡Œå‹•è¼‰å…·ä¸Šæœ‰é—œæ–¼è™›æ“¬å„€å™¨çš„æ¡†æ¶ï¼Œæˆ‘
å€‘æ¡ç”¨é¦¬çˆ¾å¯å¤«éˆä¾†é€²è¡Œåˆ†æè™›æ“¬å„€å™¨è»Ÿä»¶ç”±å››å€‹å±¤æ¬¡çµ„æˆçš„ã€‚æˆ‘å€‘æˆåŠŸåœ°
å˜—è©¦ä½¿ç”¨ PRISM å·¥å…·ä¾†å»ºç«‹é¦¬çˆ¾å¯å¤«éˆä¸¦è©•ä¼°è™›æ“¬å„€å™¨è»Ÿé«”çš„æ•ˆèƒ½ã€‚ç¶“ç”±è»Ÿ
é«”è§€æ¸¬é–’ç½®ç‹€æ…‹çš„æƒ…æ³ï¼ŒåŒ…æ‹¬ï¼šé–’ç½®ç‹€æ…‹ä¸‹çš„æ©Ÿç‡å€¼å’Œé æœŸå¯ä»¥ç™¼é€è¨Šæ¯æ•¸
é‡ã€‚æˆ‘å€‘ä¹Ÿç ”ç©¶ä½¿ç”¨é¦¬å¯å¤«æ±ºç­–æ¨¡å‹ä¾†é€²è¡Œå° IEEE802.11 æ¨¡å‹çš„ç ”ç©¶ï¼Œä¸¦æ
å‡ºå¹¾é …çœ‹æ³•ï¼ŒåŒ…æ‹¬ï¼šç¢°æ’å½¢æˆã€éš¨æ©Ÿå»¶é²æ™‚é–“ã€æµé€æ™‚é–“ã€é¦¬å¯å¤«çè³æ¨¡å¼
ä»¥åŠ Hybrid å¼•æ“ä¸èƒ½ç”¨æ–¼çè³å€¼é‹ç®—ã€‚æœ¬è¨ˆç•«æˆæœä¹ŸåŒ…æ‹¬åœ¨ç•°è³ªæ„Ÿæ¸¬èˆ‡é©…å‹•
å™¨ç¶²è·¯ä¸­å”èª¿å¼äº’é€šèˆ‡ç›¸ä¾æ€§èšåˆæ¶æ§‹ä¹‹ç ”ç©¶[7]ã€‚ç”±æ–¼å³æ™‚æ€§çš„è¡Œç‚ºåˆ†æ[5-6]
åœ¨è»Ÿé«”ç™¼å±•ä¸Šæ˜¯éå¸¸é‡è¦æ€§ï¼Œæœªä¾†æˆ‘å€‘å°‡æŒçºŒé€²è¡Œç ”ç©¶ï¼ŒæœŸèƒ½æœ‰åŠ©æ–¼æˆ‘åœ‹ç”¢
å°åœ¨åµŒå…¥å¼ç³»çµ±ä¸Šçš„ç™¼å±•ã€‚ 
åƒè€ƒæ–‡ç» 
[1] ç¶“æ¿Ÿéƒ¨ï¼Œã€Œ2010 å¹´ç”¢æ¥­æŠ€è¡“ç™½çš®æ›¸ã€ï¼Œhttp://doit.moea.gov.tw/itech/ã€‚ 
[2] J. Jezequel and B. Meyer, â€œDesign by Contract: The Lessons of Ariane, 
Computer,â€ January 1997. 
[3] C. Baier and J. P. Katoen, â€œPrinciples of Model Checking,â€ The MIT Press, pp. 
1-16, 2008. 
[4] M. Kwiatkowska, G. Norman and J. Sprostion, â€œProbabilistic Model Checking 
of the IEEE 802.11 Wireless Local Area Network Protocol,â€ Proc. 
PAPM/PROBMIVâ€™02, Vol. 2399 of Lecture Notes in Computer Science, pp. 
169-187, July 2002. 
[5] G. Norman, D. Parker and J. Sproston, â€œModel Checking for Probabilistic 
Timed automata,â€ to appear in Formal Methods in system Design, Springer, 
2012. 
[6] M. Kwiatkowska, G. Norman and D. Parker, â€œPRISM 4.0: Verfication of 
Probabilistic Real-time Systems,â€ in Proc. 23rd International Conference on 
Computer Aided Verification (CAVâ€™11), vol. 6806 of LNCS, pp. 585-591, 
Springer, July 2011. 
[7] é‚±ä»æˆ, â€œåœ¨ç•°è³ªæ„Ÿæ¸¬èˆ‡é©…å‹•å™¨ç¶²è·¯ä¸­å”èª¿å¼äº’é€šèˆ‡ç›¸ä¾æ€§èšåˆæ¶æ§‹ä¹‹ç ”
ç©¶â€, é€¢ç”²å¤§å­¸åšå£«è«–æ–‡, February, 2012. 
ä¸€ã€åƒåŠ æœƒè­°ç¶“é 
å»å¹´12æœˆ16-18æ—¥åƒåŠ ç”±ä¸­åœ‹æ·±åœ³å“ˆçˆ¾æ¿±å·¥æ¥­å¤§å­¸èˆ‰è¡Œçš„ç¬¬äºŒå±†å‰µæ–°ä»¿ç”Ÿè¨ˆç®—åœ‹
éš›ç ”è¨æœƒ(Second International Conference on Innovations in Bio-inspired 
Computing and Applications)ï¼Œæ­¤æœƒè­°æ¶µè“‹14å€‹ä¸»é¡Œï¼ŒåŒ…æ‹¬ï¼šäººå·¥å…ç–«ç³»çµ±ã€äººå·¥
æ™ºæ…§ã€äººå·¥ç¥ç¶“ç¶²è·¯ã€ç´°èƒè‡ªå‹•æ©Ÿã€èªçŸ¥æ¨¡å‹ã€æ¨¡ç³Šé‚è¼¯ç­‰è­°é¡Œã€‚ 
æœ¬äººåœ¨æ·±åœ³èˆ‰è¡Œçš„å‰µæ–°ä»¿ç”Ÿè¨ˆç®—åœ‹éš›ç ”è¨æœƒä¸Šï¼Œèˆ‡æœ¬æ ¡é„§æ‰€é•·æ¢ç¶±ã€é¾æ•™æˆç§‹å¬Œã€
æ—æ•™æˆå¿—é´»ç­‰åŒä»å…±ç™¼è¡¨å››ç¯‡æ–‡ç« ï¼Œåˆ†åˆ¥æ˜¯ã€ŒBenchmark Dalvik and Native for Android 
Systemã€ã€ã€ŒAn Implemntation for Connecting Android Powered Device to External 
Worldã€ã€ã€ŒBluetooth-based Android Interactive Applications for Smart Livingã€ã€
ã€ŒDesign and Implement Augmented Reality for Supporting Driving Visual Guidanceã€
åˆ†åˆ¥ç”±æœ¬äººã€é„§æ•™æˆæ¢ç¶±ã€é¾æ•™æˆç§‹å¬Œã€æ—æ•™æˆå¿—é´»é€²è¡Œå£é ­å ±å‘Šã€‚ã€ŒBenchmark Dalvik 
and Native for Android Systemã€æ–‡ç« ï¼Œå…¨æ–‡å¦‚é™„ä»¶ä¸€ã€‚ 
äºŒã€èˆ‡æœƒå¿ƒå¾— 
ã€ŒBenchmark Dalvik and Native for Android Systemã€æ˜¯ä»Šå¹´åœ‹ç§‘æœƒè¨ˆç•«åŸ·è¡Œ
çš„åˆæ­¥ç ”ç©¶æˆæœï¼Œè°·æ­Œçš„AndroidåŸç”Ÿé–‹ç™¼å¥—ä»¶ï¼ˆNDKï¼‰æ˜¯ä¸€å€‹å·¥å…·é›†ï¼Œå¯ä»¥ç”¨ä¾†ç™¼å±•
åŸç”Ÿå‡½å¼åº«ï¼Œä½¿ç”¨åŸç”Ÿç¨‹å¼ç¢¼ä¾†æå‡Androidæ‡‰ç”¨ç¨‹å¼çš„æ•ˆèƒ½ã€‚NDKä½¿é–‹ç™¼äººå“¡èƒ½å¤ è¼•
é¬†åœ°ç·¨è­¯C / C++ç¨‹å¼ä¾›Androidé–‹ç™¼å¹³å°ä½¿ç”¨ã€‚è‹¥é–‹ç™¼äººå“¡ä¸é—œå¿ƒå¦‚ä½•æœ‰æ•ˆåœ°ä½¿ç”¨åŸ
ç”Ÿç¨‹å¼ç¢¼å’ŒDalvikçš„Javaç¨‹å¼ç¢¼ï¼Œå°‡å°è‡´ç³»çµ±æ•´é«”æ•ˆèƒ½ä½è½ã€‚é›–ç„¶æœ‰ä¸€äº›ç ”ç©¶è¨è«–é—œ
æ–¼Javaå’ŒC / C++è©•ä¼°æ•ˆèƒ½çš„æ¨™ç«¿ç¨‹å¼ä½†æ˜¯ä»–å€‘ä¸è€ƒæ…®Dalvikå’ŒåŸç”Ÿç¨‹å¼ç¢¼çš„Android
ç·¨è­¯çµæœæˆ–è©•ä¼°åœ¨çœŸæ­£çš„Androidè¨­å‚™çš„æ•ˆèƒ½ã€‚å› æ­¤åœ¨é€™é …å·¥ä½œä¸­ï¼Œæˆ‘å€‘åœ¨çœŸæ­£çš„
Androidè¨­å‚™ä¸Šä½¿ç”¨äº†ä¸€å€‹æ›´å®Œæ•´çš„æ–¹æ³•ç‚ºåŸºæº–çš„Dalvikçš„JavaåŸç”Ÿç¢¼å’ŒåŸç”Ÿç¨‹å¼ç¢¼ã€‚
æˆ‘å€‘é€²è¡Œäº†12æ¬¡æ¸¬è©¦ç¨‹åºçš„æ€§èƒ½é€²è¡Œåˆ†æï¼Œç™¼ç¾åŸç”Ÿç¨‹å¼ç¢¼çš„é€Ÿåº¦æ¯”ç´„34.2ï¼…çš„
Dalvikçš„Javaç¨‹å¼ç¢¼ã€‚ 
æ­¤æ¬¡åƒåŠ åœ‹éš›æœƒè­°ï¼Œé™¤äº†å‘èˆ‡æœƒè€…èªªæ˜æˆ‘å€‘æ‰€å¯¦ä½œçš„æŠ€è¡“åŠæ–°çš„æ–¹æ³•ï¼Œä¹Ÿå¯ä»¥è½
å–èˆ‡æœƒè€…çš„æ„è¦‹ï¼Œé€²è€Œæ”¹å–„æˆ‘å€‘çš„ç³»çµ±åŠç†è«–ã€‚ 
Benchmark Dalvik and Native Code for Android System 
 
 
Cheng-Min Lin 
Department of Computer and Communication 
Engineering, Nan Kai University of Technology, 
Caotun Township, Nantou County, Taiwan (R.O.C.) 
e-mail: lcm@nkut.edu.tw 
Jyh-Horng Lin 
Department of Electrical Engineering,  
Nan Kai University of Technology, 
Caotun Township, Nantou County, Taiwan (R.O.C.) 
e-mail:jhlin@nkut.edu.tw
Chyi-Ren Dow 
Department of Information Engineering and Computer 
Science, Feng-Chia University 
TaiChung City, Taiwan (R.O.C.) 
e-mail: crdow@fcu.edu.tw 
Chang-Ming Wen 
Graduate Institute of Information Engineering and 
Computer Science, Feng-Chia University, 
TaiChung City, Taiwan (R.O.C.) 
e-mail: m9740977@fcu.edu.tw
 
 
Abstractâ€”Google's Android Native Development Kit (NDK) is 
a toolset that lets you embed components to use of native code 
in your Android applications. It makes possible for developers 
to easily compile in C/C++ for the Android development 
platform. Generally, developer does not concern how effective 
between native code and Dalvik Java code that will causes poor 
performance of Android. There are some researches discussed 
about benchmark Java and C/C++. But they do not consider 
the issues of Dalvik and native code for Android programming 
or evaluate them in real Android device. In this work, we use a 
more complete approach to benchmark Dalvik java code and 
Native code on real Android device. We conducted 12 test 
programs to analyze the performance and found that native 
code faster than Dalvik Java code for about 34.2%. 
Keywords-Component; Android; NDK; Benchmark; Native 
code ; Dalvik Java code; 
 INTRODUCTION 
Google Android is an operating system which includes 
middleware, key applications, and software stack for mobile 
devices [6]. The first Googleâ€™s Android phone T-Mobile G1 
was announced at Guastavinoâ€™s in New York City unveiled 
September 23 2008. Over the past years, the market of 
Google Android continues growing rapidly. Today, many 
devices install the Android system as the operating system. 
To developing Android program, the Google Inc 
provides two kits for the Android development platform: 
The Android Software Development Kit (SDK) provides 
necessary tools and libraries for programmers to 
begin developing applications that run on 
Android-powered devices [3]. The first Android 
SDK (m3-rc20a) was released on 12 December 2007. 
Now, the latest version is SDK Tools, Revision 12 
was released on July 2011. This version supports 
Android 2.3.4 and 3.2 Platform developments. 
The Android Native Development Kit (NDK) is a toolset 
that lets programmers to embed components that 
make use of native code in Android applications [7]. 
The first Android NDK (Android 1.5 NDK, Release 
1) was released on June 2009. Now, the latest 
version of Android NDK, Revision 6 was released 
on July 2011. This version supports ARM and X86 
platforms. 
Generally, developer does not concern how effective 
between native code and Dalvik Java code that will causes 
poor performance of Android. 
In additional, there are some researches [9-11] discussed 
about benchmark Java and C/C++. But they do not consider 
the issues of Dalvik and native code for Android 
programming or evaluate them in real Android device [1]. In 
this work, we use a more complete approach to benchmark 
Dalvik java code and Native code on real Android device. 
We refer to the benchmark programs of predecessors [12] 
and port them to the Android platform.  
The reset of this paper is organized as follows. In Section 
2, we discuss related works. While in Section 3, we describe 
the contents of the comparison benchmarks. Section 4 
demonstrates the experimental results. Lastly, we conclude 
this paper in Section 5. 
RELATED WORKS 
A few related studies indicating performance analysis 
have been made. Keithâ€™s web [12] evaluates 14 kinds of 
algorithms in Java and C + + performance comparison. The 
work shows that Java has better performance than C++. But 
the performance analysis for native code and Dalvik Java 
code in Android platform was not evaluated. However, we 
refer the authorâ€™s programs and port them to the Android 
platform for comparing native code and Dalvik Java code. 
L. Batyuk et al. [1] benchmarks Native code on Android 
emulator and Linux x86 PC. The work shows that native 
applications can be up to 30 times as fast as an identical 
algorithm running in Dalvik VM and java applications can 
speed-up to 10 times if utilizing JNI. But there are too few 
experimental methods evaluated and experiments were down 
é™„ä»¶ä¸€ã€æœƒè­°è«–æ–‡å…¨æ–‡ 
HTC DESIRE A8181 SPECIFICATION 
CPU Qualcomm 8250, 1GHz 
RAM 576MB 
ROM 512MB 
Android Version 2.2 Froyo 
DEVELOPMENT ENVIRONMENT 
Operating System Microsoft Windown XP SP3 
IDE Eclipse 3.5.2 
SUN Java Version 1.6.0_26 
Android SDK Revision 12 . 
Android NDK Revision 6. 
GCC/G++ Version Cygwin / 4.3.4 
Android Emulator Android 2.1-update1 / API 7 
 
Typically, Default heap size of Android phone is 24MB. 
To avoid out memory error caused by the program, we adjust 
the heap size to 64MB. 
Figure 2 is one of the program screenshot that it shows 
the performance of the Nestedloop test program. 
 
Mestedloop program screenshot. 
Results 
Figure 4 shows the experimental results. The x-axis of 
the graph represents input parameter. The y-axis of the graph 
represents execution time in milliseconds. The blue line of 
the graph represents Dalvik Java code and red line of the 
graph represents native code. 
According to the results, most experiment using the 
native code is faster than using the same algorithm running 
on Dalvik Java code. Throughout of the recursive experiment 
Ackermann in Dalvik Java code performance is very bad. 
When we set the input parameter to 6, it produces a 
â€œStackOverflowErrorâ€ error and then the program crash. 
Another result from the entire experiment, we found that 
Hash, Heapsort and Random testing of Dalvik Java code was 
faster than native code. In the native code, Nested loops has 
best performance. 
In the separate analysis, we set input parameter to let the 
entire program's execution time to 3 seconds. Figure 3 shows 
the results of all evaluation results.  
 
The program's execution time is about 3 seconds. 
Table 4 shows the detail experimental results of Figure 3. 
We found that native code faster than Dalvik Java code 
about 34.20%.  
DALVIK JAVA CODE WITH NATIVE CODE COMPARED 
Test program Input Dalvik Native Compare 
Ackermann 14 
Program 
Crash 
202065 - - 
Fibonacci 35 540439 72648 86.56% 
Hash 290000 11873 30679 -158.39% 
Hash2 10000 234268 147226 37.15% 
Heapsort 1000000 4378 5543 -26.61% 
Matrix 100000 115306 24703 78.58% 
Methcall  1E+09 411370 30276 92.64% 
Objinst 1E+08 487266 172997 64.50% 
Nestedloop 35 35406 7 99.98% 
Random 1E+07 5126 7521 -46.72% 
Sieve 100000 61035 22244 63.56% 
Strcat 1400000 1657 250 84.91% 
Average 34.20% 
a. Dalvik and Native execution time in milliseconds  
CONCLUSIONS AND FUTUREWORK 
In this work, we benchmark Dalvik java code and native 
code with Android phone HTC Desire. We rewrite 12 
programs and port them to the Android platform for 
comparing native code and Dalvik Java code. 
We evaluate different algorithms in Dalvik Java code and 
native code. According to the results, we found that there are 
three tests that the Dalvik Java code faster than native code. 
Also, we found that a one item that Dalvik Java code 
performance is very bad. In addition, the overall performance 
assessment of native code is faster than Dalvik Java code 
about 34.2%. This will help software designers to create 
efficient Android applications. 
In our future work, we will continue analysis of dual-core 
mobile CPU performance and battery power consumption 
comparison in Dalvik Java code and native code that help 
software designers to create efficient Android applications. 
ACKNOWLEDGMENT 
0
500
1000
1500
2000
2500
3000
3500
Ti
m
e
(m
s)
Dalvik
Native
  
  
  
  
  
  
Experimental results 
 
0
50000
100000
150000
200000
250000
1 2 3 4 5 6 7 8 9 10 11 12 13 14
Ti
m
e
(m
s)
Ackermann
Dalvik
Native
Input
0
100000
200000
300000
400000
500000
600000
1 4 7 10 13 16 19 22 25 28 31 34 37 40 43 46
T
im
e
(m
s)
Fibonacci
Dalvik
Native
Input
0
5000
10000
15000
20000
25000
30000
35000
1 3 5 7 9 11 13 15 17 19 21 23 25 27 29
Ti
m
e
(m
s)
Hash
Dalvik
Native
Input(10^4)
0
50000
100000
150000
200000
250000
1 2 3 4 5 6 7 8 9 10
Ti
m
e
(m
s)
Hash2
Dalvik
Native
Input(10^3)
0
1000
2000
3000
4000
5000
6000
1 2 3 4 5 6 7 8 9 10
Ti
m
e
(m
s)
Heapsort
Dalvik
Native
Input (10^5)
0
20000
40000
60000
80000
100000
120000
140000
1 2 3 4 5 6 7 8 9 10
Ti
m
e
(m
s)
Matrix
Dalvik
Native
Input(10^4)
0
5000
10000
15000
20000
25000
30000
35000
40000
45000
1 2 3 4 5 6 7 8 9 10
Ti
m
e
(m
s)
Methcall
Dalvik
Native
Input(10^7)
0
10000
20000
30000
40000
50000
60000
1 2 3 4 5 6 7 8 9 10
Ti
m
e
(m
s)
Objinst
Dalvik
Native
Input(10^6)
0
5000
10000
15000
20000
25000
30000
35000
40000
1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35
Ti
m
e
(m
s)
Nestedloop
Dalvik
Native
Input
0
1000
2000
3000
4000
5000
6000
7000
8000
1 2 3 4 5 6 7 8 9 10
Ti
m
e
(m
s)
Random
Dalvik
Native
Input(10^6)
0
1000
2000
3000
4000
5000
6000
7000
1 2 3 4 5 6 7 8 9 10
Ti
m
e
(m
s)
Sieve
Dalvik
Native
Input(10^3)
0
200
400
600
800
1000
1200
1400
1600
1800
1 2 3 4 5 6 7 8 9 10 11 12 13 14
Ti
m
e
(m
s)
Strcat
Dalvik
Native
Input(10^5)
100ï¦ï¨å°ˆé¡Œç ”ç©¶è¨ˆç•«ç ”ç©¶æˆæœå½™æ•´è¡¨ 
è¨ˆç•«ä¸»æŒäººï¼šï§´æ­£æ• è¨ˆç•«ç·¨è™Ÿï¼š100-2221-E-252-011- 
è¨ˆç•«åç¨±ï¼šä»¥é¦¬å¯å¤«æ±ºç­–éç¨‹ç‚ºåŸºç¤çš„é«˜æ•ˆèƒ½å³æ™‚åµŒå…¥å¼ç³»çµ±é©—è­‰ç’°å¢ƒä¹‹ç ”ç©¶èˆ‡å¯¦ä½œ 
ï¥¾åŒ– 
æˆæœé …ç›® å¯¦éš›å·²é”æˆ
ï¥©ï¼ˆè¢«æ¥å—
æˆ–å·²ç™¼è¡¨ï¼‰
é æœŸç¸½é”æˆ
ï¥©(å«å¯¦éš›å·²
é”æˆï¥©) 
æœ¬è¨ˆç•«å¯¦
éš›è²¢ç»ç™¾
åˆ†æ¯” 
å–®ä½ 
å‚™ è¨» ï¼ˆ è³ª åŒ– ï¥¯
æ˜ï¼šå¦‚ï¥©å€‹è¨ˆç•«
å…±åŒæˆæœã€æˆæœ
ï¦œ ç‚º è©² æœŸ åˆŠ ä¹‹
å° é¢ æ•… äº‹ ...
ç­‰ï¼‰ 
æœŸåˆŠï¥æ–‡ 0 0 100%  
ç ”ç©¶å ±å‘Š/æŠ€è¡“å ±å‘Š 1 1 100%  
ç ”è¨æœƒï¥æ–‡ 1 0 100% 
ç¯‡ 
 
ï¥æ–‡è‘—ä½œ 
å°ˆæ›¸ 0 0 100%   
ç”³è«‹ä¸­ä»¶ï¥© 0 0 100%  å°ˆï§ å·²ç²å¾—ä»¶ï¥© 0 0 100% ä»¶  
ä»¶ï¥© 0 0 100% ä»¶  
æŠ€è¡“ç§»è½‰ 
æ¬Šï§ï¤Š 0 0 100% åƒå…ƒ  
ç¢©å£«ç”Ÿ 4 2 100%  
åšå£«ç”Ÿ 2 1 100%  
åšå£«å¾Œç ”ç©¶å“¡ 0 0 100%  
åœ‹å…§ 
ï¥«èˆ‡è¨ˆç•«äººï¦Š 
ï¼ˆæœ¬åœ‹ç±ï¼‰ 
å°ˆä»»åŠ©ï§¤ 0 0 100% 
äººæ¬¡ 
 
æœŸåˆŠï¥æ–‡ 1 1 40%  
ç ”ç©¶å ±å‘Š/æŠ€è¡“å ±å‘Š 0 0 100%  
ç ”è¨æœƒï¥æ–‡ 5 1 100% 
ç¯‡ 
 
ï¥æ–‡è‘—ä½œ 
å°ˆæ›¸ 0 0 100% ç« /æœ¬  
ç”³è«‹ä¸­ä»¶ï¥© 0 0 100%  å°ˆï§ å·²ç²å¾—ä»¶ï¥© 0 0 100% ä»¶  
ä»¶ï¥© 0 0 100% ä»¶  
æŠ€è¡“ç§»è½‰ 
æ¬Šï§ï¤Š 0 0 100% åƒå…ƒ  
ç¢©å£«ç”Ÿ 0 0 100%  
åšå£«ç”Ÿ 2 0 100%  
åšå£«å¾Œç ”ç©¶å“¡ 0 0 100%  
åœ‹å¤– 
ï¥«èˆ‡è¨ˆç•«äººï¦Š 
ï¼ˆå¤–åœ‹ç±ï¼‰ 
å°ˆä»»åŠ©ï§¤ 0 0 100% 
äººæ¬¡ 
 
