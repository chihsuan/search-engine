ï¨ˆæ”¿é™¢åœ‹å®¶ç§‘å­¸å§”å“¡æœƒå°ˆé¡Œç ”ç©¶è¨ˆç•«å ±å‘Š  
ç†±èƒ½èˆ‡åŠŸï¥¡å°å‘ä¹‹ç ”ç©¶æ–¹æ³•ï¼æ‡‰ç”¨æ–¼è™•ï§¤å™¨ä¹‹è¨­è¨ˆ               
å­è¨ˆç•«å›› : ç†±èƒ½å°å‘ä¹‹ç·¨è­¯å™¨æ–¹æ³•åŠç›¸å°æº«ï¨æ„Ÿæ‡‰å™¨è¨­ç½®ä¹‹ç ”ç©¶(2/3) 
è¨ˆç•«ç·¨è™Ÿï¼šNSC 98-2220-E-007-024 
åŸ·ï¨ˆæœŸé–“ï¼š98 ï¦ 8 æœˆ 1 æ—¥è‡³ 99 ï¦ 7 æœˆ 31 æ—¥ 
ä¸»æŒäººï¼šé»ƒå©·å©· æ¸…è¯å¤§å­¸è³‡è¨Šå·¥ç¨‹ç³» æ•™æˆ 
 
 
ä¸€ã€ ä¸­è‹±æ–‡æ‘˜è¦ï¼š 
 
éš¨è‘—è£½ç¨‹çš„é€²æ­¥ï¼Œæ™¶ç‰‡(Chip)é–“çš„åŒ¯ï§Šæ’éš¨
è‘—è£½ç¨‹ï¥§æ–·çš„é€²æ­¥åŠå„ç¨®é›»å­ç”¢å“çš„éœ€æ±‚
ï¥¾å¢åŠ ï¼Œé€™äº›ç”¢å“çš„è¨­è¨ˆè¤‡é›œï¨ä¹Ÿéš¨ä¹‹ä¸Š
æ˜‡ï¼Œè€Œé€™å€‹è¶¨å‹¢é€ æˆé›»èƒ½è€—æåœ¨ VLSI çš„è¨­
è¨ˆä¸Šç›¸å°çš„è¶Šï¤­è¶Šé‡è¦ã€‚ç”±æ–¼å–®ä½é¢ç©æ¶ˆ
è€—çš„é›»èƒ½è¶Šï¤­è¶Šå¤§ï¼Œé€ æˆæº«ï¨çš„æ•ˆæ‡‰ä¹Ÿç›¸
å°è¶Šï¤­è¶Šå¤§ã€‚ç”±æ–¼æº«ï¨æ‰€é€ æˆçš„å½±éŸ¿ç”š
é‰…ï¼Œå› æ­¤ï¼Œç›®å‰æœ‰è¨±å¤šçš„ç ”ç©¶ï¼Œï¨¦è‘—é‡åœ¨
å¦‚ ä½• æœ‰ æ•ˆ çš„ é€² ï¨ˆ ç†± èƒ½ ç®¡ ï§¤ (thermal 
management)ã€‚ è¿‘å¹¾ï¦æœ‰è¨±å¤šé‡å°ä¸­å¤®
è™•ï§¤å™¨(CPU)æ•£ç†±çš„ç ”ç©¶ï¼Œè€Œé€™äº›ç ”ç©¶å¤§è‡´
ä¸Šå¯ä»¥åˆ†æˆï¥¸å¤§ï§ï¼šéœæ…‹ç†±èƒ½ç®¡ï§¤(static 
thermal management)èˆ‡å‹•æ…‹ç†±èƒ½ç®¡ï§¤
(dynamic thermal management)ã€‚ 
éœæ…‹ç†±èƒ½ç®¡ï§¤(static thermal management)
æ–¹é¢ï¼Œæˆ‘å€‘æå‡ºçš„æ–¹æ³•ä¸»è¦æ˜¯åœ¨ç¨‹å¼ç·¨è­¯
æ™‚åšè™•ï§¤ï¼Œä¸¦ä¸”è‘—é‡æ–¼æš«å­˜å™¨çš„ç†±èƒ½ç®¡
ï§¤ã€‚ä¸­å¤®è™•ï§¤å™¨çš„æœ€é«˜æº«ï¨é»é€šå¸¸ï¨¦ç™¼ç”Ÿ
åœ¨æš«å­˜å™¨ï¼Œé€™æ˜¯å› ç‚ºæš«å­˜å™¨è¢«å­˜å–çš„æ¬¡ï¥©
ç›¸å°æ–¼å…¶ä»–å…ƒä»¶è€Œè¨€æ˜¯æœ€å¤šçš„ï¼Œè€Œä¸”æš«å­˜
å™¨çš„é¢ç©ï¨¦åå°ï¼Œå› æ­¤ç„¡æ³•æœ‰æ•ˆçš„æ•£ç†±ã€‚ 
å‹• æ…‹ ç†± èƒ½ ç®¡ ï§¤ (dynamic thermal 
management)æ–¹é¢ï¼Œé€²ï¨ˆç†±èƒ½ç®¡ï§¤çš„æ–¹æ³•
ä¹‹ä¸€ï¼Œæ˜¯ï§ç”¨æº«ï¨æ„Ÿæ‡‰å™¨ (temperature 
sensor)ï¤­æ¸¬ï¥¾æ™¶ç‰‡ä¸Šçš„æº«ï¨ï¼Œç›®çš„å¸Œæœ›æ¸›
å°‘æ¸¬ï¥¾æº«ï¨çš„èª¤å·®ã€‚åœ¨ç¾ä»Šçš„å…ˆé€²è£½ç¨‹
ä¸­ï¼Œè£½ç¨‹è®Šï¥¢æ€§(process variations)æ˜¯ä¸€å€‹
æœƒå½±éŸ¿æ¸¬ï¥¾æº«ï¨çš„é‡è¦å› ç´ ã€‚ç›®å‰æ‰€æå‡º
é—œæ–¼æº«ï¨æ„Ÿæ‡‰å™¨çš„æ¶æ§‹ä¸­ï¼Œå—åˆ° process 
variations çš„å½±éŸ¿ï¤æ˜¯ç›¸ç•¶åš´é‡ï¼Œæœ€å¤§çš„èª¤
å·®å€¼ç”šè‡³æœƒé”åˆ°ï¼‹(ï¼)12â„ƒï¼Œé€²è€Œå½±éŸ¿æ™¶ç‰‡
çš„ performanceã€‚æ‰€ä»¥è¨ˆç•«çš„ç›®çš„å¸Œæœ›æå‡º
æ–°çš„ä¸€ç¨®æ¶æ§‹ï¼ŒåŒæ™‚è€ƒæ…®å¦‚ä½•åœ¨è¨­è¨ˆçš„æ™¶
ç‰‡ä¸Šï¼Œé©ç•¶çš„æ“ºä¸Šæº«ï¨æ„Ÿæ‡‰å™¨ï¤­é€²ï¨ˆæ¸¬
ï¥¾ï¼Œï¤­è§£æ±ºé€™äº›å•é¡Œã€‚ 
å› æ­¤åœ¨æœ¬è¨ˆåŠƒä¸­æ¢è¨ï¥¸å€‹å•é¡Œï¼š 
(ä¸€)ã€éœæ…‹ç†±èƒ½ç®¡ï§¤ä¹‹æš«å­˜å™¨ç¹«çµåŠæŒ‡ï¦¨æ’
ç¨‹ä»¥å¹³è¡¡åŠæ¸›å°‘æš«å­˜å™¨å­˜å–ã€‚ 
(äºŒ)ã€å‹•æ…‹ç†±èƒ½ç®¡ï§¤ä¹‹ç›¸å°æº«ï¨æ„Ÿæ‡‰å™¨ä¹‹è¨­
è¨ˆåŠå…¶è¨­ç½®ã€‚ 
 
äºŒã€ ç ”ç©¶è¨ˆåŠƒä¹‹èƒŒæ™¯åŠç›®çš„ 
 
éš¨è‘—è£½ç¨‹ï¥§æ–·çš„é€²æ­¥åŠå„ç¨®é›»å­ç”¢å“çš„éœ€
æ±‚ï¥¾å¢åŠ ï¼Œé€™äº›ç”¢å“çš„è¨­è¨ˆè¤‡é›œï¨ä¹Ÿéš¨ä¹‹
ä¸Šæ˜‡ï¼Œè€Œé€™å€‹è¶¨å‹¢é€ æˆé›»èƒ½è€—æåœ¨ VLSI çš„
è¨­è¨ˆä¸Šç›¸å°çš„è¶Šï¤­è¶Šé‡è¦ã€‚ç”±æ–¼å–®ä½é¢ç©
æ¶ˆè€—çš„é›»èƒ½è¶Šï¤­è¶Šå¤§ï¼Œé€ æˆæº«ï¨çš„æ•ˆæ‡‰ä¹Ÿ
ç›¸å°è¶Šï¤­è¶Šå¤§ã€‚ 
æº«ï¨æœƒé€ æˆçš„å½±éŸ¿æœ‰å¤šï¼Œåœ¨é€™ï§¨æˆ‘å€‘èˆ‰å‡º
å…¶ä¸­çš„å››å€‹ï¦µå­ï¼Œç¬¬ä¸€ï¼Œé›»æ™¶é«”çš„é€Ÿï¨æœƒ
éš¨è‘—æº«ï¨å‡é«˜è€Œï¨‰ä½ï¼Œé€™æ˜¯å› ç‚ºé›»è·æ”œå¸¶
ç§»å‹•ï¨(carrier mobility)ä¹Ÿæ˜¯éš¨è‘—æº«ï¨ä¸Šå‡
è€Œï¨‰ä½ï¼›ç¬¬äºŒï¼Œæº«ï¨å°ï¥é›»ï§Šçš„åŠŸï¥¡æ¶ˆè€—
æœ‰é¡¯è‘—çš„å½±éŸ¿ï¼Œåœ¨é«˜æº«çš„æ™‚å€™ï¼Œï¥é›»ï§Šæ‰€
é€ æˆçš„åŠŸï¥¡æ¶ˆè€—æœƒå‘ˆç¾å€ï¥©æˆé•·çš„ç¾è±¡ï¼›
ç¬¬ä¸‰ï¼Œå°ç·š(interconnect metal)ä¸Šçš„é›»é˜»
(resistivity)ä¹Ÿå’Œæº«ï¨æœ‰éå¸¸å¯†ï¨€çš„é—œä¿‚ï¼Œèˆ‰
ï¦µï¤­ï¥¯ï¼ŒéŠ…ç·šçš„é›»é˜»åœ¨æº«ï¨ç”± 20â„ƒä¸Šå‡è‡³
120â„ƒæ™‚æœƒå¢åŠ ç´„ 39%ï¼Œå°ç·šé›»é˜»è¶Šé«˜ï¼Œ
å°ç·šçš„å‚³å°é€Ÿï¥¡è¶Šä½ï¼Œå› æ­¤æœƒåš´é‡å½±éŸ¿ç”¢
å“æ•ˆèƒ½(performance)ï¼›ç¬¬å››ï¼Œæº«ï¨å°ç”¢å“
å¯é æ€§(reliability)ä¹Ÿæœ‰éå¸¸å¤§çš„å½±éŸ¿ï¼Œé€™å¯
ä»¥ ç”± é˜¿ ç‘ å°¼ æ–¯ æ–¹ ç¨‹ å¼ (Arrhenius 
equation)ï¼šMTF = MTF0 exp(EÎ± / kbT) 
å¾—åˆ°è­‰æ˜ï¼Œå…¶ä¸­ T æ˜¯æº«ï¨è®ŠåŒ–ï¼ŒMTF(mean 
time to failure)è¡¨ç¤ºç”¢å“çš„å¹³å‡å£½å‘½æ™‚é–“ã€‚
ç”±é€™å€‹æ–¹ç¨‹å¼å¯ä»¥ç™¼ç¾æº«ï¨è¶Šé«˜ï¼Œç”¢å“çš„
life time è¶ŠçŸ­ã€‚ 
ç”±æ–¼æº«ï¨æ‰€é€ æˆçš„å½±éŸ¿ç”šé‰…ï¼Œå› æ­¤ï¼Œç›®å‰
æœ‰è¨±å¤šçš„ç ”ç©¶ï¼Œï¨¦è‘—é‡åœ¨å¦‚ä½•æœ‰æ•ˆçš„é€²ï¨ˆ
ç†±èƒ½ç®¡ï§¤(thermal management)ã€‚ è¿‘ å¹¾
register re-binding)ã€‚ 
ã€€ æŒ‡ ï¦¨ æ’ ç¨‹ ä»¥ æ¸› å°‘ æš« å­˜ å™¨ å­˜ å– 
(Thermal-aware post-compilation for 
instruction re-scheduling)ã€‚ 
 
(äºŒ)ã€å‹•æ…‹ç†±èƒ½ç®¡ï§¤ä¹‹ç›¸å°æº«ï¨æ„Ÿæ‡‰å™¨ä¹‹è¨­
è¨ˆåŠå…¶è¨­ç½®ã€‚ 
è€Œé€²ï¨ˆç†±èƒ½ç®¡ï§¤çš„æ–¹æ³•ä¹‹ä¸€ï¼Œæ˜¯ï§ç”¨æº«ï¨
æ„Ÿæ‡‰å™¨(temperature sensor)ï¤­æ¸¬ï¥¾æ™¶ç‰‡ä¸Š
çš„æº«ï¨ï¼Œç›®çš„å¸Œæœ›æ¸›å°‘æ¸¬ï¥¾æº«ï¨çš„èª¤å·®ã€‚
åœ¨ç¾ä»Šçš„å…ˆé€²è£½ç¨‹ä¸­ï¼Œè£½ç¨‹è®Šï¥¢æ€§(process 
variations)æ˜¯ä¸€å€‹æœƒå½±éŸ¿æ¸¬ï¥¾æº«ï¨çš„é‡è¦
å› ç´ ã€‚ç›®å‰æ‰€æå‡ºé—œæ–¼æº«ï¨æ„Ÿæ‡‰å™¨çš„æ¶æ§‹
ä¸­ï¼Œå—åˆ° process variations çš„å½±éŸ¿ï¤æ˜¯ç›¸
ç•¶åš´é‡ï¼Œæœ€å¤§çš„èª¤å·®å€¼ç”šè‡³æœƒé”åˆ°ï¼‹(ï¼)12
â„ƒï¼Œé€²è€Œå½±éŸ¿æ™¶ç‰‡çš„ performanceã€‚æ‰€ä»¥è¨ˆ
ç•«çš„ç›®çš„å¸Œæœ›æå‡ºæ–°çš„ä¸€ç¨®æ¶æ§‹ï¼ŒåŒæ™‚è€ƒ
æ…®å¦‚ä½•åœ¨è¨­è¨ˆçš„æ™¶ç‰‡ä¸Šï¼Œé©ç•¶çš„æ“ºä¸Šæº«ï¨
æ„Ÿæ‡‰å™¨ï¤­é€²ï¨ˆæ¸¬ï¥¾ï¼Œï¤­è§£æ±ºé€™äº›å•é¡Œã€‚ 
ç‚ºï¦ºèƒ½å¤ ä½¿å‹•æ…‹ç†±èƒ½ç®¡ï§¤ï¤æœ‰å¯¦éš›æ•ˆç”¨ï¼Œ
ä¸€å€‹é‡è¦çš„é—œéµå°±æ˜¯å¿…é ˆæº–ç¢ºåœ°æ¸¬ï¥¾å‡ºæº«
ï¨ï¼Œåˆ¤æ–·å‡ºçœŸæ­£æœ€é«˜æº«ï¨é»(hotspot)ã€‚åœ¨ [5]
å’Œ[6] ä¸­ï¼Œç ”ç©¶è€…æå‡ºï¦ºä¸€ç¨®çµ•å°æº«ï¨æ„Ÿæ‡‰
å™¨çš„ä¸€ç¨®æ¶æ§‹ï¼Œç›®çš„æ˜¯ç‚ºï¦ºè—‰è‘—æœ‰æ•ˆçš„é…
ç½®å’Œæ“ºæ”¾é€™äº›çµ•å°æº«ï¨æ„Ÿæ‡‰å™¨ï¼Œï¤­æ­£ç¢ºçš„
æ¸¬ ï¥¾ æº« ï¨ ï¼Œ ä¸¦ ä¸” å°‡ æº« ï¨ æ„Ÿ æ‡‰ å™¨ å°
performance å’Œ threshold voltage çš„å½±éŸ¿
ï¨‰åˆ°æœ€ä½ï¼Œçµ•å°æº«ï¨æ„Ÿæ‡‰å™¨çš„æ¶æ§‹å¦‚åœ– 
(äºŒ)ï¼š 
 
åœ– (äºŒ) 
 
çµ•å°æº«ï¨æ„Ÿæ‡‰å™¨çš„æ¶æ§‹åŒ…å«ï¥¸éƒ¨åˆ†ï¼ŒCORE 
å’Œ BJTã€‚CORE åŒ…å«ï¥¸å€‹ä¸»è¦çš„éƒ¨ä»½ï¼Œä¸€
å€‹æ˜¯ analog to digital (ADC)çš„è½‰æ›å™¨ï¼Œä¸€
å€‹æ˜¯ç©©å®šé›»ï§Šçš„ç”¢ç”Ÿå™¨ã€‚ BJT æ˜¯ç”±
diode-connected bipolar transistor æ§‹æˆï¼Œ
ä¸»è¦æ˜¯æ¥å—ç©©å®šé›»ï§Šï¼Œå¯ä»¥ç”¢ç”Ÿä¸€å€‹é›»å£“
å€¼å›å‚³ã€‚åœ¨æ­£å¸¸å·¥ä½œçš„æƒ…æ³ä¸‹ï¼Œè—‰ç”± CORE
æä¾› BJT ä¸€å€‹ç©©å®šçš„é›»ï§Š(Ibias)ï¼ŒBJT å¯
ä»¥å›å‚³çµ¦ CORE ä¸€å€‹ç©©å®šçš„é›»å£“(VEB)ï¼Œ
é…åˆ ADC çš„è½‰æ›ï¼Œå¾—åˆ°ï¥©ä½çš„è¼¸å‡ºå€¼ã€‚æ ¹
æ“šï¥©ä½çš„è¼¸å‡ºå€¼ï¼Œå¯ä»¥é‡å°æ„Ÿæ‡‰å™¨æ‰€æ“ºæ”¾
çš„ä½ç½®ï¼Œå¾—åˆ°æ­£ç¢ºçš„æº«ï¨ã€‚åœ¨ï§¤æƒ³çš„ï§ºæ³ï¼Œ
å°æ–¼æ„Ÿæ‡‰å™¨æ‰€æ“ºæ”¾çš„ä½ç½®ï¼ŒBJT å’Œçµ•å°æº«
ï¨æ˜¯æˆç·šæ€§ç›¸é—œçš„ï¼Œè€Œ CORE å°æ–¼æº«ï¨çš„
æ³¢å‹•ï¼Œå‰‡ï¥§å®¹ï§ å—å½±éŸ¿ã€‚ 
ç‚ºï¦ºç­è§£åœ¨åœ–  (äºŒ) çš„æ¶æ§‹ä¸‹ï¼Œprocess 
variations å°æ–¼çµ•å°æº«ï¨æ¸¬ï¥¾çš„å½±éŸ¿ï¼Œåœ¨
Ibias = 10uA å’Œ 45nm çš„è£½ç¨‹ä¸‹ï¼Œé€²ï¨ˆï¦ºå¹¾
å€‹å¯¦é©—ï¼Œä¸¦æ¡ç”¨ SPICE [8] é€²ï¨ˆæ¨¡æ“¬çš„å‹•
ä½œã€‚åœ¨ç¬¬ä¸€å€‹å¯¦é©—ä¸­ï¼Œå‡è¨­è€ƒæ…® process 
variations åªå‡ºç¾åœ¨ BJT çš„éƒ¨ä»½ï¼Œæ ¹æ“š VEB
æ‰€å›å‚³çš„é›»å£“ï¼Œåˆ†åˆ¥åœ¨ typicalã€fastã€slow
ä¸‰å€‹ corner é€²ï¨ˆæº«ï¨æ¨¡æ“¬çš„å‹•ä½œï¼Œç™¼ç¾åœ¨
è€ƒæ…® process variations é€ æˆ VEB èª¤å·®çš„
ï§ºæ³ä¸‹ï¼Œæ¸¬ï¥¾å‡ºçš„æº«ï¨å’Œå¯¦éš›çš„æº«ï¨ï¼Œæœ€
å¤§å¯ä»¥é”åˆ° 8â„ƒçš„èª¤å·®ã€‚åœ¨ç¬¬äºŒå€‹å¯¦é©—ä¸­ï¼Œ
å‡è¨­è€ƒæ…® process variations åªå‡ºç¾åœ¨
CORE çš„éƒ¨ä»½ï¼Œé‡å° typical corner é€²ï¨ˆæº«
ï¨çš„æ¨¡æ“¬ã€‚ç‚ºï¦ºåæ˜ å‡º process variations 
å°æ–¼ Ibias çš„å½±éŸ¿ï¼Œï§ç”¨ä¸‰ç¨®é›»ï§Š(8uA , 
10uA , 12uA)ï¤­é€²ï¨ˆåˆ†æã€‚å¯¦é©—çµæœç™¼ç¾ï¼Œ
æ¸¬ï¥¾å‡ºçš„æº«ï¨å’Œå¯¦éš›çš„æº«ï¨ï¼Œæœ€å¤§å¯ä»¥é”
åˆ° 7â„ƒçš„èª¤å·®ã€‚ 
ç‚ºï¦ºç¸½çµå¯¦é©—ã„§å’Œå¯¦é©—äºŒçš„çµæœï¼Œåœ¨ç¬¬ä¸‰
å€‹å¯¦é©—ä¸­ï¼ŒåŒæ™‚è€ƒæ…® process variations å°
æ–¼ BJT å’Œ CORE æ‰€é€ æˆçš„å½±éŸ¿ï¼Œï¤­é€²ï¨ˆæº«
ï¨çš„æ¸¬ï¥¾ï¼Œå¯¦é©—çµæœå¦‚åœ– (ä¸‰)æ‰€ç¤ºï¼š 
åœ– (ä¸‰) 
é»(hotspot)æ˜¯æˆ‘å€‘è‘—é‡çš„ç›®æ¨™ã€‚é€™å€‹æ¼”ç®—
æ³•çš„æ¦‚ï¦£ä¸»è¦æ˜¯å¸Œæœ›è—‰ç”±æ¸›å°‘æš«å­˜å™¨çš„
å­˜å–æ¬¡ï¥©ï¤­é”åˆ°ï¨‰ä½æš«å­˜å™¨çš„æœ€é«˜æº«ï¨
é»(hotspot)ï¼Œåœ¨æ­¤ï¼Œæˆ‘å€‘ï§ç”¨ç®¡ç·š(pipeline)
ä¸­çš„å‰é¥‹(forwarding)æ©Ÿåˆ¶ï¤­é”åˆ°é€™å€‹ç›®
çš„ã€‚ 
åŸæœ¬åœ¨ pipeline ä¸­çš„ forwarding æ©Ÿåˆ¶æ˜¯ç”¨
ï¤­è§£æ±º data hazard çš„å•é¡Œï¼Œé€™æ˜¯æŒ‡æœ‰äº›
æŒ‡ï¦¨æœƒæœ‰è³‡ï¦¾ç›¸ä¾(data dependency)çš„
é—œä¿‚ï¼Œæ„åŠå‰ä¸€å€‹æŒ‡ï¦¨æ‰€ç”¢ç”Ÿçš„è³‡ï¦¾åœ¨ä¸‹
ä¸€å€‹æŒ‡ï¦¨æœƒéœ€è¦ç”¨åˆ°ï¼Œç•¶æŒ‡ï¦¨åœ¨ pipeline
ä¸­é‹ä½œæ™‚ï¼Œç‚ºï¦ºï¥§å› ç‚ºé€™å€‹åŸå› è€Œç”¢ç”Ÿç®¡
ç·šé–’ç½®(stall)ï¼Œå‰‡æ‰€éœ€è¦çš„è³‡ï¦¾å°‡ç›´æ¥ç”±
pipeline buffer ä¸­å‚³éè€Œï¥§æ˜¯ç¶“ç”±å­˜å–æš«
å­˜å™¨å¾—åˆ°ï¼Œé€™å€‹æ–¹æ³•ç¨±ç‚º forwardingã€‚ç‚º
ï¦ºæ¸›å°‘å­˜å–æš«å­˜å™¨çš„æ¬¡ï¥©ï¼Œæˆ‘å€‘æå‡ºä¸€å€‹
æŒ‡ï¦¨æ’ç¨‹çš„æ–¹æ³•ï¼Œç›¡ï¥¾å°‡æ»¿è¶³ forwarding 
æ¢ä»¶çš„æŒ‡ï¦¨ç¶“ç”±æ’ç¨‹æ”¾åœ¨ä¸€èµ·ï¼Œè€Œç•¶è€ƒæ…®
é€™å€‹å•é¡Œçš„æ™‚å€™ï¼Œé ˆè¦æ³¨æ„ï¥§èƒ½å¤ ç ´å£æ¯
å€‹æŒ‡ï¦¨é–“çš„ç›¸é—œæ€§ã€‚ 
é›–ç„¶ forwarding çš„æ©Ÿåˆ¶ï¨¦å­˜åœ¨æ–¼å„å€‹ä¸­
å¤®è™•ï§¤å™¨ä¸­ï¼Œä½†æ˜¯ï¼Œä¸€èˆ¬çš„ forwarding æ©Ÿ
åˆ¶æ˜¯ï§ç”¨ç¡¬é«”æ§åˆ¶çš„æ–¹å¼ï¤­åˆ¤åˆ¥è³‡ï¦¾çš„
ï¤­æºï¼Œé€šå¸¸ï¨¦é‚„æ˜¯è¦é€²ï¨ˆæš«å­˜å™¨å­˜å–ï¼Œä¹Ÿ
å°±æ˜¯ï¥¯ï¼Œæš«å­˜å™¨æœƒåœ¨ï¥§éœ€è¦è¢«å­˜å–çš„æƒ…æ³
ä¸‹è¢«å­˜å–ï¼Œç”±åœ– (äº”) æˆ‘å€‘å¯ä»¥ç™¼ç¾é€™
é»ï¼Œå› æ­¤ï¼Œé™¤ï¦ºæå‡ºä¸€å€‹é©åˆçš„æŒ‡ï¦¨æ’ç¨‹
(instruction scheduling)æ¼”ç®—æ³•ä½¿å¯ä»¥é€²
ï¨ˆ forwarding çš„æŒ‡ï¦¨å„ï¥©å¢åŠ ä¹‹å¤–ï¼Œæˆ‘å€‘
é‚„å¿…é ˆé¡å¤–è€ƒæ…®åˆ° data path çš„ä¿®æ”¹ï¼Œä½¿
forwarding æ©Ÿåˆ¶å•Ÿå‹•çš„æ™‚å€™ï¼Œï¥§æœƒæœ‰ï¥§å¿…
è¦çš„æš«å­˜å™¨å­˜å–ç™¼ç”Ÿã€‚ 
åœ– (å››) 
(ä¸‰)ã€ç›¸å°æº«ï¨æ„Ÿæ‡‰å™¨çš„è¨­è¨ˆåŠè¨­ç½®æ–¹å¼ 
(Temperature sensor structure 
modification and placement) 
åœ¨è€ƒæ…® process variations çš„ï§ºæ³ä¸‹ï¼Œç”±
æ–¼çµ•å°æº«ï¨æ„Ÿæ‡‰å™¨ç„¡æ³•ï¨æº–åœ°æ¸¬ï¥¾æº«
ï¨ï¼Œä¹Ÿé€ æˆç„¡æ³•æ‡‰ç”¨å‹•æ…‹æº«ï¨ç®¡ï§¤çš„æŠ€
è¡“ï¼Œï¤­ï¨‰ä½æº«ï¨æ‰€é€ æˆçš„å½±éŸ¿ã€‚åœ¨æ­¤ï¼Œæˆ‘
å€‘æå‡ºä¸€å€‹å…¨æ–°çš„æ„Ÿæ‡‰å™¨æ¶æ§‹ï¼Œï¤­å–ä»£ç›®
å‰çµ•å°æº«ï¨æ„Ÿæ‡‰å™¨çš„æ¶æ§‹ã€‚é€™å€‹æ–°çš„æ¶æ§‹
ï§ç”¨ç›¸å°æº«å·®çš„æ¦‚ï¦£ï¼Œï¤­ï¨‰ä½ process 
variations é€ æˆçš„å½±éŸ¿ã€‚ 
 
åœ– (äº”) 
ç”±æ–¼æ¡ç”¨ç›¸å°æº«å·®çš„æ¦‚ï¦£ï¼Œéœ€è¦æœ‰ä¸€å€‹æº«
ï¨çš„ï¥«è€ƒé»ï¼ŒBJT çš„éƒ¨ä»½æœƒè¢«åŠƒåˆ†æˆï¥¸å€‹
éƒ¨ä»½ï¼Œä¸€å€‹éƒ¨ä»½æ˜¯ HBJTï¼Œéœ€æ”¾åœ¨æ¥è¿‘ç†±
é»çš„ä½ç½®ï¤­æ­£ç¢ºçš„æ¸¬ï¥¾æº«ï¨ã€‚  ã„§å€‹æ˜¯
RBJTï¼Œéœ€æ”¾åœ¨æº«ï¨è¼ƒç©©å®šçš„åœ°æ–¹ï¼Œï¤­ï¨‰
ä½ process variations é€ æˆçš„å½±éŸ¿ã€‚ç‚ºï¦º
è¦è¨ˆç®—ï¥¸ç¨® BJT æ‰€åœ¨ä½ç½®çš„æº«ï¨å·®ï¥¢ï¼Œåœ¨
CORE çš„éƒ¨åˆ†æ–°åŠ å…¥ï¦ºä¸€å€‹ subtractorï¼Œ
ç›®çš„å¸Œæœ›è—‰ç”±ç›¸æ¸›çš„æ–¹å¼ï¼Œå¾—å‡ºç›¸å°æº«å·®
çš„ï¥©å€¼ã€‚é€™å€‹æ¶æ§‹çš„å¥½è™•åœ¨æ–¼ç”±æ–¼æ¡ç”¨ç›¸
å°æº«å·®çš„æ¦‚ï¦£ï¼Œå³ä½¿ HBJT å’Œ RBJT ï¨¦å—
åˆ° process variations çš„å½±éŸ¿ï¼Œå°è‡´å›å‚³
çš„é›»å£“(VEB)ç”¢ç”Ÿè®Šï¥¢ï¼Œä»ç„¶å¯ä»¥ç”¨ç›¸æ¸›
çš„æ–¹å¼ï¼Œæ¶ˆå» process variations æ‰€é€ æˆ
çš„é›»å£“è®Šï¥¢ã€‚ 
å¾é€™å€‹åŸå‹ä¸­ï¼Œè¡ç”Ÿå‡ºå•é¡Œéœ€è¦å»è§£æ±ºï¼Œ
ç¬¬ä¸€å€‹ç”±æ–¼å¼•å…¥ï¦ºç›¸å°æº«å·®çš„æ¦‚ï¦£ï¼Œèƒ½å¤ 
ç®—å‡ºæº«ï¨è®ŠåŒ–çš„ï¥¾ï¼Œä½†æ˜¯çµ•å°æº«ï¨çš„ï¥©
å€¼ï¼Œä»éœ€è¦æƒ³è¾¦æ³•ï¤­è¨ˆç®—ã€‚ç¬¬äºŒå€‹ç”±æ–¼æ
å‡ºï¦ºæº«ï¨ï¥«ç…§é»çš„æ¦‚ï¦£ï¼Œéœ€æœ‰é¡å¤–çš„
BJTï¼Œï¤­å¯¦ï¨ˆ RBJT æ‰€éœ€çš„åŠŸèƒ½ï¼Œé€™æœƒé€ 
æˆé¡å¤–é¢ç©çš„è² æ“”ï¼Œå¦‚ä½•æœ‰æ•ˆçš„æ±ºå®š
HBJT å’Œ RBJT çš„ï¥©ï¥¾ï¼Œä¸¦é‡å° CORE çš„
ï¥©ç›®ï¤­é€²ï¨ˆåˆ†çµ„ï¼Œæ˜¯ä¸€å€‹é‡è¦çš„å•é¡Œã€‚ 
åœ¨æ‡‰ç”¨ç›¸å°èª¤å·®çš„æ¦‚ï¦£ä¹‹å¾Œï¼Œæ–°çš„æ¶æ§‹åŒ…
å«ï¦º HBJTã€RBJT å’Œ CORE ä¸‰éƒ¨ä»½ã€‚è€Œ
[4] K. Skadron, T. Abdelzaher and M. R. 
Stan, â€Control Theoretic Techniques 
and Thermal-RC Modeling for 
Accurate and Localized Dynamic 
Thermal Management,â€ Proceedings 
of the Eighth International 
Symposium on High-Performance 
Computer Architecture, February 
2002. 
[5] Rajarshi Mukherjee and Seda Ogrenci 
Memik, â€Systematic temperature 
sensor allocation and placement for 
microprocessors,â€ Proceedings of the 
43rd conference on Design 
Automation, 2006, pp. 542-547. 
[6] Hector Sanchez et al., â€Thermal 
management system for high 
performance PowerPCTM 
microprocessors,â€ Proceedings of 
Compcon, 1997, pp. 325-330. 
[7] J. H. Tseng and K. 
Asanovic, â€Banked Multiported 
Register Files for High-Frequency 
Superscalar Microprocessors,â€ Inter. 
Symp. on Computer Architecture, 
June 2003. 
[8] L. Nagel, â€Spice: A computer 
program to simulate computer 
circuits,â€  in UC Berkeley UCBERL 
Memo M520, May 1995. 
[9] Y. Li, D. Brooks, Z. Hu, and K. 
Skadron, â€Performance, Energy, and 
Thermal Considerations for SMT and 
CMP architectures,â€ Proceedings of 
the Eighth International Symposium 
on High-Performance Computer 
Architecture, February 2005. 
[10] Fred C. Chow and John L. 
Hennessy, â€The priority-based 
coloring pproach to register 
allocationâ€, ACM Transactions on 
Programming anguages and Systems 
Vol. 12, No.4, Oct. 1990 
[11] J. H. Tseng and K. 
Asanovic, â€Energy-efficient register 
accessâ€, Symposium on Integrated 
Circuits and System Design, Sep. 
2000 
[12] Intel 64 and IA-32 architectures 
Software Developerâ€™s Manual, Intel 
Corp, 
www.intel.com/design/processor/man
uals 
[13] W. Stallings, â€Computer Organization 
and Architecture, 7th Editionâ€, 
Prentice Hall Publishers, 2006. 
[14] W. Liao, J. Basile, and L. 
He, â€Leakage Power Modeling and 
Reduction with Data 
Retentionâ€,IEEE/ACM International 
Conference on Computer Aided 
Design, Nov. 2002. 
[15] W. Huangy, K. Sankaranarayanany, R. 
J. Ribandoz, M. R. Stan and K. 
Skadron,â€An Improved Block-Based 
Thermal Model in HotSpot 4.0 with 
Granularity 
Considerationsâ€,Proceedings of the 
Workshop on Duplicating, 
Deconstructing, and Debunking,June. 
2007 
[16] S. Rusu, G. Singer, â€The First IA-64 
Microprocessorâ€, IEEE Journal of 
Solid-state Circuits Vol. 35, No. 11 
November 2000 
[17] Kyeong-Jae Lee, Kevin Skadron and 
Wei Huang, â€Analytical model for 
sensor placement on 
microprocessors,â€ International 
Conference Computer Design, 2005, 
pp. 24-27. 
[18] W. Huang, S. Ghosh, K. 
Sankaranarayanan, K. Skadron and M. 
R. Stan, â€HotSpot: Thermal modeling 
for CMOS VLSI systems,â€ IEEE 
Transactions on Component 
Packaging and Manufacturing 
Technology, 2005. 
[19] David Brooks, Vivek Tiwari and 
Margaret Martonosi, â€Wattch: A 
framework for architectural-level 
power analysis and optimizations,â€ 
ISCA, 2000. 
[20] â€SPEC-CPU2000, Standard 
Performance Evaluation Council, 
Performance Evaluation in the New 
Millennium, Version 1.1,â€ 2000, 
http://www.specbench.org/osg/cpu20
00. 
[21] Michiel A. P. Pertijs, Kofi A. A. 
Makinwa, Johan H. Huijsing, â€A 
CMOS smart temperature sensor with 
é™„ ï¤¿ï¼š 
 
Thermal-aware Post Compilation 
for VLIW Architecture 
 
 
 
 
Proceeding of ASPDAC 
pp. 606-611, Jan. 2009 
 
Conventional 
Register File
Sub-bank 
Register File
enable 
signal
Fig. 2. The conventional and the sub-bank register ï¬les.
The second modiï¬cation is to add an enable signal to
each register ï¬le bank. The enable signal is used to turn-off
the access to the sub-bank register ï¬le so that the dynamic
power can be saved [8]. In a processor, register ï¬le is
always read even if an instruction requires no operands. We
utilize a forwarding scheme to turn off sub-bank register ï¬le.
The detailed architecture and an instruction scheduling are
described in Section III.B.
III. THE PROPOSED METHOD
In this section, we propose our two main techniques to
manage the temperature of register ï¬le. One is register binding
and the other is forwarding methods including forwarding-
aware architecture and instruction scheduling.
A. Register Binding
1) Motivation: Previous work [5] proposed a thermal man-
agement method for VLIW functional units at compiler level.
The main idea of the work is to balance the work load of
each functional unit. The order of each functional unit is
rearranged so that the access counts of each functional unit
are balanced. However, the temperature of the surrounding
units of functional units are not taken into consideration in
[5]. Since the heat would spread around, it is important to
take ï¬‚oorplan into consideration during the computation of
temperature.
For example, assume there are four sub-bank register ï¬les
called REG1, REG2, REG3, REG4 and four units surround
them named U1, U2, U3 and U4 as shown in Figure 3. Let the
four units with their corresponding temperatures are denoted
as U1Temp, U2Temp, U3Temp and U4Temp, and U1Temp >
U2Temp = U3Temp > U4Temp. Letâ€™s consider three possible
register access orders.
REG1 REG2 REG3 REG4
U1 U2
U3 U4
Fig. 3. An example with sub-bank register ï¬les and adjacent units.
â€¢ Simple binding: If REG1 is free, then all data can be
bound to REG1. Obviously, in this case, REG1 becomes
hotspot.
â€¢ Round-robin-like binding [5]: To balance the access
count of the sub-bank register ï¬les, a round-robin rotation
of REG1 â†’ REG2 â†’ REG3 â†’ REG4 can be used.
This approach is used in [5]. However, it can be predicted
that REG1 and REG2 are the potential hotspots since
U1Temp and U2Temp are higher than U3Temp and
U4Temp.
â€¢ Floorplan-aware binding: When ï¬‚oorplan information
is taken into consideration, it can be seen that REG4 is
the ï¬rst choice to be bound because REG4 is surrounded
by the coolest temperature U4Temp. For the next choice,
REG2 is the selection because REG4 is recently used
and REG2 is away from it. Next, REG3 is bound, and
ï¬nally is REG1. This sub-bank register ï¬le binding order
can balance the temperature.
From the above example, to accurately model a heat dissi-
pation of sub-bank register ï¬le, it is required to consider not
only the temperature of sub-bank register ï¬le (the temporal
usage of the register ï¬le) but also the temperature of adjacent
units (the spatial relations among register ï¬le). However, none
of previous approaches consider both temporal and spatial
information at the same time.
2) Binding Algorithm: Based on the observation mentioned
above, we propose a register binding method at post-compiler
level to eliminate hotspots. The main idea is to bind registers
so that the temperature of register banks are distributed evenly.
Before Binding algorithm proceeds, both temporal and
spatial information needs to be obtained ï¬rst. There are
two kinds of temporal information. One is the control ï¬‚ow
graph (CFG) of the running program. Since the thermal
effect is continuous, the program ï¬‚ow has to be taken into
consideration when register binding is performed. The other
temporal information is the temperature trace ï¬le which
contains temporal temperature information of every unit in
a target processor through running the entire program. These
two kinds of temporal information are used to predict the
temperature of register ï¬le and units surrounding it at any
time slot. As to the spatial information, the ï¬‚oorplan of a
target processor is used to tell which speciï¬c units surrounded
to the register ï¬le.
Our proposed algorithm is based on a priority-based graph
coloring algorithm [7] which starts by analyzing the CFG ï¬le
of the original program. First, the live range of each variable
is constructed by traversing the CFG. Then an corresponding
interference graph is built to represent the conï¬‚ict between
live ranges. Next, the priority of each live range is calculated
so that the order of live range to process coloring can be de-
cided. According to the priority order, an available register is
assigned to each live range, which is similar to color the node
in the interference graph. According to the coloring algorithm,
the selection of color has to guarantee that adjacent nodes in
the interference graph have different colors. Therefore, the
same register is not assigned to conï¬‚icting live ranges after
applying the coloring algorithm.
In our Binding algorithm, the live ranges are processed
in the same priority order as graph coloring algorithm [7].
The main difference of our binding algorithm and [7] is that
a sub-bank register ï¬le is selected for binding by using our
new Penalty cost function. Moreover, in our algorithm, when
loop structure exists, the loop is split into smaller iteration
loops before constructing live ranges. This is because the
loop is executed for many iterations. If we only bind the loop
body based on one iteration, it is likely that the bound sub-
register bank becomes hotspot. In general, the loop is spilt
into K smaller loops when we have K sub-bank register ï¬les.
Figure 4 shows our detailed algorithm.
The cost function, Penalty, mentioned in Figure 4 is used
to determine whether a sub-bank register ï¬le is selected for
binding or not. The penalties are calculated for all sub-bank
register ï¬les and then the bank with the lowest penalty is
selected for binding. The Penalty of ith sub-bank register
ï¬le REGi is deï¬ned as:
Penalty(REGi) = (weight)Ã— profling penalty(REGi)
+(1âˆ’ weight)Ã— history penalty(REGi) (1)
where profling penalty and history penalty represent the
spatial and temporal impact to the sub-bank register respec-
tively, and weight is used to tune the importance of these two
terms.
607
7A-1
Prob(edgeÄ®È•)
= 0.6
Prob(edgeÄ®È•')
= 0.4
Prob(edgeÈ•È–)
= 0.6
Prob(edgeÈ•'È–)
= 0.4
start here
È–
REG1 = 4
REG2 = 3
C(È–) = 20
È•
REG1 = 2
REG2 = 2
C(È•) = 30
È•'
REG1 = 5
REG2 = 3
C(È•') = 20
Ä®
REG1 = 2
REG2 = 3
C(Ä®) = 10
Ä¯
REG1 = 3
REG2 = 6
C(Ä¯) = 50
accumulate
window
50 
cycles
60 
cycles
Fig. 7. A partial CFG for computing accumulate window and
history penalty(REG1).
First, the upper and the lower ends of accumulate window
are computed. Since C(Î±) is less than observed cycle count,
we backward trace the CFG from basic block Î±. Now, a
branch is encountered. We apply the priority function and then
the basic block Î²â€² is included into the accumulate window.
Since the accumulated cycle count (C(Î±) + C(Î²â€²)) is still less
than observed cycle count, the backward tracing continues.
We ï¬nd that the accumulated cycle count (C(Î±) + C(Î²â€²)
+ C(Î³)) achieves observed cycle count after including basic
block Î³. Therefore, the upper end of accumulate window is
found and the backward tracing stops. Similarly, the forward
tracing is performed. The forward tracing step stops when the
basic block Î´ is reached because the accumulated cycle count
(C(Î±) + C(Î´)) is larger than the observed cycle count.
Therefore, the accumulate window of REG1 contains four
basic block Î±, Î²â€², Î³, and Î´. Counts(REG1) is calculated
as (2+5+4+3) = 13. Hence, the history penalty(REG1) =
Counts(REG1)Ã—Power(REG1)Ã—R = 13Ã—0.002Ã—0.1 =
0.0026.
B. Forwarding-aware Method
1) Motivation: The forwarding unit exists in a pipelined
architecture to eliminate data hazards at run time. However,
when forwarding occurs, useless data is still read from register
ï¬le. Reducing the access to a register ï¬le can effectively
reduce the temperature of the register ï¬le. Based on this
observation, previous work [8] proposed to turn off a register
ï¬le when forwarding condition is detected. However, [8] did
not present any detailed mechanism to turn off the register
ï¬les. Only some simulation results are shown.
To eliminate this useless read to register ï¬le, we propose a
mechanism to turn-off register ï¬le. First, forwarding condition
is detected at compile time and encoded into instructions.
Then, at run time forwarding condition is decoded from
instructions to determine which sub-bank register ï¬les should
be turned off. In addition, based on this mechanism, a
forwarding-aware instruction scheduling is proposed to allow
more operand-forwarding.
TABLE I
THE FLAG FIELD AND THE CORRESPONDING CONDITION
ï¬‚ag encoding forwarding condition
000 no forwarding occurs
001 Inst0, 1st source register
010 Inst1, 1st source register
011 Inst2, 1st source register
100 conï¬‚ict
101 Inst0, 2nd source register
110 Inst1, 2nd source register
111 Inst2, 2nd source register
Forwarding-aware instruction scheduling was also proposed
in [11]. The main difference between our approach and
[11] is that we target at a VLIW architecture while the
technique proposed in [11] targets at out-of-order supersacalar
architecture where forwarding condition is detected at run-
time. Since our instruction-level parallelism is performed at
compiler time, both the order of instruction execution and
forwarding condition can be decided at compiler time. Our
forwarding condition is guaranteed to be the same at both
compiler time and run time. Therefore, hardware overhead
we need is only a decoder.
2) Instruction Encoding and its Decoding Architecture: In
this section, we describe the instruction encoding method and
implementation of its corresponding architecture. We target at
VLIW architecture, and IA-64 instruction encoding format is
adopted [9]. Figure 8 shows the encoding format.
The instruction format shown in Figure 8 is called a bundle.
It can be regarded as a compound instruction format. Each
bundle is 128-bit long, and contains three instructions (Inst0,
Inst1 and Inst2 in Figure 8) and a 5-bit template ï¬eld.
The template ï¬eld has two purposes. One is to specify the
execution unit type of each instruction, (e.g., indicating that
instruction 0 is executed in integer ALU) and the other is to
tell whether the next bundle is to be executed in parallel with
the current bundle.
Inst2 Inst1 Inst0 Template
41 bits 41 bits 41 bits 5 bits
Fig. 8. The bundle format in IA-64.
In order to record the forwarding condition, we modify the
bundle format as shown in Figure 9. An additional 3-bit ï¬‚ag
ï¬eld is appended next to the template ï¬eld. The ï¬‚ag ï¬eld
is used to distinguish all the forwarding conditions among
the three instructions. Table I shows the ï¬‚ag encoding. For
example, ï¬‚ag=(001) represents that the value of 1st source
register of Inst0 is forwarded, and the sub-bank register ï¬le
where this register is located can be turned off. A special
condition is conï¬‚ict. It means that forwarding occurs but the
sub-bank register ï¬le can not be turned off because other
registers located in the same sub-bank register ï¬le need to
be read. In this case, we cannot turn off the sub-bank register
ï¬le directly.
Inst2 Inst1 Inst0 Template
41 bits 41 bits 41 bits 5 bits
Flag
3 bits
Fig. 9. The modiï¬ed bundle format.
Complying with the modiï¬cation of bundle format, we
modify the architecture of 8-stage data-path of IA-64 [10] as
shown in Figure 10 where only four pipeline stages (EXP ,
REN , REG, and EXE) and one ALU are depicted in this
ï¬gure. New added components are shown in bold line.
609
7A-1
dl1 ul2
btb
decode
ialu
falu
itlbdtlb
il1
FREG1
FREG2
FREG3
FREG4
IREG1
IREG2
IREG3
IREG4
Fig. 13. The Itanium ï¬‚oorplan.
TABLE II
THE PARAMETERS OF TRIMARAN AND HOTSPOT
Trimaran HotSpot
Unit Num Parameter Value
Integer register 128 Frequency 3GHz
FP register 128 Vdd 1V
Integer Units 2 Initial temperature 60
FP units 2 Thermal Resistance 0.1 K/W
Load/store unit 2 Die size 10mm x 10mm
B. Experiment on Performance
This experiment is conducted to study the run-time per-
formance penalty caused by our methods. Three methods are
evaluated and the results are shown in Table IV. The column
labeled cycle count gives the cycle counts of each benchmark
program while the pen represents the performance penalty as
compared to the original case in percentage.
From Table IV, we can see that the binding algorithm does
not affect the performance at all. This is because the binding
algorithm only replaces registers from one sub-bank register
ï¬le to another.
On the other hand, performance penalty is incurred in
forwarding method as shown in column 6. The perfor-
mance penalty of forwarding method mainly occurs in
the loop structure. Once the scheduled instructions affect
the performance in single loop iteration, the effect becomes
more serious after loop execution. Therefore, the performance
penalty of forwarding method is 1.7% in the worst case
(blit), 0.7% in the best case (crc) and 1.3% on the average.
As to the combined method which executes both methods,
the performance penalty is less serious than the forwarding
method as shown in column 8. This is because the number
of instruction satisfying forwarding conditions becomes less
in the combined method after the binding algorithm is
applied, where the usage of all sub-register ï¬les are separated.
Therefore, the performance penalty of combined method is
only 1.1% in the worst case (engine), 0.5% in the best case
(crc) and 0.9% on the average.
V. CONCLUSION
In this paper, two techniques are proposed to reduce the
hotspots of register ï¬le of VILW architecture processor at
compiler level. The ï¬rst one is register binding to balance
the temperature of register ï¬le by taking both spatial and
temporal thermal information into consideration. The second
one is forwarding method which includes forwarding-aware
architecture and instruction scheduling to reduce the access
count of register ï¬le. The experimental results show that by
combining the two techniques, the peak temperature reduction
can reach 7.89 (oC) in the best case and 7.22 (oC) in average
with only 0.9% performance penalty in average.
TABLE III
THE EXPERIMENTAL RESULTS FOR PEAK TEMPERATURE REDUCTION.
Orig. Round-robin Our Our Ourbench- Binding Binding Forwarding Combined
mark temp temp r t temp r t num temp r t temp r t
(oC) (oC) (oC) (oC) (oC) (%) (oC) (oC) (oC) (oC)
bilv 95.33 92.86 2.47 89.95 5.38 25.03 93.67 1.66 89.77 5.56
blit 102.7 98.03 4.67 95.8 6.9 26.88 97.65 5.05 95.32 7.38
crc 99.73 94.72 5.01 92.79 6.94 35.94 95.9 3.83 92.77 6.96
des 100.89 95.03 5.86 93.86 7.03 24.15 97.62 3.27 93.57 7.32
energe 94.66 89.4 5.26 87.27 7.39 33.36 89.5 5.16 86.15 8.51
ï¬r 86.54 82.19 4.35 79.7 6.84 30.69 81.03 5.51 78.65 7.89
summin 97.28 93.25 4.03 90.56 6.72 22.57 93.18 4.1 89.97 7.31
whet 90.52 87.01 3.51 85.32 5.2 20.01 86.95 3.57 83.67 6.85
average 4.395 6.55 4.02 7.22
TABLE IV
THE EXPERIMENTAL RESULTS FOR PEAK TEMPERATURE REDUCTION.
bench-
mark
Orig. Binding Forwarding Combined
cycle cycle pen cycle pen cycle pen
count count (%) count (%) count (%)
bilv 376064357 376064357 0.0 380953193 1.3 379448936 0.9
blit 50440416 50440416 0.0 51297903 1.7 50944820 1
crc 5660433 5660433 0.0 5700056 0.7 5688735 0.5
des 41964763 41964763 0.0 42594234 1.5 42300481 0.8
energe 711784 711784 0.0 720325 1.2 720325 1.2
ï¬r 45077873 45077873 0.0 45799118 1.6 45573729 1.1
summin 492696 492696 0.0 496637 0.8 496637 0.8
whet 77202731 77202731 0.0 78360771 1.5 77897555 0.9
average 0.0 1.3 0.9
REFERENCES
[1] D. Brooks and M. Martonosi, â€Dynamic Thermal Management for
High-Performance Microprocessors,â€ Proceedings of the Seventh Inter-
national Symposium on High-Performance Computer Architecture, Feb-
ruary 2001.
[2] K. Skadron, T. Abdelzaher and M. R. Stan, â€Control Theoretic Tech-
niques and Thermal-RC Modeling for Accurate and Localized Dynamic
Thermal Management,â€ Proceedings of the Eighth International Sympo-
sium on High-Performance Computer Architecture, February 2002.
[3] Y. Li, D. Brooks, Z. Hu, and K. Skadron, â€Performance, Energy, and
Thermal Considerations for SMT and CMP architectures,â€ Proceedings
of the Eighth International Symposium on High-Performance Computer
Architecture, February 2005.
[4] K. Sankaranarayanan, S. Velusamy, M.R. Stan, and K. Skadron, â€A Case
for Thermal-Aware Floorplanning at the Microarchitectural Level,â€ The
Journal of Instruction-Level Parallelism Septempter 2005.
[5] M. Mutyam, F. Li, V. Narayanan, M. Kandemir and M. J. Irwin,
â€Compiler-Directed Thermal Management for VLIW Functional Units,â€
In. ACM SIGPLAN/SIGBED Conference on Languages, Compilers, and.
Tools for Embedded Systems, June 2006.
[6] J. H. Tseng and K. Asanovic, â€Banked Multiported Register Files for
High-Frequency Superscalar Microprocessors,â€ Inter. Symp. on Computer
Architecture, June 2003.
[7] Fred C. Chow and John L. Hennessy, â€The priority-based coloring
approach to register allocationâ€, ACM Transactions on Programming
Languages and Systems, October 1990
[8] J. H. Tseng and K. Asanovic, â€Energy-efï¬cient register accessâ€, Sympo-
sium on Integrated Circuits and System Design, Sep. 2000
[9] Intel 64 and IA-32 architectures Software Developerâ€™s Manual, Intel
Corp, â€http://www.intel.com/design/processor/manualsâ€
[10] W. Stallings, â€Computer Organization and Architecture, 7th Editionâ€,
Prentice Hall Publishers, 2006.
[11] S. Park, A. Shrivastava, N. Dutt, A. Nicolau, Y. Paek and E. Earlie,
â€Bypass Aware Instruction Scheduling for Register File Power Reduc-
tionâ€. ACM SIGPLAN/SIGBED Internation Conference on Languages,
Compilers, and Tools for Embedded System, June 2006
[12] W. Liao, J. Basile, and L. He, â€Leakage Power Modeling and Reduction
with Data Retentionâ€,IEEE/ACM International Conference on Computer
Aided Design, November 2002
[13] W. Huangy, K. Sankaranarayanany, R. J. Ribandoz, M. R. Stan and K.
Skadron,â€An Improved Block-Based Thermal Model in HotSpot 4.0 with
Granularity Considerationsâ€,Proceedings of theWorkshop on Duplicating,
Deconstructing, and Debunking,June. 2007
[14] S. Rusu, G. Singer, â€The First IA-64 Microprocessorâ€, IEEE Journal of
Solid-state Circuits, November 2000
611
7A-1
TSV Redundancy: Architecture and Design
Issues in 3D IC
Ang-Chih Hsiehâ€ , TingTing Hwangâ€ , Ming-Tung Changâ€¡, Min-Hsiu Tsaiâ€¡, Chih-Mou Tsengâ€¡ and Hung-Chun Liâ€¡
â€ Department of Computer Science, National Tsing Hua University, HsinChu, Taiwan 300
â€¡Global Unichip Corporation, Hsinchu, Taiwan 300
Abstractâ€”3D technology provides many benets including
high density, high band-with, low-power, and small form-factor.
Through Silicon Via (TSV), which provides communication links
for dies in vertical direction, is a critical design issue in 3D
integration. Just like other components, the fabrication and
bonding of TSVs can fail. A failed TSV may cause a number
of known-good-dies that are stacked together to be discarded.
This can severely increase the cost and decrease the yield as
the number of dies to be stacked increases. A redundant TSV
architecture with reasonable cost for ASICs is proposed in this
paper. Design issues including recovery rate and timing problem
are addressed. Based on probabilistic models, some interesting
ndings are reported. First, the probability that three or more
TSVs are failed in a tier is less than 0.002%. Assumption of
that there are at most two failed TSVs in a tier is sufcient to
cover 99.998% of all possible faulty free and faulty cases. Next,
with one redundant TSV allocated to one TSV block, limiting
the number of TSVs in each TSV block to be no greater than
50 and 25 leads to 90% and 95% recovery rates when 2 failed
TSVs are assumed. Finally, analysis on overall yield shows that
the proposed design can successfully recover most of the failed
chips and increase the yield of TSV bonding to 99.99%. This can
effectively reduce the cost of manufacturing 3D ICs.
I. INTRODUCTION
3D integration techniques are proposed as solutions to
overcome the scaling limit [1]. 3D technology provides many
benets including high density, high band-with, low-power,
and small form-factor [2]. Through-Silicon Via (TSV) [3],
which provides communication links for dies in vertical
direction, is a critical design issue in 3D integration. In current
manufacturing process for 3D designs, each die to be inte-
grated is manufactured individually. When TSV technology
is applied, TSVs and bond pads are fabricated inside each
die [4][5]. Then, bonding technology is used for die stacking.
Just like other components, the fabrication and bonding of
TSVs can fail. A failed TSV may cause a number of known-
good-dies that are stacked together to be discarded. This can
severely increase the cost and decrease the yield as the number
of dies to be stacked increases.
To improve the yield, some recovery mechanism is needed.
A simple but effective solution is to add redundant TSVs
which can be used to replace failed TSVs. This idea has been
realized in 3D DRAM designs [6]. In the proposed scheme, for
every 4 signals, 6 TSVs are allocated as a group. A switching
This work was supported in parts by National Science Council of Taiwan,
Republic of China, under grant NSC 98-2220-E-007-024, NSC 98A052
box is required for each group to select which 4 TSVs
are actually used to transfer signals. The advantage of this
structure is that the delays of all signals are almost identical.
This is an attractive property for DRAM designs. Although
this structure is suitable to the dedicated layout style of
memory designs, the cost is too expensive for ASICs. Another
fault tolerance scheme that utilizes redundant TSVs targets on
3D network-on-chip (3DNoC) links [7]. Though signicant
yield improvement is achieved, the analysis and design ow
are based on the dedicated network structure of 3DNoC. For
ASICs, the analysis and design ow may not be suitable. In
this paper, a redundant TSV architecture and related design
issues are discussed. The proposed redundant TSV design can
successfully recover most of the failed chips and increase the
yield to 99.99% based on probabilistic models.
The rest of this paper is organized as follows. First, in Sec-
tion II, the yield of TSV bonding is discussed. In Section III,
the proposed architecture for TSV redundancy is introduced.
Next, in Section IV, the recovery rate and the number of
redundant TSVs required for the proposed architecture is an-
alyzed. Probabilistic model is used for evaluation. The design
issues for timing and required design ow are explained in
Section V. Finally the conclusion of this work is given in
Section VI.
II. FAILURE RATE ANALYSIS FOR TSV
The fabrication of TSV-based 3D ICs can be partitioned
into following stages. First, dies of each tier are fabricated
individually. The fabrication of TSVs in each tier takes place
in this stage. Depending on the technology (TSV rst/last),
either reactive-ion etching (RIE) or laser drilling is performed
before TSV metallization process. According to the diameter
and aspect ratio of TSV, proper material (Cu or W [5]) is
selected for metallization. In general, the size of a TSV is
much larger than other on-chip devices. This leads to certain
unique defect features for TSV forming [8]. For example, void
may be formed in TSV and causae a TSV to fail [10]. After the
fabrication of TSVs, wafer thinning is performed. Presently,
most 3D IC processes require each tier to be less than 100
microns [5]. The surface roughness is an important factor to
the yield of later bonding stage. When the dies of consecutive
tiers are stacked, the TSVs of the die in upped tier need to be
bonded to the bond pads of the die on lower tier, as shown in
Figure 1. Due to the alignment problem, a bond pad is required
 
 
 
 
 
978-3-9810801-6-2/DATE10 Â© 2010 EDAA 
 
 
0 10 1
TS
V_
0
TS
V_
1
R_
TS
V
0 1
TS
V_
2
0 1
TS
V_
3
0 10 1 0 1
out_0 out_1 out_2 out_3
in_0 in_1 in_2 in_3
0 10 1
TS
V_
0
TS
V_
1
R_
TS
V
0 1
TS
V_
2
0 1
TS
V_
3
0 10 1 0 1
out_0 out_1 out_2 out_3
in_0 in_1 in_2 in_3
FAILED
(b)(a)
Fig. 4. TSV Recovery Mechanism: (a) Normal operations of TSVs; (b) TSV 1 is failed and TSV 1, TSV 2, and TSV 3 are shifted right one position
0 10 1
TS
V_
0
TS
V_
1
R_
TS
V
0 1
TS
V_
2
0 1
TS
V_
3
0 10 1 0 1
out_0 out_1 out_2 out_3
in_0 in_1 in_2 in_3
reciever
sender
Fig. 3. Architecture for Redundancy TSV
Fig. 5. TSV Blocks
B. TSV Block and TSV-Chain
Due to manufacturing and physical design issues, TSVs are
not recommended to be placed arbitrarily on a plane. From
the aspect of manufacturing, a regular placement of TSVs
improves the exposure quality of the lithographic process
and therefore improves the yield. In real designs, TSVs are
suggested to be placed regularly in TSV blocks which are
determined in oorplan stage. Inside each TSV block, TSVs
are arranged in a grid-based structure to satisfy the pitch
constraint of bond pads. Examples of TSV blocks are shown
in Figure 5. Obviously, it is undesirable for a TSV-chain to
contain TSVs of different TSV blocks due to long wires
for signal shifting. Therefore, a TSV-chain in our design
is suggested to contains TSVs in the same TSV block.
Moreover, we let each TSV block contain only one redundant
TSV. This means, for each TSV block, only one TSV-chain is
dened. Nevertheless, in terms of recovery rate, the number of
TSVs in a TSV-chain needs to be limited. In case the number
of TSVs in a TSV block is too large for one TSV-chain, the
TSV block needs to partitioned to a number of smaller TSV
blocks.
The design issues for our the proposed TSV-chain are listed
as follows:
âˆ™ Determine the number of TSVs in each TSV block
âˆ™ Determine the path to link the TSVs in a TSV block as
a chain
The rst problem is related to the recovery of a 3D design.
In Section IV, an analysis based on probabilistic model is
performed to answer this question. The second problem is
related to the timing behavior of shifted signals. Discussions
on timing issues and guidelines for TSV-chain design are
presented in Section V.
IV. RECOVERY RATE ANALYSIS
In this section, the relation between the number of TSVs
in each TSV block and recovery rate is analyzed based on
probabilistic models. First, based on the failure rate of a single
TSV, the expected number of TSVs that may fail in a tier
is discussed in Section IV-A. The result of Section IV-A
determines the maximum number of failed TSVs that are
expected to be recovered by our proposed TSV-chains. Next,
for an expected number of failed TSVs in each tier, the
required number of TSV-chains as well as the size limit of
each TSV block are discussed in Section IV-B.
A. Analysis on the Expected Number of TSVs to be Recovered
Let ğ¹ stand for the failure rate of a single TSV and ğ‘
stand for the number of TSVs in a tier. The probability that
exact ğ‘› TSVs are failed in a tier can be expressed as
ğ‘ƒğ‘“ ğ‘¡ğ‘ ğ‘£=ğ‘› = ğ¶
ğ‘
ğ‘› Ã— (ğ¹ğ‘› â‹… (1âˆ’ ğ¹ )ğ‘âˆ’ğ‘›)
where ğ¶ğ‘ğ‘› represents the number of combinations of ğ‘ TSVs
with ğ‘› of them failed and ğ¹ğ‘› â‹… (1 âˆ’ ğ¹ )ğ‘âˆ’ğ‘› represents the
probability of ğ‘› chosen TSVs are failed while other ğ‘ âˆ’ ğ‘›
TSVs are not. Next, the term ğ¶ ğ‘…ğ‘ğ‘¡ğ‘–ğ‘œğ‘› is dened as the
probability that the number of failed TSVs is no greater than
ğ‘›, including the faulty free condition (that is, ğ‘› = 0). This can
be computed by accumulating ğ‘ƒğ‘“ ğ‘¡ğ‘ ğ‘£=ğ‘– for 0 â‰¤ ğ‘– â‰¤ ğ‘› and
can be expressed as
ğ¶ ğ‘…ğ‘ğ‘¡ğ‘–ğ‘œğ‘› =
ğ‘›âˆ‘
ğ‘–=0
ğ‘ƒğ‘“ ğ‘¡ğ‘ ğ‘£=ğ‘–.
The values of ğ‘ƒğ‘“ ğ‘¡ğ‘ ğ‘£=ğ‘› and ğ¶ ğ‘…ğ‘ğ‘¡ğ‘–ğ‘œğ‘› for ğ¹ = 0.0001 and
ğ‘ = {300, 400, 500} are listed in Table I.
tsv_4 tsv_3 tsv_2 tsv_1 tsv_0 tsv_rFailed
TSV
tsv_0
tsv_1
tsv_2
tsv_3
tsv_4
1/5 2/5 3/5 4/5 5/5
Fig. 7. All Possible Shifting Situations for a TSV-chain of Size 6 when 1
TSV is Failed
not be acceptable. In this section, timing issues for TSV-chain
design are discussed in Section V-A. The discussion leads
to the guidelines to link TSVs in a TSV block as a chain.
Candidate TSV-chain structures are proposed in Section V-B.
In Section V-C, design issues in each stage of 3D design ow
are discussed.
A. Design Issues for Timing
As explained in Section III-A, when a TSV is failed,
according to the position of the failed TSV in a TSV-chain,
one or more signals need to be shifted. Due to the chaining
structure, even under the assumption that each TSV has
identical failure rate, the probability for each TSV in a TSV-
chain to be shifted varies. Figure 7 shows this situation.
Assume that 1 TSV is failed in a TSV-chain of size 6,
all possible shifting situations are enumerated in Figure 7.
When no TSV is failed and no shifting is required, the TSV-
chain is shown in the right column of the rst row where
the redundant TSV is denoted as tsv r. For each row below,
the left column indicates the failed TSV and the right column
shows the shifting situation. The last row lists the shifting
probabilities of the TSVs in the TSV-chain when 1 TSV is
failed. For tsv 0, no matter which TSV in the TSV-chain is
failed, it is always shifted because it is on the position next to
the redundant TSV. On the contrary, tsv 4, which is at the head
position of the TSV-chain, need not to be shifted unless itself
is failed. In terms of extra delays introduced by signal shifting,
this property of TSV-chain indicates that the probability that
the delay of a signal linked by a TSV is increased depends
on the position of the TSV in the TSV-chain. This means, for
signals that are timing critical, it is preferable to assign these
signals at the head parts of TSV-chains.
An evaluation for an extreme case where only one signal is
timing critical is shown in Figure 8. The x-axis stands for the
number of TSVs in a TSV-chain and the y-axis stands for the
probability that the timing critical signal is shifted. The line
denoted as â€œUnawareâ€ represents that the timing critical signal
has equal probability to be located at any position of a TSV-
chain. And the line denoted as â€œTiming Awareâ€ represents that
the timing ctitical signal is always located at the beginning
of a TSV-chain. Assume that the failure rate of each TSV
is identical and there is only one failed TSV. The result in
Figure 8 shows that, in â€œUnawareâ€ cases, the probabilities for
the timing critical signal to be shifted are greater than 50%
in all cases. On the contrary, by assigning the timing critical
30%
40%
50%
60%
70%
80%
90%
100%
ity
 fo
r 
th
e 
Ti
m
in
g 
C
ri
tic
al
 
ig
na
l t
o 
be
 sh
ift
ed
Unaware
Timing Aware
0%
10%
20%
10 20 30 40 50 60 70 80 90 100
Pr
ob
ab
ili
ty
 fo
r 
th
e 
Ti
m
in
g 
C
ri
tic
al
 
Si
gn
al
 to
 b
e 
sh
ift
ed
# of TSVs in a TSV-Chain
Fig. 8. Evaluation on the Possibility for the Timing Sensitive Signal to Be
Shifted
signal to the head of a TSV-chain, the probability is reduced to
2.93% in average. Based on the evaluation, timing sensitive
signals should always be routed through the TSVs located
at the head of TSV-chains. This is one of the guideline that
should be followed when designing TSV-chains.
The next issue is to minimize the delay caused by sig-
nal shifting. This can be done by minimizing the distance
between the connected TSVs in a TSV-chain. As mentioned
in Section III-B, TSVs in each block are placed in a grid-
based structure. Therefore, by requiring the connected TSVs
in a TSV-chain to be neighbors in the grid-based structure,
minimal and xed shifting delay can be guaranteed. This also
makes the shifting delay predictable in early design stages.
Thus, the second guideline for TSV-chain design is that any
two connected TSVs in a TSV-chain must be next to each
other in the grid-based structure.
B. TSV-chain Design Problem
For each TSV block in a plane, the structure of the TSV-
chain needs to be considered. The analysis in Section V-A
indicates that timing critical signals should always be routed
through the TSVs located at the head parts of TSV-chains.
In current design ow, signals that are assigned to each TSV
block are roughly determined in oorplan stage. However, the
exact assignment of signals to TSVs is not necessarily to be
done in this stage. From the perspective of physical design,
leaving the assignment of signals to TSVs to be done in
routing stage is benecial to minimize wire length. Therefore,
in addition to the guidelines obtained in Section V-A, the
design of TSV-chain should also consider routing issues.
Based on the concept of bounding box, discussion on wire
length is given rst. For two pins on two different tiers to
be connected, the relation between the bounding box of these
two pins and a TSV block can be listed as follows. First, the
bounding box and the TSV block can be non-overlapped. In
this situation, only going through a TSV on the boundary of
the TSV block can result in minimum wire length. Next, the
TSV block can be either partially or completely overlapped by
the bounding box. In this situation, any TSV that is overlapped
by the bounding box can result in minimum wire length.
Unless the bounding box is completely contained in the TSV
block, a TSV on the boundary of the TSV block can always
be found for minimum wire length. The discussion shows
that, TSVs on the boundary of a TSV block have higher
