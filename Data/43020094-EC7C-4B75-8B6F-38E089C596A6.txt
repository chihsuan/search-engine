Introduction 
Automata theory and formal languages lay a rigorous foundation upon which many 
applications in computer science and engineering are built. A notable example is 
concerned with the notion of controllability regarding discrete event systems, originated 
by Ramadge and Wonham in 1987. Since then, a large body of results have been obtained 
for supervisory control of discrete event systems in the framework of Ramadge and 
Wonham.  
 
In this research project, our goal is to apply automata-theoretic approaches to 
dealing with various controllability related issues, including the following:  
 
1. Approximating infinite-state systems (modeled by Petri nets) by finite automata. 
2. Computing the finite representations for a class of upward-closed infinite sets. 
3. Investigating the issue of fair-controllability for systems captured by œâ-languages 
(i.e., languages over infinite strings). 
 
Our investigation in the three years of this research project has led to the following 
publications: 
 
1. H. Yen, Decidability and Complexity Analysis of Forbidden State Problems for 
Discrete Event Systems,  International Journal of Foundations of Computer 
Science, Vol. 19, No. 49, 999-1013, 2008. 
2. H. Yen and L. Yu, Decidability Analysis of Self-Stabilization for Infinite State 
Systems, Fundamenta Informaticae, Vol. 70, No. 4, 387-402, 2006. 
3. H. Yen, `Introduction to Petri Net Theory,'  Chapter 14 in Recent Advances in 
Formal Languages and Applications, Z. Esik, C. Martin-Vide, V. 
Mitrana,  (Eds.),  Studies in Computational Intelligence 25, pp. 343-373, 
Springer,  2006. 
4. H. Yen,  Concurrency, Synchronization, and Conflicts in Petri Nets (Invited 
Talk),   in Proc. of the 13th  International Conference on Implementation and 
Application of Automata (CIAA 2008), (LNCS 5148), pp. 33-35, San Francisco, 
USA, July 21-24, 2008. 
5. H. Yen, Decidability and Complexity Analysis of Forbidden State Problems for 
Discrete Event Systems, Workshop on  Reachability Problems,  (satellite event 
of the DLT'07), July 7-8, Turku, Finland. 
6. H. Yen and C. Chen, Computing Minimal Elements of Upward-Closed Sets for 
Petri Nets, in Proc. of the 28th Int'l Conf. on Application and Theory of Petri 
Main contributions
‚ô£ H. Yen, Decidability and Complexity Analysis of Forbid-
den State Problems for Discrete Event Systems, International
Journal of Foundations of Computer Science, Vol. 19, No. 49,
999-1013, 2008.
In supervisory control of discrete event systems [7], a central problem,
known as the forbidden state problem, asks for the design of a supervisor
to guide a system with controllable/uncontrollable transitions to avoiding a
certain set of forbidden states during the course of its computation. At any
state, a state-feedback or event-feedback supervisory control policy is capable
of disabling certain controllable transitions, while leaving all the uncontrol-
lable transitions enabled. It is not hard to see that if a control policy avoiding
forbidden states exists, then by shutting down all the controllable transitions
at any state the goal can certainly be achieved. Traditionally, the forbidden
state problem in supervisory control seeks for a control policy that is max-
imally permissive in the sense that the policy enforces the weakest control
among all policies avoiding forbidden states (if they exist) [1, 2, 5].
In this paper, we consider the forbidden state problem with respect to
two new types of control policies, namely, non-blocking policy and fair policy,
under either the state-feedback or the event-feedback control. In addition,
we focus on the decision version of the forbidden state problem, i.e., deciding
whether a control policy exists or not under which the system can always
be controlled to avoid reaching any forbidden state. Under a non-blocking
policy, if in a state from which only controllable transitions are enabled, a
control policy is not allowed to ‚Äòshut down‚Äô the computation by disabling
all potentially executable controllable transitions. Under a fair policy, if
without the presence of the controller, a controllable transition is enabled
infinitely many times along an infinite computation, then any control action
involving the transition must not be denied by the control policy forever.
We investigate the forbidden state problem from a complexity/decidability
aspect for two types of systems: finite-state systems and systems that can be
modelled by Petri nets, which are the two most extensively studied models in
the community of discrete event systems, as indicated in many articles (e.g.,
[1, 7]). Our results are summarized in Tables 1 and 2.
1
the line of self-stabilization has been focusing on providing solutions (and
their proofs) for self-stabilizing systems with a variety of properties and
topologies. (See [17] for a bibliography of self-stabilization.) In a some-
what different direction of research, Gouda, Howell and Rosier ([16]) have
showed that the property of self-stabilization is ‚Äòunstable‚Äô across a wide va-
riety of system classes, ranging from cellular automata, Turing machines,
communicating finite state machines, to Petri nets. They basically demon-
strated that the simulation paradigm, which is a useful tool for designing and
analyzing systems, may not be ‚Äòrobust‚Äô with respect to the property of self-
stabilization. (The simulation paradigm, simply speaking, is a methodology
routinely used for designing or analyzing one class of systems with the help of
another (hopefully, a well-studied one) through the simulation of the former
by the latter. In this manner, properties of the former can be deduced from
the respective properties of the latter.) Unlike traditional properties such as
liveness, boundedness and fairness which are almost always preserved under
standard simulations, self-stabilization could easily be lost through the pro-
cess of simulation from one class of systems to another. (For more details,
see [16].) To our knowledge, [16] also pioneers the introduction of the notion
of self-stabilization to the model of Petri nets. In a subsequent paper [12],
specific efforts have been devoted to reasoning about self-stabilization as-
pects of Petri nets from the computational complexity point of view. Among
those complexity results derived in [12], detecting whether a Petri net is self-
stabilizing is complete for polynomial time for bounded ordinary Petri nets,
whereas it is PSPACE-complete for bounded general Petri nets.
As far as we know, very little is known regarding the complexity of the
self-stabilization problem (i.e., the problem of deciding whether a system is
self-stabilizing or not) for infinite-state systems. At this moment, the best
bounds of the problem for general Petri nets are a lower bound of expo-
nential space and an upper bound of Œ†2 (the second level of the arithmetic
hierarchy), whereas it is Œ†2-complete for Turing machines [12]. Therefore,
it is of interest and importance to take a closer look at the problem for
other infinite-state systems, in the hope of recognizing the key character-
istics which govern the decidability/undecidability nature of the problem.
An equally important goal is to, perhaps, come up with a unified frame-
work through which decidability/undecidability of self-stabilization can be
obtained. In this paper, we extend the work of [12] by investigating, from
the decidability viewpoint, the problem of deciding whether a given system
3
The quest for solving the general reachability problem for Petri nets has
constituted perhaps the most important and challenging line of research in
the Petri net community in the past. Knowing that the problem requires
exponential space, the decidability issue of the problem was left unsolved for
a long period of time until Mayr finally provided an answer in the affirma-
tive. Before Mayr‚Äôs proof, a number of attempts were made to investigate the
problem for restricted classes of PNs, in hope of gaining more insights and
developing new tools in order to conquer the general PN reachability prob-
lem. A common feature of those attempts is that decidability of reachabiltiy
for those restricted classes of Petri nets was built upon their reachability
sets being semilinear. As semilinear sets precisely correspond to the those
characterized by Presburger Arithmetic (a decidable theory), decidability of
the reachability problem follows immediately. In view of the importance of
the role played by the concept of semilinearity in Petri net theory, we devote
a section in this paper to surveying analytical techniques and complexity
results for subclasses of Petri nets exhibiting semilinear reachability sets. As
for the general reachability problem, the only known algorithm is nonprim-
itive recursive . The exact complexity of the reachability problem remains
the most challenging open problem in Petri net theory.
It is well-known that the computational power of Petri nets is strictly
weaker than that of Turing machines, making them inadequate for modelling
certain real-world systems such as prioritized systems. To overcome this
shortcoming, a number of extended Petri nets have been introduced to en-
hance the expressive capabilities of Petri nets. Among them are colored Petri
nets, Petri nets with inhibitor arcs, timed Petri nets, prioritized Petri nets,
and more. With the above extended Petri nets powerful enough to simulate
Turing machines, all nontrivial problems for such Petri nets become undecid-
able. A natural and interesting question to ask is: are there Petri nets whose
powers lie between conventional Petri nets and Turing machines? It turns
out that the so-called reset nets and transfer nets are two such witnesses.
The quest for such ‚Äòweaker‚Äô extensions has attracted considerable attentions
in recent years.
This paper gives an overview of basic analytical techniques and decidabil-
ity/complexity results for various Petri net problems.
‚ô£ H. Yen, Concurrency, Synchronization, and Conflicts in Petri
5
synchronization are key ingredients behind the power of Petri nets. With
either mechanism removed, the restricted class of Petri nets becomes strictly
less powerful as a computational model. Petri nets without place sharing
are called conflict-free Petri nets; whereas Petri nets lacking the capability
of transition synchronization are called communication-free Petri nets. Both
conflict-free and communication-free Petri nets exhibit effective semilinear
reachability sets, which in turn allows us to derive various complexity results
for problems associated with such Petri net classes.
In this talk, we first survey some of the analytical techniques and results
known for Petri nets lacking the mechanisms of synchronization and/or re-
source sharing. We then investigate the issue of separability in the theory of
Petri net languages. Intuitively speaking, a Petri net is said to be k-separable
if starting from a marking ¬µ which is divisible by k (k > 1), any computa-
tion sequence of the Petri net can be distributed to k identical copies of the
Petri net, each begins with ¬µ
k
as its initial marking. It has recently been
shown that marked graphs are always k-separable. We are able to show the
property of k-separability to hold for a wider class of Petri nets. We also
relate k-separability with the issue of shuÔ¨Ñe decomposition, and present a
few open problems along this line. Another issue that is addressed in this
talk is with respect to Petri net languages under the concurrent semantics,
as opposed the traditional interleaving semantics. In this setting, each step
of a Petri net is a set of executable transitions that are concurrently enabled
in a marking. We present some known results concerning concurrent Petri
net languages, and also point out some problems remained to be answered.
‚ô£H. Yen and C. Chen, Computing Minimal Elements of Upward-
Closed Sets for Petri Nets, in Proc. of the 28th Int‚Äôl Conf. on
Application and Theory of Petri Nets and Other Models of Con-
currency, (Petri Nets 2007), (LNCS 4546), pp. 465-483, Siedlce,
Poland, June 25-29, 2007.
A set U over k-dimensional vectors of natural numbers is called upward-
closed (or right-closed) if ‚àÄx ‚àà U, y ‚â• x =‚áí y ‚àà U . It is well known that
an upward-closed set is completely characterized by its minimal elements,
which always form a finite set. Aside from being of interest mathematically,
evidence has suggested that upward-closed sets play a key role in a number of
decidability results in automated verification of infinite state systems. In the
7
upward-closed sets investigated in [33] for general Petri nets, we illustrate
the usefulness of our approach in performing backward-reachability analysis,
which is a useful technique in automated verification. We show that for cer-
tain classes of Petri nets and state set Q, the backward-reachability set of Q
is not only upward-closed but falls into the category to which our unified ap-
proach can be applied. Such Petri nets include several well known subclasses
for which reachability is characterizable by integer linear programming. Our
analysis can also be applied to the model of lossy vector addition systems
with states (VASSs) [28] to derive bounds for the backward-reachability sets.
For (conventional or lossy) VASSs, we further enhance the work of [28] by
providing complexity bounds for the so-called global model checking problem
with respect to a certain class of formulas. (In [28], such a problem was
only shown to be decidable, yet no complexity was available there.) Upward-
closed sets associated with a kind of parametric clocked Petri nets are also
investigated in this paper, serving as yet another application of our unified
approach.
‚ô£ C. Chen, S. Wang and H. Yen, Reachability Analysis of Vari-
ants of Communication-Free Petri Nets, accepted with minor
revisions in IEICE, 2008
Petri nets are one of the most popular tools for modeling concurrent
systems. In spite of their popularity, conventional Petri nets are very difficult
to analyze. Over the years, various subclasses of Petri nets have been defined
and investigated in the literature, hoping that by imposing certain structural
or behavioral constraints on the basic model of Petri nets, such restricted
classes become easier to analyze while retaining sufficient expressive power.
A communication-free Petri net is a Petri net in which each transition has
exactly one input place, and the firing of a transition removes exactly one
token from its input place. As a modeling tool, the computational power
of communication-free Petri nets is somewhat limited. The limitation is
a direct consequence of the inability for communication-free Petri nets to
model ‚Äòsynchronization‚Äô actions, which require places to synchronize through
transition firings.
With respect to the reachability problem, it has been shown in [43] that
the problem is NP-complete for communication-free Petri nets (equivalently
9
must fire within their time bounds, clocked Petri nets (of [42]) allow time to
elapse, causing enabled transitions to become disabled without being fired.
In fact, this sort of ‚Äòlazy firing‚Äô semantics of clocked Petri nets is the key be-
hind the decidability of the reachability problem. In this paper, we define the
so-called alternating RQ communication-free Petri nets where R denotes the
resets and Q denotes the queries ‚Äì a restricted class of clocked Petri nets in
which, aside from being communication-free structurally, resets and queries
of a clock along any computation must appear alternatively. Our definition
of alternating RQ communication-free Petri nets is mainly motivated by the
work of [47] in which the so-called alternating RQ timed automata were de-
fined. As it turns out, alternating RQ timed automata admit more efficient
verification algorithms, in comparison with that for the general model of
timed automata [47] (see also [48]). As indicated in [47, 48], many practical
examples in the literature meet the alternating RQ constraints. Inspired by
[40, 47, 48], we tailor the alternating RQ conditions defined in [47, 48] to our
clocked communication-free Petri net model.
‚ô£ C. Chen, S. Chin, and H. Yen, Reachability Analysis of
Augmented Marked Graphs via Integer Linear Programming,
accepted with minor revisions in Computer Journal, 2008.
Petri nets have been applied to modelling and analyzing various systems
successfully due to the expressive power of such an abstract model. The
reachability problem, a problem of determining whether a specific marking
can be reached as a result of a required functional behavior, is a major topic
when studying the dynamics of Petri nets. As reported in the literature (see,
e.g., [70],[65],[68],[67]), solving systems of linear inequalities and constraints
is one of the key techniques for analyzing reachability properties of Petri
nets. In a Petri net P with initial marking ¬µ0, a marking ¬µ is reachable
from ¬µ0 in P only if ¬µ = ¬µ0 + Ax (which is called the state equation of the
associated Petri net) has an nonnegative integer solution for x ‚àà Nm, where
m is the number of transitions in P and A is the adjacency matrix of the
Petri net. However, the converse does not necessarily hold, i.e., for general
Petri nets, the existence of a solution of the state equation does not always
imply reachability. There are, however, subclasses of Petri nets for which
their reachability problem can be captured by the state equation. Among
them, the most notable one is the class of marked graphs (see, e.g., [69]), for
11
Conventionally a model checking procedure uses an exhaustive search of the
state space of the system to determine if some specification is satisfied or not.
The second aim of our work is to extend our approach of reasoning about
reachability by means of solving systems of linear inequalities to the model
checking problem of decomposable AMGs. In our setting, we consider a class
of branching time temporal logic EÀúF + Pres, for which the temporal oper-
ator EF is augmented with Presburger formulas with a limited use of the
negation (¬¨) operator. We model-check decomposable AMGs with respect
to EÀúF +Pres temporal logic and provide a complexity analysis of the model
checking algorithm.
References
[1] L. Holloway, and B. Krogh, Controlled Petri Nets: a Tutorial Survey,
in Discrete Event Systems, Lecture Notes in Control and Information
Sciences 199, G. Cohen and J.-P. Quadrat (eds.), pp. 158-168, Springer-
Verlag, 1994.
[2] L. Holloway, A. Khare, and Y. Gong, Computing Bounds for Forbidden
State Reachability Functions for Controlled Petri Nets, IEEE Trans.
SMC-A, 34(2): 219-228, 2004.
[3] R. Howell, L. Rosier and H. Yen, A Taxonomy of Fairness and Temporal
Logic Problems for Petri Nets, Theoret. Comput. Sci., 82:341-372, 1991.
[4] N. Jones and W. Laaser, Complete Problems for Deterministic Polyno-
mial Time, Theoret. Comput. Sci., 3:105‚Äì117, 1977.
[5] B. Krogh, J. Magott, and L. Holloway, On the Complexity of Forbidden
State Problems for Controlled Marked Graphs, Proc. 30th IEEE Conf.
on Decision and Control, 85-91 vol.1, 1991.
[6] J. Peterson, Petri Net Theory and the Modeling of Systems, Prentice
Hall, Englewood Cliffs, NJ, 1981.
[7] P. Ramadge and W. Wonham, The Control of Discrete Event Systems,
Proc. IEEE, 77(1):81‚Äì98, 1989.
[8] Alur, R. and Dill, D., A theory of timed automata, Theoret. Comput.
Sci., 126:183-235, 1994.
13
[22] Presburger, M., U¬®ber die vollsta¬®ndigkeit eines gewissen systems der
arithmetik ..., Comptes rendues du premier Congres des Math. des Pays
Slaves, Warsaw, 92-101, 395, 1929.
[23] Rosier, L. and Yen, H., Logspace hierarchies, polynomial time and the
complexity of fairness problems concerning œâ-machines. SIAM J. Com-
puting, 16(5):779-807, 1987.
[24] R. Valk, M. Jantzen., The Residue of Vector Sets with Applications to
Decidability in Petri Nets, Acta Informatica, 21:643-674, 1985.
[25] Yen, H., Wang, B. and Yang, M., Deciding a class of path formulas for
conflict-free Petri nets, Theory of Computing Systems, 30(5):475-494,
1997.
[26] R. Alur, and D. Dill, A theory of timed automata, Theoret. Comput.
Sci. 126 , 183-235, 1994.
[27] R. Alur, T. Henzinger, M. Vardi, Parametric real-time reasoning, in
Proc. 25th ACM STOC, 592‚Äì601, 1993.
[28] A. Bouajjani and R. Mayr, Model checking lossy vector addition sys-
tems. STACS‚Äô99, Trier, Germany. LNCS 1563, 323-333. 1999.
[29] I. Borosh, and L. Treybis, Bounds on positive integral solutions to linear
diophantine equations, Proc. Amer. Math. Soc., 55, 299-304, 1976.
[30] R. Howell, L. Rosier, and H. Yen, Normal and sinkless Petri nets, J.
Comput. System Sci., 46, 1‚Äì26, 1993.
[31] C. Rackoff, The covering and boundedness problems for vector addition
systems, Theoret. Comput. Sci., 6, 223-231, 1978.
[32] L. Rosier, and H. Yen, A multiparameter analysis of the boundedness
problem for vector addition systems, J. Comput. System Sci., 32, 105-
135, 1986.
[33] R. Valk, M. Jantzen. The residue of vector sets with applications to
decidability in Petri nets, Acta Informatica, 21, 643-674, 1985.
[34] F. Wang, and H. Yen, Timing parameter characterization of real-time
systems, Proc. CIAA 2003, LNCS 2759, 23-34, 2003.
15
[48] Lam, W. and Brayton, R., Criteria for the Simple Path Property in
Timed Automata, CAV‚Äô94, LNCS 818, pp. 27-40, 1994.
[49] Lipton, R., The Reachability Problem Requires Exponential Space,
Technical Report 62, Yale University, Dept. of CS., Jan. 1976.
[50] Marsan, M. and Chiola, G., On Petri Nets with Deterministic and Ex-
ponential Transition Firing Times, , Proceedings of the 7th European
Workshop on Application and Theory of Petri Nets, pp. 151-165, 1986.
[51] Mayr, E., An Algorithm for the General Petri Net Reachability Prob-
lem, SIAM J. Comput., 13(3):441-460, 1984.
[52] Ramchandani, C., Analysis of Asynchronous Concurrent Systems by
Petri Nets, Tech Report MAC TR-120, Massachusetts Institute of Tech-
nology, 1974.
[53] Yen, H., On Reachability Equivalence for BPP-Nets, Theoret. Comput.
Sci., 179:301-317, 1997.
[54] Yen, H., Priority Conflict-Free Petri Nets, Acta Inform., 35:673-688,
1998.
[55] Ben-Ari, M. Manna, Z. and Pnueli, A. (1983) The temporal logic of
branching time, Acta Inform., 20, 207-226.
[56] O. Burkart and J. Esparaza, More infinite results, Current Trends in
Theoretical Computer Science, pp. 480-503, 2001.
[57] K. S. Cheung, Modelling and Analysis of Manufacturing Systems Using
Augmented Marked Graphs, Information Technology And Control, Vol.
35, No. 1, 19 - 26, 2006.
[58] K. S. Cheung, New characterization for live and reversible augmented
marked graphs, Information Processing Letters, Vol. 92, No. 5, pp. 239-
243, 2004.
[59] F. Chu and X.-L. Xie, Deadlock analysis of Petri nets using siphons
and mathematical programming, IEEE Transactions on Robotics and
Automation, Vol. 13, No. 6, pp. 793-804, 1997.
17
[69] T. Murata, Circuit Theoretic Analysis and Synthesis of Marked Graphs,
IEEE Transactions on Circuits and Systems, Vol. CAS-24, No. 7, July
1977.
[70] S. Reveliotis, A linear characterization of the Petri net reachability
space corresponding to bounded-length fireable transition sequences
and its implications for the structural analysis of process-resource nets
with acyclic, quasi-live and strongly reversible process subnets, 44th
IEEE Conference on Decision and Control 2005 and 2005 European
Control Conference, pp. 2113- 2118, 2005.
[71] H. Yamasaki, Normal Petri Nets, Theoretical Computer Science, Vol.
31, No. 3, pp. 307-315, June 1984.
[72] H. Yen, A Polynomial Time Algorithm to Decide Pairwise Concurrency
of Transitions for 1-Bounded Conflict-Free Petri Nets, Information Pro-
cessing Letters, Vol. 38, No. 2, pp. 71-76, 1991.
[73] M. Zhou, M.C. Leu, Petri net modeling of a flexible assembly station
for printedcircuit boards, IEEE Internationl Confreence on Robotics
and Automation, vol. 3, pp.2530-2535, 1991.
19








388 H. Yen and L. Yu / Decidability Analysis of Self-Stabilization for Infinite-State Systems
Following the seminal work of Dijkstra [7], the majority of research along the line of self-stabilization
has been focusing on providing solutions (and their proofs) for self-stabilizing systems with a variety of
properties and topologies (see [10] for a bibliography of self-stabilization). In a somewhat different di-
rection of research, Gouda, Howell and Rosier ([9]) have showed that the property of self-stabilization
is ‚Äòunstable‚Äô across a wide variety of system classes, ranging from cellular automata, Turing machines,
communicating finite state machines, to Petri nets. They basically demonstrated that the simulation
paradigm, which is a useful tool for designing and analyzing systems, may not be ‚Äòrobust‚Äô with re-
spect to the property of self-stabilization. The simulation paradigm, simply speaking, is a methodology
routinely used for designing or analyzing one class of systems with the help of another (hopefully, a
well-studied one) through the simulation of the former by the latter. In this manner, properties of the
former can be deduced from the respective properties of the latter. Unlike traditional properties such as
liveness, boundedness and fairness which are almost always preserved under standard simulations, self-
stabilization could easily be lost through the process of simulation from one class of systems to another
(for more details, see [9]). To our knowledge, [9] also pioneers the introduction of the notion of self-
stabilization to the model of Petri nets. In a subsequent paper [5], specific efforts have been devoted to
reasoning about self-stabilization aspects of Petri nets from the computational complexity point of view.
Among those complexity results derived in [5], detecting whether a Petri net is self-stabilizing is com-
plete for polynomial time for bounded ordinary Petri nets, whereas it is PSPACE-complete for bounded
general Petri nets.
As far as we know, very little is known regarding the complexity of the self-stabilization problem
(i.e., the problem of deciding whether a system is self-stabilizing or not) for infinite-state systems. At
this moment, the best bounds of the problem for general Petri nets are a lower bound of exponential
space and an upper bound of   (the second level of the arithmetic hierarchy), whereas it is   -complete
for Turing machines [5]. Therefore, it is of interest and importance to take a closer look at the problem
for other infinite-state systems, in the hope of recognizing the key characteristics which govern the de-
cidability/undecidability nature of the problem. An equally important goal is to, perhaps, come up with
a unified framework through which decidability/undecidability of self-stabilization can be obtained. In
this paper, we extend the work of [5] by investigating, from the decidability viewpoint, the problem of
deciding whether a given system is self-stabilizing for a wide range of infinite-state systems, including
lossy vector addition systems with states, one-counter machines, conflict-free Petri nets, lossy counter
machines, and lossy channel systems. As it turns out, the decidability of self-stabilization for lossy vec-
tor addition systems with states, one-counter machines, and conflict-free Petri nets can be established in
a unified setting, taking advantage of the existence of a periodic witness for non-self-stabilizing infinite
computations. For lossy counter machines and lossy channel systems, however, the self-stabilization
problem turns out to be undecidable.
The rest of this paper is organized as follows. In Section 2, we give the definitions of transition
systems and self-stabilization. Section 3 deals with the issue of deciding whether a given system is self-
stabilized or not from the decidability viewpoint for a variety of infinite-state systems. A conclusion is
given in Section 4.
2. Preliminaries
A transition system (or system, for short)  is a four-tuple 	
 , where  consists of a (possibly
infinite) set of configurations, 
 is a (possibly infinite) set of transition symbols, 
Ô¨ÄÔ¨ÇÔ¨ÅÔ¨É defines
390 H. Yen and L. Yu / Decidability Analysis of Self-Stabilization for Infinite-State Systems
Let
  (  ) denote the set of (nonnegative) integers, and   (   ) the set of vectors of  (nonnegative)
integers. In this paper, we consider only those systems for which  can be encoded in such a way
that   	  , for some finite set  and integer 2 4 (  is referred to as the set of states of
system  ). For a vector 
     and a finite set  (= Ô¨Ç   , for some  )   , the set  
  =
Ô¨Ç(Ô¨É Ô¨ÅÔ¨Ä  Ô¨ÇÔ¨ÄÔ¨É
 
  
! 

"
$#+
Ô¨Ä &%'  is called the linear set with base 
 over the set of periods  . A
semilinear set ( Ô¨Ä)(7Ô¨Ä ) (cf. [8]) is a finite union of linear sets. A semilinear set is effectively semilinear
if all the periods of those linear sets can be effectively computed. It is known that semilinear sets are
exactly those that can be expressed in Presburger Arithmetic [15], which is a decidable theory. Given
a set Ô¨Ä*+

, Ô¨Ä is upward (resp., downward) closed if ,   Ô¨Ä and ,.-+/ (resp., /0-1, ) implies
/
 
Ô¨Ä , where the ordering - in N

is the component-wise extension of the natural ordering in N. Given
an upward-closed set 2 , an element 3    N

 is said to be minimal if there is no 4 .53    2 such
that 47683 . We write - 19 :2  to denote the set of minimal elements of 2 . We denote by <; the set
*= Ô¨Ç>  , where > is an object not in N ( >@?  N) such that the natural operations and ordering over N
is extended to A; as follows: >	 B> 8>	 C DA B> 8> , >E%F DG%'>58> and 6H> for all

  N. The operations and ordering of  
;
(i.e. I*= Ô¨Ç>    ) are thus extended likewise. An element
3 
  N

;
 in a downward-closed set J is said to be maximal if there is no 4 .+3    J such that
4LKM3 . We write -AÔ¨ÄÔ¨É3 IJ  to denote the set of maximal elements of J . From Dickson‚Äôs lemma, it is
well-known that for each upward-closed set 2 N N

 , - 19 :2  is finite. Even so, - 19 :2  might not be
effectively computable in general. It is reasonably easy to see that both upward and downward closed
sets are semilinear.
3. Decidability Analysis
In this section, the OPO problem for various infinite-state models, including lossy vector addition systems
with states, one-counter machines, and conflict-free Petri nets, will be shown to be decidable. Before
going into the details, we begin by giving an overview of the general strategy using which the decidability
results are obtained.
Recall from the definition of OPO that a system  is not self-stabilizing iff either (i) a finite compu-
tation ends up with a dead configuration being not reachable from the initial configuration, or (ii) an
infinite non- OPO computation exists. As we shall see later, (i) is relatively easy to check as long as certain
properties of  are decidable. The idea behind our approach of checking (ii) is built upon showing that
to demonstrate the non- OPO nature of a system, it is sufficient to search among only non- OPO computations
of periodic behaviors, and hopefully, the confinement to such computations admits a decidable checking
of (ii). By non- OPO periodic computations we mean those non- OPO computations of the form ORQSQPT T T , i.e.,
repeating U from O infinitely many times witnesses non- OPO . In our subsequent investigation, we character-
ize the following two types of non- OPO periodic behaviors, through which a unified strategy is developed
serving as a foundation for our decidability results of the OPO problem.
V (Strongly periodic:) Every finite computation  Q   with   2Ô¨Ä and  .  Ô¨Å     ensures non- OPO
of its infinite repetition (i.e.,  QSQPT T T is non- OPO ).
V (Weakly periodic:) If infinite non- OPO computations exist, there must be one of the form WQSQPT T T .
392 H. Yen and L. Yu / Decidability Analysis of Self-Stabilization for Infinite-State Systems
W-decidable systems correspond to systems whose non-ss behaviors can be captured by non-ss
computations of the weakly periodic type. Like the case in s-decidability, (1) suggests that infinite
non-ss behaviors are witnessed by the existence of a periodic computation. Condition (2) further
ensures that checking the existence of a periodic non-ss computation stated in (1) is decidable.
We are in a position to show the following unified strategy using which decidability of the ss problem
will be established in our subsequent discussion for a number of infinite-state systems for which the
existence of a non-reachable dead configuration is decidable.
Theorem 3.1. With respect to a computational model   , if for every system  = 	
 in   , where
 5 <

, the query ‚Äò 9      IJ J      Ô¨ÅÔ¨Ä 
	       .  ‚Äô is decidable, and  is
either s-decidable or w-decidable, then the OPO problem is decidable for   .
Proof:
The query ‚Äò 9       IJ J      Ô¨ÅÔ¨Ä 
	       .  ‚Äô being decidable ensures the existence of
an effective procedure to determine whether a non-reachable dead configuration exists or not. It remains
to consider those systems for which non-ss is witnessed by the existence of infinite non-ss computations.
First consider the case when  is s-decidable. In this case,  has infinite non-ss computations
iff Condition (1) of the definition of s-decidability holds, meaning that the non-ss is witnessed by a
periodic computation. Furthermore, the formula   in Condition (3) of the definition of s-decidability is
decidable. For such a system, our decision procedure involves checking whether the formula   holds or
not. Assuming the formula   holds, let   , O and  be such that

O  OF 


 
Ô¨Å

 
 

 

Ô¨Å
Ô¨É O .
 
Ô¨ÅÔ¨Ä 
	   
 
  
According to Condition (2) of the definition of s-decidability, the above implies the validity of the infinite
non-ss computation     O

 
 
 O  



 
 
 O  Ô¨Å %

  . Hence,  is non-ss. On the other hand,
if  has an infinite non-ss computation, then there is a finite computation     O

 
 
 O  

 satisfying
Condition (1) of the definition of s-decidability; hence, the    O   above satisfy   . In view of the above,
the formula   holds iff  has a non-ss computation.
Now consider a w-decidable system  . Our decision procedure for the OPO problem involves checking
whether the formula " in Condition (2) of the definition of w-decidability holds or not. Suppose  "
holds and let    O   be the values that satisfy  " . Then clearly     O

 
 
 O! 



 
 
 O! Ô¨Å %

  witnesses an infinite non-ss computation. On the other hand,  being non-ss, in conjunction with
Condition (1) of the definition of w-decidability, ensures the validity of formula  " . This completes the
proof of the theorem. 	

We are in a position to show each of the models of lossy vector addition systems with states, one-
counter machines and conflict-free Petri nets to be either s-decidable or w-decidable; hence, the OPO
problem for these systems is decidable according to Theorem 3.1.
3.1. Lossy Vector Addition Systems with States
A  -dimensional vector addition systems with states (VASSs) is a 5-tuple           , where

 

 is called the start vector, 0  ' is called the set of addition rules,  is a finite set of states,
394 H. Yen and L. Yu / Decidability Analysis of Self-Stabilization for Infinite-State Systems
(this is to ‚Äòsimulate‚Äô the       part in 2 O ). When a token is moved from   to  , the simulation
of VASS  starts at a state, say   in Figure 2, with contents of places 


 4 - 1 -D , remain intact. At
some point in time, the token in   is transferred to  to signal the end of the simulation as well as the
beginning of the final phase. Suppose , is the marking with respect to      at the end of the third
phase. In the final phase, the design enables us to test  4 - 1'-  , "  , 


 by asking whether the
zeros in      




 are reachable in the end (this can be done using transitions such as   in Figure
2, which consumes an equal amount of tokens from   and 

 ). As the reachability problem for VASS is
decidable, the query       2 O .   is therefore decidable as well. In view of the above, we have
that the set of the minimal elements of 2 is effectively computable. This, together with the effective
computability of the set of the maximal elements of Ô¨ÅÔ¨Ä 
	       (see [3]), yields Condition (3) of
the definition of the s-decidability. Hence,  is s-decidable. Theorem 3.1 implies the decidability of the
OPO problem. 	

Figure 2. Decidability proof of  
	 ?
3.2. One-Counter Machines
A one-counter machine  consists of a finite-state control equipped with a counter on which three types
of operations, namely, addition, subtraction and test-for-zero can be performed. For convenience, we
use the following to denote the above three basic operations:
(1)          ,  2  (resp., 76  ), meaning that  can go from state   to state    by adding  to the
counter (resp., by subtracting Ô¨É  Ô¨É from the counter, provided that the value of the counter is greater
than or equal to Ô¨É  Ô¨É )
(2)           , meaning that  can go from state   to state    provided that the value of the counter
is zero.
396 H. Yen and L. Yu / Decidability Analysis of Self-Stabilization for Infinite-State Systems
V
Ô¨Å

   
 
 = Ô¨Ç  

Ô¨É   

 
 


 and sequence  uses some test-for-zero moves  . Consider
a computation   
 	
   ! 

  






 
  





 
  







 
 


 such that 	 and
	

are test-for-zero moves, and sequences , and   do not use any test-for-zero moves (here
 !  and       are the first and last, respectively, configurations along the above compu-
tation at which test-for-zero moves are carried out. Also notice that  3 !  may be equal to
 



 and 	 to 	
 ). We define a binary relation  on       such that     iff     
 
 
 
  
in  . According to Lemma 3.1, using a depth-first search the relation  can effectively be com-
puted. Now Ô¨Å

   
 
  Ô¨Ç  

Ô¨É!  
 
 
 

 

  


 
 Ô¨É           
 
Ô¨Å

   	   Ô¨É
  
 
   
 


 
 
Ô¨Å

  

 

 
   , which is expressible in Presburger Arithmetic.
	

Lemma 3.3. A one-counter machine  (with initial state    ) has an infinite non- OPO computation iff one
of the following holds:
(1) there exists a configuration      such that     

 
 
  and      .  Ô¨Å           ,
(2) there exist a configuration      and a simple positive loop  starting from state   such that     



 


 , 

K  , and   2      % 



   .
 
Ô¨Å    
 
    (notice that test-for-zero transitions
are absent in  ).
Proof:
The if (   ) part is rather obvious; now we show the only if (    ) part.
Suppose  

 


0

 0 is a non- OPO computation of infinite length. Then one of the
following must hold:
(A) there exist indices 1   1 6   such that  +   , or
(B) the counter grows unboundedly and there exists an 1 such that the counter never becomes zero after

 
 
   and there exists a simple positive loop which appears infinitely often in  .
If (A) is the case, then condition (1) follows immediately. Consider case (B). Let     

 
 
  

 ,
for some

K  . We claim that     

 
 
  



 
 
  Ô¨Å %

 

 
 
  
 %

  constitutes
an infinite non- OPO computation. If this is not the case, there must exist an integer K  such that

 
W !%


 
Ô¨Å    
 
    . Consider Figure 3, where  is the configuration such that  appears 
times in


 


. Clearly,      %



	


T T T



is executable (for the test-for-zero operation is never
used after   ), which contradicts the assumption that  be on a non- OPO computation  . 	

Theorem 3.3. The OPO problem for one-counter machines is decidable.
Proof:
The proof is carried out through the use of the unified strategy stated in Theorem 3.1. For a one-counter
machine  , Lemma 3.2 establishes the effective semilinearity of Ô¨Å        

 , 
 

 

 
 

 

.
Ô¨Ä 2   
 

 

 is trivially semilinear, for the finiteness of   .            , an     is in
J J   
 
 iff the following holds: (i)             &/2             .    ), (ii)    
398 H. Yen and L. Yu / Decidability Analysis of Self-Stabilization for Infinite-State Systems
more than one transition is also an output of each such transition [13]. In a conflict-free PN, once
a transition becomes enabled, the only way to disable the transition is to fire the transition itself
(that is,     T,  .   , ,

 ,

and ,

 
 implies ,


 
 ).
To show the OPO problem for conflict-free PNs to be decidable, we require the following lemmas.
Lemma 3.4. Given a conflict-free PN  and a marking , , the set Ô¨Å   is effectively semilinear.
Proof:
The semilinearity of the reachability set for conflict-free PNs was originally illustrated in [13]. Subse-
quently, it has been shown in [12] that, given a conflict-free PN         , reachability can be char-
acterized as a system of linear inequalities Ô¨É(     over variables     


 

 
3 3 	 ,
among others, such that
(1) the size of Ô¨É(     is bounded by a polynomial in the size of  ,
(2) given two markings , and ,  , ,

 ,

, for some sequence  , if and only if Ô¨É(     has an integer
solution while assigning , to       and ,

to  


 

 
 , and
(3) for each transition     , the solution of variable 3  in Ô¨É(     exactly equals the number of
times transition  fires in  .
As a result, Ô¨Å   is clearly effectively semilinear. 	

Lemma 3.5. Given a PN  =        , the set J J   is effectively semilinear (here  can be a
general Petri net, not necessarily conflict-free, for which the range of  is N).
Proof:
Let   Ô¨Ç  

  %  . We define 
 = Ô¨Ç"Ô¨Ç+      !   Ô¨É! 4 - 1F- -   4 - - 	        FK
, (for each    
 and      ,   has at least one input place in  ). 
 is clearly a finite set. We
also let ,  Ô¨Ç,     Ô¨É            	        K ,     and  

.
 
	,  

  , , for a
given    
 . Notice that , is finite and contains dead markings only. If ,

is a marking such that
 ,

 

3 ,  

  4W-  - 	  , and  ,

 

 2C,  

  

.
 
  , then ,

is a dead marking as well. Hence
the set of dead markings equals 




7Ô¨Ç,

Ô¨É  ,

2.,  Ô¨É  ,

    ,     
 
   , which is
semilinear since 
 and , range over finite sets. 	

Lemma 3.6. (From [18]) For an arbitrary path ,

 , in a conflict-free PN  =        ,  can be re-
arranged into

	
  






  






 
  



, for some sequences        and integers       ,
4W-

- Ô¨É  Ô¨É , such that
(1). (  4W- 1 -  ) (    T) (     '-54 ), and
(2). (  4W- 1 -  
 4 ) ( Ô¨Ä      

. Ô¨Ä 

  ),
where      denotes the number of occurrences of  in   , and Ô¨Ä     is the set of transitions fired in   .
400 H. Yen and L. Yu / Decidability Analysis of Self-Stabilization for Infinite-State Systems
3.4. Lossy Counter Machines and Lossy Channel Systems
Like one-counter machines, an  -counter machine  consists of a finite-state control equipped with
 counters       , on which three types of operations, namely, addition, subtraction, and test-for-
zero can be performed. A configuration of  is a tuple    -  -   , where   is a state of  and
-   -   -  2  4W- 1 -C  are the values of counters       , respectively. The initial configu-
ration of  is         , where    is the initial state of  .
Let

 be a relation defined as follows [14]:

 
-  -   -  

 
 

-


 -


 -


 iff

 
-  -   -  3
 

-


 -


 -



 

 

 

Ô¨É 
$#+  
- )K
$#+  
-


 .
A relation

 is said to be a lossiness relation if 1  

 

 , where 1

is the identity relation. A
lossy counter machine ( (  , for short) is a counter machine whose transition relation   is defined as
O"
 
O
 iff  O


 O


'O"

 O


 O



 O

, where O   O


 O

 O


are configurations, meaning that before
and/or after a conventional counter machine transition (i.e.,  ), the counter value may spontaneously
decrease. The reader is referred to [14] for more about LCMs under various lossiness relations. In [14],
for every lossiness relation the following problem was shown to be undecidable:
V (Structural termination) Given an  -counter LCM  , does  terminates for every initial state?
The negation of the problem is that given an  -counter LCM  with initial state    , does there
exist -  -    N and a state   such that there is an infinite run emanating from    -   -   ?
In fact, as shown in [14] the undecidability result holds even when  is restricted to contain five counters
and is strongly-cyclic and input-bounded.
Theorem 3.5. The OPO problem for LCMs is undecidable for every lossiness relation.
Proof:
The proof is done by showing that, given an LCM  , we can construct an LCM 

in such a way that
 is structurally nonterminating iff 

is not self-stabilizing. The construction is depicted in Figure
4, in which    and  


are the initial states of  and 

, respectively. 

is constructed from  by
adding two new states, namely,  


and  , and the following transitions. For each state  in  , we add a
transition from  to  which is always executable (for example, adding zero to the first counter). In state
 ,  self-loops are attached each subtracts one from the respective counter. A transition is introduced
from  to  


which is enabled provided that all the counters are zero. Finally, from  


to    there are
 transitions each of which subtracts one from the respective counter. Now it is not difficult to see the
following:
V The reachability set of 

is exactly Ô¨Ç   


      , since the transition from  


to    can never
be executed from the initial configuration   


     .
V The only dead configuration of 

is Ô¨Ç   


      .
V Every infinite computation of 

must always begin and stay in  , regardless of the counter
values with which the computation begins.
402 H. Yen and L. Yu / Decidability Analysis of Self-Stabilization for Infinite-State Systems
of real-time nature. For the model of timed automata [2], the region graph technique can easily be
applied to showing the decidability (in fact, in PSPACE) of self-stabilization (in the sense defined in this
paper). However, to cope with the nature of real-time systems, one might have to tailor the notion of
self-stabilization to better capture the intuitive concept of ‚Äòself-stabilizing in a certain amount of time,‚Äô
as opposed to ‚Äòreaching a legitimate configuration eventually‚Äô as defined in the conventional sense.
Acknowledgment: The authors would like to thank the anonymous referees for suggestions that greatly
improved the content as well as the presentation of our results.
References
[1] Abdulla, P., Jonsson, B.: Undecidable verification problems for programs with unreliable channels, Inform.
and Comput., 130, 1996, 71‚Äì90.
[2] Alur, R., Dill, D.: A theory of timed automata, Theoret. Comput. Sci., 126, 1994, 183‚Äì235.
[3] Bouajjani, A., Mayr, R.: Model checking lossy vector addition systems, Proc. of STACS‚Äô99, 1563, 1999.
[4] Ce¬¥ce¬¥, G., Finkel, A., Iyer, S.: Unreliable channels are easier to verify than perfect channels, Inform. and
Comput., 124(1), 1996, 20‚Äì31.
[5] Cherkasova, L., Howell, R., Rosier, L.: Bounded self-stabilizing Petri nets, Acta Informat., 32, 1995, 189‚Äì
207.
[6] Dickson, L.: Finiteness of the odd perfect and primitive abundant numbers with n distinct prime factors,
Amer. J. Math., 35, 1913, 413‚Äì422.
[7] Dijkstra, E.: Self-stabilizing systems in spite of distributed control, C. ACM, 17, 1974, 643‚Äì644.
[8] Ginsburg, S.: The mathematical theory of context-free languages, McGraw-Hill, 1966.
[9] Gouda, M., Howell, R., Rosier, L.: The instability of self-stabilization, Acta Informat., 27, 1990, 697‚Äì724.
[10] Herman, T.: A comprehensive bibliography on self-stabilization, Chicago Journal of Theoretical Computer
Science, Available from http://www.cs.uiowa.edu/ftp/selfstab/bibliography, 1998.
[11] Hopcroft, J., Pansiot, J.: On the reachability problem for 5-dimensional vector addition systems, Theoret.
Comput. Sci., 8(2), 1979, 135‚Äì159.
[12] Howell, R., Rosier, L.: On questions of fairness and temporal logic for conflict-free Petri nets, Advances in
Petri Nets 1988 (G. Rozenberg, Ed.), 340, Springer-Verlag, Berlin, 1988.
[13] Landweber, L., Robertson, E.: Properties of conflict-free and persistent Petri nets, J. Assoc. Comput. Mach.,
25, 1978, 352‚Äì364.
[14] Mayr, R.: Undecidable problems in unreliable computations, Theoret. Comput. Sci., 297(1-3), March 2003,
337‚Äì354.
[15] Presburger, M.: ¬®Uber die vollsta¬®ndigkeit eines gewissen systems der arithmetik ganzer Zahlen, Comptes
Rendus du I congres de Mathematiciens des Pays Slaves, 1929, 92‚Äì101.
[16] Rosier, L., Yen, H.: Logspace hierarchies, polynomial time and the complexity of fairness problems concern-
ing   -machines, SIAM J. Computing, 16(5), 1987, 779‚Äì807.
[17] Valk, R., Jantzen, M.: The residue of vector sets with applications to decidability in Petri nets, Acta Infor-
matica, 21, 1985, 643‚Äì674.
[18] Yen, H., Wang, B., Yang, M.: Deciding a class of path formulas for conflict-free Petri nets, Theory of
Computing Systems, 30(5), 1997, 475‚Äì494.

344 Hsu-Chun Yen
the Petri net community in the past. Knowing that the problem requires ex-
ponential space [40], the decidability issue of the problem was left unsolved
for a long period of time until Mayr [42, 43] Ô¨Ånally provided an answer in
the aÔ¨Érmative (see also [38]). Before Mayr‚Äôs proof, a number of attempts
were made to investigate the problem for restricted classes of PNs, in hope
of gaining more insights and developing new tools in order to conquer the
general PN reachability problem (see, e.g., [16, 21, 39, 41, 48, 61]). A com-
mon feature of those attempts is that decidability of reachabiltiy for those
restricted classes of Petri nets was built upon their reachability sets being
semilinear. As semilinear sets precisely correspond to the those characterized
by Presburger Arithmetic (a decidable theory), decidability of the reachabil-
ity problem follows immediately. In view of the importance of the role played
by the concept of semilinearity in Petri net theory, we devote a section in
this paper to surveying analytical techniques and complexity results for sub-
classes of Petri nets exhibiting semilinear reachability sets. As for the general
reachability problem, the only known algorithm is nonprimitive recursive (see
[38, 42, 43]). The exact complexity of the reachability problem remains the
most challenging open problem in Petri net theory.
It is well-known that the computational power of Petri nets is strictly
weaker than that of Turing machines, making them inadequate for modelling
certain real-world systems such as prioritized systems [1]. To overcome this
shortcoming, a number of extended Petri nets have been introduced to enhance
the expressive capabilities of Petri nets. Among them are colored Petri nets,
Petri nets with inhibitor arcs, timed Petri nets, prioritized Petri nets, and
more. With the above extended Petri nets powerful enough to simulate Turing
machines, all nontrivial problems for such Petri nets become undecidable. A
natural and interesting question to ask is: are there Petri nets whose powers
lie between conventional Petri nets and Turing machines? It turns out that
the so-called reset nets and transfer nets are two such witnesses. The quest
for such ‚Äòweaker‚Äô extensions has attracted considerable attentions in recent
years.
This paper gives an overview of basic analytical techniques and decidabil-
ity/complexity results for various Petri net problems. Our survey is by no
means comprehensive; the interested reader is refer to [12, 33, 49] for other
survey articles concerning the decidability and complexity issues of Petri nets.
See also [7, 53, 58] for more about Petri nets and their related problems.
The rest of this paper is organized as follows. Section 14.2 gives the basic
notations and terminologies of Petri nets and their equivalent models. Section
14.3 is devoted to the deÔ¨Ånitions of various Petri net problems that are of
interest in the Petri net community. An overview of analytical techniques
known to be useful for reasoning about Petri net behaviors is presented in
Section 14.4. Decidability and complexity results concerning various Petri net
problems for general Petri nets and for subclasses of Petri nets are given in
Section 14.5 and Section 14.6, respectively. Finally, in Section 14.7 we brieÔ¨Çy
discuss the computational power of various extended Petri nets.
346 Hsu-Chun Yen
Fig. 14.1. A Petri net.
By establishing an ordering on the elements of P and T (i.e., P =
{p1, ..., pk} and T = {t1, ..., tm}), we deÔ¨Åne the k √óm incidence matrix [T ] of
(P, T, œï) so that [T ](i, j) = œï(tj , pi)‚àí œï(pi, tj). Note that œï(tj , pi), œï(pi, tj),
and [T ](i, j), respectively, represent the number of tokens removed, added,
and changed in place i when transition j Ô¨Åres once. Thus, if we view a mark-
ing ¬µ as a k-dimensional column vector in which the ith component is ¬µ(pi),
each column of [T ] is then a k-dimensional vector such that if ¬µ0
œÉ‚àí‚Üí ¬µ, then
the following state equation holds:
¬µ0 + [T ] ¬∑#œÉ = ¬µ,
where #œÉ is an m-dimensional vector with its jth entry denoting the number
of times transition tj occurs in œÉ.
Example 2. Consider the PN in Figure 14.1. As marking ¬µ = (0, 1, 2, 1, 0)
is reachable from the initial marking ¬µ0 = (1, 0, 0, 1, 0) through the Ô¨Åring
sequence œÉ = t2t1t2, it is easy to verify (as the following equation shows) that
the state equation ¬µ0 + [T ] ¬∑#œÉ = ¬µ holds.
‚éõ
‚éú‚éú‚éú‚éú‚éù
1
0
0
1
0
‚éû
‚éü‚éü‚éü‚éü‚é†
+
‚éõ
‚éú‚éú‚éú‚éú‚éù
1 ‚àí1 0 0
‚àí1 1 0 0
0 1 ‚àí1 0
0 0 ‚àí1 1
0 0 1 ‚àí1
‚éû
‚éü‚éü‚éü‚éü‚é†
‚éõ
‚éú‚éú‚éù
1
2
0
0
‚éû
‚éü‚éü‚é† =
‚éõ
‚éú‚éú‚éú‚éú‚éù
0
1
2
1
0
‚éû
‚éü‚éü‚éü‚éü‚é†
unionsq
As the following example shows, the existence of a solution for the state
equation of a PN is necessary but not suÔ¨Écient to guarantee reachability.
Example 3. Consider a PN P=(P, T, œï) with P = {p1, p2, p3}, T = {t1, t2} and
œï(p1, t1) = ‚àí1, œï(t1, p2) = 1, œï(p2, t2) = ‚àí1, œï(t2, p1) = 1, and œï(t2, p3) = 1.
Let the initial marking be (0, 0, 0) and the Ô¨Ånal marking be (0, 0, 1). The
associated state equation is
348 Hsu-Chun Yen
that y + v ‚â• 0. The VASS is speciÔ¨Åed by G = (x,W, T, p0), where p0 is the
starting state.
Example 4. For the PN shown in Figure 14.1, the corresponding VAS „Äàx,W „Äâ
is:
‚Ä¢ x = (1, 0, 0, 1, 0),
‚Ä¢ W = {(1,‚àí1, 0, 0, 0), (‚àí1, 1, 1, 0, 0), (0, 0,‚àí1,‚àí1, 1), (0, 0, 0, 1,‚àí1)}.
Such a VAS can also be regarded as a VASS with a single state. unionsq
A k√óm vector replacement system (VRS) [37] is a triple (w0, U,W ), where
w0 ‚àà Nk (start vector), U ‚àà Nk√óm (check matrix), and W ‚àà Zk√óm (addition
matrix) such that, for any i, j with 1 ‚â§ i ‚â§ m and 1 ‚â§ j ‚â§ k, we have
Ui(j) + Wi(j) ‚â• 0. Here Ui (respectively, Wi) is the i-th column vector of U
(respectively, W ). A vector Wi ‚àà W is said to be enabled in a vector x ‚àà Nk
if and only if x ‚â• Ui; as Ui +Wi ‚â• 0, adding Wi to x yields x+Wi ‚àà Nk. For
a VRS G = (w0, U,W ), R(G) denotes the set of vectors from Nk that can be
reached from w0 by iteratively adding vectors from W enabled in the vector
computed so far.
It is known that Petri net, VAS, VASS, and VRS are computationally
equivalent. In fact, given an n-dimensional VASS G, we can eÔ¨Äectively con-
struct an (n + 3)-dimensional VAS G‚Ä≤ that simulates G [21].
14.3 Petri Net Problems
What follows are problems that are of particular importance and interest in
the study of PNs.
‚Ä¢ The reachability problem: given a PN P (with initial marking ¬µ0) and a
marking ¬µ, deciding whether ¬µ ‚àà R(P, ¬µ0).
‚Ä¢ The boundedness problem: given a PN P (with initial marking ¬µ0), deciding
whether |R(P, ¬µ0)| is Ô¨Ånite or not.
‚Ä¢ The covering problem: given a PN P (with initial marking ¬µ0) and a
marking ¬µ, deciding whether there exists a ¬µ‚Ä≤ ‚àà R(P, ¬µ0) such that ¬µ‚Ä≤ ‚â• ¬µ.
‚Ä¢ The equivalence problem: given two PNs P1 (with initial marking ¬µ1) and
P2 (with initial marking ¬µ2), deciding whether R(P1, ¬µ1) = R(P2, ¬µ2).
‚Ä¢ The containment problem: given two PNs P1 (with initial marking ¬µ1) and
P2 (with initial marking ¬µ2), deciding whether R(P1, ¬µ1) ‚äÜ R(P2, ¬µ2).
350 Hsu-Chun Yen
4. L3-live if t appears inÔ¨Ånitely often in some Ô¨Åring sequence from ¬µ0;
5. L4-live or live if t is L1-live for every marking ¬µ in R(P, ¬µ0);
A PN is said to be L0, L1, L2, L3, and L4-live if each of its transitions is
L0, L1, L2, L3, and L4-live, respectively.
Example 6. Consider the PN shown in Figure 14.3. For any k ‚àà N ,
(1, 0, 0)
(t1)
kt2(t3)
k
‚àí‚Üí ; hence, t3 is L2-live. However, it is reasonably easy to see
that t3 is not L3-live as there is no computation along which t3 is Ô¨Åred in-
Ô¨Ånitely many times. In fact, the following implications hold: L4-liveness (the
strongest) =‚áí L3-liveness =‚áí L2-liveness =‚áí L1-liveness. unionsq
Fig. 14.3. L2 vs. L3 liveness.
14.4 Analytical Techniques
In this section, we summarize various techniques useful for analyzing PN prop-
erties. Our focus is on algebraic techniques, structural analysis, and state-space
analysis. Other techniques such as simulation and synthesis/reduction are be-
yond the scope of our discussion. Structural analysis is mainly designed for
reasoning about properties of PNs that are independent of the initial mark-
ings. State-space analysis, on the other hand, allows us to infer properties of
PNs that are sensitive to the initial markings.
14.4.1 Algebraic Techniques
In the framework of using algebraic techniques for reasoning about PNs, solv-
ing a PN problem is reduced to Ô¨Ånding a solution for an algebraic (in)equation
associated with the PN. Due to the nature of this technique, the method is in
general eÔ¨Écient (in most cases, polynomial in the size of the PN). Unfortu-
nately, this technique generally provides only necessary or suÔ¨Écient informa-
tion for either inferring desired properties or ruling out dangerous conditions.
352 Hsu-Chun Yen
(
1, 2, 1
)
‚éõ
‚éù
‚àí1 1
1 ‚àí1
‚àí1 1
‚éû
‚é† =
(
0
0
)
,
as (1,2,1) is a P-invariant. Using the so-called Farkas Algorithm, the minimal
P-invariants (i.e., bases) of a PN can be calculated. Nevertheless, in the worst
case the number of minimal P-invariants is exponential in the size of the PN,
indicating that Farkas Algorithm may require exponential worst-case time.
Fig. 14.5. A PN with a P-invariant (1,2,1).
Suppose ¬µ is a reachable marking (from the initial marking ¬µ0) through
a Ô¨Åring sequence œÉ. Clearly, ¬µ0 + [T ]#œÉ = ¬µ. (Here ¬µ0 and ¬µ are column
vectors.) Let X be a P-invariant. Then
X ¬∑ ¬µ = X ¬∑ (¬µ0 + [T ] ¬∑#œÉ) = X ¬∑ ¬µ0 + X ¬∑ [T ] ¬∑#œÉ = X ¬∑ ¬µ0.
Recall that in the example in Figure 14.5, (1, 1, 0) is a P-invariant. For every
reachable marking ¬µ, we have ¬µ(p1) + ¬µ(p2) = ¬µ0(p1) + ¬µ0(p2), meaning that
the total number of tokens in p1 and p2 together remain unchanged during
the course of the PN computation. Hence, if the PN starts from the initial
marking (1, 0, 1), then the property of mutual exclusion for places p1 and
p2 can be asserted as ¬µ(p1) + ¬µ(p2) = ¬µ0(p1) + ¬µ0(p2) = 1 for all reachable
marking ¬µ. It is easy to see that if there exists a P-invariant X with X(p) > 0,
for all p ‚àà P , then the PN is guaranteed to be structurally bounded. Hence,
place invariants can be used for reasoning about structural boundedness.
Transition Invariant:
A transition invariant of PN P = (P, T, œï) is a mapping InvT : T ‚Üí N (i.e.,
assigning nonnegative weights to transitions) such that Œ£t‚ààT InvT (t)(‚àÜ(t)) =
0. In words, Ô¨Åring each transition the number of times speciÔ¨Åed in the T-
invariant brings the PN back to its starting marking. Again consider the PN
shown in Figure 14.5 in which (2, 2) (i.e., InvT (t1) = InvT (t2) = 2) is clearly
a T-invariant, so is (n, n), for arbitrary n ‚â• 0. Like P-invariants, any linear
354 Hsu-Chun Yen
Fig. 14.6. A free-choice PN which is bounded but not live.
markings from a given initial marking, in hope of deducing PN properties
by examining the structure of the reachability graph. Figure 14.7 displays a
portion of the reachability graph associated with the PN in Figure 14.1.
Fig. 14.7. Portion of the reachability graph of the Petri net in Figure 14.1.
In spite of its simplicity, the applicability of the technique of reachability
graph analysis is rather limited; it can only be applied to bounded (i.e., Ô¨Ånite)
PNs with small reachability sets. Even for bounded PNs which exhibit Ô¨Ånite
reachbility graphs, the technique is ‚Äòexpensive‚Äô in the sense that it suÔ¨Äers
from the state explosion phenomenon as the sizes of the reachability sets grow
beyond any primitive recursive function even for bounded PNs in the worst
case. More will be said about this later.
(0,1,1,1,0)
(1,0,1,1,0)      (0,1,0,0,1)
(0,1,2,1,0)      (1,0,0,0,1)
t2
t1
t2
t3
t3 t1
Initial
marking
(1,0,0,1,0)
Reachable markings
356 Hsu-Chun Yen
(4) case (i) there is a node ¬µ‚Ä≤ = ¬µ + ‚àÜt in GP(¬µ0)
(5) add an edge ¬µ t‚Üí ¬µ‚Ä≤ to GP(¬µ0)
(6) case (ii) there is a node ¬µ‚Ä≤‚Ä≤ from ¬µinit to ¬µ such that ¬µ‚Ä≤‚Ä≤ < ¬µ + ‚àÜt
(7) add an ‚Äúnew‚Äù node x with
(8) x(p) = œâ if ¬µ‚Ä≤‚Ä≤(p) < (¬µ + ‚àÜt)(p)
(9) x(p) = ¬µ‚Ä≤‚Ä≤(p), otherwise
(10) add an edge ¬µ t‚Üí x
(11) case (iii) otherwise
(12) add an ‚Äúnew‚Äù node x with x = ¬µ + ‚àÜt and an edge ¬µ t‚Üí x
(13) end for
(14) mark ¬µ with ‚Äúold‚Äù
(15) end while
end algorithm
As it turns out, the coverability graph of a PN is always Ô¨Ånite ([36]). In ad-
dition, a PN is unbounded iÔ¨Ä an œâ occurs in the corresponding coverability
graph, which, in turn, yields a decision procedure for deciding the bounded-
ness property. It should be noted that such a technique does not answer the
reachability problem as œâ abstracts out the exact number of tokens that a
place can accumulate, should the place be potentially unbounded.
A reachability graph (possibly of inÔ¨Ånite size) captures the exact informa-
tion about the set of reachable markings of a PN, whereas a coverability graph
(always of Ô¨Ånite size) provides an over-approximation of the reachability set,
should it be inÔ¨Ånite. Again the coverability graph analysis suÔ¨Äers from state
explosion.
14.5 Complexity Analysis of Various Petri Net Problems
14.5.1 Boundedness and Covering
The boundedness problem was Ô¨Årst considered by Karp and Miller in [36],
where it was shown to be decidable using the technique of coverability graph
analysis. The algorithm presented there was basically an unbounded search
and consequently no complexity analysis was shown. Subsequently, a lower
bound of O(2c√óm) space was shown by Lipton in [40], where m represents the
dimension of the problem instance and c is some constant. Finally, an upper
bound of O(2c√ón√ólogn) space was given by RackoÔ¨Ä in [56]. Here, however,
n represents the size or number of bits in the problem instance and c is a
constant.
Lipton‚Äôs exponential space lower bound was established by constructing
a VAS to maintain and store a number, whose value ranges between 0 and
22
k
. This number could then be incremented by 1 (as long as the current
value was below the upper limit), decremented by 1 (as long as the current
value exceeded 0), and tested for zero. The zero-test was the hard part in
358 Hsu-Chun Yen
necessary) to make the length ‚â§ (2ng(i))i+1. With no loss of generality,
we assume the (i+1)st position to be the coordinate whose value exceeds
2ng(i) at vh. Recalling the deÔ¨Ånition of g(i), there is a self-covering path,
say l, of length ‚â§ g(i) from vh. By appending l to v1...vh (i.e., replacing the
original suÔ¨Éx path vh...vm by l), the new path is an (i + 1)-bounded self-
covering path, because the value of the (i+1)st coordinate exceeds 2ng(i)
and the path l (of length bounded by ‚â§ g(i)) can at most subtract (2ng(i))
from coordinate i+1. (Note that the application of an addition vector can
subtract at most 2n from a given coordinate.)
By solving the recurrence relation g(0) ‚â§ 2nc and g(i + 1) ‚â§ (2ng(i))nc ,
0 ‚â§ i ‚â§ k ‚àí 1, the length of the shortest path witnessing unboudedness is
‚â§ 22c√ón√ólogn . A nondeterministic search immediately yields a O(2c√ón√ólogn)
space complexity for the boundedness problem.
The complexity (both upper and lower bounds) of the covering problem
can be derived along a similar line of that of the boundedness problem. See
[56] for details.
14.5.2 Reachability
Of various problems of interest in the study of PNs, the reachability problem
is perhaps the one that has attracted the most attention in the PN community
in the past four decades. One reason is that the problem has many real-world
applications; furthermore, it is the key to the solutions of several other PN
problems (such as liveness).
Before the decidability question of the reachability problem for general
PNs was answered in the aÔ¨Érmative by Mayr [42, 43] in the early 1980‚Äôs
(see also [38]), a number of attempts were made to investigate the problem
for restricted classes of PNs, in hope of gaining more insights and developing
new tools in order to conquer the general PN reachability problem. Before
Mayr‚Äôs proof, Sacerdote and Tenney [60] claimed the reachability problem to
be decidable; yet they failed to provide a convincing proof. What follows are
notable milestones along this line of research.
In 1974, van Leeuwen [61] Ô¨Årst showed the reachability problem to be
decidable for 3-dimensional PNs. Hopcroft and Pansiot [21] later extended
van Leeuwen‚Äôs Ô¨Ånding to 5-dimensional PNs in 1979. About the same time
Landweber and Robertson [39] as well as Grabowski [16], Mayr [41] and Muller
[48] considered PNs on which either structural or behavioral constraints are
imposed, and showed the reachability problem to be decidable for the classes
of conÔ¨Çict-free and persistent PNs. A important common feature of the above
attempts is that the decidability result was built upon showing the reachability
set to be semilinear. As it turns out, semilinearity is also preserved for the
so-called normal [62], sinkless [62], and communication-free PNs (also known
as BPP nets) [28, 10].
Although the reachability problem for general PNs is known to be de-
cidable, no complexity analysis was given in [42, 43], (nor in [38]). The best
360 Hsu-Chun Yen
liveness problem. As a result, deciding whether a PN is live or not is decidable.
Like the general reachability problem, the exact computational complexity of
the liveness problem remains open.
14.5.5 Model Checking
For some time, temporal logic has been considered a useful formalism for rea-
soning about systems of concurrent programs. A typical problem involving
temporal logic is the model checking problem, i.e., the problem of determin-
ing whether a given structure deÔ¨Ånes a model of a correctness speciÔ¨Åcation
expressed in the temporal logic.
Before getting into the study of model checking for PNs, we require the
following basic deÔ¨Ånitions of linear-time temporal logic (LTL) and a branching-
time temporal logic called computation tree logic (CTL).
An LTL well-formed formula is deÔ¨Åned as
F | ¬¨f | f ‚àß g | ¬© f | f U g
where F is a predicate, and f and g are well-formed formulas. For convenience,
we also write f‚à®g ‚â° ¬¨(¬¨f‚àß¬¨g), f ‚â° true U f and f ‚â° ¬¨¬¨f . Intuitively,
¬©, U , , and  are temporal operators denoting next-time, until, eventually,
and always, respectively. LTL formulas are interpreted on computation paths.
With respect to a computation path s0 ‚Üí s1 ‚Üí ¬∑ ¬∑ ¬∑ , the intuitive meanings
of the the above formulas are:
1. F : the atomic predicate F holds at s0,
2. ¬¨f : formula f does not hold at s0,
3. f ‚àß g : both f and g hold at s0,
4. ¬© f : f holds at s1 (i.e., the immediate successor of s0),
5. f U g : there exists an i ‚â• 0 such that f holds at s0, ..., si‚àí1 and g holds
at si.
A CTL formula is deÔ¨Åned as
F | ¬¨f | f ‚àß g | ‚àÉ ¬© f | ‚àÄ ¬© f | ‚àÉ(f U g) | ‚àÄ(f U g)
where F is a predicate, f and g are CTL formulas, and ‚àÉ and ‚àÄ are path quan-
tiÔ¨Åers denoting ‚Äòthere exists a path‚Äô and ‚Äòfor all paths‚Äô, respectively. Among
others, useful abbreviations include: ‚àÉf ‚â° ‚àÉ(true Uf); ‚àÄf ‚â° ‚àÄ(true Uf);
‚àÄf ‚â° ¬¨‚àÉ(¬¨f); ‚àÉf ‚â° ¬¨‚àÄ(¬¨f).
CTL formulas are interpreted on computation trees. With respect to a tree
rooted at s0, the intuitive meanings of the formulas mentioned above are:
1. F , ¬¨f and f ‚àß g are the same as those in the LTL case,
2. ‚àÉ¬© f : there exists a child s of s0 such that f holds at s,
3. ‚àÄ¬© f : for every child s of s0, f holds at s,
4. ‚àÉ(f U g): there exists a computation path l from s0 such that f U g holds
with respect to l,
362 Hsu-Chun Yen
iff
( ((r1 = 1 ‚àß r2 = 0) ‚àß¬©(r1 = 0 ‚àß r2 = 1)) ‚áí (
‚àß
i
(pi = 0 ‚àß p‚Ä≤i = 0)) )
Note that ((r1 = 1‚àß r2 = 0)‚àß¬©(r1 = 0‚àß r2 = 1)) holds only at a marking at
which transition a Ô¨Åres. Using a similar construction, the undecidability result
for either state-based or action-based branching-time temporal logic can be
shown.
The idea behind model checking an action-based linear-time temporal for-
mula œÜ for PN P is the following. (See [17] for details.) Construct a Buchi
automaton M¬¨œÜ to capture all the computations satisfying the negation of
œÜ. Then it can be shown that P satisÔ¨Åes œÜ iÔ¨Ä the intersection between the
sets of computations of P and M¬¨œÜ is empty. By using a VASS to capture
the ‚ÄòCartesian product‚Äô of P (equivalently, a VAS) and M¬¨œÜ (a Ô¨Ånite automa-
ton), the model checking problem is then reduced to Ô¨Ånding certain inÔ¨Ånite
computations in a VASS, which turns out to be decidable.
14.5.6 Self-stabilization
Before the end of this section, let us elaborate a bit about the self-stabilization
issue of PNs. The notion of self-stabilization was introduced by Dijkstra [8] to
describe a system having the behavior that regardless of its starting conÔ¨Ågura-
tion, the system would return to a ‚Äòlegitimate‚Äô conÔ¨Åguration eventually. (By a
legitimate conÔ¨Åguration, we mean a conÔ¨Åguration which is reachable from the
initial conÔ¨Åguration of the system.) The motivation behind self-stabilization
is that a self-stabilizing system has the ability to ‚Äòcorrect‚Äô itself even in the
presence of certain unpredictable errors that force the system to reach an
‚Äòillegitimate‚Äô conÔ¨Åguration during the course of its operations. In this sense,
self-stabilizing systems exhibit fault-tolerant behaviors to a certain degree.
Let S be a (Ô¨Ånite or inÔ¨Ånite) system with c0 as its initial conÔ¨Åguration. Also
let R(S, c0) (={c | c0 ‚àó‚Üí c}) denote the set of reachable conÔ¨Ågurations from
c0. A computation œÉ from conÔ¨Åguration c1 is said to be non-self-stabilizing iÔ¨Ä
one of the following holds:
1. œÉ is Ô¨Ånite (œÉ : c1
t1‚Üí c2 t2‚Üí ¬∑ ¬∑ ¬∑ cm‚àí1 tm‚àí1‚Üí cm, for some m) such that cm is a
dead conÔ¨Åguration and cm ‚àà R(S, c0), or
2. œÉ is inÔ¨Ånite (œÉ : c1
t1‚Üí c2 t2‚Üí ¬∑ ¬∑ ¬∑ ci ti‚Üí ci+1 ¬∑ ¬∑ ¬∑ ) such that ‚àÄi ‚â• 1, ci ‚àà
R(S, c0).
See Figure 14.10. A system is said to be self-stabilizing if for each conÔ¨Åguration
c, none of the computations emanating from c is non-self-stabilizing. The self-
stabilization problem is to determine, for a given (Ô¨Ånite or inÔ¨Ånite) system,
whether the system is self-stabilizing.
The self-stabilization problem has only been scarcely studied in the Petri
net community. It is known [4] that for bounded ordinary PNs (i.e. PNs with-
out multiple arcs), the problem is PTIME-complete, whereas for bounded
364 Hsu-Chun Yen
that can be expressed by Presburger Arithmetic (i.e., Ô¨Årst order theory over
natural numbers with addition) [55], which is a decidable theory.
10
5
L1
L1 = L ( (3,8); (0,3) )
L2 = L ( (5,6); (3,1), (1,2) )
L3 = L ( (6,3); (4,0), (4,1), (2,6) )
L2
L3
4
3
2
1
1 2 3 4 5 6 7 8 9 10
Fig. 14.11. A semilinear set.
It is known [21] that for PNs of dimension 6 (equivalently, 6-dimensional
vector addition systems, or 3-dimensional vector addition systems with states)
or beyond, their reachability sets may not be semilinear in general.
For subclasses of PNs with semilinear reachability sets, a natural question
to ask is: What is the size of its semilinear representation? An answer to the
above question is key to the complexity analysis of various PN problems. In
what follows, we survey several notable examples along the line of research
of analyzing the sizes of semilinear representations for PNs with semilinear
reachability sets.
Finite PNs:
The reachability sets of Ô¨Ånite (i.e., bounded) PNs are trivially semilinear.
Mayr and Meyer [45] showed that the containment and equivalence prob-
lems for Ô¨Ånite VASs are not primitive recursive. Subsequently, McAloon [46]
showed that the problems are primitive recursive in the Ackermann function,
and Clote [5], using Ramsey theory, showed the Ô¨Ånite containment problem
to be DTIME (Ackermann) complete. Using a diÔ¨Äerent approach, Howell,
Huynh, Rosier and Yen [22] showed an improvement of two levels in the prim-
itive recursive hierarchy over results previously obtained by McAloon, thus
answering a question posed by Clote.
2-dimensional VASS or 5-dimensional VAS (PN):
It was Ô¨Årst known by Hopcroft and Pansiot [21] that PNs of dimension 5 always
have semilinear reachability sets. However, Hopcroft-Pnasiot algorithm does
366 Hsu-Chun Yen
same necessary and suÔ¨Écient condition for the class of PNs without token-
free circuits in every reachable marking [62].
Formally, a circuit c of a PN is a sequence p1t1p2t2 ¬∑ ¬∑ ¬∑ pntnp1 (pi ‚àà P ,
ti ‚àà T , pi ‚àà ‚Ä¢ti, ti ‚àà ‚Ä¢pi+1), such that pi = pj ,‚àÄi = j (i.e., all nodes
except the Ô¨Årst and the last are distinct along the closed path). We write
Pc = {p1, p2, ¬∑ ¬∑ ¬∑ , pn} (resp., Tc = {t1, t2, ¬∑ ¬∑ ¬∑ , tn}) to denote the set of places
(resp., transitions) in c, and tr(c) to represent the sequence t1t2 ¬∑ ¬∑ ¬∑ tn. We
deÔ¨Åne the token count of circuit c in marking ¬µ to be ¬µ(c) =
‚àë
p‚ààPc ¬µ(p). A
circuit c is said to be token-free in ¬µ iÔ¨Ä ¬µ(c) = 0. Given two circuits c and
c‚Ä≤, c is said to be included (resp., properly included) in c‚Ä≤ iÔ¨Ä Pc ‚äÜ Pc‚Ä≤ (resp.,
Pc ‚äÇ Pc‚Ä≤). We say c is minimal iÔ¨Ä it does not properly include any other
circuit. Circuit c is said to be a
‚Ä¢ ‚äï-circuit iÔ¨Ä ‚àÄi, 1 ‚â§ i ‚â§ n, ‚Ä¢ti = {pi} (i.e., ti has pi as its unique input
place), or
‚Ä¢ -circuit iÔ¨Ä ‚àÄt ‚àà T,‚àëp‚ààPc(œï(t, p)‚àí œï(p, t)) ‚â• 0 (i.e., no transition can de-
crease the token count of c).
In this section, we elaborate on a useful technique, called decomposition,
using which the reachability relation for various subclasses of PNs is linked
with integer linear programming [26, 50, 63, 64]. Among those for which our
decompositional approach is applicable include:
‚Ä¢ ConÔ¨Çict-free Petri nets: A PN P = (P, T, œï) is conÔ¨Çict-free [39] iÔ¨Ä for every
place p, either
1. |p‚Ä¢| ‚â§ 1, or
2. ‚àÄt ‚àà p‚Ä¢, t and p are on a self-loop.
In words, a PN is conÔ¨Çict-free if every place which is an input of more
than one transition is on a self-loop with each such transition.
‚Ä¢ Normal Petri nets: A PN P = (P, T, œï) is normal [62] iÔ¨Ä for every minimal
circuit c and transition tj ‚àà T ,
‚àë
pi‚ààPc
ai,j ‚â• 0. Intuitively, a PN is normal
iÔ¨Ä no transition can decrease the token count of a minimal circuit by Ô¨Åring
at any marking, Alternatively, every minimal circuit of a normal PN is a
-circuit.
‚Ä¢ Sinkless Petri nets: A PN P = (P, T, œï) is sinkless [62] iÔ¨Ä each minimal
circuit of P is sinkless.
‚Ä¢ BPP nets: A PN P = (P, T, œï) is a BPP net [10, 28] iÔ¨Ä ‚àÄ t ‚ààT, |‚Ä¢t| = 1, i.e.,
every transition has exactly one input place, implying that every circuit of
a BPP net is a ‚äï-circuit. BPP nets are also known as communication-free
PNs.
‚Ä¢ Trap-circuit Petri nets: A PN P = (P, T, œï) is a trap-circuit PN [30] iÔ¨Ä for
every circuit c in P, Pc is a trap.
‚Ä¢ Extended trap-circuit Petri nets: A PN P = (P, T, œï) is an extended trap-
circuit PN [63] iÔ¨Ä for every circuit c in P, either Pc is a trap or c is a
‚äï-circuit.
368 Hsu-Chun Yen
Each of the subclasses of PNs depicted in Figure 14.12 enjoys the merit of
having a ‚Äònice‚Äô decomposition. In what follows, we elaborate on two notable
examples, namely, the classes of normal and sinkless PNs. For other subclsses
of PNs, the reader is referred to [50, 63, 64].
Let ¬µ0
œÉ1‚àí‚Üí ¬µ1 œÉ2‚àí‚Üí ¬µ2 ¬∑ ¬∑ ¬∑¬µn‚àí1 œÉn‚àí‚Üí ¬µn = ¬µ be a computation in a normal
(or sinkless) PN P reaching ¬µ. The rearrangement œÉ1œÉ2 ¬∑ ¬∑ ¬∑œÉn of œÉ is such
that if œÉ = t1œÉ‚Ä≤1t2œÉ
‚Ä≤
2 ¬∑ ¬∑ ¬∑ tnœÉ‚Ä≤n where t1, t2, ..., tn mark the Ô¨Årst occurrences
of the respective transitions in œÉ (i.e., ti, 1 < i ‚â§ n, is not in the preÔ¨Åx
t1œÉ
‚Ä≤
1 ¬∑ ¬∑ ¬∑ ti‚àí1œÉ‚Ä≤i‚àí1) then œÉi is a permutation of tiœÉ‚Ä≤i. (In words, the appearance
of a new transition triggers the beginning of a new segment.) Furthermore,
by letting
‚Ä¢ T0 = √ò,
‚Ä¢ ‚àÄ1 ‚â§ i ‚â§ n, Ti = Ti‚àí1 ‚à™ {ti}, for some ti ‚àà Ti‚àí1 enabled at ¬µi‚àí1, and
‚Ä¢ œïi is the restriction of œï to (P √ó Ti) ‚à™ (Ti √ó P ),
it can be shown [26] that reachability in sub-PN Pi can be captured by an
instance ILPi(¬µi‚àí1, ¬µi, zi). That is, marking ¬µi is reachable from ¬µi‚àí1 in sub-
PN Pi iÔ¨Ä there is a solution with respect to variable zi in ILPi(¬µi‚àí1, ¬µi, zi). As
a result, if ¬µ is reachable, then (1) there must exist a canonical computation
reaching ¬µ such that the computation can be decomposed into a sequence
of sub-computations, say œÉ1, œÉ2, ¬∑ ¬∑ ¬∑ , œÉn, each coincides with the respective
member in the PN P decomposition; namely P1,P2, ¬∑ ¬∑ ¬∑ ,Pn, and (2) checking
the reachability of PN P is equivalent to solving the a collection of systems
of linear equalities made up of ILPi(¬µi‚àí1, ¬µi, zi), for 1 ‚â§ i ‚â§ n. See [26] for
more details.
Based on the decompositional approach, the reachability problem for each
of the subclasses of PNs depicted in Figure 14.12 is solvable in NP. (In fact,
the problem is NP-complete as the NP-hardness lower bound is easy to show.)
In addition to the aforementioned subclasses of PNs, single-path PNs are
another class whose semilinear reachability sets have been characterized in
detail. See [23] for more.
14.7 Extended Petri Nets
As mentioned in our earlier discussion, the power of conventional PNs is
strictly weaker than that of Turing machines. Those using PNs to model
real-world systems have often found the expressive power of PNs to be too
simple and limited. In many real-time applications, it is often desirable to
give certain jobs higher priorities over others, so that critical actions can be
Ô¨Ånished within their time constraints. One way to do so, for example, is to
assign each transition of a process a priority which indicates the degree of im-
portance or urgency. As [1] indicates, the conventional PN model is unable to
model prioritized systems. From a theoretical viewpoint, the limitation of PNs
370 Hsu-Chun Yen
Fig. 14.14. Simulating test-for-zero of a two-counter machine.
(P, T, œï) equipped with a set FR (‚äÜ T √ó P ) of reset arcs. When a transition
t with (t, p) ‚àà FR is Ô¨Åred, place p is reset to zero. In a transfer net, a set FT
(‚äÜ P √ó T √ó P ) of transfer arcs is associated with a PN (P, T, œï) such that
when t is Ô¨Åred with (p, t, q) ‚àà FT , then the following actions are taken in the
given order: (1) removing the enabling tokens, (2) transferring all tokens from
p to q, and (3) adding the usual output tokens.
Interestingly and somewhat surprisingly, the boundedness problem is de-
cidable for transfer nets but undecidable for reset nets. The termination prob-
lem is decidable for both classes, whereas structural termination turns out
to be undecidable for both. The interested reader is referred to [9, 13] for
more about reset and transfer nets. It is of interest to seek additional de-
cidability/complexity results for problems related to such PN extensions as
well as characterizing additional PN extensions which are weaker than Turing
machines but more powerful than conventional PNs.
References
1. T. Agerwala and M. Flynn. Comments on capabilities, limitations and ‚Äòcorrect-
ness‚Äô of Petri nets, Proc. of 1st Annual Symposium on Computer Architecture,
1973, 81‚Äì86.
2. H. Baker. Rabin‚Äôs proof of the undecidability of the reachability set inclusion
problem of vector addition systems, Computation Structures Group Memo 79,
Project MAC, MIT, July 1973.
3. I. Borosh, and L. Treybig. Bounds on positive integral solutions of linear Dio-
phantine equations, Proc. Amer. Math. Soc. 55 (1976), 299‚Äì304.
4. L. Cherkasova, R. Howell and L. Rosier. Bounded self-stabilizing Petri nets,
Acta Informatica, 32 (1995), 189‚Äì207.
5. P. Clote. On the Ô¨Ånite containment problem for Petri nets, Theoretical Computer
Science, 43 (1986), 99‚Äì105.
372 Hsu-Chun Yen
28. D. Huynh. Commutative grammars: the complexity of uniform word problems,
Information and Control 57 (1983), 21‚Äì39.
29. O. Ibarra. Reversal-bounded multicounter machines and their decision problems,
JACM 25, 1 (1978), 116‚Äì133.
30. A. Ichikawa and K. Hiraishi. Analysis and control of discrete event systems
represented by Petri nets, LNCS 103, Springer-Verlag, 1987, 115‚Äì134.
31. P. Jancar. Decidability of a temporal logic problem for Petri nets, Theoretical
Computer Science 74 (1990), 71‚Äì93.
32. P. Jancar. Non-primitive recursive complexity and undecidability for Petri net
equivalences, Theoretical Computer Science 256 (2001), 23-30.
33. M. Jantzen. Complexity of place/transition nets, Advances in Petri nets 86,
LNCS 254, Springer-Verlag, Berlin, 1986, 413‚Äì435.
34. K. Jensen. Coloured Petri Nets and the Invariant-Method, Theor. Comp. Science
14 (1981), 317‚Äì336.
35. N. Jones, L. Landweber and Y. Lien. Complexity of some problems in Petri
nets, Theoretical Computer Science 4:277-299, 1977.
36. R. Karp and R. Miller. Parallel program schemata, Journal of Computer and
System Sciences 3 (1969), 167‚Äì195.
37. R. Keller. Vector replacement systems: a formalism for modelling asynchronous
systems, Tech. Rept. 117, Computer Science Lab., Princeton Univ. 1972.
38. R. Kosaraju. Decidability of reachability in vector addition systems, Proc. the
14th Annual ACM Symposium on Theory of Computing, 1982, 267‚Äì280.
39. L. Landweber and E. Robertson. Properties of conÔ¨Çict-free and persistent Petri
nets, JACM 25, 3 (1978), 352‚Äì364.
40. R. Lipton. The reachability problem requires exponential space, Technical Re-
port 62, Yale University, Dept. of CS., Jan. 1976.
41. E. Mayr. Persistence of vector replacement systems is decidable, Acta Infor-
mattica 15 (1981), 309‚Äì318.
42. E. Mayr. An algorithm for the general Petri net reachability problem, STOC,
1981, 238‚Äì246.
43. E. Mayr. An algorithm for the general Petri net reachability problem, SIAM J.
Comput. 13 (1984), 441‚Äì460.
44. R. Mayr. Decidability and complexity of model checking problems for inÔ¨Ånite-
state systems, PhD thesis, Computer Science Dept., TU-Munich, Germany,
April 1998.
45. E. Mayr and A. Meyer. The complexity of the Ô¨Ånite containment problem for
Petri nets, J. ACM, 28, 3 (1981), 561‚Äì576.
46. K. McAloon. Petri nets and large Ô¨Ånite sets, Theoretical Computer Science 32
(1984), 173‚Äì183.
47. P. Merlin. A study of the recoverability of computing systems, PhD thesis, Dept.
of Information and COmputer Science, Univ. of California at Irvine, 1974.
48. H. Muller. Decidability of reachability in persistent vector replacement systems,
9th Symp. on Math. Found. of Computer Science, LNCS 88, Springer-Verlag,
Berlin, 1980, 426‚Äì438.
49. T. Murata. Petri nets: properties, analysis and applications, Proc. of the IEEE,
77, 4 (1989), 541‚Äì580.
50. H. Olse¬¥n. Automatic veriÔ¨Åcation of Petri nets in a CLP framework, Ph.D. Thesis,
Dept. of Computer and Information Science, IDA, Linko¬®ping Univ., 1997.
51. S. Patil. Coordination of asynchronous events, PhD thesis, Dept. of Elec. Eng.,
MIT, Cambridge, Mass., May. 1970.
Concurrency, Synchronization, and Conflicts in
Petri Nets
Hsu-Chun Yen?
Dept. of Electrical Engineering, National Taiwan University, Taipei, Taiwan, R.O.C.
Dept. of Computer Science, Kainan University, Taoyuan, Taiwan, R.O.C.
yen@cc.ee.ntu.edu.tw
Petri nets represent one of the most popular formalisms for specifying, mod-
eling, and analyzing concurrent systems. In spite of their popularity, many in-
teresting problems concerning Petri nets are either undecidable or of very high
complexity. Lipton [7] and Rackoff [10] showed exponential space lower and upper
bounds, respectively, for the boundedness problem. As for the containment and
the equivalence problems, Rabin [1] and Hack [5], respectively, showed these two
problems to be undecidable. The reachability problem is known to be decidable
[8] and exponential-space-hard [7].
Studying Petri nets from the aspect of formal language has long been recog-
nized as an important branch of research in Petri net theory. It has been shown
that all Petri net languages are context-sensitive, assuming that a transition‚Äôs
label cannot be Œª. Also, Petri net languages and context-free languages are in-
comparable, i.e., there are Petri net languages that are not context-free and vice
versa. See [9, 11]. It was shown in [4] that Petri net languages are exactly those
that can be expressed by concurrent regular expressions, i.e., regular expressions
augmented with interleaving, interleaving closure, synchronization and renam-
ing operations. As interleaving (denoted by ‚Äñ) is also known as shuÔ¨Ñe in formal
languages, it is of interest to take a closer look at various shuÔ¨Ñe-related issues
in the framework of Petri net languages.
A Petri net (PN, for short) is a 3-tuple (P, T, œï), where P is a finite set
of places, T is a finite set of transitions, and œï is a flow function œï : (P √ó T )
‚à™ (T √ó P ) ‚Üí N . A marking is a mapping ¬µ : P ‚Üí N , specifying a PN‚Äôs
configuration. The computational power of PNs stems from the ability for their
transitions to compete for resources as well as to synchronize and to execute
concurrently in the course of a computation. Generally speaking, there are two
sources of ‚Äùresource sharing‚Äù in the computation of a PN. For x ‚àà P ‚à™ T , we
define ‚Ä¢x = {y | œï(y, x) > 0} and x‚Ä¢ = {y | œï(x, y) > 0}.
- Place sharing: t1, t2 ‚àà T and ‚Ä¢t1 ‚à© ‚Ä¢t2 6= ‚àÖ.
Transitions t1 and t2 ‚Äùshare‚Äù a common input place p in ‚Ä¢t1 ‚à© ‚Ä¢t2, in the
sense that they compete for resources (tokens) kept in p.
? Research supported in part by National Science Council Grant NSC-96-2221-E-002-
028 and Excellent Research Projects of National Taiwan University, 95R0062-AE00-
05.
results concerning concurrent PN languages, and also point out some problems
remain to be answered.
References
1. Baker, H. Rabin‚Äôs proof of the undecidability of the reachability set inclusion prob-
lem of vector addition systems, Computation Structures Group Memo 79, Project
MAC, MIT, July 1973.
2. Best, E., Esparza, J., Wimmel, H., and Wolf, K. Separability in conflict-free Petri
nets, Perspectives of Systems Informatics (PSI 2006), LNCS 4378, Springer, pp.
1-18, 2006.
3. Campeanu, C., Salomaa, K. and Vagvolgyi, S. ShuÔ¨Ñe quotient and decompositions,
Developments in Language Theory, LNCS 2295, Springer, pp. 223-226, 2002.
4. Garg, V. and Raghunath, M. Concurrent regular expressions and their relationship
to Petri nets, Theoretical Computer Science, 96:285-304, 1992.
5. Hack, M. The equality problem for vector addition systems is undecidable, In
C.S.C. Memo 121, Project MAC, MIT, 1975.
6. Ito, M. ShuÔ¨Ñe decomposition of regular languages, Journal of Universal Computer
Science, Vol. 8, No. 2, 257-259, 2002.
7. Lipton, R. The reachability problem requires exponential space, Technical Re-
port 62, Yale University, Dept. of CS., Jan. 1976.
8. Mayr, E. An algorithm for the general Petri net reachability problem, STOC, pp.
238-246, 1981.
9. Peterson, J. Petri Net Theory and the Modeling of Systems, Prentice Hall, Engle-
wood Cliffs, NJ, 1981.
10. Rackoff, C. The covering and boundedness problems for vector addition systems,
Theoretical Computer Science 6:223-231, 1978.
11. Reisig, W. Petri Nets: An Introduction, Springer-Verlag New York, Inc., New York,
NY, 1985.
12. Wolfsthal, Y. and Yoeli, M. An equivalence theorem for labeled marked graphs,
IEEE Trans. on Parallel and Distributed Systems, Vol. 5, No. 8, 886-891, August
1994.
13. Yen, H. Sequential versus concurrent languages of labeled conflict-free Petri nets,
IEEE Trans. on Automatic Control, Vol. 47, No. 7, 1158-1162, July 2002.
14. Yen, H. Introduction to Petri net theory, Chapter 14 in Recent Advances in Formal
Languages and Applications, Studies in Computational Intelligence, Vol. 25, Z.
Esik, C. Martin-Vide, and V. Mitrana (Eds.), pp. 343-373, 2006.
466 H.-C. Yen and C.-L. Chen
minimal elements are eÔ¨Äectively computable. A notable example is the set of
initial markings of a Petri net from which a designated Ô¨Ånal marking is cover-
able. More recent work of [1] demonstrated decidability to compute, from a given
upward-closed set of Ô¨Ånal states, the set of states that are backward reachable
from the Ô¨Ånal states. In a practical aspect of research in upward-closed sets,
BDD-like data structures called covering sharing trees [6] have been developed
to represent in a compact way collections of upward-closed sets over numerical
domains. Subsequent experimental results [7] have further demonstrated such
symbolic representations and manipulations of upward-closed sets to be promis-
ing in performing backward reachability analysis of problems for inÔ¨Ånite state
systems such as Petri nets.
Given the importance of upward-closed sets, it is of interest theoretically and
practically to be able to characterize the class of upward-closed sets for which
their minimal elements are computable. Along this line of research, Valk and
Jantzen ([13]) presented a suÔ¨Écient and necessary condition under which the
set of minimal elements of an upward-closed set is guaranteed to be eÔ¨Äectively
computable. Supposed U is an upward-closed set over Nk and œâ is a symbol rep-
resenting something being arbitrarily large. In [13], it was shown that the set of
minimal elements of U is eÔ¨Äectively computable iÔ¨Ä the question ‚Äòreg(v)‚à©U = ‚àÖ?‚Äô
is decidable for every v ‚àà (N‚à™{œâ})k, where reg(v) = {x | x ‚àà Nk, x ‚â§ v}. (More
will be Such a strategy has been successfully applied to showing computability of
a number of upward-closed sets associated with Petri nets ([13]). Note, however,
that [13] reveals no complexity bounds for the sizes of the minimal elements.
As knowing the size of minimal elements might turn out to be handy in many
cases, the following question arises naturally. If more is known about the query
‚Äòreg(v)‚à©U = ‚àÖ?‚Äô (other than just being decidable), could the size of the minimal
elements be measured? In fact, answering the question in the aÔ¨Érmative is the
main contribution of this work.
Given a vector v ‚àà (N ‚à™ œâ)k, suppose ||v|| is deÔ¨Åned to be the maximum
component (excluding œâ) in v. We demonstrate that for every v, if a bound on the
size of a witness for reg(v)‚à©U = ‚àÖ? (if one exists) is available, then such a bound
can be applied inductively to obtain a bound for all the minimal elements of U . In
a recent article [14], such a strategy was Ô¨Årst used for characterizing the solution
space of a restricted class of parametric timed automata. In this paper, we move
a step further by formulating a general strategy as well as applying our uniÔ¨Åed
framework to a wide variety of Petri net problems with upward-closed solution
sets. In addition to those upward-closed sets investigated in [13] for general
Petri nets, we illustrate the usefulness of our approach in performing backward-
reachability analysis, which is a useful technique in automated veriÔ¨Åcation.
Given a system S with initial state q, and a designated set of states Q,
backward-reachability analysis involves computing the set pre‚àó(S,Q) which con-
sists of all the states from which some state in Q is reachable, and then deciding
whether q ‚àà pre‚àó(S,Q). Forward-reachability analysis, on the other hand, com-
putes all the states that can be reached from q to see whether the intersection
with Q is non-empty or not. In general, pre‚àó(S,Q) may not be computable for
468 H.-C. Yen and C.-L. Chen
(resp., inÔ¨Ånite) strings of symbols from T , and T+ = T ‚àó ‚àí {Œª}, where Œª is the
empty string.
A Petri net (PN, for short) is a 3-tuple P = (P, T, œï), where P is a Ô¨Ånite set
of places, T is a Ô¨Ånite set of transitions, and œï is a Ô¨Çow function œï : (P √ó T )
‚à™ (T √ó P ) ‚Üí N . Let k and m denote |P | (the number of places) and |T | (the
number of transitions), respectively. The k is also called the dimension of the
PN. A marking is a mapping Œº : P ‚Üí N . The transition vector of a transition t,
denoted by t¬Ø, is a k-dimensional vector in Zk, such that t¬Ø(i) = œï(t, pi)‚àíœï(pi, t),
and the set of transition vectors, denoted by T¬Ø , to be {t¬Ø | t ‚àà T }.
A transition t ‚àà T is enabled at a marking Œº iÔ¨Ä ‚àÄp ‚àà P , œï(p, t) ‚â§ Œº(p). If a
transition t is enabled, it may Ô¨Åre and yields marking Œº‚Ä≤ (written as Œº t‚Üí Œº‚Ä≤)
with Œº‚Ä≤(p) = Œº(p)‚àíœï(p, t)+œï(t, p), ‚àÄp ‚àà P . A sequence of transitions œÉ = t1...tn
is a Ô¨Åring sequence from Œº0 iÔ¨Ä Œº0
t1‚Üí Œº1 t2‚Üí ¬∑ ¬∑ ¬∑ tn‚Üí Œºn for some markings Œº1,...,Œºn.
(We also write ‚ÄòŒº0
œÉ‚Üí Œºn‚Äô.) We write ‚ÄòŒº0 œÉ‚Üí‚Äô to denote that œÉ is enabled and
can be Ô¨Åred from Œº0, i.e., Œº0
œÉ‚Üí iÔ¨Ä there exists a marking Œº such that Œº0 œÉ‚Üí Œº.
The notation Œº0
‚àó‚Üí Œº is used to denote the existence of a œÉ ‚àà T ‚àó such that
Œº0
œÉ‚Üí Œº. A marked PN is a pair ((P, T, œï), Œº0), where (P, T, œï) is a PN, and Œº0 is
called the initial marking. Throughout the rest of this paper, the word ‚Äòmarked‚Äô
will be omitted if it is clear from the context. By establishing an ordering on
the elements of P and T (i.e., P = {p1, ..., pk} and T = {r1, ..., rm}), we can
view a marking Œº as a k-dimensional vector with its i-th component being Œº(pi),
and #œÉ as an m-dimensional vector with its jth entry denoting the number of
occurrences of transition rj in œÉ. The reachability set of P with respect to Œº0 is
the set R(P , Œº0) = {Œº | ‚àÉœÉ ‚àà T ‚àó, Œº0 œÉ‚Üí Œº}. The reachability problem is that of,
given a marked PN (P , Œº0) and a marking Œº, deciding whether Œº ‚àà R(P , Œº0).
F (P , Œº0) (= {œÉ ‚àà T ‚àó | Œº0 œÉ‚Üí}) denotes the set of all Ô¨Åreable sequences of
transitions in PN (P , Œº0). Given a œÉ ‚àà Tœâ, In(œÉ) denotes the set of all elements
in T that occur inÔ¨Ånitely many times in œÉ.
A k-dimensional vector addition system with states (VASSs) is a 5-tuple
(v0, V, s1, S, Œ¥), where v0 ‚àà Nk is called the start vector, V (‚äÜ Zk) is called
the set of addition rules, S is a Ô¨Ånite set of states, Œ¥(‚äÜ S √ó S √ó V ) is the tran-
sition relation, and s1 (‚àà S) is the initial state. Elements (p, q, v) of Œ¥ are called
transitions and are usually written as p ‚Üí (q, v). A conÔ¨Åguration of a VASS is a
pair (p, x) where p ‚àà S and x ‚àà Nk. For convenience, we write state((p, x)) = p
and val((p, x)) = x. (s1, v0) is the initial conÔ¨Åguration. The transition p ‚Üí (q, v)
can be applied to the conÔ¨Åguration (p, x) and yields the conÔ¨Åguration (q, x+ v),
provided that x + v ‚â• 0. In this case, (q, x + v) is said to follow (p, x). Let œÉ0
and œÉt be two conÔ¨Ågurations. Then œÉt is said to be reachable from œÉ0 iÔ¨Ä œÉt = œÉ0
or conÔ¨Ågurations œÉ1, ..., œÉt‚àí1 such that œÉr+1 follows œÉr for r = 0, ..., t ‚àí 1. A k-
dimensional VASS is basically a k-counter machine without zero-test capabilities
(i.e., the counter machine cannot test individual counters for empty and then
acts accordingly). It is well known that PNs and VASSs are computationally
equivalent.
470 H.-C. Yen and C.-L. Chen
w0
m
b
b
U
Fig. 1. Induction Basis
minh(U) implies the existence of such a witness.) It must be the case that there
exists an index imh+1(‚àà {im1, ..., imh}) such that m(imh+1) ‚â§ wmh (imh+1) (‚â§
f(f (h‚àí1)(b))) = f (h)(b)), since otherwise, wmh < m ‚Äì contradicting that m being
minimal. The induction step is therefore proven.
4 Some Applications
In this section, Theorem 2 is used to derive upper bounds for the minimal ele-
ments of various upward-closed sets associated with PNs and VASSs.
4.1 Petri Nets
We examine some upward-closed sets deÔ¨Åned and discussed in [13]. Some deÔ¨Ån-
itions from [13] are recalled Ô¨Årst. Given a PN (P, T, œï), a vector Œº ‚àà Nk is said
to be
‚Äì TÀÜ -blocked, for TÀÜ ‚äÜ T , if ‚àÄŒº‚Ä≤ ‚àà R(P , Œº), ¬¨(‚àÉt ‚àà TÀÜ , Œº‚Ä≤ t‚Üí). For the case when
TÀÜ= T , Œº is said to be a total deadlock.
‚Äì dead if F (P , Œº) is Ô¨Ånite.
‚Äì bounded if R(P , Œº) is Ô¨Ånite; otherwise, it is called unbounded.
‚Äì TÀÜ -continual, for TÀÜ ‚äÜ T , if there exists a œÉ ‚àà Tœâ, Œº œÉ‚Üí and TÀÜ ‚äÜ In(œÉ).
For a PN (P , Œº0), consider the following four sets deÔ¨Åned in [13]:
‚Äì NOTBLOCKED(TÀÜ )={Œº ‚àà Nk | Œº is not TÀÜ -blocked}.
‚Äì NOTDEAD={Œº ‚àà Nk | Œº is not dead}.
‚Äì UNBOUNDED={Œº ‚àà Nk | Œº is unbounded}.
‚Äì CONTINUAL(TÀÜ )={Œº ‚àà Nk | Œº is TÀÜ -continual}.
472 H.-C. Yen and C.-L. Chen
Lemma 1. Given a k-dimensional PN (P, T, œï), a transition t ‚àà T , a z ‚àà Nkœâ,
reg(z)‚à© NOTBLOCKED({t}) = ‚àÖ iÔ¨Ä there is a witness z‚Ä≤ with ||z‚Ä≤|| ‚â§ n2d√ók√ólogk ,
where n = ||T¬Ø || and d is a constant. (Note that the bound is independent of z).
Proof. (Sketch) The proof tailors the inductive approach used in [11] for the
covering problem of PNs to incorporating a multi-parameter analysis.
As was done in [11], for each w ‚àà Zk, let s(i, w) be the length of the shortest
i-bounded i-covering path (starting from w) with respect to t, if at least one such
path exists; otherwise, let s(i, w) = 0. We deÔ¨Åne h(i) = max{s(i, w) | w ‚àà Nk}.
It is important to note, as pointed out in [11], that h(i) depends on t and T¬Ø ,
and is independent of the starting vector from which the path of the PN begins.
Let n be ||T¬Ø ||, which is an upper bound on the number of tokens that can be
removed from a place as a result of Ô¨Åring a single PN transition. Lemmas 3.3
and 3.4 of [11] show that
h(0) = 1 and h(i + 1) ‚â§ (n √ó h(i))i+1 + h(i), for 1 ‚â§ i < k.
In order to be self-contained, a proof sketch of the above is given below. h(0) = 1
is trivial (as indicated in Lemma 3.3 of [11]). The key in RackoÔ¨Ä‚Äôs proof relies
on Ô¨Ånding a bound for h(i) inductively, where i = 1, 2, ..., k.
Let p : v1 ¬∑ ¬∑ ¬∑ vm be any (i + 1)-covering path. Consider two cases:
‚Äì Case 1: Path p is (i+1)‚àí (n√óh(i))-bounded. Then there exists an (i+1)‚àí
(n√óh(i))-bounded (i+1)-covering path with no two vectors agree on all the
Ô¨Årst i + 1 coordinates. Hence, the length of such a path is ‚â§ (n √ó h(i))i+1.
‚Äì Case 2: Otherwise, let vh be the Ô¨Årst vector along p that is not (n √ó h(i))
bounded. By chopping oÔ¨Ä (i + 1)-loops, the preÔ¨Åx v1...vh can be shortened
if necessary (as in Case 1) to make the length ‚â§ (n √ó h(i))i+1. With no loss
of generality, we assume the (i + 1)st position to be the coordinate whose
value exceeds n √ó h(i) at vh. Recalling the deÔ¨Ånition of h(i), there is an i-
covering path, say l, of length ‚â§ h(i) from vh. By appending l to v1...vh (i.e.,
replacing the original suÔ¨Éx path vh...vm by l), the new path is an (i + 1)-
bounded (i + 1)-covering path, because the value of the (i+ 1)st coordinate
exceeds n √ó h(i) and the path l (of length bounded by ‚â§ h(i)) can at most
subtract (n√óh(i)) from coordinate i+1. (Note that the application of a PN
transition can subtract at most n from a given coordinate.) Note that the
length of the new path is bounded by (n √ó h(i))i+1 + h(i).
By solving the recurrence relation h(0) = 1 and h(i+1) ‚â§ (n√óh(i))i+1+h(i),
for 1 ‚â§ i < k, we have h(k) ‚â§ n2c√ók√ólogk , for some constant c. What this bound
means is that regardless of the initial vector, if v can be covered then there
is a covering path of length bounded by n2
c√ók√ólogk
. Since a path of length ‚â§
n2
c√ók√ólogk
can at most subtract ||T¬Ø ||√ón2c√ók√ólogk from any component, the witness
||z‚Ä≤|| is therefore bounded by (||t¬Ø|| + ||T¬Ø || √ó n2c√ók√ólogk) ‚â§ n2d√ók√ólogk , for some
constant d.
Now consider the set UNBOUNDED.
474 H.-C. Yen and C.-L. Chen
be the length of the shortest i-bounded TÀÜ -self-covering path (starting from w),
if at least one such path exists; otherwise, let m‚Ä≤(i, w) = 0. We deÔ¨Åne g‚Ä≤(i) =
max{m‚Ä≤(i, w) | w ‚àà Zk}. Then following a very similar inductive argument as
presented in [11,12], a recurrence relation g‚Ä≤(0) ‚â§ nck, and g‚Ä≤(i + 1) ‚â§ (n2 √ó
g‚Ä≤(i))k
c
, for 1 ‚â§ i < k and some constant c, can be derived. The rest is easy.
Theorem 3. Given a k-dimensional PN (P, T, œï) and a TÀÜ ‚äÜ T ,
||min(NOTBLOCKED(TÀÜ ))||, ||min(UNBOUNDED)||, ||min(NOTDEAD)||,
||min(CONTINUAL(TÀÜ ))|| ‚â§ n2d√ók√ólogk , where n = ||T¬Ø || and d is a constant.
Proof. (Sketch) Given a z ‚àà Nkœâ, deÔ¨Åne f(||z||) = n2
d√ók√ólogk
(where n = ||T¬Ø || and
d a constant stated in Lemma 1) which provides an upper bound for a witness
certifying reg(z)‚à© NOTBLOCKED(TÀÜ ) = ‚àÖ, if one exists. Notice that the value
of f is independent of z. Our result follows immediately from Theorem 2. From
Lemmas 2, 3, and 4, the other three cases are similar.
The results in Theorem 3 can easily be modiÔ¨Åed for the model of VASSs. It
is interesting to point out that the minimal elements of a number of upward-
closed sets concerning inÔ¨Ånite computations of Petri nets with respect to various
notions of fairness (see DeÔ¨Ånition 6.9 of [13]) can also be obtained from the result
of Theorem 3, as the set CONTINUAL is suÔ¨Écient to capture such inÔ¨Ånite fair
computations.
Now we consider a problem that arises frequently in automated veriÔ¨Åcation.
Given a system S with initial state q, and a designated set of states Q, it is often
of interest and importance to ask whether some state in Q can be reached from q,
which constitutes a question related to the analysis of a safety property. Instead
of using the forward-reachability analysis (which computes all the states that can
be reached from q to see whether the intersection with Q is non-empty or not),
an equally useful approach is to use the so-called backward-reachability analysis.
In the latter, we compute the set pre‚àó(S,Q) which consists of all the states from
which some state in Q is reachable, and then decide whether q ‚àà pre‚àó(S,Q). In
general, pre‚àó(S,Q) may not be computable for inÔ¨Ånite state systems.
For PNs, we deÔ¨Åne the backward-reachability (BR, for short) problem as
follows:
‚Äì Input: A PN P and a set U of markings
‚Äì Output: The set pre‚àó(P , U) = {Œº | R(P , Œº) ‚à© U = ‚àÖ}
In words, the problem is to Ô¨Ånd the set of initial markings from which a marking
in U can be reached. Now suppose U is upward-closed, then {Œº | R(P , Œº)‚à©U = ‚àÖ}
is upward-closed as well, and is, in fact, equivalent to
‚ãÉ
ŒΩ‚ààmin(U){Œº | ‚àÉŒº‚Ä≤ ‚àà
R(P , Œº), Œº‚Ä≤ ‚â• ŒΩ}. The latter is basically asking about coverability issues of PNs.
Hence, the max-value of the minimal elements can be derived along the same
line as that for the set NOTBLOCKED.
476 H.-C. Yen and C.-L. Chen
- Output: Ô¨Ånd the values of Œ∏1, ¬∑ ¬∑ ¬∑ , Œ∏n (if they exist) so that there exists a
computation reaching a marking in Q. In what follows, we let S(Œ∏1, ¬∑ ¬∑ ¬∑ , Œ∏n)
denote such a set of solutions.
Even for timed automata, it is known that the emptiness problem (i.e., the
problem of deciding whether there exists a parameter setting under which the
associated timed language is empty or not) is undecidable when three or more
clocks are compared with unknown parameters [3]. In what follows, we consider
a special case in which the involved atomic clock constraints are only of the form
x ‚â§ Œ∏ or x < Œ∏, and there are no negative signs immediately before inequalities.
In this case, the set ‚Äò{(Œ∏1, ¬∑ ¬∑ ¬∑ , Œ∏n) | there exists a computation in P reaching
a marking in Q under (Œ∏1, ¬∑ ¬∑ ¬∑ , Œ∏n)}‚Äô is clearly upward-closed, as x ‚â§ Œ∏ =‚áí
x ‚â§ Œ∏‚Ä≤ and x < Œ∏ =‚áí x < Œ∏‚Ä≤, if Œ∏ ‚â§ Œ∏‚Ä≤. That is, whatever enabled under Œ∏ is also
enabled under Œ∏‚Ä≤.
A technique known to be useful for reasoning about timed automata is based
on the notion of ‚Äòequivalence classes‚Äô [2]. In spite of the diÔ¨Äerences in value, two
diÔ¨Äerent clock readings may induce identical system‚Äôs behaviors; in this case,
they are said to be in the same clock region. For clock constraints falling into
the types given in our setting, the number of distinct clock regions is always Ô¨Ånite
[2], meaning that a timed automaton (which is of inÔ¨Ånite-state potentially) is
equivalent behaviorally to a so-called region automaton (which is of Ô¨Ånite-state).
Furthermore, the number of clock regions of a timed automaton A is bounded
by 2|Q|(|X | ¬∑ (CA + 2))|X|, where |Q| is the number of states of A, |X | is the
number of clocks of A, and CA is the maximum timing constant involved in A
(see [2] for details). This, coupled with our earlier discussion of upward-closed
sets and PNs, yields the following result:
Theorem 4. Given a k-dimensional clocked PN P with unknown integer para-
meters Œ∏1, ¬∑ ¬∑ ¬∑ , Œ∏n in its clock constraints, and an upward-closed set Q of goal
markings, ||min(S(Œ∏1, ¬∑ ¬∑ ¬∑ , Œ∏n))|| is bounded by O((D ¬∑ |X |)2d2 ¬∑n¬∑k¬∑logk¬∑|X|n), where
|X | is the number of clocks, D is the absolute value of the maximum number
involved in P and min(Q), and d2 is a constant.
Proof. (Sketch) The proof is somewhat involved, and hence, only a proof sketch
is given here. Our derivation is based on the approach detailed in Theorem 2.
For the PN to reach Q, it suÔ¨Éces to consider whether a marking covering an
element in min(Q) is reachable or not. Recall from Theorem 2 that our approach
for computing ||min(S(Œ∏1, ¬∑ ¬∑ ¬∑ , Œ∏n))|| begins by letting (Œ∏1, ¬∑ ¬∑ ¬∑ , Œ∏n)=(œâ, ¬∑ ¬∑ ¬∑ , œâ) =
v0. In this case, the associated clocked PN can be simpliÔ¨Åed by deleting all the
clock constraints involving Œ∏i, because x ‚â§ (<)œâ always holds. Now the idea is
to simulate clocked PNs by VASSs. To this end, we use the ‚Äòstate‚Äô portion of the
VASS to capture the structure of (Ô¨Ånitely many) clock regions of a clocked PN as
discussed earlier, and an ‚Äòaddition vector‚Äô of the VASS to simulate a transition
of the PN. Using the analysis of [2], it is not hard to see that the number of clock
regions is bounded by O((|X | ¬∑ C0)|X|), where |X | is the number of clocks and
C0 is the maximum timing constant (i.e., maximum value of constants involved
in clock constraints), which corresponds to the number of states of the VASS.
478 H.-C. Yen and C.-L. Chen
c, then one of t‚Äôs output places must be in c as well. Intuitively, a PN is normal
iÔ¨Ä no transition can decrease the token count of a minimal circuit by Ô¨Åring at
any marking. For the deÔ¨Ånitions and the related properties for the rest of the
PNs in Figure 2, the reader is referred to [16].
Trap- Extended
Trap-Circuit
Normal
General Petri Nets
Conflict-
Free
BPP
Circuit
Fig. 2. Containment relationship among subclasses of PNs
In [10], the reachabiliy problem of normal PNs was equated with ILP using
the so-called decompositional approach. The idea behind the decompositional
technique relies on the ability to decompose a PN P=(P, T, œï) (possibly in a
nondeterministic fashion) into sub-PNs Pi = (P, Ti, œïi) (1 ‚â§ i ‚â§ n, Ti ‚äÜ T ,
and œïi is the restriction of œï to (P √ó Ti) ‚à™ (Ti √ó P )) such that for an arbi-
trary computation Œº0
œÉ‚Üí Œº of PN P , œÉ can be rearranged into a canonical form
œÉ1œÉ2 ¬∑ ¬∑ ¬∑œÉn with Œº0 œÉ1‚Üí Œº1 œÉ2‚Üí Œº2 ¬∑ ¬∑ ¬∑Œºn‚àí1 œÉn‚Üí Œºn = Œº, and for each i, a system
of linear inequalities ILPi(x, y, z) can be set up (based upon sub-PN Pi, where
x, y, z are vector variables) in such a way that ILPi(Œºi‚àí1, Œºi, z) has a solution
for z iÔ¨Ä there exists a œÉi in T ‚àói such that Œºi‚àí1
œÉi‚Üí Œºi and z = #œÉi . See Figure 3.
Consider a normal PN P = (P, T, œï) and let P = {p1, ..., pk} and T =
{t1, ..., tm}. In [10], it was shown that an arbitrary computation of a normal PN
can be decomposed according to a sequence of distinct transitions œÑ = tj1 ¬∑ ¬∑ ¬∑ tjn .
More precisely, we deÔ¨Åne the characteristic system of inequalities for P and œÑ as
S(P , œÑ) = ‚ãÉ1‚â§h‚â§n Sh, where
- Sh = {xh‚àí1(i) ‚â• œï(pi, tjh), xh = xh‚àí1 + Ah ¬∑ yh | 1 ‚â§ i ‚â§ k}, Ah is an
k √ó h matrix whose columns are t¬Øj1 , ¬∑ ¬∑ ¬∑ , t¬Øjh , yh is a h√ó 1 column vector, for
1 ‚â§ h ‚â§ n.
480 H.-C. Yen and C.-L. Chen
Bv ‚â• b, then for some constant c independent of d, d1, d2, there exists a vector
v such that Bv ‚â• b and ||v|| ‚â§ dcd1 .
Now we are in a position to derive a bound for the minimal elements of pre‚àó for
normal PNs.
Theorem 5. Given a normal PN P = (P, T, œï) with |P | = k and |T | = m, a
marking Œº‚Ä≤, and a linear constraint L(v1, ..., vm), then ||min(pre‚àó(P , (Œº‚Ä≤, L)))|| ‚â§
(a1)(c‚àóa2)
k
, where c is some constant, a1 = max{||T¬Ø ||, s, (m+ k) ‚àóm} ‚àóm ‚àó ||T¬Ø||,
a2 = (m ‚àó k + r), r the number of (in)equalities in L, and s the absolute value
of the largest integer mentioned in L.
Proof. Given a subset of places Q ‚äÜ P , we deÔ¨Åne a restriction of P on Q as PN
PQ = (Q, T, œïQ), where œïQ is the restriction of œï on Q and T (i.e., œïQ(p, t) =
œï(p, t);œïQ(t, p) = œï(t, p) if p ‚àà Q). It is obvious from the deÔ¨Ånition of normal
PNs that PQ is normal as well.
Now consider a vector v ‚àà Nkœâ. To Ô¨Ånd a witness for reg(v)‚à©pre‚àó(P , (Œº‚Ä≤, L)) =
‚àÖ, if one exists, it suÔ¨Éces to consider sub-PN with Q(v) = {p | v(p) = œâ, p ‚àà P}
as the set of places (as opposed to the original set P ), since each œâ place can
supply an arbitrary number of tokens to each of its output transitions. (That
is, places associated with œâ components in v can be ignored as far as reaching
a goal marking in U is concerned.) Hence, reg(v) ‚à© pre‚àó(P , (Œº‚Ä≤, L)) = ‚àÖ iÔ¨Ä for
some œÑ (of length ‚â§ m), the following system of linear inequalities has a solution
H ‚â° S(PQ, œÑ) ‚à™{x0 = v} ‚à™ {xn ‚â• Œº‚Ä≤} ‚à™ L(v1, ..., vm) ‚à™
{(v1, ..., vm)tr = y‚Ä≤1 + ... + y‚Ä≤n}.2
Notice that in the above, {(v1, ..., vm)tr = y‚Ä≤1 + ... + y‚Ä≤n} ensures that for each
transition ti, the number of times ti being used in the computation (i.e., y‚Ä≤1(i)+
y‚Ä≤2(i) + ¬∑ ¬∑ ¬∑ + y‚Ä≤n(i)) captured by S(PQ, œÑ) equals vi. Recall that y‚Ä≤h captures the
Ô¨Åring count vector in segment h.
A careful examination reveals that in H , the number of inequalities is bounded
by O(m ‚àó k + r), and the number of variables is bounded by O((m + k) ‚àó m).
Furthermore, the absolute value of the maximal numbers in H is bounded by
max{||v||, ||T¬Ø ||, s}. Using Lemma 5, if H has a solution, then a ‚Äòsmall‚Äô solution of
max-value bounded by (max{||v||, ||T¬Ø ||, s, (m+k)‚àóm})b‚àó(m‚àók+r) exists, for some
constant b. Recall that the y‚Ä≤h vector variable represents the numbers of times
the respective transitions are used along segment h of the reachability path.
As a result, an initial marking with at most m ‚àó ((max{||v||, ||T¬Ø ||, s, (m + k) ‚àó
m})b‚àó(m‚àók+r)) ‚àó ||T¬Ø || tokens in each of the œâ places suÔ¨Éces for such a path to be
valid in the original PN, since each transition consumes at most ||T¬Ø || tokens from
a place. The above is bounded by (a1‚àó||v||)b‚àóa2 (for a1, a2 given in the statement
of the theorem), where b is a constant. Now deÔ¨Åne f(||v||) = (a1 ‚àó||v||)b‚àóa2 . From
Theorem 2, ||min(pre‚àó(P , (Œº‚Ä≤, L)))|| is bounded by f (k‚àí1)(||(œâ, ..., œâ)||), which
can easily be shown to be bounded by (a1)(c‚àóa2)
k
, for some constant c.
2 The superscript tr denotes the transpose of a matrix.
482 H.-C. Yen and C.-L. Chen
the state of the conÔ¨Åguration. In [4], it was shown the following global model
checking problem to be decidable:
‚Äì Given a k-dim VASS V= (v0, V, s1, S, Œ¥) with S = {s1, ..., sh} and a formula
œÜ = ‚àÉœâ(œÄ1, ..., œÄh), for upward-closed constraints œÄ1, ..., œÄh,
‚Äì Output: The set [[œÜ]]V={œÉ | œÉ |= œÜ in V}.
The following result gives a complexity bound for the above problem.
Theorem 7. For each state s ‚àà S, ||min({v ‚àà Nk | (s, v) ‚àà [[œÜ]]V})|| is bounded
by n2
d√ók√ólogk
, where n = max{||T¬Ø ||, u}, u is the absolute value of the largest
number mentioned in œÜ, and d is a constant.
Proof. (Sketch) The proof is done by constructing a VASS V ‚Ä≤=(v‚Ä≤0, V ‚Ä≤, s‚Ä≤1, S‚Ä≤, Œ¥‚Ä≤)
from V such that (s1, v0) |= œÜ in V iÔ¨Ä there exists an inÔ¨Ånite path from (s‚Ä≤1, v‚Ä≤0)
in V ‚Ä≤.
Assume that œÄi =
‚à®
1‚â§l‚â§k(xl ‚â• ci,l). For convenience, for a value c and an
index l, we deÔ¨Åne [c]l to be a vector whose l ‚àí th coordinate equals c; the rest
of the coordinates are zero. The construction is as follows:
‚Äì S‚Ä≤ = S ‚à™ {qi,l,j | 1 ‚â§ i ‚â§ h, 1 ‚â§ l ‚â§ k, 1 ‚â§ j ‚â§ h}
‚Äì For each addition rule v ‚àà Œ¥(si, sj), k addition rules are used to test the
k primitive constraints in œÄi, by including the following rules: ‚àÄ1 ‚â§ l ‚â§ k,
[‚àíci,l]l ‚àà Œ¥‚Ä≤(si, qi,l,j). Furthermore, we also have (v + [ci,l]l) ‚àà Œ¥‚Ä≤(qi,l,j , sj) to
restore the testing of ci,l as well as adding vector v.
‚Äì v‚Ä≤0 = v0 and s
‚Ä≤
1 = s1
Based upon the above construction, it is reasonably easy to show that (s1, v0) |=
œÜ in V iÔ¨Ä there exists an inÔ¨Ånite path from (s‚Ä≤1, v‚Ä≤0) in V ‚Ä≤. The bound of the the-
orem then follows from Theorem 3.
5 Conclusion
We have developed a uniÔ¨Åed strategy for computing the sizes of the minimal
elements of certain upward-closed sets associated with Petri nets. Our approach
can be regarded as a reÔ¨Ånement of [13] in the sense that complexity bounds
become available (as opposed to merely decidability as was the case in [13]), as
long as the size of a witness for a key query is known. Several upward-closed
sets that arise in the theory of Petri nets as well as in backward-reachability
analysis in automated veriÔ¨Åcation have been derived in this paper. The reader
is referred to [8] [9] for related results concerning complexity and decidability of
some upward-closed sets associated with Petri nets. It would be interesting to
seek additional applications of our technique.
Acknowledgments. The authors thank the anonymous referees for their com-
ments that improved the presentation of this paper.












