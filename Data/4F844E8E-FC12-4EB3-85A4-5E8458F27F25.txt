1 
ï¨ˆæ”¿é™¢åœ‹å®¶ç§‘å­¸å§”å“¡æœƒå°ˆé¡Œç ”ç©¶è¨ˆç•«æˆæœå ±å‘Š 
ç¹”å“è‡ªå‹•åŒ–è¦–è¦ºæª¢é©—ç³»çµ±(III)  
Automated Inspection of Fabric (III) 
è¨ˆç•«ç·¨è™Ÿï¼šNSC 99-2221-E-214-037 
åŸ· ï¨ˆ æœŸ é™ï¼š99 ï¦ 8 æœˆ 1 æ—¥è‡³ 100 ï¦ 10 æœˆ 31 æ—¥ 
ä¸» æŒ äººï¼šå³æ–‡è¨€   ç¾©å®ˆå¤§å­¸å·¥æ¥­å·¥ç¨‹èˆ‡ç®¡ï§¤å­¸ç³» 
å…±åŒä¸»æŒäººï¼š  
è¨ˆç•«ï¥«èˆ‡äººå“¡ï¼š 
ä¸€ã€ä¸­æ–‡æ‘˜è¦ 
ç´¡ç¹”æ¥­å°æ–¼ç”¢å“çš„æª¢é©—ï¼Œé€šå¸¸æ¡ç”¨æŠ½é©—ï¤­
ç›£æ§ç”¢å“å“è³ªï¼Œä¸¦ç”±æ“ä½œå“¡ä»¥ç›®è¦–æª¢é©—ç‚ºä¸»ã€‚
ä½†äººçœ¼æª¢é©—å¸¸å¸¸ç„¡æ³•æœ‰ä¸€è‡´çš„æª¢é©—çµæœï¼Œï¤å¯
èƒ½å—åˆ°çœ¼ç›ç–²ï¥è€Œæœ‰èª¤åˆ¤çš„æƒ…å½¢ç™¼ç”Ÿï¼ŒåŒæ™‚äºº
å·¥æª¢é©—ç·©æ…¢ï¼Œä½¿å¾—é«˜é€Ÿè‡ªå‹•åŒ–ç”Ÿç”¢ç³»çµ±è¨­å‚™ç„¡
æ³•æœ‰æ•ˆç™¼æ®ã€‚å› æ­¤å»ºï§·ä¸€å¥—é«˜é€Ÿä¸”æº–ç¢ºçš„è‡ªå‹•
åŒ–ç‘•ç–µæª¢æ¸¬æ–¹æ³•æ˜¯è¿«ï¨€éœ€è¦çš„ï¼Œäº¦åŒæ™‚èƒ½ç™¼æ®
ï¨‰ä½äººå·¥éœ€æ±‚èˆ‡æª¢é©—çµæœä¸€è‡´ç­‰å„ªé», å¸Œæœ›
æœ‰åŠ©æ–¼ç¹”å“è‡ªå‹•åŒ–æª¢é©—æŠ€è¡“ä¹‹æå‡ã€‚æœ¬ï¦ï¨è¨ˆ
ç•«ä¸­ç¹¼çºŒç™¼å±•ç¹”å“ç‘•ç–µè¾¨ï§¼æ–¹æ³•ï¼ŒæŒçºŒå¢åŠ æ¸¬
è©¦æ¨£æœ¬ï¼Œä¸¦è¨­è¨ˆä¸€å¥—å®Œæ•´çš„ç¹”å“ç‘•ç–µè¾¨ï§¼ç³»çµ±ã€‚
æ­¤ç³»çµ±é™¤å¸Œæœ›å°ç¹”å“ç‘•ç–µçš„å€‹åˆ¥ç´°éƒ¨ç‰¹å¾µå¦¥
å–„é€²ï¨ˆæ“·å–å¤–ï¼Œï¤å†€æœ›ç”±å‰è¿°æ“·å–å‹•ä½œæ‰€å¾—ä¹‹
ç‰¹å¾µè³‡è¨Šèƒ½å°ç¹”å“ç‘•ç–µè¾¨ï§¼ä¹‹è¾¨ï§¼ï¥¡æœ‰æ•ˆæ
æ˜‡ï¼Œä»¥é”åˆ°ï¤å®Œå–„ä¹‹ç¹”å“ç‘•ç–µè¾¨ï§¼æ•ˆæœã€‚ 
 
é—œéµè©ï¼šç¹”å“ã€ç‘•ç–µã€è‡ªå‹•åŒ–æª¢é©—ã€æ©Ÿå™¨è¦–è¦ºã€
å½±åƒè™•ï§¤ 
Abstract 
Along with the unceasing evolution of 
technique and technology, the textile industry in 
Taiwan should reform to the future industry of 
information guidance, speed guidance, and the 
innovation by the support of electronic 
enterprise and automation technology. In 
traditional, textile industry usually uses spot 
check to monitor the quality of the products and 
primarily inspects the products by operators. But 
the visual inspection by human may not have 
consistent results, and the probability of 
mistakes caused by eyestrain will happen. 
Recently, the development of computer 
hardware has been established robustly to 
replace the traditional inspection or manual 
inspection. Machine vision system with fast, 
accuracy and stable features, has been widely 
used the inspections in industry. This research is 
to develop an automated fabric visual inspection 
system. The main types of defects for fabric are 
holes, greasy dirt, broken end, broken pick, and 
slack end. By a serial of image processing steps, 
and incorporate with the concept of quality 
control, and finally, integrating software 
programming and hardware device. By this 
study, an automated, reliable and faster 
examination is aimed to raise the efficiency and 
quality of inspection techniques in fabric 
industry. 
 
Keywords: fabric, defect, automated inspection, 
machine vision, image processing 
3 
height, image width). Gabor filter defined as  
2 2( , ) [ ( , , , , )] [ ( , , , , )]R IE x y G x y G x yï³ ï¦ ï± ï³ ï¦ ï±ï€½ ï€«  (3) 
  Where ( , )E x y  is Gabor energy in window 
sizes w. ( , , , , )RG x y ï³ ï¦ ï±  is total real part energy. 
( , , , , )IG x y ï³ ï¦ ï±  is total imaginary part energy. 
The ( , , , , )IG x y ï³ ï¦ ï±  and ( , , , , )IG x y ï³ ï¦ ï±  defined 
as 
( , , , , ) [ ( , ) ( , )]
n n
R R
j n i n
G x y f x i y j G i jï³ ï¦ ï±
ï€½ï€­ ï€½ï€­
ï€½ ï€« ï€« ïƒ„ïƒ¥ ïƒ¥                      
( , , , , ) [ ( , ) ( , )]
n n
I I
j n i n
G x y f x i y j G i jï³ ï¦ ï±
ï€½ï€­ ï€½ï€­
ï€½ ï€« ï€« ïƒ„ïƒ¥ ïƒ¥  (4) 
  The optimal Gabor filter can separate 
optimal parameter design and Gabor filter. That 
chose optimal parameter for satisfactory texture 
and suitable detection. So optimal Gabor filter 
can solve segmentation/classification [8]. 
 
  The proposed algorithm has three parts: 
image preprocessing, training and detection. 
First grab image in this study and then want 
get suitable detection image. So, proceed 
preprocessing. When get standard image, if not 
have optimal parameter. The training can get 
optimal parameter. Then utilize optimal Gabor 
filter detect the flaw and output the result. 
The original image often is color image. That 
has huge information. Therefore processing time 
was time-consuming. So, we usually used gray 
scale. It can reduce image information. The gray 
scale defined as  
 
ï€¨ ï€© ï€¨ ï€© ï€¨ ï€©( , ) , ,,
3
r x y g x y b x y
f x y
ï€« ï€«ï€½ ,        (5) 
where ( , )f x y  is gray level in coordinates ( , )x y  
for the image, ( , )r x y  is red color information in 
coordinates ( , )x y  of image, ( , )g x y  is green 
color information in coordinates ( , )x y  of image, 
and ( , )b x y  is blue color information in 
coordinates ( , )x y . 
Grab-image has pepper because process of 
Grab-image has unknown factors. But pepper 
will infect inspection results. Therefore pepper 
must was reduced. The median filter was a 
nonlinear filter. It can reduce the pepper and it 
can not excessive aliasing for subject. Median 
filter defined as  
( , ) { ( - , ), ( , ) }g x y median f x k y l k l wï€½ ï€­ ïƒ      (6) 
 
In (6), ( , )g x y is median of gray level in mask 
w. w is mask sizes (2 1) (2 1)n nï€« ï‚´ ï€«  in 
coordinates ( , )x y  of image. n=1,2,â€¦,
min( , )M N . 
 
  If standard image was gotten and optimal 
parameter was chosen. After that can start 
inspection. Training used no flaw image and 
then parameter was selected by objective 
function was minimize average energy and 
minimize energy standard deviation. The 
objective function defined as 
min  
. .
       1
      0 180
, , , , 0
T T
s t
M
x y
ï­ ï³
ï¦
ï±
ï³ ï¦ ï±
ï€«
ï‚£ ï‚£
ï‚° ï‚£ ï‚£ ï‚°
ï‚³
                 (7)   
Where M is mask size. Tï­  is average Gabor 
energy of template image. Tï³  is energy 
standard deviation of template image. 
  The fabric image transform into Gabor energy. 
Flaw energy is usually higher than normal 
energy. So mask M Mï‚´  was selected in 
template image. This mask can relate fabric 
texture. Then parameters were selected by 
real-valued genetic (RGA) solve objective 
function. The parameters can make template 
transform Gabor energy and get minimize 
average energy and minimize energy standard 
deviation. 
 
åœ‹ç§‘æœƒè£œåŠ©å°ˆå®¶å­¸è€…å‡ºå¸­åœ‹éš›å­¸è¡“æœƒè­°å¿ƒå¾—å ±å‘Š 
                                     æ—¥æœŸï¼š100 ï¦ 7 æœˆ 31 æ—¥ 
 
ä¸€ã€ ï¥«åŠ æœƒè­°ç¶“é 
2011 ç¬¬ä¸ƒå±†åœ‹éš›è‡ªç„¶è¨ˆç®—æœƒè­° (2011The 7th International Conference on Natural 
Computation))æ˜¯ IEEE æ”¯æŒçš„é‡è¦åœ‹éš›æœƒè­°ï¼Œé¦–æ¬¡èˆ‰è¾¦æ™‚é–“ç‚º 2005ï¼Œæ­¤æ¬¡èˆ‡ç¬¬å…«å±†åœ‹éš›æ¨¡ç³Šç³»
çµ±èˆ‡çŸ¥ï§¼ç™¼æ˜(The 8th International Conference on Fuzzy Systems and Knowledge Discovery)å…±åŒ
åœ¨ä¸Šæµ·èˆ‰è¾¦ï¼Œæœƒè­°ï¥æ–‡é›†æ”¶ï¤¿æ–¼ IEEE Conference ç³»ï¦œï¼Œå¼•ç”¨æ–¼ EI Compendex and ISTP,åŠ IEEE 
Xplore (IEEE Conference Record Number for ICNCï¼‡11: 18082; IEEE Conference Record Number 
for FSKDï¼‡11: 18083;ICNC IEEE Catalog Number: CFP11CNC-PRT, ISBN: 978-1-4244-9951-9; 
FSKD Catalog Number: CFP11FSK-PRT, ISBN: 978-1-61284-178-6.)ã€‚è—‰ç”±æ­¤å…±èšä¸€å ‚çš„é›£å¾—æ©Ÿ
æœƒï¼Œå¯å½¼æ­¤äº¤æ›ç ”ç©¶å¿ƒå¾—èˆ‡æ•™å­¸ç¶“é©—ï¼Œä»¥åšç‚ºæœªï¤­å­¸è¡“ï§¤ï¥èˆ‡å¯¦å‹™ç®¡ï§¤ä¹‹ï¥«è€ƒã€‚å€‹äººï¥«åŠ æ­¤
æ¬¡æœƒè­°ï¼Œä¸€æ–¹é¢å¯é€²ä¸€æ­¥ç­è§£èˆ‡æŒæ¡æ–°çš„ç ”ç©¶è¶¨å‹¢ï¼Œå¦ä¸€æ–¹é¢äº¦å¯ä¼¸å±•ç¾©å®ˆå¤§å­¸ç ”ç©¶æ–¼åœ‹éš›
çš„èƒ½ï¨Šï¨ã€‚ 
ç”±æ–¼æœ€é è¿‘æœƒè­°æ‰€åœ¨åœ°é»ç”±é«˜é›„ç›´é£›çš„æ©Ÿå ´ç‚ºå¤§ï§“ä¸Šæµ·æµ¦æ±æ©Ÿå ´(Pudong Airport)ï¼Œç‚ºï¦º
ï¥«åŠ æ­¤æ¬¡æœƒè­°ï¼Œæˆ‘æ–¼ 7/23/2011 æ­ä¹˜è¯èˆªç”±é«˜é›„ç›´é£›ä¸Šæµ·æµ¦æ±æ©Ÿå ´ç­æ©Ÿï¼Œå›ç¨‹å³ä¾å»ç¨‹åå‘
æ­æ©Ÿè¿”å›é«˜é›„æ©Ÿå ´ã€‚å¤§ï§“ä¸Šæµ·èˆ‡å°ç£ç„¡æ™‚å·®ã€‚ 
ç¶œè§€æ­¤æ¬¡æœƒè­°ï¥æ–‡ä¸»é¡Œ, è¨ˆæœ‰ Neural Network Applications, Cognitive Computing and 
Cognitive Science, Natural Computation: Theory and Algorithms, Natural Computation 
Applications, ICNC Invited Sessions ç­‰ä¸»é¡Œ, ç™¼è¡¨å ´æ¬¡å‰‡åˆ†ç‚º Neural Networks: Theory and 
Algorithms, Neuro-Biological Systems, Cellular Neural Networks, Support Vector Machines and 
Statistical Neural Network Models, Principal and Independent Component Analysis, 
Self-Organizing Maps, Neurodynamics and Spiking Neurons, Other Theoretical Topics in Neural 
è£œåŠ©ç·¨è™Ÿ NSC 99-2221-E-214 -037 
è¨ˆç•«åç¨± ç¹”å“è‡ªå‹•åŒ–è¦–è¦ºæª¢é©—ç³»çµ±(III) 
å‡ºåœ‹äººå“¡
å§“å å³æ–‡è¨€ 
æœå‹™æ©Ÿæ§‹
åŠè·ç¨± ç¾©å®ˆå¤§å­¸å·¥æ¥­å·¥ç¨‹èˆ‡ç®¡ï§¤å­¸ç³»æ•™æˆ 
æœƒè­°æ™‚é–“ 
100 ï¦ 7 æœˆ 25 æ—¥
è‡³ 
100 ï¦ 7 æœˆ 29 æ—¥ 
æœƒè­°åœ°é» å¤§ï§“ä¸Šæµ· 
æœƒè­°åç¨± 
(ä¸­æ–‡)2011 ç¬¬ä¸ƒå±†åœ‹éš›è‡ªç„¶è¨ˆç®—æœƒè­° 
(è‹±æ–‡)2011 The 7th International Conference on Natural Computation 
ç™¼è¡¨ï¥æ–‡
é¡Œç›® 
(ä¸­æ–‡)ï§ç”¨å­—ï¤…æ¯”å°æ–¹æ³•æ–¼æ‰‹æŒè¾¨ï§¼ 
(è‹±æ–‡)A String Matching Method for Hand Recognition 
äºŒã€ èˆ‡æœƒå¿ƒå¾— 
ICNC 2011 èˆ‡ ICFSKD2011 å…±åŒèˆ‰è¾¦æ˜¯ IEEE æ”¯æŒæ¯ï¦èˆ‰è¾¦ä¸€æ¬¡çš„é‡è¦æœƒè­°ï¼Œè‡ª 2005 èµ·èˆ‰
è¾¦å„å¸å¼• 3,000 ç¯‡ï¥æ–‡æŠ•ç¨¿ï¼Œæœ¬æ¬¡æœƒè­°å³æœ‰å…± 527 ç¯‡ï¥æ–‡æ¥å—ç™¼è¡¨ï¼Œä¸¦é‚€è«‹ï§‘å€‹å°ˆé¡Œæ¼”è¬›ï¼Œå³
é¡¯å¾—æ­¤æœƒè­°å…¶é‡è¦æ€§ã€‚æ­¤æ¬¡æœƒè­°é™¤ä¸»è¾¦åœ‹å¤§ï§“æœ‰ç›¸ç•¶å¤šçš„ï¥æ–‡ç™¼è¡¨å¤–ï¼Œï¤­è‡ªå…¨çƒçš„ï¥æ–‡äº¦ç›¸ç•¶
å¤šã€‚è—‰ç”±ï¥«èˆ‡æ­¤æœƒè­°å¯ä»¥ç­è§£å…¨çƒé—œæ–¼è‡ªç„¶è¨ˆç®—ç ”ç©¶çš„æœ€æ–°ç™¼å±•è¶¨å‹¢ï¼Œäº¦å¯ä»¥ç”±æ­¤æ‰¾å°‹æ–°çš„ç ”
ç©¶æ–¹å‘èˆ‡é¡Œç›®ï¼Œå› æ­¤ç²ï¨—ï¥¼å¤šã€‚ 
 
ä¸‰ã€ è€ƒå¯Ÿï¥«è§€æ´»å‹•(ç„¡æ˜¯é …æ´»å‹•è€…ï¥­ï¥¶) 
  ç„¡ 
 
å››ã€ å»ºè­° 
       å¸Œæœ›èƒ½å¤šé¼“ï¥¿èˆ‡çåŠ©åœ‹å…§å­¸è€…èˆ‡å­¸ç”Ÿï¥«èˆ‡åœ‹éš›æœƒè­°ï¼Œä»¥é–‹å±•åœ‹éš›è¦–é‡ï¼Œä¸¦èƒ½æŒæ¡ä¸–ç•Œç™¼å±•è¶¨
å‹¢ã€‚åœ¨æ­¤æ¬¡ç ”è¨æœƒä¸­æœ‰è¨±å¤šï¤­è‡ªå°ç£çš„ï¥æ–‡ç™¼è¡¨ï¼Œå¯ï¨Šï¥«èˆ‡åœ‹éš›æ€§ç ”è¨æœƒé™¤ï¦ºå€‹åˆ¥å­¸è€…ï¥«èˆ‡å¤–ï¼Œ
ï¥´èƒ½å°æ–¼ä¸€äº›é‡è¦çš„ç ”è¨æœƒï¼Œæä¾›é¡å¤–çš„è³‡æºï¼Œä»¥æ•´åˆåœ‹å…§å­¸è€…é•·æœŸç©æ¥µï¥«èˆ‡ï¼Œç›¸ä¿¡å¯ä»¥å¾—åˆ°æ¯”
è¼ƒå…·é«”çš„å½±éŸ¿ï¦Šã€‚ 
 
äº”ã€ æ”œå›è³‡ï¦¾åç¨±åŠå…§å®¹ 
1. ICNC â€™11-FSKDâ€™11 å¤§æœƒæ‰‹å†Šï¼šè­°ç¨‹ç°¡ä»‹èˆ‡ç™¼è¡¨ï¥æ–‡å ´åœ° 
2. ICNC  2011 å…‰ç¢Ÿï¥æ–‡é›†ï¼šåŒ…å«æœ¬æ¬¡æœƒè­°æ‰€æœ‰ç™¼è¡¨ï¥æ–‡å…¨æ–‡é›»å­æª” 
3. ICNC  2011 ï¥æ–‡é›†ï¼šåŒ…å«æœ¬æ¬¡æœƒè­°æ‰€æœ‰ç™¼è¡¨ï¥æ–‡å…¨æ–‡ 
4. Call for papers: CAAI Transactions on Intelligent Systems 
5. CAAI Transactions on Intelligent Systems: No. 3, Vol. 6, 2011 
 
ï§‘ã€ å…¶ä»– 
ç„¡ 
 
The above method solves the linear string-to-string correction 
problem by finding the edit distance and its corresponding edit 
sequence. Here the problem is to find the edit distance Ä¯([s], [t]) 
as well as its corresponding edit sequence, where [s] and [t] are 
the cyclic strings of s and t, respectively. It becomes the cyclic 
string-to-string correction problem. We can assume that mÊ€n 
without losing the generality, and the strings s and t are the 
cyclic strings. Then the edit distance proposed by Maes [3] is 
Ä¯([s], [t])=min{Ä¯(s,Ä±j(t)): j=0, 1,â€¦, m-1},                        â€¦ (1) 
where Ä±j(t) is the string obtained from t after j cyclic shifts. 
  To calculate the edit distances, suppose that tt = 
t1t2â€¦tmt1t2â€¦tm is the string, which concatenates t with itself. 
We can first construct the edit graph H associated with s and tt 
(see Fig. 2). Then we can determine the edit distance Ä¯(s,Ä±j(t)) 
by finding the shortest path from v(0, j) to v(n, m+j), for j = 0, 
1, ..., m-1. The minimum edit distance can be found and its 
corresponding edit sequence can be identified. 
 
0 
1 
2 
3 
4 
5 
0 1 2 3 4 (0) 
t t 
s 
5(1) 6(2) 7(3) 8(4)
W1,3 
W2,4 
W3,0 
W4,1 
W5,2 
 
Figure 2. The edit graph H associated s and tt , the shortest path, and the edit 
sequence (e1: (s1Äºt3), e2: (s2Äºt4), e3: (s3ÄºÈœ), e4: (s4Äºt1), e5: (s5Äºt2)). 
B. Primitive feature extraction 
For the robustness of the recognition algorithm, it is 
desirable that the features should be translation-invariant, 
rotation-invariant, and scale-invariant. Since the dominant 
points on the object boundary are sufficient to represent the 
shape of an object, we will derive the primitive features by 
using the information on the dominant points 
The proposed recognition algorithm involves string 
matching. Thus the primitive features should not be too 
complex and the dimension of the features should be small. In 
here, a new feature, the normalized reciprocal of compactness 
is used as the feature in the string matching process. Since the 
features used in the recognition algorithm are TRS-invariant, 
the proposed recognition algorithm is independent of changing 
of the position, orientation, and scale. 
  Suppose that Pi is the i th point with the coordinate (xi, yi) 
on the boundary of the object. The dominant points on the 
boundary of the object can be detected and the detected 
dominant points are denoted as Vi's, for i = 1, 2, ..., M. 
Suppose that the centroid of the object is C(xc, yc), where xc 
and yc are defined as 
xc= Â¦ ixN
1
 and yc= Â¦ iyN
1
                              â€¦ (2) 
 The reason that we use the reciprocal of the compactness 
instead of the compactness is the same as that of the modified 
compactness. In such cases, the compactness isnâ€™t adequately 
defined. Suppose that ri is the i th reciprocal of the 
compactness, then ri is defined as  (see Fig. 3) 
ri= ai /pi2,                                                              â€¦ (3) 
where pi= CVCiViViV i 11   is the perimeter and ai 
is the area of the triangle. 
 
Figure 3. The reciprocal of compactness: five fingers and one palm 
C. Cyclic string matching using the reciprocal of 
compactness 
Suppose that I and R are the input shape and the reference 
shape, respectively. For convenience, the approximated 
polygons of the shapes are also denoted by I and R. 
Furthermore, let n and m be the numbers of vertices for I and 
R, respectively. Now, the reciprocal of the compactness is 
denoted as the symbol. The strings s = s1s2â€¦sn and t= t1t2â€¦tm 
represent the input shape and the reference shape, respectively. 
  Let X be the set that the elements are the reciprocal of the 
compactness, i.e., si or tj. It can be seen that the reciprocal of 
compactness and the vertices of polygons both are cyclic. The 
problem of matching two shapes is therefore identical to the 
cyclic string matching between strings s and t. Given an edit 
cost function Ä°, then we can construct the edit graph H 
associated with s and tt to find the shortest path. The paired 
symbols of I and R would be found by tracing the minimum 
cost edit sequence. Thus, the matching relation between the 
vertices of I and R can be determined. 
  Suppose that the two ordered sequences, BI = (I1, I2,â€¦, Ik) 
and BR=(R1, R2,â€¦, Rk), represent the matching results. It 
indicates that the Ij th vertex of I matches with the Rj th vertex 
of R (see Fig. 4). In Fig. 4, the shape I has 6 vertices (V1 to V6) 
and the shape R has 6 vertices (W1 to W6). In addition, Viâ€™ and 
Wiâ€™ indicate the vertices of the i th matched pair for two 
shapes. After cyclic string matching, 5 vertices of I are 
[9] W. H. Tsai, and S. S. Yu, â€œAttributed string matching with merging for 
shape recognition,â€ IEEE Trans. Pattern Analysis and Machine 
Intelligence, 7, 1985, pp. 453-462. 
[10] Y. T. Tsay, and W. H. Tsai, â€œModel-guided attributed string matching 
by split-and- merge for shape recognition,â€ International Journal of 
Pattern Recognition and Artificial Intelligence, 3, 1989, pp. 159-179  
[11] R. A. Wagner, and M. J. Fischer, â€œThe string-to-string correction 
problem,â€ J. ACM, 21, 1974, pp. 168-173. 
[12] W. Y. Wu, â€œTwo-dimensional object recognition through string 
matching,â€ Imaging Science Journal,  49, 2001, pp. 213-221 
[13] E. Yoruk, H. Dutagaci, and B.Sankur, â€œHand biometrics,â€ Image and 
Vision Computing, 24, 2006, pp. 483â€“497. 
 
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•«è¡ç”Ÿç ”ç™¼æˆæœæ¨å»£è³‡æ–™è¡¨
æ—¥æœŸ:2011/10/05
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•«
è¨ˆç•«åç¨±: ç¹”å“è‡ªå‹•åŒ–è¦–è¦ºæª¢é©—ç³»çµ±(III)
è¨ˆç•«ä¸»æŒäºº: å³æ–‡è¨€
è¨ˆç•«ç·¨è™Ÿ: 99-2221-E-214-037- å­¸é–€é ˜åŸŸ: ç”Ÿç”¢ç³»çµ±è¦åŠƒèˆ‡ç®¡åˆ¶
ç„¡ç ”ç™¼æˆæœæ¨å»£è³‡æ–™
å…¶ä»–æˆæœ 
(ç„¡æ³•ä»¥é‡åŒ–è¡¨é”ä¹‹æˆ
æœå¦‚è¾¦ç†å­¸è¡“æ´»å‹•ã€ç²
å¾—çé …ã€é‡è¦åœ‹éš›åˆ
ä½œã€ç ”ç©¶æˆæœåœ‹éš›å½±éŸ¿
åŠ›åŠå…¶ä»–å”åŠ©ç”¢æ¥­æŠ€
è¡“ç™¼å±•ä¹‹å…·é«”æ•ˆç›Šäº‹
é …ç­‰ï¼Œè«‹ä»¥æ–‡å­—æ•˜è¿°å¡«
åˆ—ã€‚) 
ç„¡ 
 æˆæœé …ç›® é‡åŒ– åç¨±æˆ–å…§å®¹æ€§è³ªç°¡è¿° 
æ¸¬é©—å·¥å…·(å«è³ªæ€§èˆ‡é‡æ€§) 0  
èª²ç¨‹/æ¨¡çµ„ 0  
é›»è…¦åŠç¶²è·¯ç³»çµ±æˆ–å·¥å…· 0  
æ•™æ 0  
èˆ‰è¾¦ä¹‹æ´»å‹•/ç«¶è³½ 0  
ç ”è¨æœƒ/å·¥ä½œåŠ 0  
é›»å­å ±ã€ç¶²ç«™ 0  
ç§‘ 
æ•™ 
è™• 
è¨ˆ 
ç•« 
åŠ  
å¡« 
é … 
ç›® è¨ˆç•«æˆæœæ¨å»£ä¹‹åƒèˆ‡ï¼ˆé–±è½ï¼‰äººæ•¸ 0  
 
