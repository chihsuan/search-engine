a given class may be changed in various 
classification applications. For example, the 
class â€™National Taiwan Universityâ€™ will have 
different training datasets when we are trying to 
classify the classes of â€™National Taiwan 
Universityâ€™ and â€™National Chiao Tung Universityâ€™, 
and the classes of â€™National Taiwan Universityâ€™ 
and â€™Veterans General Hospitalâ€™. This is because 
the former â€™National Taiwan Universityâ€™ stands for 
a â€™schoolâ€™ but the latter stands for 
a â€™hospital.â€™ 
 
In the first year, we plan to develop a Web-based 
unsupervised learning method, which doesnâ€™t require 
manually-labelled training data. The method acquires 
training data from the Web in an automatic way to 
deal with the three problems. Several experiments 
will be conducted on the reuters-21578 dataset to 
evaluate the performance of the proposed method. 
In the second year, we plan to apply the Web-based 
learning method to the application of search-result 
clustering. Combined with query log mining, the 
search-result clustering problem is converted to the 
unsupervised search-result classification problem. A 
real search-result clustering system will be 
developed to demonstrate our ideas. 
è‹±æ–‡é—œéµè©ï¼š Unsupervised Classification, Web Mining, Search-
result Clustering 
 
  
 
 
æ‘˜è¦: 
 
æœ¬ç ”ç©¶è¨ˆç•«ä»¥å…©å¹´ç‚ºæœŸ,æ—¨åœ¨ç™¼å±•ã€ŒåŸºæ–¼ç¶²è·¯ä¹‹éç›£ç£å¼åˆ†é¡æŠ€è¡“ã€åŠå…¶åœ¨ã€Œæœ å°‹çµæœåˆ†ç¾¤ã€ä¸Šçš„æ‡‰
ç”¨ã€‚ 
 
å‚³çµ±çš„åˆ†é¡æŠ€è¡“æ¡ç”¨ç›£ç£å¼å­¸ç¿’æ–¹å¼,éœ€è¦è¨“ç·´è³‡æ–™è¨“ç·´åˆ†é¡æ¨¡å‹,ä»¥é æ¸¬æœª çœ‹éè³‡æ–™çš„å¯èƒ½é¡åˆ¥,ç›¸
é—œçš„ç ”ç©¶å‡è¨­ã€Œæ¯å€‹é¡åˆ¥å·²æœ‰é©ç•¶æ¨™è¨˜å¥½çš„è¨“ç·´è³‡æ–™ã€,å¯ æ˜¯,åœ¨çœŸå¯¦çš„åˆ†é¡æ‡‰ç”¨ä¸Š,å»é¢è‡¨ä¸‰å€‹å•é¡Œ:(1)
ä»¥äººå·¥çš„æ–¹å¼å¤§é‡åœ°æ¨™è¨˜æ‰€æœ‰è¨“ç·´ è³‡æ–™é¡åˆ¥,æˆæœ¬é«˜ä¸”è²»æ™‚è²»åŠ›;(2)ä¸ä¸€å®šæ‰€æœ‰å¯¦éš›çš„åˆ†é¡æ‡‰ç”¨,éƒ½å¯
ä»¥å®¹æ˜“å–å¾—è¶³å¤ çš„è¨“ç·´è³‡æ–™,å¦‚:åˆ†é¡åƒåœ¾é›»å­éƒµä»¶;(3)éå»å·²æ¨™è¨˜å¥½é¡åˆ¥çš„è¨“ç·´è³‡æ–™ä¸ä¸€å®šä»ç„¶é©ç”¨æ–¼
æ–°çš„åˆ†é¡å•é¡Œ,å¦‚:åˆ†é¡ã€Œå°å¤§ã€å’Œã€Œæ¸…å¤§ã€ä¹‹è¨“ç·´è³‡æ–™ä¸åŒæ–¼åˆ†é¡ã€Œå°å¤§ã€å’Œã€Œæ¦®ç¸½ã€,å‰è€…ã€Œå°å¤§ã€
å±¬æ–¼ã€Œå­¸æ ¡ã€,å¾Œè€…å±¬æ–¼ã€Œé†«é™¢ã€ã€‚ 
 
æœ¬è¨ˆç•«ç¬¬ä¸€å¹´é æœŸå»ºç«‹ä¸€å€‹ã€ŒåŸºæ–¼ç¶²è·¯ä¹‹éç›£ç£å¼åˆ†é¡ã€æ©Ÿåˆ¶,ä¸éœ€ä»»ä½•äººå·¥ æ¨™è¨˜è³‡æ–™,æ¡ç”¨ç¶²è·¯æ¢å‹˜
æŠ€è¡“,è‡ªå‹•å¾ç¶²è·¯è’é›†è¨“ç·´è³‡æ–™,è² è²¬è§£æ±ºä¸Šè¿°ä¸‰å€‹å•é¡Œ, æ‰€ææ–¹æ³•å°‡åœ¨æ¨™æº–åˆ†é¡æ¸¬è©¦é›†(reuters-21578)
ä¸Šé€²è¡Œæ•ˆèƒ½è©•ä¼°ã€‚ 
 
æœ¬è¨ˆç•«ç¬¬äºŒå¹´å°‡æ‡‰ç”¨ç¬¬ä¸€å¹´çš„æˆæœæ–¼ã€Œæœå°‹çµæœåˆ†ç¾¤ã€ä¸Š,çµåˆæœå°‹å¼•æ“ä½¿ç”¨ è€…æŸ¥è©¢è¨˜éŒ„ä¹‹æ¢å‹˜æŠ€è¡“,
å°‡ã€Œæœå°‹çµæœåˆ†ç¾¤ã€çš„å•é¡Œè½‰è®Šæˆã€Œéç›£ç£å¼æœå°‹çµæœåˆ† é¡ã€å•é¡Œ,ä¸¦åŸºæ–¼æ­¤æŠ€è¡“é–‹ç™¼ä¸€ã€Œç¶²é æœå°‹
çµæœåˆ†ç¾¤ã€ç³»çµ±ã€‚ 
 
é—œéµå­—: éç›£ç£å¼åˆ†é¡ã€ç¶²è·¯æ¢å‹˜ã€è¨“ç·´è³‡æ–™è’é›† 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 1. Introduction 
Document classification has been extensively studied in the fields of data mining and 
machine learning. Conventionally, document classification is a supervised learning task [1, 2] 
in which adequately labeled documents should be given so that various classification models, 
i.e., classifiers, can be learned accordingly. However, such requirement for supervised text 
classification has its limitations in practice. First, the cost to manually label sufficient amount 
of training documents can be high. Secondly, the quality of labor works is suspicious, 
especially when one is unfamiliar with the topics of given classes. Thirdly, in certain 
applications, such as email spam filtering, prototypes for documents considered as spam 
might change over time, and the need to access the dynamic training corpora 
specifically-tailored for this kind of application emerges. Automatic methods for data 
acquisition, therefore, can be very important in real-world classification work and require 
further exploration. 
 
Previous works on automatic acquisition of training sets can be divided in two types. One of 
which focused on augmenting a small number of labeled training documents with a large pool 
of unlabeled documents. The key idea from these works is to train an initial classifier to label 
the unlabeled documents and uses the newly-labeled data to retrain the classifier iteratively. 
Although classifying unlabeled data is efficient, human effort is still involved in the 
beginning of the training process. 
 
The other type of work focused on collecting training data from the Web. As more data is 
being put on the Web every day, there is a great potential to exploit the Web and devise 
algorithms that automatically fetch effective training data for diverse topics. A major 
challenge for Web-based methods is the way to locate quality training data by sending 
effective queries, e.g., class names, to search engines. This type of works can be found in [3, 
4, 5, 6], which present an approach that assumes the search results initially returned from a 
class name are relevant to the class. Then the search results are treated as auto-labeled and 
additional associated terms with the class names are extracted from the labeled data. By 
sending the class names together with the associated terms, appropriate training documents 
can be retrieved automatically. Although generating queries is more convenient than 
manually collecting training data, the quality of the initial search results may not always be 
good especially when the given classes have multiple concepts. For example, the concepts of 
class â€œAppleâ€ include company and fruit. Such a problem can be observed widely in various 
applications. 
 
The goal of the project is, given a set of concept classes, to automatically acquire training 
corpus based merely on the names of the given classes. Similar to our previous attempts, we 
To carefully examine the possibility of querying search engines for acquiring training data, 
we did an evaluation with different search engines, search-result types (snippet or document), 
and the number of search results. 5 CS-related classes were taken into account, including 
â€œArchitectureâ€, â€œIRâ€, â€œNetworkâ€, â€œProgrammingâ€, and â€œTheoryâ€. Each class name ci was 
sent to 3 search engines, including Google
1
, Yahoo!
2
, and Live Search
3
. Top 100 snippets 
were extracted as training data. We also gathered the research papers from the corresponding 
conferences to the 5 classes as the testing documents. Table 1 shows the performance of 
different search engines. Querying by the class names can achieve classification accuracy at a 
range from 0.35 to 0.56. More specifically, the three search engines perform well in 
â€œProgrammingâ€ and â€œTheoryâ€ but poorly in the others on average. This arises from the fact 
that irrelevant documents may be located for those classes with ambiguous names. The way 
to query by the class names is not reliable due to the ambiguity of the class names (the first 
challenge). For example, the word â€œarchitectureâ€ is widely used in CS, art and construction. 
From the results, we select Google as our backend search engine in this project. 
 
We further explore if the classification performance can be improved by downloading Web 
pages for training. The result is shown in Table 2. It reveals that Web pages might introduce 
more noises than snippets do, while the snippets summarize Web pages and capture the 
concepts of classes C by their context. Moreover, to download Web pages is time-consuming. 
Our methods, therefore, only retrieve snippets as the training source. 
Table 1. Accuracy of different search engines for classification of CS papers. 
Engine Architecture IR Network Programming Theory Avg. 
Google 0.075 0.382 0.899 0.723 0.762 0.568 
Yahoo! 0.112 0.022 0.094 0.863 0.665 0.351 
Live Search 0.269 0.006 0.083 0.784 0.815 0.391 
 
Intuitively, collecting more snippets or documents might enhance the performance. Table 3 
shows the results of changing training data sizes from 100 to 900. It could be found that 
classification accuracy does not increase obviously when the numbers of snippets and 
documents reach 200 and 300, respectively. This is because much relevant information can 
be retrieved in top ranked search results returned by the search engine. Noises are 
unavoidably included from longer lists. Hence, simply fetching a large amount of snippets or 
documents from a single search result cannot achieve satisfactory performance. Even if we 
expand the queries, i.e., the class names, using pseudo-relevance feedback (PRF) [7, 8, 9], the 
improvement is still minor since the generated expanded keywords cannot effectively 
discriminate different classes (our second challenge). The performance comparison between 
our methods and PRF will be given in Section 4.2. 
 
                                               
1 The Google search engine: http://www.google.com/search 
2 The Yahoo! search engine: http://search.yahoo.com/search 
3 The MSN Live search engine: http://search.live.com/ 
DMOZ by each class name ci and get a set of the nodes relevant to ci in the DMOZ directory. 
Suppose the set of the nodes is N(ci). The least common ancestors (LCA) of all of the nodes 
N(ci) (i=1â€¦n) are viewed as the common concepts of C. The LCAs are the shared ancestors 
of N(ci) (i=1â€¦n) located farthest from the roots of the DMOZ directory. For example, by 
searching class â€œArchitectureâ€, we get the path â€œArts: Architectureâ€ and â€œComputers: 
Emulators: Intel x86 Architectureâ€. When search the class â€œProgrammingâ€, we find it has the 
same common concept of â€œComputersâ€ (from â€œComputers: Programmingâ€) with 
â€œArchitectureâ€. Thus the concept â€œComputersâ€ would be the common concepts between the 
two classes â€œArchitectureâ€ and â€œProgrammingâ€. 
 
Although Open Directory Project covers diverse topics and is very precise, sometimes we 
might get few or even no common concepts among C. The problem is serious for those 
classes not so popular such as names of person or organizations. For example, if we query the 
class â€œCornellâ€, we only get 5 paths for the class, which contains few candidates of concepts 
to select and expand. To deal with this problem, we extract terms co-occurring with each 
class ci in Web pages, cluster the terms, and treat the representative term for each class as one 
of the common concepts. More specifically, all of the classes {c1, c2, â€¦ , cn}ïƒC are 
combined into one query â€œc1 + c2 + â€¦ + cnâ€, and then submitted to a search engine. After 
stemming and removing stopwords, we extract 20 high-frequency terms as candidates for 
common concepts from top 100 snippets returned from the search engine. To group these 
candidates, we send them separately to the search engine and generate corresponding feature 
vectors based on their top 100 snippets. Uni- and bi-grams are adopted as feature terms and 
TF-IDF is used to calculate feature weights. Next, a graph G = (V, E) is constructed, where v
ïƒV represents one candidate term, and eïƒE is the cosine similarity between two feature 
vectors. Finally, we perform the star clustering algorithm [10] to choose the star centers, 
which are the common concepts among C. 
 
In this project, we adopt both of LCAs from DMOZ and co-occurring terms from Web pages 
as our common concepts among C. After common concepts generated, we can either use it to 
sample the Web and acquire good training data, or utilize them while discriminative concepts 
are generating. 
 
3.2 Expansion by Discriminative Concepts 
A discriminative concept is a concept that can help distinguish one certain concept class of 
interest (say, c) from all the classes (c'â‰ c). Such a concept contributes more relevance to one 
specific class than to the others. Unlike common concepts, which are shared by all the 
concept classes in C, any discriminative concept has a specific concept class to contribute 
relevance to, called the host. Let fc be the feature vector of concept class c. Let the similarity 
between any two concepts x and y be denoted asÏƒ x,y = cos(fx, fy). An ideal discriminative 
concept k for concept c must satisfy all the following constraints: 
 
1. Concept k should exhibit high similarity to its host c. 
 This procedure can be repeated several times for each class so that the total number of 
discovered training instances can reach our expectation. However, certain changes on 
definitions and notations required by the adaptation needs to be clarified in advance. First, we 
can no longer expect that the feature vector for a concept class c remains the same throughout 
multiple iterations. In each iteration, when new training instances added to the collection, 
feature vectors for c actually changes. Next, the set of discriminative concepts ğœ…ğ‘  discovered 
in each iteration would vary, as similarity measure suffers from the change as well. Certain 
modification in definitions should be taken care of so as to seamlessly fit the aforementioned 
criteria into the framework, while treating notations for a concept and for a concept class 
differently might clutter up the framework. For simplicity, no explicit treatment will be done 
to the equations in the following text. Readers should take caution that, when 
class-to-concept or class-to-class similarity computation is considered in discussions, the 
feature vector referred to a concept class is in fact derived from its current training set (rather 
than SRc). On the other hand, we will use ğœ…ğ‘
(i)
 in place of plain ğœ…ğ‘  in the rest of the work. 
 
Assume that the algorithm repeats t times. The initial training data for concept class c is 
denoted as Dc
(0)
, and in each iteration iïƒ [1,t], a new training set for c is produced and 
represented by Dc
(i)
. Consider a simple framework as follows. For all cïƒC, we have: 
Dc
 0 = SRc                                                  
Dc
(i) = Dc
(i) âˆªkâˆˆÎºc (i) SRcâˆªk , i > 0 
where Dc
(i)
 and ğœ…ğ‘
(i)
 is the set of training instances and the set of discovered discriminative 
concepts, respectively, for concept class c at iteration i. Eventually, the algorithm stops after 
the t-th iteration. The content of Dc
(t)
 will serve as the final training data for all concept class 
c. 
 
Since practically it is infeasible to populate the entire set of Îºc , several heuristics are 
involved in creation of the set: 1) We look for terms with high discrimination power 
(specifically, unigram and bigrams) in the context of D
(i-1)
 using commonly-used 
information-theoretic measures, such as information gain and inverse document-frequency. 
These candidates are then examined with the decision criteria and disqualified ones are 
discarded immediately; 2) candidates that survived the test are ranked accordingly by the 
score function, which is a simple rewrite of the criteria that indicates the average degree of 
deviation for the candidate k: 
1
 c âˆ’ 1
  
Ïƒc,k
Ïƒc â€²,k
âˆ’ Î´(1 âˆ’ Ïƒc,c â€²) 
c â€²â‰ c
 
The summands will not cancel out since the score is calculated for the candidates satisfying 
the criteria. Generally, testing all the candidate terms may result in an extremely inefficient 
procedure. In practice, we set up a strict threshold on the information gain and idf in light of 
reducing the number of candidates. We test only the top m concepts selected by the filter in 
the end. The value m is set to be 15 throughout the work. 
 
 
4.2 Text Classification 
Table 5 compares the classification accuracy between different methods. For each class, the 
baseline method is to use only the class name as query, submit to the search engine, and 
collect snippets as training data. The method from query expansion (QE) is to use 
pseudo-relevance feedback (PRF) for each class, where the terms with high TF-IDF values in 
the snippets are selected as expansion terms which used for acquiring training data. LC is the 
method implemented based on LiveClassifier [3]. With the concept hierarchy of each class, 
all the concepts are used to combine with the class name as a query, then submit to the search 
engine and collect the snippets as training data. 
 
From Table 5, we find that merely sending class names as queries cannot retrieve quality 
training data. It only achieves the accuracy at 0.57 on average. Even if we expand the class 
names with PRF (the method of QE), the accuracy cannot be improved by QE in this case. 
This is because PRF is a general solution to the keyword mismatching problem and thus 
would not be well applied to our classification problem. LC manually labels some concepts 
of the class names, e.g., the concept of â€œArchitectureâ€ is about computer architecture, so that 
more relevant training data to original classes can be fetched. LC gets higher accuracy at 
about 0.71. But such concepts labeled by people are often few. Our CM method can discover 
more useful common concepts, as shown in Table 6, where keywords â€œcomputersâ€, 
â€œconferenceâ€, and â€œproceedingâ€ are all helpful in searching relevant data for each class when 
combined with original class name. CM, on the other hand, might introduce noisy keywords 
often co-occurring with the class names such as keyword â€œwebâ€. Due to the assistance of 
more common concepts, we collect more quality training data by CM. The accuracy for CM 
comes to 0.76, which is much better than LC and QE. 
 
In addition, we observe that the performance for class â€œNetworkâ€ is originally high in 
baseline method. To realize what makes the result, we check the process for getting training 
data in advance. Except for the accurate semantic for the term â€œNetworkâ€, we discover that 
the snippets from search engine are suitable and with good quality for the class â€œNetworkâ€. 
This is related to the characteristic of the Web. To our experience, the documents ranked from 
search engines might be mostly relevant to the fields about computer or network. 
 
The results of Web pages classifications, as shown in Table 7, are similar to previous 
experimental results except the average accuracy obtained here is lower in general due to the 
noisy Web pages that are unreliable for testing. Moreover, sometimes the concepts derived 
from the Web are not effective in classification (even they are correct). For example, from the 
Web, DM learns two discriminative concepts of â€œutâ€ and â€œmilwaukeeâ€ for classes â€œTexasâ€ 
and â€œWisconsinâ€, respectively. But their impacts on classifying our testing data are futile. 
Although there are some noises in the Web page dataset and the concepts found are correct 
but less useful, CM+DM does an improvement while training by the snippets from these 
concepts, and surpasses the performance of LiveClassifier (LC). By our methods, the quality 
training data are fetched and the classifier learns better, thus become more robust for text 
classification. 
Both datasets are divided into training and testing data. We combine the training data 
collected from the Web and sample Î±  % of the training data as a new training corpus. For 
comparison, we also train a classifier with just those Î±  % of the labeled data only. The Î±  
value varies from 1 to 100. Î±  =100 means to use all the labeled data from original divided 
training set, thus become a supervised learning. 5-fold cross validation is used to evaluate the 
classification accuracy. 
 
Figure 1 and 2 show the two experimental results, respectively. We find that the Web corpus 
improves the classifierâ€™s accuracy more than 6% when Î± is small for both datasets. In other 
words, when the labeled data is insufficient or even with no quality, sampling training data 
from the Web could substantially complements the manually-labeled data. The performance 
of both classifiers increases when more labeled data are included. However, when more and 
more manually-labeled data is given, the improvement by the Web becomes less obvious or 
even slightly worse. This is because once we add more data from the Web, we also introduce 
the noises such that the accuracy glows slowly when the quality documents are enough. In CS 
papers classification, the performance reaches as higher as all training data used when 50% 
labeled data is added. For Web pages classification, we have the same performance as 
supervised learning when only use 20% labeled data. The performance even exceeds the 
result from supervised learning when 40% labeled data is joined. It explains more quality 
data from the Web is helpful in classification. This result also shows that using all the labeled 
data is not always as good as expected because some of the labeled data are not in good 
quality. 
  
Fig. 1. Accuracy of training data from the Web plus % 
labeled data for CS papers classification. 
Fig. 2. Accuracy of training data from the Web plus % 
labeled data for Web pages classification. 
This experiment shows us that the training data from the Web does help to improve the text 
classification. Moreover, we could use a very few number of labeled data, plus the Web 
corpus our methods collect, to train a desirable classifier. The Web helps the classifiers to 
learn the unseen concepts which do not exist due to the insufficiency or the unreliable quality 
of labeled data. It also tells us that the suitable training data might change by time, thus the 
original labeled data performs worse in new classification tasks. From the result, we believe 
that our methods can benefit the task of text classification, and other advanced applications. 
 
80
82
84
86
88
90
92
94
96
98
100
1% 3% 5% 7% 9% 20% 40% 60% 80% 100%
web+labeled pure labeled Î±=100
55
60
65
70
75
80
85
90
1% 3% 5% 7% 9% 20% 40% 60% 80% 100%
web+labeled pure labeled Î±=100
quality training data from the Web. Without labeled data and associated terms given by 
human, our methods perform well and classify documents accurately for the text 
classification problem. 
 
6. Discussions and Conclusions 
In this project, we propose two methods to automatically sample the Web and find quality 
training data for text classification. We first examine the effects of different search engines, 
retrieved data types, and sizes of retrieved data. Moreover, from the subset of documents and 
the method by associated terms, we know that sampling the Web for concepts of classes and 
fetching training data can substantially improve the performance of classification. It might be 
hard to distinguish the classes with the ambiguity and close relationship without labeled data. 
By the discovering of common concepts and discriminative concepts, the ambiguity of class 
names is eliminated and more relevant concepts are utilized for sampling suitable and quality 
training data from the Web. Several experiments conducted in this work show that our 
methods are useful and robust for classifying documents and Web pages. Furthermore, our 
experiments show that the training data sampled from the Web helps the conventional 
supervised classification, which need quality and labeled data. The result demonstrates that 
the quality of labeled data might not always desirable due to the lack of useful key concepts, 
and we can provide proper training data from the Web to further improve the results of text 
classification. In additions, two dataset with different characteristics are used for our 
experiments and the analysis from different dataset is carefully conducted in this project. 
Compared to previous works, the advantage of our methods is the fully automatic processes 
during the concepts expansion and the training data collecting. Our methods are independent 
of classification models, thus existing models can be incorporated with the proposed 
methods. 
 
However, our work has some limitations. The classes we choose are related to each other. In 
other words, the performance would be better while the classes are in the same level in the 
hierarchy of topic classes. With the relationships between the classes, our methods can 
perform the context-aware technique among the classes to acquire more relevant documents, 
making the classifiers robust. To go a step further, there are more challenges to choose the 
quality documents in the training corpus sampled from the Web. We can also sample good 
training documents while a pool of unlabeled data is provided. We believe that these 
challenges are worth studied and would be the research directions in our future work. 
References 
[1] Y. Yang and X. Liu, â€œA re-examination of text categorization methods,â€ in Proceedings of the 22nd 
Annual International ACM SIGIR conference, 1999, pp. 42â€“49. 
[2] Y. Yang, â€œAn evaluation of statistical approaches to text categorization,â€ Information Retrieval, 
vol. 1, pp. 69â€“90, 1999. 
[3] C.-C. Huang, S.-L. Chuang, and L.-F. Chien, â€œLiveclassifier: Creating hierarchical text classifier 
through web corpora,â€ in World Wide Web Conference, 2004. 
  
  
3. è«‹ä¾å­¸è¡“æˆå°±ã€æŠ€è¡“å‰µæ–°ã€ç¤¾æœƒå½±éŸ¿ç­‰æ–¹é¢ï¼Œè©•ä¼°ç ”ç©¶æˆæœä¹‹å­¸è¡“æˆ–æ‡‰ç”¨åƒ¹
å€¼ï¼ˆç°¡è¦æ•˜è¿°æˆæœæ‰€ä»£è¡¨ä¹‹æ„ç¾©ã€åƒ¹å€¼ã€å½±éŸ¿æˆ–é€²ä¸€æ­¥ç™¼å±•ä¹‹å¯èƒ½æ€§ï¼‰ï¼ˆä»¥
500å­—ç‚ºé™ï¼‰ 
 
å‚³çµ±çš„åˆ†ï§æŠ€è¡“æ¡ç”¨ç›£ç£å¼å­¸ç¿’æ–¹å¼ï¼Œåœ¨çœŸå¯¦çš„åˆ†ï§æ‡‰ç”¨ä¸Šï¼Œä»¥äººå·¥çš„æ–¹å¼å¤§ï¥¾åœ°æ¨™è¨˜
æ‰€æœ‰è¨“ï¦–è³‡ï¦¾ï§åˆ¥ï¼Œæˆæœ¬é«˜ä¸”è²»æ™‚è²»ï¦Šã€‚æœ¬è¨ˆç•«åˆ©ç”¨æ¡ç”¨ç¶²ï¤·æ¢å‹˜æŠ€è¡“ï¼Œè‡ªå‹•å¾ç¶²ï¤·è’é›†è¨“
ï¦–è³‡ï¦¾ï¼Œï¥§éœ€ä»»ä½•äººå·¥æ¨™è¨˜è³‡ï¦¾ï¼Œè‡ªå‹•å»ºï§·ä¸€å€‹ã€ŒåŸºæ–¼ç¶²ï¤·ä¹‹éç›£ç£å¼æ–‡ä»¶åˆ†ï§ã€æ©Ÿåˆ¶ï¼Œä¸¦
æ¢è¨å¦‚ä½•çµåˆå°‘æ•¸äººå·¥æ¨™è¨˜çš„è³‡ï¦¾ï¼Œå¢åŠ åˆ†ï§æ•ˆèƒ½çš„æº–ç¢ºåº¦ã€‚è¨ˆç•«æˆæœé©ç”¨æ–¼è¨±å¤šå¯¦éš›çš„åˆ†
ï§æ‡‰ç”¨ï¼Œä¾‹å¦‚ï¼šå”åŠ©æœå°‹å¼•æ“å–å¾—è¶³å¤ çš„è¨“ï¦–è³‡ï¦¾, é€²è¡Œç¶²é æœå°‹çµæœçš„è‡ªå‹•åˆ†ï§ã€‚ 
éƒ¨ä»½ç›¸é—œç ”ç©¶æˆæœå·²ç™¼è¡¨æ–¼è³‡è¨Šæª¢ç´¢ï¦´åŸŸ(CIKM)ä¹‹ä»£è¡¨æ€§åœ‹éš›æœƒè­°åŠ(ROCLING)åœ‹å…§
æœƒè­°ï¼ŒåŠæ•¸ä½åœ–æ›¸ï¨¬ï¦´åŸŸ(IJDLS)ç›¸é—œçš„åœ‹éš›æœŸåˆŠã€‚ 
å·²ç™¼è¡¨ä¹‹ç›¸é—œè«–æ–‡å¦‚ä¸‹ï¼š 
 
Ting-Chu Lin and Pu-Jen Cheng. Query Sampling for Learning Data Fusion. In Proc. of ACM 
International Conference on Information and Knowledge Management (CIKM), 2011. 
(Acceptance rate: 15%) 
Wei-Yen Day, Chun-Yi Chi, Ruey-Cheng Chen, and Pu-Jen Cheng. Sampling the Web as 
Training Data for Text Classification. International Journal of Digital Library Systems (IJDLS), 
1:4, 2010. 
Jen-Wei Kuo, Pu-Jen Cheng, and Hsin-Min Wang. Learning to Rank from Bayesian Decision 
Inference. In Proc. of ACM International Conference on Information and Knowledge 
Management (CIKM), 2009. (Acceptance rate: 14.5%) 
Wei-Yen Day, Chun-Yi Chi, Ruey-Cheng Chen, Pu-Jen Cheng, and Pei-Sen Liu. Web Mining 
for Unsupervised Classification. In Proc. of Conference on Computational Linguistics and 
Speech Processing (ROCLING), 2009. 
 
ç„¡ç ”ç™¼æˆæœæ¨å»£è³‡æ–™ 
å…¶ä»–æˆæœ 
(ç„¡æ³•ä»¥é‡åŒ–è¡¨é”ä¹‹æˆ
æœå¦‚è¾¦ç†å­¸è¡“æ´»å‹•ã€ç²
å¾—çé …ã€é‡è¦åœ‹éš›åˆ
ä½œã€ç ”ç©¶æˆæœåœ‹éš›å½±éŸ¿
åŠ›åŠå…¶ä»–å”åŠ©ç”¢æ¥­æŠ€
è¡“ç™¼å±•ä¹‹å…·é«”æ•ˆç›Šäº‹
é …ç­‰ï¼Œè«‹ä»¥æ–‡å­—æ•˜è¿°å¡«
åˆ—ã€‚) 
å…©ç¯‡ CIKM è«–æ–‡, CIKM ç‚ºè³‡è¨Šæª¢ç´¢é ˜åŸŸéå¸¸å…·æœ‰ä»£è¡¨æ€§çš„åœ‹éš›æœƒè­°, å¹³å‡æ¥å—
ç‡åƒ…æœ‰ 15% 
 
 æˆæœé …ç›® é‡åŒ– åç¨±æˆ–å…§å®¹æ€§è³ªç°¡è¿° 
æ¸¬é©—å·¥å…·(å«è³ªæ€§èˆ‡é‡æ€§) 0  
èª²ç¨‹/æ¨¡çµ„ 0  
é›»è…¦åŠç¶²è·¯ç³»çµ±æˆ–å·¥å…· 0  
æ•™æ 0  
èˆ‰è¾¦ä¹‹æ´»å‹•/ç«¶è³½ 0  
ç ”è¨æœƒ/å·¥ä½œåŠ 0  
é›»å­å ±ã€ç¶²ç«™ 0  
ç§‘ 
æ•™ 
è™• 
è¨ˆ 
ç•« 
åŠ  
å¡« 
é … 
ç›® è¨ˆç•«æˆæœæ¨å»£ä¹‹åƒèˆ‡ï¼ˆé–±è½ï¼‰äººæ•¸ 0  
 
