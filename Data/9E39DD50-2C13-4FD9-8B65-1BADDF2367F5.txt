I 
æ‘˜ è¦ 
 
æ ¹æ“šè‘—åçš„ XML æ‡‰ç”¨è»Ÿé«”å•† Sarvega å…¬å¸çš„èª¿æŸ¥ï¼ŒXML è³‡æ–™çš„æµé‡æ–¼ 2004 å¹´è¶…è¶Šäº† Email çš„æµé‡ï¼Œ
ä¸”å°‡æ–¼ 2007 å¹´è¶…è¶Š Web æµé‡ï¼Œé€™æ˜¯éå¸¸é‡è¦çš„ç™¼å±•è¶¨å‹¢ï¼Œæˆ‘å€‘å‘¨åœå°‡å……æ–¥è‘—è¨±å¤š XMLæ–‡ä»¶èˆ‡è³‡æ–™ï¼Œ
å¤§é‡çš„ XML è³‡æ–™å°‡é€éç¶²è·¯æˆ–å…¶ä»–å‚³è¼¸åª’ä»‹åœ¨ä¸–ç•Œå„åœ°é€²è¡Œäº¤æµèˆ‡è½‰æ›ï¼›XSLT æ¨™æº–è½‰æ›èªè¨€ï¼ˆW3C
æ‰€åˆ¶è¨‚ï¼‰ä¸»è¦ç”¨ä¾†æ“·å–ã€é‡çµ„æˆ–è½‰æ› XML è³‡æ–™ï¼Œå› æ­¤ï¼Œå¦‚ä½•å¿«é€Ÿä¸”æ­£ç¢ºçš„åŸ·è¡Œ XSLT è½‰æ›ï¼Œæ»¿è¶³æœª
ä¾†çš„éœ€æ±‚æ˜¯æˆ‘å€‘å¿…é ‡é¢å°çš„æŒ‘æˆ°ã€‚å¦ä¸€æ–¹é¢ï¼Œåœ¨ç¡¬é«”è£½ç¨‹æŠ€è¡“å°šæœªæœ‰é—œéµæ€§çªç ´ä¹‹å‰ï¼Œå¤šåŸ·è¡Œç·’
ï¼ˆmultithreadï¼‰å¤šæ ¸å¿ƒï¼ˆmulticoreï¼‰è™•ç†å™¨ç³»çµ±ç¬¦åˆä½¿ç”¨è€…é«˜æ•ˆèƒ½ä¸”ä½è€—èƒ½çš„éœ€æ±‚ï¼Œä¹Ÿæ˜¯ç›®å‰æ™¶ç‰‡è¨­
è¨ˆçš„ä¸»æµã€‚å¤šæ ¸å¿ƒè™•ç†å™¨ç³»çµ±æ–¼ç¡¬é«”éƒ¨åˆ†çš„æ”¯æ´ï¼Œå·²é€æ¼¸è¶¨æ–¼æˆç†Ÿéšæ®µï¼Œä½†æ˜¯åœ¨è»Ÿé«”éƒ¨åˆ†ï¼Œä»ç„¶é‚„æ²’
æœ‰æº–å‚™å¥½ã€‚é™¤äº†ç ”ç™¼å¤šæ ¸å¿ƒç¨‹å¼çš„è»Ÿé«”é–‹ç™¼å·¥å…·ä¹‹å¤–ï¼Œå“ªäº›æ‡‰ç”¨ç¨‹å¼éœ€è¦å¤šæ ¸å¿ƒè™•ç†å™¨ï¼Œä¸€ç›´æ˜¯è»Ÿç¡¬
é«”å» å•†æƒ³çŸ¥é“çš„å•é¡Œï¼Œä¹Ÿæ˜¯å¤šæ ¸å¿ƒç¡¬é«”ç³»çµ±æ˜¯å¦èƒ½è¢«å¤§å®¶æ‰€æ¥å—çš„é—œéµã€‚æ ¹æ“šæˆ‘å€‘çš„åˆ†æèˆ‡è©•ä¼°ï¼Œ
XSLT çš„è½‰æ›æ˜¯æ¡ç”¨ä¸åŒçš„æ¨£ç‰ˆå¥—ç”¨åˆ° XML source tree ä¸­ä¸åŒçš„ tree node çš„é›†åˆï¼Œæ¯å€‹æ¨£ç‰ˆçš„åŸ·è¡Œå…·
æœ‰å¾ˆé«˜çš„ç¨ç«‹æ€§ï¼Œéå¸¸é©åˆåœ¨å¤šåŸ·è¡Œç·’å¤šæ ¸å¿ƒè™•ç†å™¨ç³»çµ±ä¸‹åŸ·è¡Œï¼Œç™¼æ®å¤šæ ¸å¿ƒè™•ç†å™¨ç³»çµ±çš„æ•ˆèƒ½ã€‚ 
 
æœ¬ç ”ç©¶è¨ˆç•«ä¹‹è¨ˆç•«åç¨±ç‚ºâ€XSLT optimizer for multicore architectureâ€ï¼Œç ”ç™¼ XSLT analyzer èˆ‡ XSLT 
optimizerã€‚ç ”ç©¶ç›®çš„ç‚ºä½¿ç”¨ç¨‹å¼åˆ†æèˆ‡ç·¨è­¯å™¨æœ€ä½³åŒ–çš„æŠ€è¡“ï¼Œå°‡ XSLT ç·¨è­¯ç‚ºå¤šåŸ·è¡Œç·’å¤šæ ¸å¿ƒä¹‹ C ç¨‹
å¼ï¼Œé€™ç¨®æ–¹å¼å¯ä»¥åŠ é€ŸåŸå…ˆä½¿ç”¨ç›´è­¯æ–¹å¼çš„åŸ·è¡Œæ•ˆèƒ½ï¼Œæˆ‘å€‘åŒæ™‚ä¹Ÿå°‡åˆ©ç”¨å¤šæ ¸å¿ƒè™•ç†å™¨çš„ç¡¬é«”è³‡æºï¼Œ
ç›¡é‡åŒæ™‚åŸ·è¡Œå¯å¹³è¡ŒåŸ·è¡Œçš„ XSLT operationsï¼Œå‰µé€ å¤šæ ¸å¿ƒè™•ç†å™¨ç³»çµ±çš„ä½¿ç”¨åƒ¹å€¼ã€‚Figure Ié¡¯ç¤º XSLT
ç·¨è­¯å™¨çš„åŸºæœ¬æ¶æ§‹ï¼ŒTable I åˆ—å‡ºæœ¬è¨ˆç•«æ–¼å„å¹´åº¦ä¹‹å·¥ä½œé …ç›®èˆ‡ç”¢å‡ºã€‚æœ¬è¨ˆç•«çš„ç ”ç©¶æˆæœèˆ‡ç›¸é—œä¹‹æŠ€
è¡“ï¼Œå°‡å¯é©æ™‚çš„æä¾›è™•ç†å¤§é‡ XML è³‡æ–™è½‰æ›é€Ÿåº¦éæ…¢å•é¡Œçš„è§£æ±ºæ–¹æ³•ï¼ŒåŒæ™‚ä¹Ÿå°‡é©—è­‰é€™é¡çš„æ‡‰ç”¨å¾ˆ
é©åˆåœ¨å¤šæ ¸å¿ƒè™•ç†å™¨ç³»çµ±ä¸‹åŸ·è¡Œï¼Œåœ¨å­¸è¡“ä¸Šï¼Œæœ‰é‡è¦çš„ç ”ç©¶åƒ¹å€¼ï¼›åœ¨ç”¢æ¥­ç•Œæˆ–æ—¥å¸¸ç”Ÿæ´»ä¸Šï¼Œè®“åœ‹å…§ä¸­
å°ä¼æ¥­èƒ½åœ¨æœ‰é™çš„é›»è…¦è³‡æºä¸‹ï¼Œå¿«é€Ÿè™•ç† XML çš„è³‡æ–™ï¼Œæå‡å…¶ç«¶çˆ­åŠ›ï¼Œå°ç”¢æ¥­ç•Œä¹Ÿæœ‰éå¸¸é‡è¦çš„å¹«
åŠ©ã€‚ 
 
 
é—œéµè©ï¼šXMLã€XSLTã€ç·¨è­¯å™¨ã€å¤šæ ¸å¿ƒï¼ˆmulticoreï¼‰ã€å¤šåŸ·è¡Œç·’ï¼ˆmultithreadï¼‰ 
 
III 
 
Abstract 
 
According to the report from Sarvega, a leading corporation in the area of XML applications, XML traffic 
already exceeds all mail traffic in 2004 and expects to exceed all web traffic in 2007. Every minute and 
every moment, massive XML data files are created, transferred, exchanged, extracted, and re-organized 
through by network or other transfer-medias. XSLT, a standard XML transformation language defined by 
W3C, is used to extract, re-organize and transfer XML data files. Therefore, how we can use XSLT to 
transfer these massive XML data files quickly is a very critical problem we cannot avoid. Besides, the trend 
of processor design is going to multithreaded / multicore architecture to meet the requirement of high 
performance and low power. In this part, many industry companies and research groups work hard on not 
only exploitation of software development tools, but also the application of multicore architecture. 
According to our analysis and evaluation, XSLT transformation use different template to match the 
corresponding nodes in the XML source tree, and each template is isolated in most cases. Consequently, 
XSLT transformation is very suitable to execute under multicore architecture for exploit the performance. 
 
The title of this research project is â€œXSLT optimizer for multicore architectureâ€. In this project, we will 
develop an XSLT analyzer and XSLT optimizer. The main objective of this project is to compile XSLT file 
into multithreaded / multicore C program by leverage the technologies of program analyses and compiler 
optimizations. Figure I shows the structure of XSLT compiler and Table I lists the working items at each year. 
From the view of point of performance, the compiled program has a better performance than interpreted 
program. In addition to compile technology, our approach will also try to execute XSLT operations in 
parallel to explore the hardware resources of multicore processor. Accordingly, the research results and 
technologies developed in this project will provide a solution of handling massive XML data files, and prove 
XSLT translation can fit the application of multicore architecture. To sum up, on one hand, this research 
project contributes a very important research value. One the other hand, the result from this project will help 
the industry to advance their capability of processing massive XML data files under limited resources, and 
improve their competition power. 
 
 
Keywordsï¼šXMLã€XSLTã€Compilerã€multicoreã€multithread 
 
V 
 
ç›® éŒ„ 
 
 
æ‘˜ è¦ .................................................................................................................................................................................... 2 
Abstract ................................................................................................................................................................................. 4 
ç›® éŒ„ .................................................................................................................................................................................... 6 
åœ– ç›® éŒ„ .............................................................................................................................................................................. 7 
ä¸€ã€ å‰è¨€ ......................................................................................................................................................................... 8 
äºŒã€ ç ”ç©¶èƒŒæ™¯ ................................................................................................................................................................. 9 
ä¸‰ã€ ç ”ç©¶æ–¹æ³• ............................................................................................................................................................... 12 
å››ã€ çµæœèˆ‡è¨è«– ........................................................................................................................................................... 21 
äº”ã€ çµè«– ....................................................................................................................................................................... 25 
å…­ã€ åƒè€ƒæ–‡ç» ............................................................................................................................................................... 26 
ä¸ƒã€ é™„éŒ„ ....................................................................................................................................................................... 29 
 
2 
 
 
ä¸€ã€ å‰è¨€ 
 
è¿‘å¹´ä¾†ç¶²éš›ç¶²è·¯å°è³‡æ–™å„²å­˜ã€è³‡æ–™äº¤æ›ã€è³‡è¨Šå‚³è¼¸ç­‰æ–¹é¢çš„éœ€æ±‚å¿«é€Ÿå¢åŠ ï¼Œå› æ­¤ W3C åˆ¶å®š XML
æ¨™æº–ç”¨ä¾†æè¿°è³‡æ–™å…§å®¹èˆ‡æ ¼å¼ï¼Œç¶“éå¤šå¹´çš„æ¨å»£ï¼ŒXMLå·²æˆç‚ºæè¿°è³‡æ–™çš„æ¨™æº–èªè¨€ï¼Œä¸¦ä¸”å»£æ³›åœ°æ‡‰ç”¨
åœ¨ä¸åŒç³»çµ±ä¹‹é–“çš„è³‡æ–™äº¤æ›;åŒæ¨£ç”± W3C åˆ¶å®šçš„ XSLTï¼ŒåŠŸèƒ½æ˜¯ç”¨ä¾†æè¿°å¦‚ä½•å°‡ XMLæ–‡ä»¶è½‰æ›æˆå…¶ä»–
è³‡æ–™æ ¼å¼ï¼Œåœ¨XSLTè½‰æ›çš„éç¨‹ä¸­ï¼ŒXSLT processoråŒæ™‚è®€å…¥XMLæ–‡ä»¶èˆ‡XSLT stylesheetï¼Œä¾æ“š stylesheet
çš„ç¯„æœ¬è¦å‰‡å°‡ XML æ–‡ä»¶è½‰æ›è¼¸å‡ºæˆ‘å€‘æ‰€éœ€è¦çš„è³‡æ–™æ ¼å¼ã€‚XSLT å¸¸è¦‹çš„æ‡‰ç”¨æ˜¯å°‡ XML è½‰æ›ç‚ºé©åˆåœ¨
æ¨™æº–ç€ç å™¨ä¸Šé¡¯ç¤ºçš„ HTMLæ–‡ä»¶ï¼Œé™¤æ­¤ä¹‹å¤–ï¼ŒXSLT ä¹Ÿæ”¯æ´æ¨™æº–çš„è³‡æ–™äº¤æ›è¦å‰‡ï¼Œä»¥ç¬¦åˆ B2Bï¼ˆbusiness 
to businessï¼‰èˆ‡ B2Cï¼ˆbusiness to customerï¼‰çš„éœ€æ±‚ã€‚é™¤äº†ä»¥ä¸Šå…¸å‹çš„æ‡‰ç”¨ä¹‹å¤–ï¼ŒXSLT æ‰€è™•ç†çš„è½‰æ›ä¹Ÿ
é€æ¼¸è®Šå¾—é¾å¤§ä¸”è¤‡é›‘ï¼Œå› æ­¤ï¼Œææ˜‡ XSLT processor çš„æ•ˆèƒ½æˆç‚ºä¸€å€‹ç›¸ç•¶é‡è¦çš„èª²é¡Œã€‚ 
 
XSLT processor é€šå¸¸æœ‰å…©ç¨®å¯¦ä½œæ–¹æ³•ã€‚ç¬¬ä¸€ç¨®æ–¹æ³•æ¡ç”¨ç›´è­¯å™¨ï¼ˆInterpreterï¼‰æ¶æ§‹ï¼Œåœ¨ run-time çš„éš
æ®µï¼ŒåŒæ™‚è§£æ XSLT æŒ‡ä»¤ä¸¦ä¸”å° XML é€²è¡Œè½‰æ›ï¼Œæ­¤ç¨®æ¶æ§‹çš„ç¼ºé»èˆ‡ç›´è­¯å™¨ç›¸ä¼¼ï¼ŒåŸ·è¡Œæ•ˆç‡ä¸è‰¯ã€ç¼ºä¹
æœ€ä½³åŒ–çš„ç©ºé–“ã€‚ç¬¬äºŒç¨®æ–¹æ³•æ¡ç”¨ç·¨è­¯å™¨ï¼ˆCompilerï¼‰æ¶æ§‹ï¼Œå…ˆå°‡ XSLT æ¨£æ¿ï¼ˆstylesheetï¼‰è§£æéå¾Œç¿»è­¯
æˆ C èªè¨€ç¨‹å¼ç¢¼ï¼Œä¹‹å¾Œå°‡æ­¤ç¨‹å¼ç¢¼ç·¨è­¯ç‚ºåŸ·è¡Œæª”ï¼ŒåŸ·è¡Œæ­¤åŸ·è¡Œæª”ï¼Œå³å¯å° XML é€²è¡Œè½‰æ›ã€‚æ­¤æ–¹æ³•åœ¨
ä½¿ç”¨ç›¸åŒ XSLT æ¨£æ¿çš„æ¢ä»¶ä¸‹ï¼Œå¯ä»¥é‡è¤‡ä½¿ç”¨ç·¨è­¯çš„åŸ·è¡Œæª”ï¼Œåªéœ€ç¿»è­¯ä¸€æ¬¡ XSLT æ¨£æ¿ï¼Œé‚„å¯ä»¥åˆ©ç”¨
ç·¨è­¯å™¨çš„ç›¸é—œæœ€ä½³åŒ–æ–¹æ³•ä¾†ææ˜‡æ•ˆèƒ½ã€‚å¾è³‡æ–™å®‰å…¨çš„è§’åº¦ä¾†çœ‹ï¼ŒXSLT ä»¥åŸ·è¡Œæª”çš„æ–¹å¼é‹ä½œï¼Œè½‰æ›å…§å®¹
è¼ƒä¸æ˜“è¢«æœ‰å¿ƒäººå£«æ‰€çŸ¥æ‚‰ã€‚ä¸‹åœ–åˆ†åˆ¥ç‚ºç›´è­¯å¼ï¼ˆFigure 1ï¼‰å’Œç·¨è­¯å¼ï¼ˆFigure 2ï¼‰çš„è½‰æ›æµç¨‹ã€‚XSLT compiler
å°‡ XSLT stylesheet ç¿»è­¯æˆå°æ‡‰çš„ C èªè¨€ç¨‹å¼ç¢¼ï¼Œç¶“é Native compiler ç·¨è­¯å¾Œç”¢ç”Ÿèˆ‡ XSLT stylesheet ç›¸
åŒåŠŸèƒ½çš„åŸ·è¡Œæª”ã€‚ 
 
XML
XSLT 
stylesheet
XSLT
interpreter
XML
HTML
PDF
Others ...
 
Figure 1: å‚³çµ±ç›´è­¯å¼çš„è½‰æ›æ–¹å¼. 
 
 
4 
<xsl:stylesheet version="1.0"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
 
<xsl:output method="html" encoding="utf-8"/>
 
<xsl:template match="/">
      <html>
      <body>
      <xsl:apply-templates/>      
      </body>
      </html>
</xsl:template>
<xsl:template match="Course">
  <h3> <xsl:value-of select="Teacher"/> </h3>
  <ul>
       <li><xsl:value-of select="Title"/></li>
  </ul>
</xsl:template>
</xsl:stylesheet>
 
Figure 3: Example of XSLT stylesheet. 
 
 
ç‚ºäº†è¨­è¨ˆ XSLT ä¹‹ç·¨è­¯æ¼”ç®—æ³•ï¼Œéœ€è¦å…ˆäº†è§£è©²ç”¢ç”Ÿæ€æ¨£çš„ç¨‹å¼ç‰‡æ®µï¼Œå› æ­¤ï¼Œæˆ‘å€‘å…ˆæ‰‹å‹•å»ºç«‹ä¸€ä»½ç¨‹
å¼æ¶æ§‹ï¼Œå…¶ä¸­çš„æ¯å€‹éƒ¨åˆ†ï¼Œåˆ†åˆ¥å°æ‡‰ XSLT çš„ç›¸é—œæŒ‡ä»¤ã€‚ Figure 7 æ˜¯æˆ‘å€‘ç·¨è­¯å‡ºä¾†ç›¸å°æ‡‰çš„ C codeï¼Œ
ç°è‰²éƒ¨åˆ†ç”¨ä¾†è™•ç† XSTLç›¸é—œçš„æŒ‡ä»¤ï¼Œå¦‚ apply-templatesã€value-ofï¼Œç™½è‰²çš„éƒ¨åˆ†å‰‡æ˜¯ function body çš„
å€å¡Šã€‚ 
 
é€™å€‹æ¶æ§‹é€²è¡Œ XSLT ç¿»è­¯çš„ä¸»è¦é‡é»èªªæ˜å¦‚ä¸‹: 
(1) main functionè®€å– XMLæ–‡ä»¶ï¼Œä¸¦ä¸”å»ºç«‹ç›¸å°æ‡‰çš„ XML treeï¼Œæˆ‘å€‘å°‡æ“ä½œé€™å€‹æ¨¹ç‹€çµæ§‹ä¾†å®Œæˆ
è½‰æ›çš„å·¥ä½œï¼Œå®ƒæ‰®æ¼”äº†éå¸¸é‡è¦çš„è§’è‰²ã€‚ 
(2) æ ¹æ“š XSLT çš„è¦å‰‡ï¼Œæˆ‘å€‘å¾ root é–‹å§‹æ¯”å° patternä¸¦ä¸”å¥—ç”¨ç¯„æœ¬ï¼Œè‹¥æ²’æœ‰ç™¼ç¾ç¬¦åˆçš„ç¯„æœ¬ï¼Œå‰‡
ä¾ç…§ç¯€é»çš„å…§å»ºç¯„æœ¬ä¾†è™•ç†ï¼Œå¦‚åŒ main functionçš„ä¸‹åŠæ®µæ‰€æè¿°ã€‚ 
(3) <xsl:template match=â€/â€>å’Œ<xsl:template match=â€Courseâ€>ä»¥ function call ä¾†å¯¦ä½œã€‚ 
(4) åœ¨ç¿»è­¯å‡ºä¾†çš„ C code ä¸­ï¼Œåˆ©ç”¨é©ç•¶çš„ APIä¾†è™•ç† XML æ–‡ä»¶ä¸­ä¸åŒçš„è³‡æ–™ç¯€é»ã€‚ 
(5) <xsl:apply-templates>å’Œ<xsl:value-of>åˆ†åˆ¥å¯¦ä½œå‡ºå„åˆ¥çš„å‡½å¼ã€‚ 
 
6 
<html><body>
    All courses
   <h3> Tom </h3>
<ul><li> Computer Architecture </li></ul>
   <h3> Jason </h3>
<ul><li> Programming Language </li></ul>
</body></html>
 
Figure 6: Transformation result. 
 
 
 
ä¸‰ã€ ç ”ç©¶æ–¹æ³• 
 
Figure 8èªªæ˜äº†XSLT compilerçš„è»Ÿé«”æ¶æ§‹ï¼Œæ•´å€‹æ¶æ§‹èˆ‡å…¸å‹çš„ç·¨è­¯å™¨æ¶æ§‹éå¸¸ç›¸ä¼¼ï¼Œç‚ºäº†ä¿ç•™ XSLT
çš„ç‰¹æ€§ä»¥åŠå¾Œç«¯åˆ†æçš„æ–¹ä¾¿ï¼Œåœ¨ front-end éšæ®µï¼Œæˆ‘å€‘å…ˆå°‡ XSLT æ¨£æ¿è½‰æ›æˆ IR treeï¼Œå› ç‚º XSLT æœ¬èº«
ä¹Ÿæ˜¯ XML æ ¼å¼ï¼Œéå¸¸é©åˆç”¨ tree structure ä¾†è¡¨ç¤ºã€‚åœ¨ Back-end éšæ®µï¼ŒIR tree ç¶“é Code generator ç¿»è­¯
æˆç›¸å°æ‡‰çš„ C codeï¼Œæ¯å€‹ XSLT æŒ‡ä»¤åˆ†åˆ¥ç”±ç¨ç«‹çš„å‡½å¼ä¾†å¯¦ç¾ï¼Œé€éå‘¼å«é€™äº›å‡½å¼ä¾†å®Œæˆ XSLT æ¨£æ¿
çš„è½‰æ›å·¥ä½œã€‚è½‰æ›æ¼”ç®—æ³•çš„ç´°ç¯€ï¼Œæè¿°å¦‚ä¸‹ã€‚ 
 
3.1 <xsl:template> element 
 
XSLT æ¨£æ¿ä¸­çš„ç¯„æœ¬ï¼ˆtemplateï¼‰ä¾ç·¨è­¯çš„é †åºè¢«å‘½åç‚º template1,template2, template3, ..., templateNï¼Œ
N ç‚ºç¯„æœ¬çš„å€‹æ•¸ï¼Œtemplate0 å‰‡é è¨­ç‚ºè™•ç†ç´”æ–‡å­—ç¯€é»çš„å…§å»ºç¯„æœ¬ã€‚ç·¨è­¯<xsl:template>å…ƒä»¶æ™‚ï¼Œæœƒä¾ç…§
DFSï¼ˆdeep-first searchï¼‰çš„é †åºæ‹œè¨ªç¯„æœ¬çš„æ¨¹ç‹€çµæ§‹ï¼Œæ¯æ¬¡æ‹œè¨ªçš„ç¯€é»ï¼Œå‰‡æœƒä¾ç…§ç¯€é»çš„å…§å®¹ç”¢ç”Ÿå‡ºå°
æ‡‰çš„ç¨‹å¼ç‰‡æ®µã€‚<xsl:template match=â€/â€>ä¸­çš„å±¬æ€§å€¼ matchå¯ä»¥è¢«ä½¿ç”¨ä¾†å° XML ç¯€é»é€²è¡Œç¯„æœ¬æ¯”å°ï¼Œ
å› æ­¤åœ¨ç·¨è­¯ç¯„æœ¬æ™‚ï¼Œå±¬æ€§å€¼ match å°‡ä»¥è®Šæ•¸å½¢å¼è¢«è¨˜éŒ„åœ¨ç›¸å°æ‡‰çš„ target C code ä¸­ï¼Œå¹«åŠ©
<xsl:apply-templates>ä¾†æ¯”å°åˆé©çš„ç¯„æœ¬ã€‚ä»¥ Figure 3 çš„<xsl:template match=â€/â€>ç‚ºä¾‹ï¼Œå…¶å°æ‡‰çš„å‡½å¼ 
templateN åŸ·è¡Œé †åºæ‡‰ç‚º<html>ã€<body>ã€<xsl:apply-templates>ã€</body>ã€</html>ï¼Œç¶“è§€å¯Ÿå¾—çŸ¥ï¼ŒåŸ·
è¡Œé †åºç‚º FILOï¼ˆfirst-in, last-outï¼‰ï¼Œå› æ­¤æˆ‘å€‘é¸æ“‡ stack çµæ§‹ä¾†è™•ç†ç¯„æœ¬çš„ç·¨è­¯ã€‚Figure 9 ç‚º<xsl:template 
match=â€/â€>çš„æ¨¹ç‹€çµæ§‹ï¼ŒFigure 10 æ˜¯ç¯„æœ¬ç·¨è­¯çš„éç¨‹ã€‚é¦–å…ˆï¼Œæˆ‘å€‘æ‹œè¨ª<html>å’Œ<body>ç¯€é»ï¼Œç”¢ç”Ÿå°
æ‡‰çš„æ•˜è¿°åˆ° target C code ä¸­ï¼Œ<html>èˆ‡<body>è¢« pushåˆ° stack ä¸­ï¼Œæ¥è‘—æ‹œè¨ª xsl:apply-templatesï¼Œæˆ‘å€‘
ç”¢ç”Ÿä¸€å€‹å°æ‡‰çš„ function call åˆ° target code ä¸­ï¼ŒåŒæ¨£ pushç¯€é»åˆ° stack ä¸­ï¼Œç¹¼çºŒæœå°‹å¾Œç™¼ç¾æ²’æœ‰å­ç¯€é»ï¼Œ
å°±å°‡<xsl:apply-templates> pop å‡ºä¾†ï¼Œæ¥è‘— pop å‡º<html>èˆ‡<body>ï¼Œç”¢ç”Ÿ end tagçš„è¼¸å‡ºåˆ° targe code ä¸­ï¼Œ
8 
Parser
IR tree
Target C code
Code generator
Front-end
Back-end
XSLT stylesheet
(source program)
Symbol-table 
manager
Error handler
 
Figure 8: Software architecture of the XSLT compiler Zebu. 
 
 
xsl:template html body xsl:apply-templates
match â€œ/â€
 
Figure 9: Tree structure of <xsl:template match=â€/â€> in Figure 3. 
 
 
Stack
html
body
xsl:apply-templates
Stack
html
Stack
html
body
Stack
html
body
Stack
html
Stack
/* Code fragment in target C 
code */
template2() {
  ...
Output tag <html>   /*(a)*/
Output tag <body>   /*(b)*/
Handle <xsl:apply-template> 
element             /*(c)*/
Output tag </body>  /*(d)*/
Output tag </html>  /*(e)*/
... }
(a) (b) (c)
(d)(e)
 
Figure 10: Code generation and stack data structure. 
 
 
3.2 <xsl:apply-templates> element 
 
xsl:apply-templates element å¯ä»¥å®šç¾©ä¸€ç¾¤è¦äº¤ç”±ç¯„æœ¬è¦å‰‡è™•ç†çš„ç¯€é»ï¼Œä¸€èˆ¬å¯åˆ†ç‚ºé¸æ“‡ç‰¹å®šç¯€é»åŠ
è™•ç†æ‰€æœ‰å­ç¯€é»å…©ç¨®æƒ…æ³ã€‚ç¶“éæˆ‘å€‘çš„ XSLT compiler è™•ç†ï¼Œapply-template æŒ‡ä»¤å°‡è¢«ç·¨è­¯è€Œç”¢ç”Ÿå‡½å¼
match_templateã€‚ç‚ºäº†ä½¿ match_template èƒ½æ­£ç¢ºé‹ä½œï¼Œæˆ‘å€‘éœ€è¦æ¯å€‹ç¯„æœ¬çš„ match å±¬æ€§å€¼ï¼Œå› æ­¤åœ¨ç¯„æœ¬
ç·¨è­¯çš„éšæ®µï¼Œå°‡å±¬æ€§å€¼ matchè¨˜éŒ„åœ¨ target C code çš„é™£åˆ— tlist ä¸­ï¼Œè€Œåœ¨æ‰€æœ‰ç¯„æœ¬åˆ†æèˆ‡ç·¨è­¯å®Œæˆå¾Œï¼Œ
10 
ä¸Šå±¤çš„ symbol table æ‰¾ä¸åˆ°å®šç¾©çš„è®Šæ•¸ï¼Œå‰‡å¾€ä¸‹å±¤çš„ symbol table å»å°‹æ‰¾ã€‚Figure 13 è¡¨ç¤º symbol table
èˆ‡ scope ä¹‹é–“çš„å°æ‡‰ç‹€æ³ã€‚ 
 
 
/*
 * <xsl:apply-templates> is processed by the function
 * match_template() that visits all child nodes of
 * the current node to check for whether or not a template is matched.
 * - cnode is a pointer that points to an XML tree node.
 */
char *tlist[] = {"__text__", "Course", "/"};
match_template(cnode) {
  ...
/* cnode points to the children of the current code. */
cnode = cnode->children;
while (cnode != NULL) {
   ...
   for (i=0; i<=2; i++) {
      ...
      if (cnode->name matches tlist[i]) {
         switch(i) {
         case 0: template0(); break;
         case 1: template1(); break;
         case 2: template2(); break;
         }
      }
   }
   if (no match)
      match_template(cnode);
   /* cnode points to the next sibling node of the current node. */
   cnode = cnode->next;      
}
}
 
Figure 12: Code skeleton of the function match_template. 
 
 
Symbol table II
Name Value
Data 
type
Symbol table I
Name Value
Global symbol table
Name Value
XSLT tree structure
Data 
type
Data 
type
 
Figure 13: Symbol table and the corresponding scope. 
 
 
 
12 
æ˜¯å¦æœ‰ç¬¦åˆçš„ç¯„æœ¬å¥—ç”¨ï¼Œè‹¥æœªç™¼ç¾åˆ°å¯å¥—ç”¨çš„ç¯„æœ¬ï¼Œå‰‡ä¾ XSLT çš„å…§å»ºè¦å‰‡ï¼Œå‘¼å« match_template ç¹¼
çºŒæ¯”å°æ ¹ç¯€é»çš„æ‰€æœ‰å­ç¯€é»ã€‚ 
 
xsl:template html xsl:for-each
match "/"
"Found!!"
select "/Semester/Course"
template1() {
  ...
  Output tag <html>
 /* Parse XPath expression and store proper information */
 xpath_info = XPath_parse("...");
  /* Identify the XPath-interested node.
     result_node_set points to the set of nodes */
  result_node_set = XPath_evaluation(xpath_info, ...);
  for (i=0; i<size(result_node_set); i++) {
     ...
  }
  ...
}
 
Figure 15: Pseudo code of the <xsl:for-each> element. 
 
 
main()
{
  ...
  Read XML file;
  Construct the corresponding tree structure;
  RootNode points to the root node of the XML tree;
  ...
  /* Begin XSLT transformation */  
  xsltprocessing(RootNode);
  ...
}
/* check whether user-defined templates match the root node */
xsltprocessing(cnode) {
  ...
if (cnode != NULL) {
   for (i=0; i<=2; i++) {
      if (cnode->name matches tlist[i]) {
         switch(i) {
         case 0: template0(); break;
         case 1: template1(); break;
         case 2: template2(); break;
         }
      }
   }
/* If no match, the built-in template rule is applied. */
   if (no match)
      match_template(cnode);
}
}
chAr *tlist[] = {"__text__", "Course", "/"};
...
 
Figure 16: Pseudo code of the main and xsltprocessing functions. 
14 
3.8 Multithreaded XSLT compiler 
 
 ç‚ºäº†é”åˆ° XML transformation å¹³è¡ŒåŒ–çš„ç›®çš„ï¼Œæˆ‘å€‘å¿…é ‡å…ˆåˆ†æä¸¦ä¸”æ‰¾å‡ºå¯ä»¥å¹³è¡ŒåŸ·è¡Œçš„ taskï¼Œ
ä»¥å®Œæˆå¾ŒçºŒå¹³è¡ŒåŸ·è¡ŒåŠåˆä½µçš„å·¥ä½œï¼Œå› æ­¤ï¼Œæˆ‘å€‘å°‡åˆ†æˆä¸‰å€‹éšæ®µä¾†å¯¦ä½œï¼ŒåŒ…æ‹¬ task åˆ†æã€task queue
åŸ·è¡Œã€çµæœåˆä½µã€‚ 
 
3.8.1 Task åˆ†æ 
é€™å€‹éšæ®µä¸»è¦å·¥ä½œæ˜¯æ‰¾å‡ºå¯å¹³è¡ŒåŒ–çš„ taskï¼Œç”± XMLè½‰æ›éç¨‹å¯ä»¥ç™¼ç¾ï¼Œç‰¹å®š XML ç¯€é»çš„
è½‰æ›ä¸¦ä¸æœƒå½±éŸ¿å…¶ä»–ç¯€é»è½‰æ›ï¼Œä¹Ÿå°±æ˜¯èªªï¼Œç¯€é»ä¹‹é–“çš„è½‰æ›ä¸å…·æœ‰ç›¸ä¾é—œä¿‚ï¼Œé©åˆä½œç‚ºå¹³
è¡ŒåŸ·è¡Œçš„å–®ä½ã€‚ä¸€é–‹å§‹ï¼Œæˆ‘å€‘ä»¥ deep-firstã€left-to-right çš„é †åºä¾† traverse XML treeï¼Œæ¯æ¬¡æ¯”
å°åˆ°ä¸€å€‹ç¯€é»ï¼Œå°±åˆ©ç”¨ tlist ä¾†æª¢æŸ¥è©²ç¯€é»æ˜¯å¦ç‚ºæ¬²è½‰æ›ä¹‹ç¯€é»ï¼Œtlist å…§å®¹ç‚º XSLT compile
éšæ®µæ‰€è¨˜éŒ„çš„å„ç¯„æœ¬ match å±¬æ€§å€¼ã€‚è‹¥è©²ç¯€é»ç¬¦åˆè½‰æ›æ¢ä»¶ï¼Œå‰‡è¦–æ­¤ç¯€é»ç‚ºå¯å¹³è¡ŒåŒ–ä¹‹
taskï¼Œå› æ­¤ï¼Œæˆ‘å€‘è¨˜éŒ„é€™å€‹ç¯€é»çš„è³‡æ–™ä¸¦ä¸”åœ¨ task tree ä¸­å°æ‡‰ä½ç½®ç”¢ç”Ÿä¸€å€‹ taskç¯€é»ï¼Œtask tree
ä»£è¡¨æ‰€æœ‰ task çš„åˆä½µé †åºï¼Œç¯€é»é–“çš„é †åºç­‰åŒæ–¼åŸä¾† XSLT çš„å¥—ç”¨é †åºï¼Œè—‰ç”± task treeï¼Œå¯
ä»¥ç¢ºä¿å¹³è¡ŒåŒ–èˆ‡å¾ªåºåŸ·è¡Œçš„çµæœä¸€è‡´ã€‚ 
 
3.8.2 Task queue åŸ·è¡Œ 
æ‰¾å‡ºå¯å¹³è¡ŒåŒ–çš„ task å¾Œï¼Œæˆ‘å€‘åˆ©ç”¨ task queue ä¾†å¯¦ä½œå¹³è¡ŒåŒ–åŸ·è¡Œçš„éƒ¨åˆ†ï¼Œtask queue æ˜¯æ¡ç”¨
å‹•æ…‹æ–¹å¼ä¾†åˆ†é… taskï¼Œç•¶å…¶ä¸­ä¸€å€‹ thread åŸ·è¡Œå®Œç›®å‰æ‰€æ‹¿åˆ°çš„ task å¾Œï¼Œå¯ä»¥å¾ task queue
ä¸­å–å¾—ä¸‹ä¸€å€‹ taskï¼Œä¾†é¿å… thread é–’ç½®çš„æƒ…æ³ç™¼ç”Ÿï¼Œç›¸å°åœ°ï¼Œå°‡ task éœæ…‹åˆ†é…çµ¦ thread åŸ·
è¡Œï¼Œè¼ƒå®¹æ˜“ç”¢ç”Ÿ load unbalance çš„å•é¡Œã€‚ 
 
åœ¨é€™å€‹éšæ®µï¼Œæˆ‘å€‘å…ˆ fork å‡ºèˆ‡åŸ·è¡Œå¹³å°ä¹‹CPU core å€‹æ•¸ç›¸åŒçš„ threadï¼Œthread ä¾åºå°‡ task æ”¾
åˆ° task queue ä¸­ï¼Œæ‰€æœ‰ task æ”¾å…¥ queue ä¹‹å¾Œï¼Œthread å†å¾ queue ä¸­å–å¾— task ä¾†åŸ·è¡Œã€‚åœ¨ XML
è½‰æ›çš„ä¾‹å­ä¸­ï¼Œè‹¥ç¯„æœ¬çš„è½‰æ›å…§å®¹éæ–¼ç°¡å–®ï¼Œå°‡å°è‡´ task çš„åŸ·è¡Œæ™‚é–“éçŸ­ï¼Œthread éœ€è¦é »
ç¹åœ°å¾ task queue å–å‡º task åŸ·è¡Œï¼Œä½¿å¾— queue çš„å­˜å–æˆç‚ºæ•ˆèƒ½çš„ç“¶é ¸ï¼Œæˆ‘å€‘ä¹Ÿå¯¦ä½œç›¸é—œçš„
æ–¹æ³•ï¼Œå°‡éæ–¼ç°¡å–®çš„ task åˆä½µæˆè¼ƒå¤§çš„ taskï¼Œä»¥æ”¹å–„å¹³è¡ŒåŒ–çš„æ•ˆèƒ½ã€‚åœ¨ task åŸ·è¡Œçš„éç¨‹ä¸­ï¼Œ
é‡åˆ° apply-templates æŒ‡ä»¤æ™‚ï¼Œæˆ‘å€‘æœƒè¨˜éŒ„ä¸‹ç›®å‰ buffer ä½ç½®ï¼Œç•¶ thread åŸ·è¡Œå®Œä¸€å€‹ task å¾Œï¼Œ
ä¾¿å°‡è½‰æ›å…§å®¹è¨˜éŒ„åˆ°è©² task çš„ buffer ä¸­ï¼Œå°‡ä¾†æˆ‘å€‘å¯ä»¥é€é task tree ä¾†è®€å– buffer é€²è¡Œæœ€
å¾Œçµæœçš„åˆä½µå·¥ä½œã€‚ 
 
 
3.8.3 çµæœåˆä½µ 
åœ¨é€™å€‹æ­¥é©Ÿï¼Œè—‰ç”±ç¬¬ä¸€éšæ®µæ‰€å»ºç«‹çš„ task tree çµæ§‹ï¼Œå¯ä»¥ç¢ºä¿ task çµæœæ­£ç¢ºåœ°è¢«åˆä½µï¼Œæˆ‘
å€‘ä¾ç…§ deep-firstã€ left-to-right çš„é †åºä¾† traverse task treeï¼Œä¸¦ä¸”åƒè€ƒä¸Šä¸€å€‹éšæ®µè¨˜éŒ„
apply-templates çš„ buffer ä½ç½®ï¼Œå®Œæ•´åˆä½µæœ€å¾Œçš„çµæœï¼Œå°‡çµæœè¼¸å‡ºè‡³ output fileï¼Œæ­¤çµæœå°‡
èˆ‡å¾ªåºåŸ·è¡Œç›¸åŒã€‚ 
 
16 
 
 
Table 2: Configuration of the experimental environment. 
 
 
 
Table 3: Benchmark programs. 
 
 
 
æˆ‘å€‘é‡æ¸¬äº”å€‹è‘—åçš„ XSLT processorï¼ˆå¦‚ Table 4 æ‰€ç¤ºï¼‰ï¼ŒFigure 18 èˆ‡ Table 5 é¡¯ç¤ºå„å€‹ XSLT processor
çš„åŸ·è¡Œæ™‚é–“ï¼Œçµæœé¡¯ç¤ºæˆ‘å€‘çš„ XSLT compiler æœ‰æœ€å°‘çš„åŸ·è¡Œæ™‚é–“ã€‚Figure 19 èˆ‡ Table 6 é¡¯ç¤º speedup çš„
æ¯”è¼ƒï¼Œå…¶æ¯”è¼ƒçš„ baseline ç‚º Xalan XSLT processorï¼Œçµæœé¡¯ç¤ºï¼Œæˆ‘å€‘çš„ XSLT compiler å¹³å‡æœ‰ 1.36 å€çš„
åŠ é€Ÿã€‚ 
 
 
 
18 
 
Table 5: Execution time (nanoseconds) for evaluated XSLT processors. 
 
 
 
Figure 19: Comparison of speed-ups for evaluated XSLT processors compared to Xalan. 
 
20 
å¤šåŸ·è¡Œç·’çš„ XSLT compiler åˆæ¯”å¾ªåºçš„ XSLT compiler å¿« 1.43 å€ã€‚é€™é … XSLT è™•ç†æŠ€è¡“å¯ä»¥åŠ é€Ÿè¨±å¤š
Web æ‡‰ç”¨ç¨‹å¼è™•ç† XSLT è½‰æ›çš„æ•ˆèƒ½ï¼ŒåŒæ™‚ï¼Œä¹Ÿè®“ç›¸é—œä¹‹æ‡‰ç”¨ç¨‹å¼åœ¨æœ‰é™çš„é‹ç®—è³‡æºä¸‹ï¼Œæ»¿è¶³æœªä¾†é¾
å¤§çš„ XML è™•ç†éœ€æ±‚ã€‚ 
 
 
å…­ã€ åƒè€ƒæ–‡ç» 
[1] libxml2 APIs, http://xmlsoft.org/index.html. 
[2] Xalan-Java, http://xml.apache.org/xalan-j/xsltc/index.html#compiler. 
[3] World Wide Web Consortium. XSL Transformations (XSLT). W3C Recommendation. 
(http://www.w3.org/TR/xslt) 
[4] World Wide Web Consortium. XML Path Language. W3C Recommendation. 
(http://www.w3.org/TR/xpath) 
[5] Anguel Novoselsky. The Oracle XSLT Virtual Machine. XTech 2005 Amsterdam, Netherlands, 24-27 
MAY 2005. 
[6] World Wide Web Consortium. Extensible Markup Language (XML) 1.0. W3C Recommendation. 
(http://www.w3.org/TR/1998/REC-xml-19980210) 
[7] Anguel Novoselsky and K. Karun. XSLTVM â€“ an XSLT Virtual Machine. XML Europe 2000, Paris, 
France, June 12-16, 2000. 
[8] Oracle's Java XSLT processor is available from 
http://technet.oracle.com/tech/xml/parser_java2/index.html. 
[9] TransforMiix, The Mozilla Project offers its TransforMiiX processor at 
http://www.mozilla.org/projects/xslt. 
[10] Gregor/XSLT framework, http://www.ambrosoft.com/. 
[11] XSLT performance benchmarks: XSLTMark, http://www.datapower.com/xmldev/xsltmark.html. 
[12] MSXML, The Microsoft XML Parser is available at 
http://msdn.microsoft.com/xml/general/xmlparser.asp 
[13] The XPath 1.0 Recommendation, published by the World Wide Web consortium. The definitive 
specification of the XPath expression syntax used within an XSLT style sheet. 
[14] P. Briggs. Automatic parallelization. ACM SIGPLAN Notices, 31(4):11-15, 1996. 
[15] J. Derrick. Cost effective XML processing in the datacenter. In XML Europe 2004, Amsterdam, The 
Netherlands, Apr. 2004. 
22 
http://www-106.ibm.com/developerworks/xml/library/x-xslt/. 
[34] D. Jacobs. Rescuing XSLT from Niche Status. 
http://www.xfront.com/rescuing-xslt.html. 
[35] Intel XSLT accelerator. 
http://www.intel.com/cd/software/products/asmo-na/eng/335035.htm. 
 
Compiler Support for Effective
XSL Transformation
Ching-Mao Chenâ€ , Fu-Shun Chuâ€¡,and Peng-Sheng Chenâˆ—Â§
Department of Computer Science and Information Engineering
National Chung Cheng University, Chia-Yi 621, Taiwan
SUMMARY
XML (Extensible Markup Language) is a markup language used to describe data or documents. The main
goal of XML is to facilitate the sharing of data across diverse information systems, especially via the
Internet. XSLT (XML Stylesheet Transformations) is a standard approach to describe how to transform
an XML stylesheet into another data format. The ever-increasing number of Web technologies being used
in our everyday lives often leverage XSLT to support data exchange among heterogeneous environments,
and the associated increasing burdens on XSLT processors has increased the demand for high-performance
XSLT processors. In this paper we present an XSLT compiler, named Zebu, that can transform an XSLT
stylesheet into the corresponding C program. The compiled program can be used to transform documents
without requiring XSLT stylesheets to be processed. The results from experimental testing using standard
âˆ—Correspondence to: Department of Computer Science and Information Engineering
National Chung Cheng University, Chia-Yi 621, Taiwan
â€ E-mail: mash105@gmail.com
â€¡E-mail: p700603@yahoo.com.tw
Â§E-mail: pschen@cs.ccu.edu.tw
2 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
(1) An increasing number of Web technologies are being used in our everyday lives. These
technologies often leverage XSLT to support solutions in heterogeneous environments [5].
(2) The maturing of technologies of information integration is increasing the importance of the
performance and throughput of data exchange. A requirement to transform massive data set
is also becoming more and more frequent.
(3) Social networking is increasing in popularity, with individuals being grouped for specific events
and sharing various types of information. The performance of XSLT processors represents one of
the major bottlenecks in supporting the setting up of large-scale social networking and handling
the exchange of massive amounts of information [6].
(4) An application gateway decouples back-end applications and consumers to achieve the goals of
better maintainability and higher security [7, 8, 9]. XML can be flexibly used to describe the
rules that will be applied to application traffic. Message traffic can be easily managed by XSLT
and fast XSLT processors are crucial to handling increasing traffic volumes.
(5) The management of massive volumes of XML data is becoming increasingly important to the
database community [10, 11, 12]. Especially, how to efficiently search and transform massive
volumes of XML data is becoming a critical problem.
The expansion of the above applications will increase the importance of designing and building
high-performance XSLT processors. Two general implementation approaches are used for XSLT
processors. The first is an interpreter-based approach that transforms an XSLT stylesheet and executes
the corresponding operations at run-time. The drawback is that an XSLT stylesheet is parsed and
analyzed whenever an XSLT processor is executed, which requires considerable amounts of time and
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
4 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
XSLT 
stylesheet
XSLT
compiler
XML
HTML
PDF
Others ...
XML
C program
Native C
compiler
XSLT 
executable
XSLT 
executable
Figure 2. Execution flow of an XSLT compiler
to 1.36 times compared to the Xalan-XSLTC XSLT processor. This technique will also help to advance
the capabilities to process massive XML data files with limited resources, and thereby improve the
competitiveness of the industry.
1.1. Contributions
This paper makes the following contributions:
(1) Compilation algorithm: It presents a compilation algorithm that translates an XSLT stylesheet
into the corresponding ISO-compliant C code.
(2) Implementation: It presents the implementation and the corresponding data structures in detail.
(3) Experimental results: It presents results obtained in experimental testing using standard
benchmarks, which show that our XSLT compiler exhibits better overall performance than
conventional XSLT processors.
The remainder of this paper is organized as follows. Section 2 briefly describes the transformation
process of an XSLT processor and presents an example that illustrates the conceptual skeleton of the
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
6 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html" encoding="utf-8"/>
<xsl:template match="/">
<html>
<body>
<xsl:apply-templates/>      
</body>
</html>
</xsl:template>
<xsl:template match="Course">
<h3> <xsl:value-of select="Teacher"/> </h3>
<ul>
<li><xsl:value-of select="Title"/></li>
</ul>
</xsl:template>
</xsl:stylesheet>
Figure 3. Example of an XSLT stylesheet
tree, and the <xsl:value-of> elements take information from the XML Teacher and Title elements and
adds them to the result tree. Once the transformation is finished, the output in Figure 6 is displayed.
2.2. XSLT stylesheet and corresponding C code
When designing the compilation algorithm it is necessary to understand and observe what the target C
code could look like. Consider the XSLT stylesheet in Figure 3 and the behavior of XSLT processing.
We determined a conceptual skeleton of target C code that performs the same transformation operation
as an XSLT stylesheet. Figure 7 illustrates the skeleton of the target C code. Each gray box shows
the appropriate function that will be called to handle the corresponding operation, and each white box
represents a function body. Several important observations are explained as follows:
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
8 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
<html><body>
All courses
<h3> Tom </h3>
<ul><li> Computer Architecture </li></ul>
<h3> Jason </h3>
<ul><li> Programming Language </li></ul>
</body></html>
Figure 6. Transformation result
(1) The main function first reads the appropriate XML file and constructs the corresponding tree
structure, which is a critical data structure in this C code.
(2) According to XSLT transformation rules, we begin by pattern matching from the XML root node
and then search for an appropriate template to apply the transformation. If no matched template
is found, the built-in template will be executed. The bottom half of the main function behaves as
described above.
(3) The XSLT templates <xsl:template match=â€œ/â€> and <xsl:template match=â€œCourseâ€> are viewed
and processed as C functions.
(4) Due to the input XML file being unpredictable, the C functions for handling the appropriate built-
in templates should be added to the target C code.
(5) The XSLT elements <xsl:apply-template> and <xsl:value-of> are represented as C functions.
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
10 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
Parser
IR tree
Target C code
Code generator
Front-end
Back-end
XSLT stylesheet
(source program)
Symbol-table 
manager
Error handler
Figure 8. Software architecture of the XSLT compiler Zebu
preserve the characteristics of XSLT processing, a tree structure is adopted for the IR format. The code-
generator pass traverses the IR and generates corresponding target C code. In our compiler, each XSLT
element is transformed into a corresponding C function or corresponding C statements. The entire
XSLT process relies on cooperation among these functions. The proposed transformation algorithms
are described below.
3.1. The <xsl:template> element
For each XSLT template element, a dedicated C function is generated in the target C code. In our
compiler the template functions are named as template1, template2, template3, . . ., templaten, where
the n value in templaten is decided by the compilation order of the template elements, with template0
is reserved for the built-in template rule. We traverse each node in the tree structure of the template
element in a deep-first visiting order. Each node is transformed into the corresponding C statements.
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
12 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
Stack
html
body
xsl:apply-templates
Stack
html
Stack
html
body
Stack
html
body
Stack
html
Stack
/* Code fragment in target C 
code */
template2() {
...
Output tag <html>   /*(a)*/
Output tag <body>   /*(b)*/
Handle <xsl:apply-template> 
element             /*(c)*/
Output tag </body>  /*(d)*/
Output tag </html>  /*(e)*/
... }
(a) (b) (c)
(d)(e)
Figure 10. Code generation and stack data structure
3.2. The <xsl:apply-templates> element
The <xsl:apply-templates> element makes the XSLT processor apply a template to its child nodes
or to the specialized nodes. A C function named match template is generated to handle this
element in the target C code. Generating the correct match template function requires an
understanding of all match attributes in all templates. Accordingly, the code generation of the
match template function is performed after all templates have been compiled. Figure 11 shows the
code fragments in the target C code after compiling all templates in Figure 3. The built-in template is
transformed into the corresponding C function named template0, and we internally use â€œ text â€ as its
recorded match attribute. Next, the <xsl:template match=â€œCourseâ€> and <xsl:template match=â€œ/â€>
elements are transformed into the corresponding C functions, template1 and template2, and the match
attributes â€œCourseâ€ and â€œ/â€ are recorded. Finally, an array of strings (tlist) containing match-attribute
information is generated in the target C code. Figure 12 displays the code skeleton of the function
match template after compiling <xsl:apply-templates> in Figure 3. The match template
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
14 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
/*
* <xsl:apply-templates> is processed by the function
* match_template() that visits all child nodes of
* the current node to check for whether or not a template is matched.
* - cnode is a pointer that points to an XML tree node.
*/
char *tlist[] = {"__text__", "Course", "/"};
match_template(cnode) {
...
/* cnode points to the children of the current code. */
cnode = cnode->children;
while (cnode != NULL) {
...
for (i=0; i<=2; i++) {
...
if (cnode->name matches tlist[i]) {
switch(i) {
case 0: template0(); break;
case 1: template1(); break;
case 2: template2(); break;
}
}
}
if (no match)
match_template(cnode);
/* cnode points to the next sibling node of the current node. */
cnode = cnode->next;      
}
}
Figure 12. Code skeleton of the function match template
(2) Evaluating XPath expression: This reads a parsed XPath expression and returns an appropriate
set of nodes in an XML document.
(3) Value extraction: This extracts the correct values from the XPath-selected nodes.
3.4. XSLT elements for declaring variables and parameters
XSLT provides elements that can be used to define variables and parameters in a stylesheet. Consider
one of these elements, <xsl:variable>. The scope of an <xsl:variable> element is the element that
contains it; if its parent is <xsl:stylesheet>, the scope is global. These elements are handled by
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
16 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
/*
* This function implements the functionality of
* the <xsl:value-of> element.
* Variable cnode points to the XML tree node.
* Variable xpath-string is the corresponding string value of
* XPath description.
*/
xsl_valueof(cnode, xpath-string)
{
/* Initialization */
...
/* Parse XPath expression and store appropriate information */
xpath_info = XPath_parse(xpath-string);
/* (1) Identify the XPath node of interest.
(2) result_node_set points to the node */
result_node_set = XPath_evaluation(xpath_info, ...);
Output the correct value by using result_node_set;
/* Release the resources */
...
}
Figure 14. Pseudo code of <xsl:value-of> element
of the select attribute is parsed for obtaining the appropriate set of nodes. Then, we use a FOR-
LOOP construct to visit each node in the set. Finally, the transformations of the child nodes of the
<xsl:foreach> element are performed and generated C codes are placed in the loop body of the FOR-
LOOP construct.
3.6. Main and xsltprocessing functions
After traversing and compiling the tree structure of an XSLT stylesheet, we begin to generate the main
function in the target C code. We add the appropriate C statements to the main function for reading
input XML files and building the corresponding tree structure. Then, a call to the xsltprocessing
function is added to the main function for starting an XSLT transformation. The xsltprocessing
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
18 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
main()
{
...
Read XML file;
Construct the corresponding tree structure;
RootNode points to the root node of the XML tree;
...
/* Begin XSLT transformation */  
xsltprocessing(RootNode);
...
}
/* check whether user-defined templates match the root node */
xsltprocessing(cnode) {
...
if (cnode != NULL) {
for (i=0; i<=2; i++) {
if (cnode->name matches tlist[i]) {
switch(i) {
case 0: template0(); break;
case 1: template1(); break;
case 2: template2(); break;
}
}
}
/* If no match, the built-in template rule is applied. */
if (no match)
match_template(cnode);
}
}
chAr *tlist[] = {"__text__", "Course", "/"};
...
Figure 16. Pseudo code of the main and xsltprocessing functions
left-to-right visiting order. The adopted transformation policies vary with the characteristics of the
nodes, as described in detail in Sections 3.1, 3.3, 3.4, and 3.5. After traversing the XSLT tree structure,
we generate the function match template to handle the <xsl:apply-templates> element. Finally,
the main and xsltprocessing functions are correctly generated in the target C code.
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
20 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
Zebu (XSLT compiler)
ISO-compliant C code libxmllibxslt
XSLT stylesheet
Native C compiler
Executable codeXML stylesheet
(source)
Transformed content
(result)
Figure 17. Compilation and execution flow of the Zebu compiler
4.1. Implementation
Figure 17 illustrates the compilation and execution flow of the Zebu compiler. An XSLT stylesheet is
read by the Zebu compiler and compiled into the corresponding ISO-compliant C code. Our current
implementation leverages two open-source libraries, libxml2 [16, 17] and libxslt [18, 19], to parse the
XML stylesheet, construct the corresponding tree structure, and handle XPath expressions. These two
libraries were developed as part of the GNOME project [20] and implemented in the C programming
language. Due to their features of completeness and stabilization, they are selected to help the Zebu
compiler to manipulate the XML stylesheet. A native C compiler is used to compile the target C code,
and to correctly link the object code with libxml2 and libxslt libraries into an executable code. The
executable code can be executed to fetch an XML stylesheet and produce the transformed content, in
the same manner as an XSLT processor.
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
22 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
4.2. Evaluation environment
Table II lists the configuration of the experimental environment. The experiments were evaluated on
an Intel-Core-i7-based computer system with 12 GB of memory. The native C compiler GCC 4.3.4
was used with the -O3 option to compile target C codes that were transformed by the Zebu compiler.
The POSIX function clock gettime with parameter CLOCK PROCESS CPUTIME ID was adopted to
measure the execution time. Table III lists the benchmarks used to evaluate the performance. The fourth
and fifth columns in the table list the sizes of the input XML and XSLT stylesheets, respectively. These
benchmarks were selected from XSLTMark [21, 22], which contains comprehensive benchmarks for
evaluating the performance of XSLT.
The five XSLT processors used to evaluate the performance are described in Table IV. Each tested
benchmark was run 11 times on each XSLT processor, with the first run being discarded in order to
reduce the effects of disk I/O. An average time was then computed from the results of the remaining
ten executions for evaluation and comparison.
4.3. Experimental results
Table V lists the code sizes of the transformed C code, and Figure 18 and Table VI compares the
execution times among the evaluated XSLT processors. The results show that the execution time was
lowest for the Zebu compiler for all of the evaluated XSLT processors. Figure 19 and Table VII
present the speed-up values with Xalan selected as the comparison baseline. The speed-up for the
Zebu compiler has an average of about 1.36 times, whereas the benchmark xslbench2 exhibits only a
1.03-times speed-up. This low value is due to xslbench2 containing 8 templates and the tested input
XML stylesheet being very large, with 2699 nodes in the corresponding tree structure. The C code
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
24 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
Table III. Benchmark programs [22]
Benchmark Description Number of
templates
Size of XSLT
stylesheet (bytes)
Size of input XML
stylesheet (bytes)
axis Tests XPath selection along differ-
ent axes
2 1309 360
find Test breadth of XML structure 2 380 4259
game Produces a HTML table of the data 2 1111 2667
inventory Produces a HTML table of the data 2 811 1893
identity The identity transform 1 284 16047
avts Tests attribute-value template ex-
pansion
2 465 16047
dbtail Prints a table by traversing the
following-sibling axis
2 497 16047
creation Tests xsl:element and xsl:attribute 3 557 16047
functions Tests various number and string
functions
1 1218 16047
total Reports on sales data 1 806 1220
attests Tests node copying using named
attribute sets
3 852 1220
xslbench2 Test a very large XML file 8 1127 149524
encrypt Performs a Rot-13 operation on all
element names and text nodes
2 745 16047
dbonerow Selects a single row from a very
large table
2 1836 16047
trend Computes trends in the input data 1 643 1806
union Performs complex pattern matching 3 628 173
xpath Performs complex pattern matching 3 615 296
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
26 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
Table V. Code size of transformed C code
Benchmark Number of lines of C code
axis 559
find 383
game 510
inventory 584
identity 313
avts 397
dbtail 527
creation 426
functions 399
total 371
attests 483
xslbench2 1016
encrypt 412
dbonerow 488
trend 392
union 505
xpath 445
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
28 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
Table VII. Speed-ups for evaluated XSLT processors compared to Xalan
Benchmark Zebu Xslta Saxon Xalan XT
axis 1.4329 1.0402 1.0161 1.0000 1.0021
find 1.3711 1.0361 0.9921 1.0000 0.9989
game 1.4284 0.9944 1.0129 1.0000 0.9974
inventory 1.4232 1.0155 0.9987 1.0000 0.9957
identity 1.2031 1.0176 1.0030 1.0000 0.9746
avts 1.4467 1.0374 1.0071 1.0000 0.9998
dbtail 1.4202 1.0389 1.0109 1.0000 1.0007
creation 1.3941 1.0195 1.0050 1.0000 0.9601
functions 1.4834 1.0871 1.0539 1.0000 0.9983
total 1.4610 1.0374 0.9612 1.0000 1.0204
attsets 1.4339 1.0336 0.9994 1.0000 0.9897
xslbench2 1.0392 1.0083 0.9705 1.0000 0.9824
encrypt 1.1745 1.0297 1.0025 1.0000 0.9975
dbonerow 1.0889 1.0112 0.9812 1.0000 1.0012
trend 1.3980 0.9991 1.0013 1.0000 0.9670
union 1.4295 1.0382 1.0136 1.0000 0.9877
xpath 1.4813 1.0557 1.0422 1.0000 1.0368
average 1.3594 1.0294 1.0042 1.0000 0.9947
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
30 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN

	





	
	
	




	
	


	



	


     ! " " " " 



Figure 19. Comparison of speed-ups for evaluated XSLT processors compared to Xalan
Xalan-Java, written in Java, is one of the Apache XML projects. It consists of an interpretive
processor and an XSLT compiler. The interpretive processor generally operates with the XML parser,
Xerces-Java, and completely implements the standard of XSLT 1.0. It also provides Java interfaces for
easily performing XML transformations. The standard of XPath 1.0 is also supported, and appropriate
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
32 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
very similar to that used for our XSLT compiler. The major difference other than compilation algorithm
is that XSLTC generates C++ code whereas our compiler produces C code. In addition, the advantage
of our XSLT compiler is that a C compiler is much more common than a C++ compiler, especially for
embedded and specialized computing systems.
5.3. Hardware-based approach
XSLTVM [36, 37] is an XSLT virtual machine that was developed by Novoselsky and Karun. It has a
stack-based architecture and contains a dedicated low-level instruction set for XSLT processing. The
virtual machine is designed to be independent of the implementation technology, host hardware, and
host operating system, so it can be easily implemented on any platform. The virtual machine stack holds
variables, partial results, and appropriate run-time information, so the stack cell can contain different
data types. The XSLTVM instruction consists of an operator and one or two operands. An XSLTVM
instruction gets the operands from the stack, perform the operation, and replaces them with the result.
XVM (XML virtual machine) [38] is a hybrid sequential-query virtual machine for processing
XPath, XQuery, XQueryP, and XSLT. A compiler, XCompiler, is provided to compile XQuery,
XQueryP, and XSLT into the corresponding unified byte code, which is platform independent. Like
XSLTVM, XVM is a stack-based virtual machine where each instruction gets its operands from the
stack and pushes the result back into the stack. In addition to a sequential execution model, XVM is
capable of interacting with external query processors via the proprietary compiler technique, query-
pushdown. Based on XVM and XCompiler, an XSLT stylesheet can be compiled, saved in a file, and
efficiently reused on different platforms .
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
34 CHING-MAO CHEN, FU-SHUN CHU, PENG-SHENG CHEN
5. Kelly PM, Coddington PD, Wendelborn AL. Distributed, parallel web service orchestration using xslt. e-Science and Grid
Computing, International Conference on 2005; 0:312â€“319.
6. Derrick J. Cost effective XML processing in the datacenter. XML Europe 2004 2004; .
7. Chang TK, Hwang GH. To secure xml documents with the extension function of xslt. Softw. Pract. Exper. 2006; 36(5):539â€“
555.
8. lmamura T, Dillaway B, Simon E. XML encryption syntax and processing. Website December 2002; Online available at
http://www.w3.org/TR/xmlenc-core/.
9. Chandramouli R. Enterprise access policy enforcement for applications through hybrid models and xslt technologies. ICEC
â€™04: Proceedings of the 6th international conference on Electronic commerce, ACM: New York, NY, USA, 2004; 490â€“499.
10. Liu ZH, Novoselsky A. Efficient xslt processing in relational database system. VLDB â€™06: Proceedings of the 32nd
international conference on Very large data bases, VLDB Endowment, 2006; 1106â€“1116.
11. Graefe G. Query evaluation techniques for large databases. ACM Comput. Surv. 1993; 25(2):73â€“169.
12. Fokoue A, Rose K, SimeÂ´on J, Villard L. Compiling xslt 2.0 into xquery 1.0. WWW â€™05: Proceedings of the 14th
international conference on World Wide Web, ACM: New York, NY, USA, 2005; 682â€“691.
13. Aho AV, Sethi R, Ullman JD. Compilers: Principles, Techniques, and Tools. Addison Wesley, 1986.
14. Muchnick S. Advanced Compiler Design and Implementation. Morgan Kaufmann, 1997.
15. Clark J, DeRose S. XML path language (xpath). W3C Recommendation November 1999; Online available at
http://www.w3.org/TR/xpath/.
16. Website. The XML C parser and toolkit of GNOME, libxml. http://xmlsoft.org 2010.
17. Fleck J. libxml tutorial. Website 2003; Online available at http://xmlsoft.org/tutorial/index.html.
18. Website. The XSLT C library for GNOME, libxslt. http://xmlsoft.org/XSLT 2010.
19. Fleck J. libxslt tutorial. Website 2001; Online available at http://xmlsoft.org/XSLT/tutorial/libxslttutorial.html.
20. Website. GNOME: The Free Software Desktop Project. http://www.gnome.org/ 2010.
21. DataPower. Benchmark tests, understanding the benchmark. Website 2000; Online available at
http://lists.w3.org/Archives/Public/w3c-ietf-xmldsig/2002JanMar/att-0102/XSLTMark-excerpts.txt.
22. Kuznetsov E, Dolph C. Xslt processor benchmarks. Website March 2001; Online available at
http://www.xml.com/pub/a/2001/03/28/xsltmark/index.html.
23. Intel. Intel XML Software Suite for Java* Environments, Userâ€™s Guide. Website 2008; Online available at
http://software.intel.com/file/1897.
Copyright cÂ© 2010 John Wiley & Sons, Ltd. Concurrency Computat.: Pract. Exper. 2010; 00:0â€“0
Prepared using cpeauth.cls
å‡ºå¸­åœ‹éš›å­¸è¡“æœƒè­°å¿ƒå¾—å ±å‘Š 
                                                             
è¨ˆç•«ç·¨è™Ÿ NSC 97-2221-E-194-028-MY2 
è¨ˆç•«åç¨± æ”¯æ´å¤šæ ¸å¿ƒè™•ï§¤å™¨æ¶æ§‹ä¹‹ XSLTå„ªåŒ–å™¨ (ç¬¬äºŒï¦) 
å‡ºåœ‹äººå“¡å§“å 
æœå‹™æ©Ÿé—œåŠè·ç¨± 
é™³éµ¬å‡ 
åœ‹ï§·ä¸­æ­£å¤§å­¸ è³‡è¨Šå·¥ç¨‹å­¸ç³» åŠ©ï§¤æ•™æˆ 
æœƒè­°æ™‚é–“åœ°é» æ°‘åœ‹ 99ï¦ 6æœˆ 14~16æ—¥ 
æœƒè­°åç¨± 
International Workshop on OpenMP, June 14-16, 2010, Tsukuba, Japan 
(IWOMP 2010) 
ç™¼è¡¨ï¥æ–‡é¡Œç›® ç„¡ 
 
ä¸€ã€ï¥«åŠ æœƒè­°ç¶“é 
ç”±æ–¼ç›®å‰ä¸»è¦çš„ç ”ç©¶è­°é¡Œèˆ‡å¦‚ä½•æ’°å¯«å¹³ï¨ˆç¨‹å¼æœ‰é—œï¼Œè€Œ OpenMPæ˜¯ç›®å‰è¢«å»£ç‚ºä½¿ç”¨ï¼Œä¸¦
å…¬èªæœ€å®¹ï§ ä½¿ç”¨ï¤­æ’°å¯«å¤šåŸ·ï¨ˆç·’å¤šæ ¸å¿ƒç¨‹å¼çš„æ–¹å¼ä¹‹ä¸€ï¼ŒIWOMP æ˜¯æ¯ï¦ OpenMP 
communityçš„èšæœƒï¼Œä¸»è¦ç™¼è¡¨ç›¸é—œ OpenMPçš„ï¥æ–‡ï¼Œä¸¦è¨ï¥ OpenMPæœªï¤­çš„ç™¼å±•æ–¹å‘ï¼Œ
å¸Œæœ›è—‰ç”±é€™æ¬¡ï¥«åŠ  IWOMPï¼Œèƒ½å¤ ç²å–åœ‹éš›é–“å°æ–¼ OpenMP ç›¸é—œç ”ç©¶çš„ç¬¬ä¸€æ‰‹è³‡ï¦¾ï¼Œå¢
å¼·åœ‹å…§åœ¨é€™éƒ¨åˆ†ç ”ç©¶çš„èƒ½ï¥¾ã€‚ 
 
 
äºŒã€èˆ‡æœƒå¿ƒå¾— 
æœ¬æ¬¡èˆ‡æœƒç²å¾—è¨±å¤šå¯¶è²´çš„çŸ¥ï§¼èˆ‡ç¶“é©—ï¼Œå¦‚ä¸‹æ‰€è¿°ï¼š 
y æœ¬æ¬¡å¤§æœƒçš„ä¸‰å ´ä¸»è¦çš„æ¼”è¬›ç‚ºMike Heroux (Sandia National Lab.)ã€Michael Wolfe 
(PGI)ã€Hans Boehm (HP)ï¼Œå…¶ä¸­ Herouxä¸»è¦è«‡åŠMPIèˆ‡å…¶ä»–æ’°å¯«å¹³ï¨ˆç¨‹å¼å·¥å…·çš„çµ
åˆï¼Œç”±ä½¿ç”¨è€…çš„è§’ï¨å‡ºç™¼ï¼Œè«‡åŠå¦‚ä½•æ’°å¯«é«˜æ•ˆèƒ½çš„å¹³ï¨ˆç¨‹å¼ï¼›Michael Wolfeæ‡‰ç®—æ˜¯
ï§¨é¢æœ€é‡ï¥¾ç´šçš„æ¼”è¬›è€…ï¼Œå…¶åœ¨å¹³ï¨ˆè™•ï§¤èˆ‡é«˜æ•ˆèƒ½è¨ˆç®—ï¦´åŸŸï¼Œç™¼è¡¨éå¸¸å¤šé‡è¦çš„ï¥æ–‡ï¼Œ
ä»–è«‡åˆ°æœªï¤­ acceleratorå°‡åœ¨é«˜æ•ˆèƒ½è¨ˆç®—ä¸Šä½”æœ‰é‡è¦çš„è§’è‰²ï¼Œè€Œå¦‚ä½•è®“ programmerèƒ½
è¼•ï§ çš„æ’°å¯«ï§ç”¨ acceleratorçš„å¹³ï¨ˆç¨‹å¼ï¤æ˜¯ä¸€é‡è¦çš„è­°é¡Œï¼ŒDr Wolfeæå‡ºï¦ºè‡ªå·±çš„
çœ‹æ³•èˆ‡è§£æ±ºæ–¹æ¡ˆï¼›æœ€å¾Œä¸€ä½ Dr. Boehm è«‡åˆ°é—œæ–¼ memory model çš„å•é¡Œï¼Œä»–å»ºè­°
OpenMPæ‡‰è©²æ”¯æ´ sequentially consistent (SC) atomics syntaxï¼Œä»¥ï§ç¨‹å¼çš„é™¤éŒ¯ï¼Œä»–æ˜¯
ç”±é OpenMP communityäººå“¡çš„è§’è‰²ï¤­å»ºè­°ï¼Œéƒ¨åˆ†èˆ‡æœƒäººå“¡æœ‰ï¥§åŒçš„æ„ï¨Šï¼Œæˆ‘å°æ–¼
é€™å€‹è­°é¡Œä»ï¥§å¤ªèƒ½ï§¤è§£ã€‚ 
 
y æœ¬æ¬¡å¤§æœƒä¹Ÿå®‰æ’ï¦ºä¸€å€‹ä¸‹åˆçš„ tutorialï¼Œä¸»é¡Œæ˜¯ä»‹ç´¹ OpenMP programmingï¼Œç”± Dr. 
Ruud van der Pasæ‰€ä¸»è¬›ï¼Œä»–æœ¬èº«ä»»è·æ–¼ Oracleï¼Œä¸”æ˜¯è³‡æ·±çš„è»Ÿé«”å·¥ç¨‹å¸«ï¼Œè‡ªå·±ä¹Ÿå‡º
ç‰ˆ OpenMPç›¸é—œçš„æ›¸ç±ï¼Œé›–ç„¶æˆ‘ä¹‹å‰å·²ç¶“å° OpenMPæœ‰ä¸€å®šçš„ç­è§£ï¼Œä½†æ˜¯ï¼Œç”±ä»–çš„
èª²ç¨‹ï§¨ï¼Œä»ç„¶æœ‰æ‰€æ”¶ç©«ã€‚ 
 
 
ä»¥ä¸‹ç‚ºæœ¬æ¬¡æœƒè­°æœƒå ´çš„ç›¸é—œç…§ç‰‡ï¼š 
 
 
 
 
 
 
 
 
 
97 å¹´åº¦å°ˆé¡Œç ”ç©¶è¨ˆç•«ç ”ç©¶æˆæœå½™æ•´è¡¨ 
è¨ˆç•«ä¸»æŒäººï¼šé™³éµ¬å‡ è¨ˆç•«ç·¨è™Ÿï¼š97-2221-E-194-028-MY2 
è¨ˆç•«åç¨±ï¼šæ”¯æ´å¤šæ ¸å¿ƒè™•ç†å™¨æ¶æ§‹ä¹‹ XSLT å„ªåŒ–å™¨ 
é‡åŒ– 
æˆæœé …ç›® å¯¦éš›å·²é”æˆ
æ•¸ï¼ˆè¢«æ¥å—
æˆ–å·²ç™¼è¡¨ï¼‰
é æœŸç¸½é”æˆ
æ•¸(å«å¯¦éš›å·²
é”æˆæ•¸) 
æœ¬è¨ˆç•«å¯¦
éš›è²¢ç»ç™¾
åˆ†æ¯” 
å–®ä½ 
å‚™ è¨» ï¼ˆ è³ª åŒ– èªª
æ˜ï¼šå¦‚æ•¸å€‹è¨ˆç•«
å…±åŒæˆæœã€æˆæœ
åˆ— ç‚º è©² æœŸ åˆŠ ä¹‹
å° é¢ æ•… äº‹ ...
ç­‰ï¼‰ 
æœŸåˆŠè«–æ–‡ 0 0 100%  
ç ”ç©¶å ±å‘Š/æŠ€è¡“å ±å‘Š 0 0 100%  
ç ”è¨æœƒè«–æ–‡ 0 0 100% 
ç¯‡ 
 
è«–æ–‡è‘—ä½œ 
å°ˆæ›¸ 0 0 100%   
ç”³è«‹ä¸­ä»¶æ•¸ 1 1 100%  å°ˆåˆ© å·²ç²å¾—ä»¶æ•¸ 0 1 100% ä»¶  
ä»¶æ•¸ 0 0 100% ä»¶  
æŠ€è¡“ç§»è½‰ 
æ¬Šåˆ©é‡‘ 0 0 100% åƒå…ƒ  
ç¢©å£«ç”Ÿ 0 0 100%  
åšå£«ç”Ÿ 0 0 100%  
åšå£«å¾Œç ”ç©¶å“¡ 0 0 100%  
åœ‹å…§ 
åƒèˆ‡è¨ˆç•«äººåŠ› 
ï¼ˆæœ¬åœ‹ç±ï¼‰ 
å°ˆä»»åŠ©ç† 1 1 100% 
äººæ¬¡ 
 
æœŸåˆŠè«–æ–‡ 0 2 100% ä¸€ç¯‡å·²ç¶“æŠ•ç¨¿ï¼Œå¦ä¸€ç¯‡æ­£åœ¨æ’°å¯«ã€‚ 
ç ”ç©¶å ±å‘Š/æŠ€è¡“å ±å‘Š 0 0 100%  
ç ”è¨æœƒè«–æ–‡ 0 0 100% 
ç¯‡ 
 
è«–æ–‡è‘—ä½œ 
å°ˆæ›¸ 0 0 100% ç« /æœ¬  
ç”³è«‹ä¸­ä»¶æ•¸ 1 1 100%  å°ˆåˆ© å·²ç²å¾—ä»¶æ•¸ 0 1 100% ä»¶  
ä»¶æ•¸ 0 0 100% ä»¶  
æŠ€è¡“ç§»è½‰ 
æ¬Šåˆ©é‡‘ 0 0 100% åƒå…ƒ  
ç¢©å£«ç”Ÿ 0 0 100%  
åšå£«ç”Ÿ 0 0 100%  
åšå£«å¾Œç ”ç©¶å“¡ 0 0 100%  
åœ‹å¤– 
åƒèˆ‡è¨ˆç•«äººåŠ› 
ï¼ˆå¤–åœ‹ç±ï¼‰ 
å°ˆä»»åŠ©ç† 0 0 100% 
äººæ¬¡ 
 
