äºŒã€ ä¸­ã€è‹±æ–‡æ‘˜è¦åŠé—œéµè©(keywords)ã€‚
æ‘˜è¦:
åœ¨ç„¡ç·šç¶²è·¯çš„é€šè¨Šæ‡‰ç”¨ä¸Šï¼Œæ‰‹æŒå¼ç³»çµ±çš„ä½¿ç”¨åœ¨æ—¥å¸¸ç”Ÿæ´»è£¡è®Šå¾—å¾ˆæ™®åŠã€‚å°‡è³‡è¨Šå‚³è¼¸èˆ‡åµŒå…¥
å¼çš„è¨­è¨ˆæ•´åˆåœ¨æ‰‹æŒå¼ç³»çµ±çš„éœ€æ±‚è®Šå¾—è¶Šä¾†è¶Šé‡è¦ï¼Œå°¤å…¶ä»Šæ—¥ç¶²è·¯æ™®åŠä½¿å¾—è³‡è¨Šçš„å‚³æ’­æ›´é ã€å–
å¾—æ›´å®¹æ˜“ã€‚é€éæ‰‹æŒå¼ç³»çµ±ï¼Œä¹Ÿå¯ä»¥å°‡è³‡è¨Šå®Œæ•´çš„æ¥æ”¶å’Œå‚³é€ã€‚ä½†åœ¨è³‡è¨Šå‚³è¼¸çš„éç¨‹ä¸­ï¼Œå¦‚ä½•ç¢º
ä¿è³‡è¨Šçš„å®Œæ•´æ€§åŠä¿å¯†æ€§è®Šæˆæœ€é‡è¦çš„è­°é¡Œã€‚æˆ‘å€‘å¿…é ˆç¢ºä¿å‚³è¼¸éç¨‹ä¸­ä¸è¢«å¤–äººç«Šå–å‚³è¼¸è³‡æ–™æˆ–
æ˜¯ä¸è¢«ç ´è§£å…¶å…§å®¹ã€‚å› æ­¤ï¼Œå°‡åŠ è§£å¯†æ©Ÿåˆ¶çµåˆåœ¨æ‰‹æŒå¼ç³»çµ±ä¸Šè®Šæˆå¾ˆé‡è¦çš„è¶¨å‹¢ã€‚
ä½†åœ¨æœ‰é™è™•ç†èƒ½åŠ›çš„åµŒå…¥å¼è™•ç†å™¨ä¸Šï¼Œé™¤äº†å¾—è² è²¬ç³»çµ±çš„é‹ä½œå’Œæ§åˆ¶å¤–ï¼Œé‚„å¾—å…¼é¡§è³‡æ–™é‹ç®—
é‡å¤§çš„è³‡è¨Šä¿å¯†æ¨™æº–æ¼”ç®—æ³•ï¼Œæœƒé€ æˆç³»çµ±åš´é‡çš„è² æ“”ä¸”å½±éŸ¿å…¶æ•´é«”é›»èƒ½çš„æ¶ˆè€—ã€‚å› æ­¤ï¼Œæœ¬è¨ˆç•«åœ¨
æ–¼é€éç¡¬é«”åŒ–è¨­è¨ˆè³‡è¨Šä¿å¯†æ¨™æº–æ¼”ç®—æ³•(æ¡ç”¨å…ˆé€²åŠ è§£å¯†æ¨™æº–)å¤–ï¼Œç”¨ä»¥é™ä½ç³»çµ±çš„è² æ“”å¤–ä¸”å…¼å…·è€ƒ
é‡ä½è€—é›»çš„è¨­è¨ˆï¼Œä»¥é™ä½å°æ•´é«”é›»æºçš„æ¶ˆè€—ã€‚æœ¬è¨ˆç•«çš„é‡é»ç‚º:
(1) è¨­è¨ˆä½è€—é›»åŠå°é¢ç©çš„ AES ç¡¬é«”é›»è·¯ã€‚
(2) æ‡‰ç”¨æ‰€è¨­è¨ˆçš„ AES ç¡¬é«”é›»è·¯åœ¨æ‰‹æŒå¼é€šè¨Šè¨­å‚™ä¸Šã€‚
é‹ç”¨ä»¥ä¸Šçš„è¨­è¨ˆï¼Œå°‡ä½¿å¾—è¨­å‚™å…¼å…·æœ‰å®‰å…¨æœå‹™åŠä½è€—é›»ä¹‹ç‰¹æ€§ï¼Œä¹Ÿå¯é”åˆ°ä½æˆæœ¬çš„è¨­è¨ˆç›®æ¨™ã€‚
é—œéµè©: ä½è€—é›»ã€è¶…å¤§å‹ç©é«”é›»è·¯ã€å…ˆé€²åŠ å¯†æ¼”ç®—æ³•ã€åµŒå…¥å¼ç³»çµ±ã€‚
Abstract:
In the applications of wireless communication network, the use of handheld appliances becomes
popular in our daily life. The requirement of integrating information transmission and embedded design
into a handheld system becomes more and more important. Especially, it is easy to obtain the
information under todayâ€™s network broadcasting. Through the handheld system, we can receive and
transmit information entirely. But in the transmission process, how to confirm the information integrity
and security becomes one of the most important issues. We need to make sure that no stranger can
destroy or intercept our transmitted data in transmission. Hence, the integration of encryption/decryption
mechanisms with handheld system becomes one of the important trends currently.
Low Cost Design of an Advanced Encryption Standard (AES) Processor
Using a New Common-Subexpression-Elimination Algorithm
Abstract - In this paper, we propose an area-efficient design of
Advanced Encryption Standard (AES) processor by applying a
new common-expression-elimination (CSE) method to the
sub-functions of various transformations in AES. The proposed
method reduces the area cost of realizing the sub-functions by
extracting the common factors in the bit-level expressions of
these sub-functions using a new CSE algorithm. Cell-based
implementation results show that the AES processor with our
proposed CSE method has significant area improvement
compared with previous designs.
I. Introduction
The Rijndael block cipher algorithm was selected as the
Advanced Encryption Standard (AES) to replace the former
data encryption standard (DES) [1]. The algorithm is a
symmetric block cipher that processes data blocks of 128
bits organized as a 44ï‚´ matrix of bytes, called a state. A
state is operated by Nr=10, 12, or 14 rounds of
transformations with key length equal to 128, 192, or 256
bits respectively. Four transformations including SubBytes
(SB), ShiftRows (SR), MixColumns (MC), and
AddRoundKey (ARK) are performed in the encryption
process. A separate KeyExpansion (KE) unit is required to
generate the round key for each ARK. Fig. 1(a) shows the
encryption structure of the AES algorithm where the initial
key is added (bit-wise XOR operation) to the input plaintext,
followed by a sequence of transformations. After performing
the final round, the output ciphertext is generated. The direct
decryption algorithm in Fig. 1(b) performs the reverse data
flow where four inverse transformations, InvSubBytes (ISB),
InvShiftRows (ISR), InvMixColumns (IMC), and
AddRoundKey (ARK), are performed instead.
By exploiting common subexpression elimination (CSE)
in different levels of granularity (such as architecture-level,
byte-level or bit-level), the hardware complexity of AES
implementations can be reduced significantly [2-12]. This
paper presents a new bit-level CSE algorithm that results in
more efficient AES implementation compared with previous
designs.
The paper organization is as follows. Sec. II surveys
several previous implementation schemes for SB, ISB, MC,
and IMC. In Sec. III, a new bit-level substructure sharing
method is presented. Performance comparisons in both the
architecture-level designs and the cell-based
implementations are given in Sec. IV, followed by
conclusions in Sec. V.
(a) (b)
Fig. 1 AES (a) encryption and (b) direct decryption flows
Ming-Chih Chen
Dept. of Electronic Engineering
National Kaohsiung First University
of Science and Technology
Kaohsiung, Taiwan, 81164
Tel: 886-7-6011000 ext 2510
Fax: 886-7-6011386
e-mail: mjchen@ccms.nkfust.edu.tw
Shen-Fu Hsiao
Dept. of Computer Science and Engineering
National Sun Yat-Sen University
Kaohsiung, Taiwan, 80424
Tel: 886-7-5252000 ext 4314
Fax: 886-7-5254301
e-mail: sfhsiao@cse.nsysu.edu.tw
Fig. 3 The proposed CSE algorithm
As mentioned, major area costs in realizing the entire
AES cipher/decipher are from SB, ISB, MC, and IMC,
which can be expressed as XOR/AND-based bit-level
equations in terms of individual binary bits of the inputs. In
this paper, we propose a new bit-level CSE method to reduce
both the area and delay of these XOR/AND-based
sum-of-product (SoP) expressions.
III. Proposed CSE Method
Our CSE method is composed of two stages. In the first
stage, we extract the AND-based common factors ( baï‚· ) if
available. In the second stage, we extract XOR-based
common factors ( baïƒ… ). In each stage, we determine the
selection of a common factor based on four priority rules as
shown in Fig. 3 in order to increase the chance of extracting
more shared subexpressions in the subsequent iterations,
leading to more area saving. The four rules are used with
priority in the order to select the common factors (CF) in the
bit-level SoP equations composed of AND and XOR
operations only. Each subsequent rule is applied only when
there is a tie in CF selection, i.e., only when there are two or
more C.F found using the previous rules.
In the following, we explain our CSE method using the
bit-level expression of the affine transformation:
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒ»
ïƒ¹
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒ«
ïƒ©
ï€«ï€«ï€«ï€«
ï€«ï€«ï€«ï€«ï€«
ï€«ï€«ï€«ï€«ï€«
ï€«ï€«ï€«ï€«
ï€«ï€«ï€«ï€«
ï€«ï€«ï€«ï€«
ï€«ï€«ï€«ï€«ï€«
ï€«ï€«ï€«ï€«ï€«
ï€½
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒ»
ïƒ¹
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒ«
ïƒ©
76543
65432
54321
43210
73210
76210
76510
76540
7
6
5
4
3
2
1
0
1
1
1
1
aaaaa
aaaaa
aaaaa
aaaaa
aaaaa
aaaaa
aaaaa
aaaaa
w
w
w
w
w
w
w
w
(7)
Eqn. (7) has only XOR operations (+). Hence, we only
need to perform the second stage in Fig. 3 with the four
same rules shown in Fig. 3. After applying priority rule 1 in
Fig. 3, we find 9 candidates of two-term CFs with the same
maximum occurrence count of 4 across entire 8 bit-level
equations in Eqn. (7). These 9 candidates are
ï€¨ ï€©10 ,aa , ï€¨ ï€©70 , aa , ï€¨ ï€©21 , aa , ï€¨ ï€©32 , aa , ï€¨ ï€©43 , aa ,
ï€¨ ï€©54 , aa , ï€¨ ï€©65 , aa , ï€¨ ï€©1,5a , ï€¨ ï€©76 , aa (8)
Continuing for the 9 CFs in Eqn. (8), we apply priority
rule 2 in Fig. 3 and reduce the candidates to the following 7
CFs
ï€¨ ï€©10 ,aa , ï€¨ ï€©70 , aa , ï€¨ ï€©21 , aa , ï€¨ ï€©32 , aa , ï€¨ ï€©43 , aa ,
ï€¨ ï€©1,5a , ï€¨ ï€©76 , aa (9)
that have the same least correlation because the index pair of
each CF in Eqn. (9) appears only 3 times in the 9 CFs in Eqn.
(8) while the index pair (4,5) in CF ï€¨ ï€©54 , aa appear 4
times in the 9 CFs in Eqn. (8). Similarly, the index pair (5, 6)
in ï€¨ ï€©65 , aa appears 4 times in the CFs of Eqn. (8). Thus,
ï€¨ ï€©54 , aa and ï€¨ ï€©65 , aa that have more correlation with
other CFs are removed from the choices, leading to the
remaining 7 candidates in Eqn. (9).
Afterward, we apply priority rule 3 in Fig. 3 and find
that the extraction of CF ï€¨ ï€©1,5a in Eqn. (9) leads to the
most terms in the 8 bit-level equations. Thus, the CF
ï€¨ ï€© )(~1, 551 aaX ï€½ï€½ is selected in the first iteration.
After performing the entire CSE algorithm of Fig. 3 with
a total of 8 iterations, we can find all the shared CFs of
821 ,,, XXX ïŒ and the final results can be expressed as
318
517
426
225
104
763
432
51
325
76
71
54
673
63
84
840
7
6
5
4
3
2
1
0 )(~
with
XXX
XXX
XaX
XaX
aaX
aaX
aaX
aX
XXa
Xa
Xa
XX
Xaa
XX
XX
Xaa
w
w
w
w
w
w
w
w
ï€«ï€½
ï€«ï€½
ï€«ï€½
ï€«ï€½
ï€«ï€½
ï€«ï€½
ï€«ï€½
ï€½
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒ»
ïƒ¹
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒ«
ïƒ©
ï€«ï€«
ï€«
ï€«
ï€«
ï€«ï€«
ï€«
ï€«
ï€«ï€«
ï€½
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒº
ïƒ»
ïƒ¹
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒª
ïƒ«
ïƒ©
(10)
We calculate the area cost and delay of the results by
using 2-input gates in architecture level. For example, the
AXOR is the area cost of 2-input AND gate and the TXOR is the
delay of the gate. The AINV is the area cost of inverter gate
and the TINV is the delay of the gate.
The original implementation of Eqn. (7) requires an area
of INVXOR AA 432 ï€« with critical path delay INVXOR TT ï€«3 .
After applying the proposed CSE algorithm in Fig. 3, we
obtain Eqn. (10) that can be realized with area cost reduced
to INVXOR AA 118 ï€« while keeping the same critical path
delay.
Our CSE Algorithm
Input: A set of bit-level equations consists of SoPs.
Output: A set of modified equations with the extracted common factors (CF).
Stage 1: Extract the two-term CF of AND-based operations by using the following priority rules:
â€“Priority 1: Find the CF with highest occurrence count across all bit-level equations.
â€“Priority 2: Select CF with the index pair that has the least correlation with other CF index pairs.
â€“Priority 3: Chose CF that leads to the most remaining terms.
â€“Priority 4: Find the CF that leads to the largest CF occurrence count in the next iteration.
Stage 2: Extract the two-term CF of XOR-based operations by using the above priority rules.
Fig. 4 Iterative processor design for AES cipher and direct cipher
B. Comparison of AES Processor Implementations
Fig. 4 shows an iterative AES processor design by
merging the cipher process and the direct decipher process
with shared MI in GF((24)2) for the SB and ISB. The data
path is 128-bit wide with 128-bit keys, i.e., a total of 16
bytes are generated concurrently in each cycle. We first
derive the bit-level SoP equations for all the transformations
required in the AES architecture of Fig. 4, and then apply
the CES algorithm of Fig. 3 to these equations and extract as
many common factors as possible. As been shown in Tables
I and II, the area costs of realizing these transformations are
significantly reduced compared with other approaches.
Table III compares the area and delay of synthesized
individual components in the AES processor with and
without using the proposed CSE. The total area is reduced
by a factor of 12% at the cost of slightly increased critical
path delay compared with Synopsys area-optimized
synthesis without CSE. We also compare different AES
processor designs as shown in Table IV. The design in [2]
adopts ROM-based S-box implementation method and
allows the selections of 128/192/256-bit data blocks with
128/192/256-bit key. So, it spends more area cost in
realizing the major transformations for processing different
lengths of data blocks. Besides, the ROM-based S-box
implementation in [2] takes more area cost in the realization
compared with other methods.
In [6], a substantial portion of the area cost is spent on
memory used to store the lookup value of SB, ISB, MC,
IMC, and round keys. The AES design in [4] has relatively
small area cost due to the sharing of the MI logic in SB and
ISB, and the merging of MC and IMC. The T-box method in
[7] uses many ROMs to store different values of the
combined SB/MC and ISB/IMC. Compared with the
previous methods, our AES design has the smallest area cost
due to the efficient CSE algorithm for the extraction of
common factors.
Table V shows the chip information of the designed AES
processor. Due to the limitation of pin counts, we adopts the
128-bit AES core and design two 8-bit wide bus interfaces
(one for input, the other for output) for transferring 8-bit
data per cycle. So, it will spend 16 cycles for transferring
128-bit data block. The fabrication of the chip uses UMC
0.18um 1P6M (one-poly six-metal) process and the die size
is about 1.197mm2. The total gate count of the proposed
AES design is approximately 25.4K including the scan chain
for testability, the 8-bit wide bus interfaces, and the 128-bit
AES core. Our AES core can operate at 90 MHz with area of
17.1K gates, leading to a throughput rate of 1.05Gbps.
TABLE III
Synthesis results of all 128-bit AES components using Synopsys
Design Compiler with Artisan UMC 0.18um library
Without CSE With Our CSELevels
Modules
Area
(gate)
Delay
(ns)
Area
(gate)
Delay
(ns)
IMC 3260 1.37 1800 2.14
ISR/AF 592 0.49 528 0.49
T 512 0.47 512 0.47
MI in
GF(24)
4032 2.71 3776 2.49
MI
in
GF((24)2)
T-1 864 0.76 640 0.80
AF/SR 912 1.18 768 1.13
MC 1300 0.73 1152 0.83
32-b SB 1308 4.35 1233 3.93KE
Reg.& MUX 2988 3.22 2988 3.22
2*ARK (256AXOR) 682 0.14 682 0.14
5*128-b MUX
(640AMUX)
1920 0.14 1920 0.14
Round Control 79 2.92 79 2.92
128-b Reg. 981 0.23 981 0.23
Total 19430 10.47 17059 11.04
KE: the key expansion unit;
å››ã€è¨ˆç•«æˆæœè‡ªè©•
æœ¬è¨ˆç•«å…ˆé€²åŠ å¯†æ¼”ç®—æ³•ä¹‹ä½è€—é›»è¨­è¨ˆèˆ‡å¯¦ä½œ (I)ï¼Œåœ¨åœ‹ç§‘æœƒç¶“è²»çš„æ”¯æŒä¸‹ï¼Œè‡ª 97
å¹´ 08 æœˆ 01 æ—¥åŸ·è¡Œè‡³ 98 å¹´ 07 æœˆ 31 æ—¥æ­¢è¨ˆç•«åŸ·è¡Œï¼Œå…±ç”¢å‡ºä¸€ç¯‡æœŸåˆŠè«–æ–‡åŠäº”ç¯‡æœƒè­°è«–
æ–‡ï¼Œä¸”é€é CIC åœ‹å®¶æ™¶ç‰‡ä¸­å¿ƒï¼Œä¸‹ç·šä¸€é¡† AES æ™¶ç‰‡ã€‚
(1) æœŸåˆŠè«–æ–‡ï¼š
[1] Ming-Chih Chen, Shen-Fu Hsiao, â€œLow Cost Design of an Advanced Encryption
Standard (AES) Processor Using a New Common-Subexpression-Elimination
Algorithm,â€ IEICE Transactions on Fundamentals of Electronics,
Communications and Computer Sciences, Dec. 2009. (Accepted)
(2) ç ”è¨æœƒè«–æ–‡ï¼š
[1] Ming-Chih Chen, and Shen-Fu Hsiao, â€œLow Cost Design of an Advanced
Encryption Standard (AES) Processor Using a New
Common-Subexpression-Elimination,â€Proceedings of The 15th Workshop on
Synthesis And System Integration of Mixed Information Technologies (SASIMI 2009),
pp. 242-247, March 2009. (Japan)
[2] å¼µè‚‡è»’, é™³éŠ˜å¿—, 32 ä½å…ƒä½é¢ç©å…ˆé€²åŠ å¯†æ™¶ç‰‡å¯¦ä½œ, No. 269, 2009 å¹´è³‡è¨Šç§‘æŠ€
åœ‹éš›ç ”è¨æœƒ, April 2009. (Taiwan)
[3] å¼µè‚‡è»’, é™³éŠ˜å¿—, ä½æˆæœ¬å…ˆé€²åŠ å¯†æ™¶ç‰‡å¯¦ä½œ, 2009 å¹´é«˜ç§‘å¤§é›»æ©Ÿè³‡è¨Šå­¸é™¢å¸«ç”Ÿ
ç ”ç™¼æˆæœç ”è¨æœƒ, pp. 124-129, May 2009. (Taiwan)
[4] é™³å»ºèˆˆ, æä½™è€€, ç‹æ­£å»·, é™³éŠ˜å¿—, RFID æŠ€è¡“æ‡‰ç”¨æ–¼é™ä½ç¸½ç‰›ä¹³å—æ±¡æŸ“ä¹‹é¢¨éšª,
2009å…¨åœ‹æš¨å…©å²¸ RFIDç§‘æŠ€è«–æ–‡ç ”è¨æœƒ.
[5] Ming-Chih Chen, and Shen-Fu Hsiao, â€œEficient Hardware Realization of 
Transformations in Advanced Encryption Standard Using a New
Common-Subexpression-Elimination Algorithm,â€ Proceedings of The 16th
National Conference on Automation Technology, pp. 1201-1205, June 2008.
(Taiwan)
[6] Ming-Chih Chen, â€œLow Cost Design of An Advanced Encryption Standard (AES) 
Processor Using Efficient Bit-Level Common Sub-expression Elimination,â€ 2008
å¹´é«˜ç§‘å¤§é›»æ©Ÿè³‡è¨Šå­¸é™¢å¸«ç”Ÿç ”ç™¼æˆæœç ”è¨æœƒ, May 2008. (Taiwan)
[7] é™³å»ºèˆˆ, æä½™è€€, ç‹æ­£å»·, é™³éŠ˜å¿—, ç„¡ç·šå°„é »è¾¨è­˜æŠ€è¡“æ‡‰ç”¨æ–¼ä¹³ç‰›åˆ†æˆ¿æ¾ä¹³çš„
ç®¡ç†, 2008å¹´æ°‘ç”Ÿé›»å­ç ”è¨æœƒ, pp. 436-438, Dec., 2008.
(3) æ™¶ç‰‡ä¸‹ç·šï¼š
[1] ä½æˆæœ¬ä¹‹ 8 ä½å…ƒ AES æ™¶ç‰‡è¨­è¨ˆ(T18-98C-11a)ã€‚
æŠ€è¡“èªªæ˜
ä¸­æ–‡ï¼š
åœ¨æœ¬è¨­è¨ˆè£¡ï¼Œæˆ‘å€‘å¯¦ç¾ä¸‰ç¨®ä¸åŒä½å…ƒæ•¸ä¹‹å…ˆé€²åŠ å¯†æ¨™æº–
(Advanced Encryption Standardï¼Œç°¡ç¨± AES)æ¼”ç®—æ³•ï¼ŒåŒ…ï¼š32 ä½å…ƒã€
16 ä½å…ƒåŠ 8 ä½å…ƒç­‰ä¸‰ç¨®ä¸åŒè³‡æ–™è·¯å¾‘å¯¬åº¦çš„ç¡¬é«”è¨­è¨ˆã€‚è€Œåœ¨ AES
æ¼”ç®—æ³•è£¡ï¼Œå…±æœ‰ä¸‰ç¨®æµç¨‹ï¼šåŠ å¯†æµç¨‹ã€ç›´æ¥è§£å¯†æµç¨‹åŠæ”¹è‰¯å¼è§£å¯†
æµç¨‹ç­‰ã€‚åœ¨çµåˆåŠ å¯†èˆ‡è§£å¯†æµç¨‹æ™‚ï¼Œä¸€èˆ¬æœ‰å…©ç¨®æ–¹å¼ï¼šåŠ å¯†èˆ‡ç›´æ¥
è§£å¯†æµç¨‹çµåˆã€åŠ å¯†èˆ‡æ”¹è‰¯å¼è§£å¯†æµç¨‹çµåˆã€‚å› æ­¤ï¼Œç•¶å¯¦ç¾ 32 ä½
å…ƒè³‡æ–™è·¯å¾‘å¯¬çš„ AES æ¼”ç®—æ³•æ™‚ï¼Œä¾¿æœ‰å…©ç¨®ä¸åŒçš„å¯¦ç¾æ–¹å¼ï¼Œè€ŒåŒ…
å« 16 ä½å…ƒåŠ 8 ä½å…ƒä¹Ÿæ˜¯ã€‚åœ¨æœ¬è«–æ–‡è£¡ï¼Œæˆ‘å€‘å°‡å¯¦ç¾ä¸Šè¿°æ‰€æœ‰çš„æ¶
æ§‹ä¸”èˆ‡å…¶ä»–æ–‡ç»æ‰€æä¹‹çµæœåšæ¯”è¼ƒã€‚
åœ¨å¾ˆå¤šæ–‡ç»å…§æåˆ°ï¼Œå¦‚ä½•æ”¹è‰¯ AES æ‰€éœ€è¦çš„é›»è·¯é¢ç©æˆ–æ˜¯é‹
ç®—é€Ÿåº¦ï¼Œé€éåˆ©ç”¨ä¸åŒçš„æ¶æ§‹è¨­è¨ˆï¼Œé‡å° AES éƒ¨åˆ†çš„è½‰æ›å‡½æ•¸åš
åŒ–ç°¡ä»¥é”åˆ°ç¯€çœé¢ç©æˆ–æ˜¯åˆ©ç”¨ç®¡ç·šåŒ–æŠ€è¡“æé«˜å…¶é‹ç®—èƒ½åŠ›ï¼Œè€Œæœ¬è«–
æ–‡çš„é‡é»å‰‡æ˜¯è‘—é‡åœ¨å¦‚ä½•åœ¨ä¸å¤§å¹…é™ä½å…¶é‹ç®—èƒ½åŠ›ï¼Œå¯ä»¥ç¬¦åˆä¸€èˆ¬
åµŒå…¥å¼ç³»çµ±çš„æ‡‰ç”¨ï¼Œä¸”å¯ä»¥é€²ä¸€æ­¥ç¯€çœ AES çš„é›»è·¯é¢ç©ï¼Œä½¿æ•ˆèƒ½
èˆ‡é›»è·¯é¢ç©äºˆä»¥å¹³è¡¡ã€‚
åœ¨æˆ‘å€‘çš„è¨­è¨ˆè£¡ï¼Œå° AES çš„é›»è·¯é¢ç©æœ‰å…©å€‹æ”¹è‰¯çš„æ–¹å¼ï¼šç¬¬
ä¸€ï¼Œæ˜¯åˆ©ç”¨æ¶æ§‹ä¸Šçš„è¨­è¨ˆï¼Œåœ¨ä¸çŠ§ç‰²é‹ç®—çš„å›åˆæ•¸(cycle)ä¸‹ï¼Œè¨­è¨ˆ
å‡ºç›¸é—œçš„è½‰æ›å‡½æ•¸æ¶æ§‹ï¼›ç¬¬äºŒï¼Œæ˜¯åˆ©ç”¨ä¸€å€‹å…±åŒå­é‹ç®—å¼åŒ–ç°¡
(Common Sub-expression Elimination,CSE)æ¼”ç®—æ³•ä¾†ç²¾ç°¡è½‰æ›å‡½æ•¸
å…§çš„ AND åŠ XOR é‚è¼¯é–˜æ•¸ç›®ï¼Œä»¥é”åˆ°é›»è·¯é¢ç©æ›´ç²¾ç°¡ã€‚ä¸‰ç¨®ä¸
åŒä½å…ƒçš„æ¶æ§‹ä¸Šå’Œå…ˆå‰çš„æ–‡ç»ä½œæ¯”è¼ƒï¼Œ32 ä½å…ƒã€16 ä½å…ƒåŠ 8 ä½å…ƒ
æ¶æ§‹ç¢ºå¯¦æœ‰é”åˆ°ä¸€å€‹ä½æˆæœ¬è€ƒé‡çš„è¨­è¨ˆï¼Œä¸”æˆ‘å€‘æå‡ºçš„ 8 ä½å…ƒæ¶æ§‹
è¨­è¨ˆæ˜¯ä»¥æœ€å°‘é‹ç®—çš„ cycle æ•¸ç‚ºå‰æä¾†åšä½æˆæœ¬è¨­è¨ˆï¼Œå…¶é¢ç©å’Œæ•ˆ
èƒ½æ¯”ï¼Œçš†æ¯”å…¶ä»–ç¾æœ‰çš„è¨­è¨ˆæ›´å¥½ã€‚
å¯åˆ©ç”¨ä¹‹ç”¢æ¥­
åŠ
å¯é–‹ç™¼ä¹‹ç”¢å“
å¯åˆ©ç”¨ç”¢æ¥­: IC è¨­è¨ˆç”¢æ¥­
å¯é–‹ç™¼ç”¢å“: network security, hardware encryption, storage devices.
æŠ€è¡“ç‰¹é»
1. 128/32/16/8-bit AES versions
2. Low area cost designs
3. Balanced area cost and performance designs
æ¨å»£åŠé‹ç”¨çš„åƒ¹å€¼
æˆ‘å€‘çš„è¨­è¨ˆç‚ºå°é¢ç©åŠå…¼é¡§æ•ˆèƒ½ä¹‹è¨­è¨ˆï¼Œå¯ä½¿ç”¨åœ¨åµŒå…¥å¼ç³»çµ±ã€ç¶²
è·¯é€šè¨ŠåŠå„²å­˜è£ç½®çš„ç¡¬é«”åŠ è§£å¯†ä¸Šã€‚
â€» 1.æ¯é …ç ”ç™¼æˆæœè«‹å¡«å¯«ä¸€å¼äºŒä»½ï¼Œä¸€ä»½éš¨æˆæœå ±å‘Šé€ç¹³æœ¬æœƒï¼Œä¸€ä»½é€ è²´å–®ä½
ç ”ç™¼æˆæœæ¨å»£å–®ä½ï¼ˆå¦‚æŠ€è¡“ç§»è½‰ä¸­å¿ƒï¼‰ã€‚
â€» 2.æœ¬é …ç ”ç™¼æˆæœè‹¥å°šæœªç”³è«‹å°ˆåˆ©ï¼Œè«‹å‹¿æ­éœ²å¯ç”³è«‹å°ˆåˆ©ä¹‹ä¸»è¦å…§å®¹ã€‚
â€» 3.æœ¬è¡¨è‹¥ä¸æ•·ä½¿ç”¨ï¼Œè«‹è‡ªè¡Œå½±å°ä½¿ç”¨ã€‚
Low Cost Design of an Advanced Encryption Standard (AES) Processor
Using a New Common-Subexpression-Elimination Algorithm
Abstract - In this paper, we propose an area-efficient design of
Advanced Encryption Standard (AES) processor by applying a
new common-expression-elimination (CSE) method to the
sub-functions of various transformations in AES. The proposed
method reduces the area cost of realizing the sub-functions by
extracting the common factors in the bit-level expressions of
these sub-functions using a new CSE algorithm. Cell-based
implementation results show that the AES processor with our
proposed CSE method has significant area improvement
compared with previous designs.
I. Introduction
The Rijndael block cipher algorithm was selected as the
Advanced Encryption Standard (AES) to replace the former
data encryption standard (DES) [1]. The algorithm is a
symmetric block cipher that processes data blocks of 128
bits organized as a 44u matrix of bytes, called a state. A
state is operated by Nr=10, 12, or 14 rounds of
transformations with key length equal to 128, 192, or 256
bits respectively. Four transformations including SubBytes
(SB), ShiftRows (SR), MixColumns (MC), and
AddRoundKey (ARK) are performed in the encryption
process. A separate KeyExpansion (KE) unit is required to
generate the round key for each ARK. Fig. 1(a) shows the
encryption structure of the AES algorithm where the initial
key is added (bit-wise XOR operation) to the input plaintext,
followed by a sequence of transformations. After performing
the final round, the output ciphertext is generated. The direct
decryption algorithm in Fig. 1(b) performs the reverse data
flow where four inverse transformations, InvSubBytes (ISB),
InvShiftRows (ISR), InvMixColumns (IMC), and
AddRoundKey (ARK), are performed instead.
By exploiting common subexpression elimination (CSE)
in different levels of granularity (such as architecture-level,
byte-level or bit-level), the hardware complexity of AES
implementations can be reduced significantly [2-12]. This
paper presents a new bit-level CSE algorithm that results in
more efficient AES implementation compared with previous
designs.
The paper organization is as follows. Sec. II surveys
several previous implementation schemes for SB, ISB, MC,
and IMC. In Sec. III, a new bit-level substructure sharing
method is presented. Performance comparisons in both the
architecture-level designs and the cell-based
implementations are given in Sec. IV, followed by
conclusions in Sec. V.
(a) (b)
Fig. 1 AES (a) encryption and (b) direct decryption flows
Ming-Chih Chen
Dept. of Electronic Engineering
National Kaohsiung First University
of Science and Technology
Kaohsiung, Taiwan, 81164
Tel: 886-7-6011000 ext 2510
Fax: 886-7-6011386
e-mail: mjchen@ccms.nkfust.edu.tw
Shen-Fu Hsiao
Dept. of Computer Science and Engineering
National Sun Yat-Sen University
Kaohsiung, Taiwan, 80424
Tel: 886-7-5252000 ext 4314
Fax: 886-7-5254301
e-mail: sfhsiao@cse.nsysu.edu.tw
Fig. 3 The proposed CSE algorithm
As mentioned, major area costs in realizing the entire
AES cipher/decipher are from SB, ISB, MC, and IMC,
which can be expressed as XOR/AND-based bit-level
equations in terms of individual binary bits of the inputs. In
this paper, we propose a new bit-level CSE method to reduce
both the area and delay of these XOR/AND-based
sum-of-product (SoP) expressions.
III. Proposed CSE Method
Our CSE method is composed of two stages. In the first
stage, we extract the AND-based common factors ( ba x ) if
available. In the second stage, we extract XOR-based
common factors ( baÂ† ). In each stage, we determine the
selection of a common factor based on four priority rules as
shown in Fig. 3 in order to increase the chance of extracting
more shared subexpressions in the subsequent iterations,
leading to more area saving. The four rules are used with
priority in the order to select the common factors (CF) in the
bit-level SoP equations composed of AND and XOR
operations only. Each subsequent rule is applied only when
there is a tie in CF selection, i.e., only when there are two or
more C.F found using the previous rules.
In the following, we explain our CSE method using the
bit-level expression of the affine transformation:
Â»Â»
Â»Â»
Â»Â»
Â»Â»
Â»Â»
Â»
Â¼
Âº
Â«Â«
Â«Â«
Â«Â«
Â«Â«
Â«Â«
Â«
Â¬
Âª








 
Â»Â»
Â»Â»
Â»Â»
Â»Â»
Â»Â»
Â»
Â¼
Âº
Â«Â«
Â«Â«
Â«Â«
Â«Â«
Â«Â«
Â«
Â¬
Âª
76543
65432
54321
43210
73210
76210
76510
76540
7
6
5
4
3
2
1
0
1
1
1
1
aaaaa
aaaaa
aaaaa
aaaaa
aaaaa
aaaaa
aaaaa
aaaaa
w
w
w
w
w
w
w
w
(7)
Eqn. (7) has only XOR operations (+). Hence, we only
need to perform the second stage in Fig. 3 with the four
same rules shown in Fig. 3. After applying priority rule 1 in
Fig. 3, we find 9 candidates of two-term CFs with the same
maximum occurrence count of 4 across entire 8 bit-level
equations in Eqn. (7). These 9 candidates are 10 ,aa ,  70 ,aa ,  21 , aa ,  32 ,aa ,  43 ,aa , 54 ,aa ,  65 ,aa ,  1,5a ,  76 ,aa (8)
Continuing for the 9 CFs in Eqn. (8), we apply priority
rule 2 in Fig. 3 and reduce the candidates to the following 7
CFs 10 ,aa ,  70 , aa ,  21 , aa ,  32 ,aa ,  43 ,aa , 1,5a ,  76 ,aa (9)
that have the same least correlation because the index pair of
each CF in Eqn. (9) appears only 3 times in the 9 CFs in Eqn.
(8) while the index pair (4,5) in CF  54 ,aa appear 4
times in the 9 CFs in Eqn. (8). Similarly, the index pair (5, 6)
in  65 ,aa appears 4 times in the CFs of Eqn. (8). Thus, 54 , aa and  65 ,aa that have more correlation with
other CFs are removed from the choices, leading to the
remaining 7 candidates in Eqn. (9).
Afterward, we apply priority rule 3 in Fig. 3 and find
that the extraction of CF  1,5a in Eqn. (9) leads to the
most terms in the 8 bit-level equations. Thus, the CF  )(~1, 551 aaX   is selected in the first iteration.
After performing the entire CSE algorithm of Fig. 3 with
a total of 8 iterations, we can find all the shared CFs of
821 ,,, XXX  and the final results can be expressed as
318
517
426
225
104
763
432
51
325
76
71
54
673
63
84
840
7
6
5
4
3
2
1
0 )(~
with
XXX
XXX
XaX
XaX
aaX
aaX
aaX
aX
XXa
Xa
Xa
XX
Xaa
XX
XX
Xaa
w
w
w
w
w
w
w
w
 
 
 
 
 
 
 
 
Â»Â»
Â»Â»
Â»Â»
Â»Â»
Â»Â»
Â»
Â¼
Âº
Â«Â«
Â«Â«
Â«Â«
Â«Â«
Â«Â«
Â«
Â¬
Âª








 
Â»Â»
Â»Â»
Â»Â»
Â»Â»
Â»Â»
Â»
Â¼
Âº
Â«Â«
Â«Â«
Â«Â«
Â«Â«
Â«Â«
Â«
Â¬
Âª
(10)
We calculate the area cost and delay of the results by
using 2-input gates in architecture level. For example, the
AXOR is the area cost of 2-input AND gate and the TXOR is the
delay of the gate. The AINV is the area cost of inverter gate
and the TINV is the delay of the gate.
The original implementation of Eqn. (7) requires an area
of INVXOR AA 432  with critical path delay INVXOR TT 3 .
After applying the proposed CSE algorithm in Fig. 3, we
obtain Eqn. (10) that can be realized with area cost reduced
to INVXOR AA 118  while keeping the same critical path
delay.
Our CSE Algorithm
Input:A set of bit-level equations consists of SoPs.
Output:A set of modified equations with the extracted common factors (CF).
Stage 1: Extract the two-term CF of AND-based operations by using the following priority rules:
Â± Priority 1: Find the CF with highest occurrence count across all bit-level equations.
Â± Priority 2: Select CF with the index pair that has the least correlation with other CF index pairs.
Â± Priority 3: Chose CF that leads to the most remaining terms.
Â± Priority 4: Find the CF that leads to the largest CF occurrence count in the next iteration.
Stage 2: Extract the two-term CF of XOR-based operations by using the above priority rules.
Fig. 4 Iterative processor design for AES cipher and direct cipher
B. Comparison of AES Processor Implementations
Fig. 4 shows an iterative AES processor design by
merging the cipher process and the direct decipher process
with shared MI in GF((24)2) for the SB and ISB. The data
path is 128-bit wide with 128-bit keys, i.e., a total of 16
bytes are generated concurrently in each cycle. We first
derive the bit-level SoP equations for all the transformations
required in the AES architecture of Fig. 4, and then apply
the CES algorithm of Fig. 3 to these equations and extract as
many common factors as possible. As been shown in Tables
I and II, the area costs of realizing these transformations are
significantly reduced compared with other approaches.
Table III compares the area and delay of synthesized
individual components in the AES processor with and
without using the proposed CSE. The total area is reduced
by a factor of 12% at the cost of slightly increased critical
path delay compared with Synopsys area-optimized
synthesis without CSE. We also compare different AES
processor designs as shown in Table IV. The design in [2]
adopts ROM-based S-box implementation method and
allows the selections of 128/192/256-bit data blocks with
128/192/256-bit key. So, it spends more area cost in
realizing the major transformations for processing different
lengths of data blocks. Besides, the ROM-based S-box
implementation in [2] takes more area cost in the realization
compared with other methods.
In [6], a substantial portion of the area cost is spent on
memory used to store the lookup value of SB, ISB, MC,
IMC, and round keys. The AES design in [4] has relatively
small area cost due to the sharing of the MI logic in SB and
ISB, and the merging of MC and IMC. The T-box method in
[7] uses many ROMs to store different values of the
combined SB/MC and ISB/IMC. Compared with the
previous methods, our AES design has the smallest area cost
due to the efficient CSE algorithm for the extraction of
common factors.
Table V shows the chip information of the designed AES
processor. Due to the limitation of pin counts, we adopts the
128-bit AES core and design two 8-bit wide bus interfaces
(one for input, the other for output) for transferring 8-bit
data per cycle. So, it will spend 16 cycles for transferring
128-bit data block. The fabrication of the chip uses UMC
0.18um 1P6M (one-poly six-metal) process and the die size
is about 1.197mm2. The total gate count of the proposed
AES design is approximately 25.4K including the scan chain
for testability, the 8-bit wide bus interfaces, and the 128-bit
AES core. Our AES core can operate at 90 MHz with area of
17.1K gates, leading to a throughput rate of 1.05Gbps.
TABLE III
Synthesis results of all 128-bit AES components using Synopsys
Design Compiler with Artisan UMC 0.18um library
Without CSE With Our CSELevels
Modules
Area
(gate)
Delay
(ns)
Area
(gate)
Delay
(ns)
IMC 3260 1.37 1800 2.14
ISR/AF 592 0.49 528 0.49
T 512 0.47 512 0.47
MI in
GF(24)
4032 2.71 3776 2.49
MI
in
GF((24)2)
T-1 864 0.76 640 0.80
AF/SR 912 1.18 768 1.13
MC 1300 0.73 1152 0.83
32-b SB 1308 4.35 1233 3.93KE
Reg.& MUX 2988 3.22 2988 3.22
2*ARK (256AXOR) 682 0.14 682 0.14
5*128-b MUX
(640AMUX)
1920 0.14 1920 0.14
Round Control 79 2.92 79 2.92
128-b Reg. 981 0.23 981 0.23
Total 19430 10.47 17059 11.04
KE: the key expansion unit;
