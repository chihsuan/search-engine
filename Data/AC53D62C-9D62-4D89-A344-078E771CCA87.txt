2Â 
Â 
ä¸­æ–‡æ‘˜è¦ 
æœ¬è¨ˆç•«ä¹‹ç›®æ¨™ç‚ºç™¼å±•ä¸‰ç¶­é›»è…¦ç¹ªåœ–ä¹‹ç³»çµ±æ™¶ç‰‡ï¼Œæ­¤ç³»çµ±æ™¶ç‰‡ä»¥å…·æœ‰åŠæ™‚æ•ˆèƒ½/åŠŸ
ï¥¡ç›£æ§çš„é«˜æ•ˆï¥¡å¯ç¨‹å¼åŒ–ä¸‰ç¶­é›»è…¦ç¹ªåœ–æ™¶ç‰‡ç³»çµ±ç‚ºç ”ç©¶ç›®æ¨™ï¼Œåœ¨ç¬¬ä¸€ï¦åŸ·ï¨ˆè¨ˆç•«
ï§¨ï¼Œæœ¬åœ˜éšŠé€éç³»çµ±æ¨¡å‹çš„å»ºï§·ï¼Œå°è»Ÿç¡¬é«”æ•´åˆé€²ï¨ˆè©•ä¼°èˆ‡åˆ†æï¼Œä¸¦é‡å°è»Ÿç¡¬é«”
ç³»çµ±æ•´åˆï¼Œæå‡ºç³»çµ±æ™¶ç‰‡çš„é©—è­‰æ–¹æ³•ï¼Œæ­¤ç‚ºç¬¬ä¸€ï¦è¨ˆç•«çš„åŸ·ï¨ˆã€‚ç¬¬äºŒï¦çš„ç ”ç©¶è¨ˆ
ç•«å»¶çºŒç¬¬ä¸€ï¦çš„ç ”ç©¶æˆæœèˆ‡è¦åŠƒï¼Œä¸¦å®Œæˆç›®æ¨™ä¹‹å¯¦ç¾ï¼šä¸»è¦ä»¥å»ºï§·è»Ÿç¡¬é«”æ•´åˆçš„
åˆ†æå·¥å…·ä»¥åŠ é€Ÿç³»çµ±æ™¶ç‰‡çš„é™¤éŒ¯æ™‚ç¨‹ï¼Œä¸¦å»ºï§·ç³»çµ±æ™¶ç‰‡çš„å³æ™‚æ•ˆèƒ½åˆ†æå·¥å…·ï¼Œä»¥
å³æ™‚æ•ˆèƒ½åˆ†æç‚ºåŸºç¤ï¼Œå¦å¤–å»ºï§·é›»å­ç³»çµ±å±¤ç´šæ¨¡çµ„ï¤­è©•ä¼°ç³»çµ±æ™¶ç‰‡åŠŸï¥¡çš„æ¶ˆè€—ï¼Œ
ä»¥é”æˆä½åŠŸï¥¡è¼¸å‡ºçš„ç›®æ¨™ï¼Œä»¥åŠæ•´åˆæ™¶ç‰‡çš„é©—è­‰æ–¹æ³•ï¼Œä¸¦è¦åŠƒæ™¶ç‰‡çš„æ¸¬è©¦æ©Ÿåˆ¶ã€‚
ç¬¬ä¸‰ï¦çš„ç ”ç©¶è¨ˆç•«ä¸»è¦ä»¥(1)QEMU-SystemCå¹³å°çš„å»ºç½®ï¼Œï§ç”¨è»Ÿé«”çš„æ–¹å¼æ¨¡æ“¬å¯¦
éš›ç¡¬é«”åœ¨FPGAä¸Šçš„ï¨ˆç‚ºï¼Œä»¥å¢åŠ è»Ÿç¡¬é«”ä¹‹é–“çš„æ•´åˆé€Ÿï¨ï¼Œ(2)ä¸‰ç¶­é›»è…¦ç¹ªåœ–æ™¶ç‰‡
åœ¨è™¹æ™¶(Socle)ç§‘æŠ€ä¹‹MDK-FPGAä¸Šå®Œæˆä¹‹æ•´åˆé©—è­‰ï¼Œç‚ºåŠ é€Ÿåœ¨æ•´åˆèˆ‡é©—è­‰æ™‚çš„
æ•ˆï¥¡ä»¥åŠå¢åŠ å„IPä¹‹ä½¿ç”¨ï¥¡ï¼Œæ•´åˆï¦ºå·¥æ¥­æ¨™æº–åŒ–ä¹‹(3)OCP-IPå¯æ“´å……æ€§ä»‹é¢æ–¼ä¸‰
ç¶­åœ–å½¢æ™¶ç‰‡ç³»çµ±ä¸­ã€‚ä»¥ä¸Šæ‰€æåŠä¹‹ä¸‰å¤§ä¸»é¡Œ(Topic)å°‡æ–¼å ±å‘Šä¸­é€ä¸€å‘ˆç¾èˆ‡ä»‹ç´¹ï¼š 
 Topic 1ï¼šQEMU-SystemC Abstraction Level Design and Verification Mechanism  
 Topic 2ï¼šFPGA Prototyping of the 3D Graphic SoC 
 Topic 3ï¼šOCP-AHB Bus Interface for 3D Graphic SoC Integration   
(å„ç« ç¯€ä¹‹ç ”ç©¶å‹•æ©Ÿã€ç›®çš„ã€æ–¹æ³•ã€é å®šå®Œæˆä¹‹å·¥ä½œé …ç›®èˆ‡é æœŸä¹‹è²¢ç»å°‡åˆ†åˆ¥æ–¼
å„ç« ç¯€ä¸­æ•˜è¿°) 
 
é—œéµè©ï¼šä¸‰ç¶­åœ–å½¢ç³»çµ±æ™¶ç‰‡ã€æ•ˆèƒ½ç›£æ§ã€è€—èƒ½ç›£æ§ã€ç³»çµ±æ™¶ç‰‡é©—è­‰ã€ç³»çµ±æ™¶ç‰‡é™¤
éŒ¯ã€é›»å­ç³»çµ±å±¤ç´šæ¨¡çµ„ 
 
 
 
 
 
 
 
 
 
 
 
 
4Â 
Â 
ç›®    ï¤¿ 
ä¸­æ–‡æ‘˜è¦............................................................2 
Abstract............................................................3 
Topic 1ï¼šQEMU-SystemC Abstraction Level Design and Verification Mechanism  
Topic 2ï¼šFPGA Prototyping of the 3D Graphic SoC.......................... 
Topic 3ï¼šOCP-AHB Bus Interface for 3D Graphic SoC Integration............. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
6Â 
Â 
 
åœ– 1-2 è»Ÿã€ç¡¬é«”é€é multiple abstraction levels co-design
æ¶æ§‹åœ– 
 ç‚ºï¦ºå»ºï§· QEMU-SystemC å¹³å°ï¼Œæˆ‘å€‘ä¿®æ”¹ï¦º QEMU çš„ source codeï¼Œæ–°å¢
ï¦º IO socket çš„è£ç½®å¦‚åœ– 1-3ï¼Œä¸¦æ’°å¯«å…¶é©…å‹•ç¨‹å¼ï¤­ä½¿ç”¨æ­¤ IO socketï¼Œç•¶è»Ÿé«”åœ¨
å­˜å–æ­¤ IO socket æ™‚ï¼Œæœƒèªç‚ºå®ƒæ­£åœ¨ä½¿ç”¨çš„æ˜¯æˆ‘å€‘ 3D Graphic çš„ç¡¬é«”ï¼Œè€Œæˆ‘å€‘ä¹Ÿ
å¦å¤–åœ¨ SystemC é€™ç«¯æ–°å¢ï¦ºä¸€å€‹ SystemC TCP/IP model ï¤­å°‡æˆ‘å€‘ç”± QEMU å‚³é€
çš„è³‡ï¦¾å¦‚åœ– 1-4ï¼Œè½‰æˆ SystemC model ä¸­æ‰€ä½¿ç”¨çš„ç¡¬é«”ä¿¡è™Ÿï¼Œä¸¦ä¸”ä¹Ÿèƒ½é€éæ­¤
TCP/IP modelï¼Œï¤­å°‡ 3D Graphic ç¡¬é«”æ‰€éœ€å‚³å›çš„ä¿¡è™Ÿï¼Œåƒæ˜¯ IRQ signalï¼Œå‚³å›
QEMU ç«¯ï¼Œè®“ QEMU æ¨¡æ“¬å‡ºï¤­çš„ CPU èªç‚ºçœŸçš„æœ‰ IRQ è¨Šè™Ÿç™¼å‡ºï¼Œé€²è€Œå‘¼å«åˆ°
æˆ‘å€‘çš„é©…å‹•ç¨‹å¼å…§éƒ¨çš„ IRQ handlerï¼Œå®Œæˆæ•´å€‹è»Ÿ/ç¡¬é«”ï§Šç¨‹ã€‚ 
 
åœ– 1-3 åŒ…å« IO socket çš„ QEMU virtual platform 
8Â 
Â 
Topic 2ï¼šFPGA Prototyping of the 3D Graphic SoC 
éš¨è‘—æ™¶ç‰‡è¨­è¨ˆè¶Šè¶¨è¤‡é›œä¹‹éš›ï¼Œæˆ‘å€‘è¦å¦‚ä½•é‡å°æ™¶ç‰‡æœ‰æ•ˆï¥¡çš„é©—è­‰ï¼Œåœ¨è¨ˆåŠƒçš„
ç¾éšæ®µä¸­æˆ‘å€‘ä»¥ 3DG SoC ç‚ºï¦µï¼Œæå‡ºä¸€å€‹ç”± System Modeling Level åˆ° Chip 
Level çš„å‡ä¸€åŒ–é©—è­‰æ–¹æ³•ï¼Œä»¥æœŸèƒ½å¤ å¿«é€Ÿé©—è­‰æ•´å€‹ç³»çµ±ï¼Œé”åˆ° Time-to-Market çš„
ç›®çš„ã€‚è€Œè—‰ç”±å¯¦éš›ä¸Šæ•´åˆä»¥åŠé©—è­‰æˆ‘å€‘çš„ 3DG SoCï¼Œä¹Ÿèƒ½å¤ ä½¿æˆ‘å€‘çš„é©—è­‰æ–¹æ³•
ï¤ï¨€å¯¦éš›ï¼Œè€Œéåƒ…æ˜¯ï§¤ï¥ä¸Šè€Œç„¡å¯¦éš›é‹ç”¨çš„æ–¹æ³•ã€‚åœ¨æœ¬è¨ˆåŠƒä¸­ï¼Œæˆ‘å€‘æå‡ºçš„å‡ä¸€
åŒ–é©—è­‰æ–¹æ³•çš„ä¸»è¦ä¸‰å€‹æ¦‚ï¦£åˆ†åˆ¥ç‚º Platform Consistentã€Test Pattern Reuseã€
Automatic Verification Mechanismã€‚è€ŒåŸºæ–¼é€™ä¸‰å€‹æ¦‚ï¦£ï¼Œæˆ‘å€‘å°‡é©—è­‰æ¨£æœ¬æå‡åˆ°
Program Level çš„å±¤æ¬¡ï¼Œé€²è€Œé”åˆ°åœ¨ï¥§åŒæŠ½è±¡å±¤æ¬¡çš„é©—è­‰ç’°å¢ƒï¨¦å¯ä»¥ä½¿ç”¨ç›¸åŒçš„
é©—è­‰æ¨£æœ¬ã€‚æ­¤å¤–ï¼Œæˆ‘å€‘ä¹Ÿä½¿ç”¨é«˜éšçš„ç¨‹å¼èªè¨€ï¤­æ’°å¯«æˆ‘å€‘çš„æ¸¬è©¦æ¨£æœ¬ï¼Œï¦µå¦‚ C èª
è¨€ï¼Œå¦‚æ­¤ä¸€ï¤­ï¼Œé¢å°è¤‡é›œçš„ç³»çµ±ç´šæ™¶ç‰‡ï¼Œæˆ‘å€‘ï¥¥å¯ä»¥å°ˆå¿ƒæ–¼åŠŸèƒ½æ€§çš„é©—è­‰ï¼Œè€Œï¥§
å¿…åƒéå»å‚³çµ±çš„é©—è­‰æ–¹æ³•å¿…é ˆè€ƒæ…®æ¯ä¸€å€‹æ™‚è„ˆé€±æœŸè¨Šè™Ÿçš„è®ŠåŒ–ï¼Œæ¸›å°‘é©—è­‰ä¸Šæ‰€éœ€
èŠ±è²»çš„å¯¶è²´æ™‚é–“ã€‚åŒæ™‚ï¼Œæˆ‘å€‘ä¹Ÿæå‡ºè‡ªå‹•åŒ–é©—è­‰æ©Ÿåˆ¶ï¼Œç•¶ç¡¬é«”æœ‰æ‰€ä¿®æ”¹æ™‚ï¼Œæ­¤æ©Ÿ
åˆ¶èƒ½å¤ å¿«é€ŸåŸ·ï¨ˆé©—è­‰ä¸¦è‡ªå‹•æ¯”å°å…¶çµæœï¼Œä»¥é”åˆ°æˆåŠŸé©—è­‰ 3DG SoC çš„ä»»å‹™ã€‚ 
æ™¶ç‰‡æ•´åˆæš¨é©—è­‰é€²ï¨ 
åœ¨æœ¬è¨ˆåŠƒä¸­çš„ç¡¬é«”æ•´åˆéƒ¨åˆ†ï¼Œé™¤ï¦ºå°‡åŸæœ¬ç³»çµ±æ™¶ç‰‡ä¸Šçš„ç¹ªåœ–ç¡¬é«”ï¼ˆå¦‚
Geometry Module, GM å’Œ Rendering Module, RMï¼‰ä»¥åŠéƒ¨åˆ†åŒ¯ï§Šæ’ä¸Šçš„è§€æ¸¬å…ƒä»¶
ï¼ˆå¦‚ Bus Tracer å’Œ Protocol Checkerï¼‰çš„ç‰ˆæœ¬ï¤æ–°ä¹‹å¤–ï¼Œæ­¤å¤–ï¼Œä¸¦æ•´åˆï¦ºåµŒå…¥å¼è™•
ï§¤å™¨ï¼ˆEmbedded Coreï¼‰åˆ°ç³»çµ±ä¸­ï¼Œä»¥æä¾›å¦ä¸€ç¨®çš„ç³»çµ±é‹ä½œï§Šç¨‹å’Œè¨­å®šæ©Ÿåˆ¶ï¼Œ
å¦‚åœ– 2-1 å³å±•ç¤ºè©²è¨ˆåŠƒä¸­ç³»çµ±æ™¶ç‰‡çš„ç¡¬é«”æ¶æ§‹ä»¥åŠé©—è­‰ç’°å¢ƒã€‚ 
 
åœ– 2-1 3DG SoC Architecture and Verification Environment 
10Â 
Â 
 
 
               åœ– 2-2 Beethoven benchmark 
 
 
                      åœ– 2-3 Cube benchmark 
 
 
                      åœ– 2-4 Elephant benchmark 
12Â 
Â 
Name W Driver Function
Clk 1 B ClockÂ input
EnableClk 1 B EnableÂ OCPÂ clock
MAdder 32(V) M TransferÂ address
MCmd 3 M TransferÂ command
MData 32(V) M WriteÂ data
MDataValid 1 M WriteÂ dataÂ valid
MRespAccept 1 M MasterÂ acceptsÂ response
SCmdAccept 1 S SlaveÂ acceptsÂ transfer
SData 32(V) S ReadÂ data
SDataAccept 1 S SlaveÂ acceptsÂ writeÂ data
SResp 2 S TransferÂ response
MBurstLength V M BurstÂ length
MBurstPrecise 1 M GivenÂ burstÂ lengthÂ isÂ precise
MBurstSeq 3 M AddressÂ sequenceÂ ofÂ burst
MBurstSingleReq 1 M BurstÂ usesÂ singleÂ request/Â multipleÂ dataÂ 
protocol
MDataLast 1 M LastÂ writeÂ dataÂ inÂ burst
MReqLast 1 M LastÂ requestÂ inÂ burst
SRespLast 1 S LastÂ responseÂ inÂ burst  
è¡¨æ ¼ 3- 1 OCP Basic Signals 
å°æ–¼æ ¸å¿ƒè€Œè¨€é™¤ï¦ºå°ˆå¿ƒæ–¼è‡ªèº« IP çš„è¨­è¨ˆä»¥å¤–ï¼Œç‚ºï¦ºç›¸å®¹æ–¼ OCP å¿…é ˆæ»¿è¶³ä¸‹ï¦œä»¶: 
1 æ ¸å¿ƒå¿…é ˆè‡³å°‘æœ‰ä¸€å€‹ OCP ä»‹é¢ 
2 æ ¸å¿ƒå’Œ OCP ä»‹é¢å¿…é ˆä¸€å€‹ç”¨ RTL ï¤­æè¿°çš„çµ„æ…‹æª”æ¡ˆ 
3 åœ¨æ ¸å¿ƒä¸Šçš„æ¯ä¸€å€‹ä»‹é¢å¿…é ˆ: 
ï¬ ç¬¦åˆæ‰€æœ‰ OCP ä»‹é¢çš„è¦ç¯„äº‹é … 
ï¬ æœ‰å®ƒçš„ç”¨æ–¼åˆæˆè¨­å®šæ‰€æè¿°çš„æ™‚åº 
ç•¶ IP åšç‚º master è§’è‰²æ™‚ï¼Œå¿…é ˆï¦šæ¥ä¸€çµ„ OCP-AHB Master Interface ä½œç‚º
Master èˆ‡ Bus ä¹‹é–“çš„è½‰æ›ç•Œé¢ï¼Œåº•ä¸‹æ˜¯ OCP èˆ‡ AHB åœ¨åšè³‡è¨Šäº¤æ›æ™‚ï¼Œè¨Šè™Ÿæ‰€
åšçš„å°æ‡‰é—œä¿‚ï¼Œåœ– 3-1 ç‚º OCP-AHB Master Interface ä¹‹è¨Šè™Ÿå°æ‡‰ä¹‹é—œä¿‚åœ–ï¼Œå·¦é‚Š
ç‚º OCP ä¹‹è¨Šè™Ÿèˆ‡ OCP Master ç›¸ï¦šæ¥ï¼Œå³é‚Šå‰‡ç‚º AHB ä¹‹è¨Šè™Ÿèˆ‡ AHB Bus ç›¸ï¦šæ¥ï¼Œ
master interface æœƒæ ¹æ“š OCP master æ‰€ç™¼å‡ºçš„ä¸€äº›å‘½ï¦¨è½‰æ›æˆ AHB çš„ protocol ç™¼
é€è‡³ bus ä¸Šï¼Œå¦å¤–ä¹Ÿæœƒå¾ bus æ¥å— slave çš„ä¸€äº› responseï¼Œè½‰æ›æˆ OCP ä¹‹è¨Šè™Ÿå‚³
çµ¦ OCP Master åšç‚ºä¸€å€‹ï¥¸é‚ŠåŒæ­¥æ©Ÿåˆ¶çš„å‚³è¼¸ä»‹é¢ã€‚ 
14Â 
Â 
 
åœ– 3-3 OCP-AHB Master Interface FSM 
 
åœ– 3-4 OCP-AHB Slave Interface FSM 
ç•¶è¨­è¨ˆå¥½ OCP-AHB interface ä»¥å¾Œï¼Œæ¥ä¸‹ï¤­å°±é€²å…¥é©—è­‰çš„æ­¥é©Ÿï¼Œï§ç”¨ç›®å‰ 3D 
Graphic SoC çš„ç’°å¢ƒï¤­é©—è­‰ OCP-AHB Interface çš„æ­£ç¢ºæ€§ï¼Œå¦‚åœ– 3-5 æ‰€ç¤ºï¼ŒOCP 
Master å’Œ OCP Slave åˆ†åˆ¥é€é OCP-AHB Master Interface ä»¥åŠ OCP-AHB Slave 
Interface æ›è¼‰åˆ° AHB Bus çš„ç’°å¢ƒä¸Šé€²ï¨ˆé©—è­‰ï¼Œè€Œé©—è­‰çš„ç’°å¢ƒèˆ‡ 3D Graphic SoC
é©—è­‰ç’°å¢ƒä¸€æ¨£åŒç‚º RTL-SystemC co-simultaion ä¹‹ç’°å¢ƒï¼Œæ•…é©—è­‰æ‰€éœ€è¦çš„ C ç¨‹å¼ã€
Golden Result çš†èˆ‡ 3D Graphic Soc é©—è­‰æ™‚ç›¸åŒï¼Œæ‰€ä»¥å¯ä»¥é”åˆ°æ¸¬è©¦ç’°å¢ƒèˆ‡æ¸¬è©¦æª”
æ¡ˆé‡è¤‡ä½¿ç”¨çš„æ¦‚ï¦£ã€‚ 
å‡ºå¸­åœ‹éš›å­¸è¡“æœƒè­°å¿ƒå¾—å ±å‘Š 
                                                             
è¨ˆç•«ç·¨è™Ÿ NSC 98-2220-E-110-002- 
è¨ˆç•«åç¨± æœ‰å³æ™‚æ•ˆèƒ½/åŠŸï¥¡ç›£æ§åŠŸèƒ½çš„é«˜æ•ˆï¥¡å¯ç¨‹å¼åŒ–ä¸‰ç¶­é›»è…¦ç¹ªåœ–æ™¶ç‰‡ç³»çµ±ï¼šè»Ÿç¡¬é«”é–‹ç™¼åŠæ•´åˆï¼å­è¨ˆç•«ã„§ç³»çµ±æ™¶ç‰‡æ•´åˆèˆ‡åˆ†æ(3/3) 
å‡ºåœ‹äººå“¡å§“å 
æœå‹™æ©Ÿé—œåŠè·ç¨± 
è³´ä¿Šå® 
åœ‹ï§·ä¸­å±±å¤§å­¸è³‡è¨Šå·¥ç¨‹å­¸ç³»/åšå£«ç”Ÿ 
æœƒè­°æ™‚é–“åœ°é» Jun. 13-18, 2010  ç¾åœ‹åŠ å·é˜¿é‚£æ¼¢(Anaheim) 
æœƒè­°åç¨± 
ä¸­æ–‡ï¼š2010 ACM/IEEE è¨­è¨ˆè‡ªå‹•åŒ–ç ”è¨æœƒ 
è‹±æ–‡ï¼š 2010 ACM/IEEE Design Automation Conference Workshop on 
Diagnostic Services in Network-on-Chips - 4th Edition 
ç™¼è¡¨ï¥æ–‡é¡Œç›® 
ä¸­æ–‡ï¼šç”¨æ–¼å–®æ™¶ç‰‡ç³»çµ±ç™¼å±•ä¹‹å¤šé‡è§£æ AXIåŒ¯ï§Šæ’è³‡ï¦¾è¿½è¹¤å™¨ 
è‹±æ–‡ï¼šAn Embedded AXI Bus Tracer with Dynamic Multi-Resolution and 
Real-Time Compression 
 
ä¸€ã€ï¥«åŠ æœƒè­°ç¶“é 
2010 ACM/IEEEè¨­è¨ˆè‡ªå‹•åŒ–ç ”ç©¶æœƒç‚ºåœ¨é›»æ©Ÿè³‡è¨Šï¦´åŸŸä¸­å’Œç³»çµ±æ™¶ç‰‡è¨­è¨ˆåŠè¨­è¨ˆè‡ªå‹•åŒ–
æ–¹é¢æœ€ç››å¤§çš„ç ”è¨æœƒï¼Œç”±ç¾åœ‹é›»è…¦å­¸æœƒï¼ˆACMï¼‰ã€é›»å­è¨­è¨ˆè‡ªå‹•åŒ–ï¦—ç›Ÿï¼ˆEDACï¼‰ã€åŠåœ‹éš›
é›»æ©Ÿé›»å­å·¥ç¨‹å¸«å­¸æœƒï¼ˆIEEEï¼‰ç­‰å–®ä½æ‰€ï¦—åˆä¸»è¾¦çš„ï¼Œç‚ºä¸€ï¦èˆ‰è¾¦ä¸€æ¬¡çš„æœƒè­°ã€‚ä»Šï¦çš„æœƒè­°åœ°
é»æ˜¯ç¾åœ‹åŠ å·é˜¿é‚£æ¼¢ï¼ˆAnaheim, CAï¼‰ï¼Œæœƒè­°ç‚ºæœŸï§‘å¤©ï¼ˆJun. 13-18, 2010ï¼‰ã€‚æœ¬æœƒè­°ç‚º
å…¨çƒICè¨­è¨ˆï¦´åŸŸæœ€é ‚å°–ä¹‹æœƒè­°ï¼Œæ¯ï¦ï¥«èˆ‡äººï¥©ï¨¦ç ´è¬äººï¼Œæ­¤ç ”è¨æœƒçš„ï¥æ–‡å°‡å¯ä»¥åœ¨åœ‹éš›é‡è¦
çš„å·¥ç¨‹ï¥æ–‡è³‡ï¦¾åº«ç³»çµ±EIä¸­ï¥ªå¼•åˆ°ã€‚ 
    DACæ˜¯ä¸€å€‹è¦æ¨¡éå¸¸é¾å¤§çš„æœƒè­°å…¶å…§å®¹éå¸¸è±å¯Œï¼Œæœ‰åˆ¥æ–¼ä¸€èˆ¬çš„å­¸è¡“æœƒè­°ï¼Œå®ƒæ˜¯ä¸€å€‹ç”¢
æ¥­ç•ŒåŠå­¸è¡“ç•Œç·Šå¯†çµåˆçš„é ‚å°–åœ‹éš›æœƒè­°ï¼Œï¥«å±•å» å•†è¶…éä¸‰ç™¾å®¶ï¼Œé™¤ï¦ºå¯å¢é€²å­¸è¡“æ–°çŸ¥ï¼Œï¦ºè§£
åˆ°ä¸–ç•Œå„çŸ¥åå¤§å­¸åŠç ”ç©¶æ©Ÿæ§‹ç›®å‰æœ€æ–°çš„ç ”ç©¶æˆæœï¼Œåˆå¯ä»¥å¾—çŸ¥ç›®å‰æ¥­ç•Œæœ€æ–°å‹•æ…‹ã€‚ 
    åœ¨Technical Sessionæ–¹é¢ï¼Œä¸»è¦æ˜¯ï¦°è½è·Ÿè‡ªå·±æœªï¤­ç ”ç©¶æ–¹å‘ç›¸é—œçš„è¨˜æ†¶é«”ç³»çµ±æœ€ä½³
åŒ–ï¼Œå¤šæ ¸å¿ƒç³»çµ±è¨­è¨ˆç©ºé–“æ¢ï¥ªï¼ŒåŠç³»çµ±å±¤ç´šè¨­è¨ˆçš„ç›¸é—œï¦´åŸŸï¼Œå…¶ä¸­æ¯”è¼ƒæœ‰å¹«åŠ©çš„æ˜¯Session 
9.2ç”±ç¾åœ‹Pennsylvania State Universityåœ˜éšŠæ‰€ç™¼è¡¨çš„Off-chip Memory Bandwidth 
Minimization Through Cache Partitioning for MultiCore Platformsï¼Œå…¶æå‡ºä¸€å¥—
Memory Bandwidth Based Cache Partitioningæ–¹æ³•ï¼Œï¥§åŒæ–¼å‚³çµ±åªè€ƒï¥¾ï¨‰ä½Cache 
Miss Rateï¼Œæœ¬ç¯‡ï¥æ–‡ä¸»è¦çš„æœ€ä½³åŒ–ç›®æ¨™ç‚ºé”åˆ°æœ€å¤§å¹…çš„Off-chip Memory Bandwidthï¨‰
ä½ï¼Œä½¿å¾—å¤šæ ¸å¿ƒç³»çµ±ï¥§æœƒå› ç‚ºé »å¯¬ï¥§è¶³è€Œï¨‰ä½ï¦ºå¤šæ ¸å¿ƒç³»çµ±é‹ç®—æ•ˆèƒ½ã€‚å¦å¤–ï¼ŒSession 22.2
æ˜¯ç”±National University of Singaporeåœ˜éšŠæ‰€è¡¨ç™¼çš„ Instruction Cache-locking 
Using Temporal Reuse Profileï¼Œå…¶é‡å°ç¨‹å¼åŸ·ï¨ˆProfileçš„è¿½è¹¤è³‡ï¦¾ï¤­é€²ï¨ˆåˆ†æï¼Œå¾ä¸­æ“·
å–å‡ºæœƒæ–¼è¿´åœˆä¸­å¤§ï¥¾ä½¿ç”¨çš„æŒ‡ï¦¨ï¼Œå› æ­¤æœƒå°‡é€™äº›æŒ‡ï¦¨ä»¥Cache-lockingçš„æ–¹å¼ï¼Œå°‡å…¶å¼·åˆ¶ä¿
å­˜æ–¼Cacheä¸­è€Œï¥§æœƒè¢«ç½®æ›å›å¤–éƒ¨è¨˜æ†¶é«”ä¸­ã€‚åœ¨Session 33.2ä¸­National Technical 
University of Athenesåœ˜éšŠæ‰€ç™¼è¡¨çš„A Framework for Automatic Parallelization, 
  
è·Ÿèˆ‡æœƒè€…é€²ä¸€æ­¥è¨ï¥ç•«é¢ â€“ 2 è·Ÿèˆ‡æœƒè€…é€²ä¸€æ­¥è¨ï¥ç•«é¢ â€“ 3 
  
è·Ÿèˆ‡æœƒè€…é€²ä¸€æ­¥è¨ï¥ç•«é¢ â€“ 4 ï¥æ–‡ç™¼è¡¨æœƒå ´å¯¦æ³ 
  
ï¥æ–‡ç™¼è¡¨æœƒå ´å¯¦æ³ å» å•†å±•è¦½è§£ï¥¯å¯¦æ³ 
 
äºŒã€èˆ‡æœƒå¿ƒå¾— 
é€™æ¬¡åˆ°ç¾åœ‹åŠ å·é˜¿é‚£æ¼¢å¸‚ï¥«åŠ ï¦º ACM/EDAC/IEEE DAC 2010æœƒè­°ï¼Œè½ï¦ºï¤­è‡ªå„åœ‹çš„
å°ˆå®¶ã€å­¸è€…å ±å‘Šï¼Œè¦ºå¾—ç²ï¨—ï¥¼å¤šã€‚æ­¤æ¬¡æœƒè­°ä¸­ï¼Œå¯ä»¥å¾—åˆ°ï¦ºåœ‹ç§‘æœƒçš„è£œåŠ©ï¼Œè®“æˆ‘å¯ä»¥å¾—ä»¥å‡º
åœ‹ï¼Œé–‹æ“´è‡ªå·±çš„è¦–é‡ï¼Œå¢å»£ï¨Šèï¼Œåœ¨æ­¤ï¼Œå†ï¨æ„Ÿè¬å„ä½åœ‹ç§‘æœƒçš„å¯©æŸ¥å§”å“¡å€‘é€šéå­¸ç”Ÿçš„å¯©æŸ¥
An Embedded AXI Bus Tracer with Dynamic
Multi-Resolution and Real-Time Compression
Chun-Hung Lai, Chien-Hung Chen, Cheng-Lung Chiang, Liang-Bi Chen, and Ing-Jer Huang
Department of Computer Science and Engineering, National Sun Yat-Sen University, Kaohsiung, Taiwan, R.O.C.
Abstractâ€”This paper proposes an embedded bus signal tracer
for AXI master/slave interfaces. The proposed AXI bus tracer
is a passive monitoring mechanism, which does not disturb the
native system behavior. In general, the trace size of cycle-accurate
monitoring is huge, and hence the proposed AXI bus tracer
provides the abstraction module and the compression module.
The abstraction module provides four trace resolution modes
that can perform cycle-accurate or a transaction-based trace
collection in an unlimited time. The compression module is used
to reduce the size of trace data to enlarge the duration of tracing.
The experimental results show that the total compression ratio is
76.7%. Moreover, we can use an independent debug bus with an
embedded processor to configurable AXI bus tracer and dumping
the trace data.
I. INTRODUCTION
A highly integrated SoC has many components. All of
components are communicated on an on-chip bus. For efficient
communication purpose, since the early 1990s, several on-
chip bus-based communication architecture standards have
been proposed to handle the communication needs of emerg-
ing SoC designs. Some of the popular standards include
ARM Microcontroller Bus Architecture (AMBA) versions
2.0 and 3.0, IBM CoreConnect, STMicroelectronics STBus,
Sonics SMART Interconnect, OpenCores Wishbone, and Al-
tera Avalon [1]. However, how to debug in the bus-based
SoC environment is a great challenge because the internal
signals are difficult to observe. To overcome this problem, we
proposed an embedded AXI tracer, which can capture the bus
signal trace directly inside the SoC and store them in an on-
chip trace memory in real time. The trace data can be dumped
off-line from the trace memory to debug host or software
for analysis of bus traffic/performance. The trace is usually
triggered by events. The event trigger is used to indicate a
stop or start of the trace. Related to the event trigger, there
are two types of trace: Pre-Triggering (Pre-T) trace and Post-
Triggering (Post-T) trace. As shown in Fig. 1, the trace of
Pre-T/Post-T captures the signals before/after the event trigger.
Pre-T is usually used to preset stop position or detected error.
Post-T is usually used to set start trace or matched event.
II. PROPOSED AXI BUS TRACER ARCHITECTURE
The proposed embedded AXI bus tracer is a passive monitor
component in an SoC, as shown in Fig. 2. The proposed em-
bedded AXI bus tracer includes an AXI tracer, a tracer mem-
ory, a SYS32TDMI (which is an ARM7-like microprocessor,
supporting JTAG debug port, developed by ourselves), on-chip
memory, and an independent debug bus. The SYS32TDMI
TimeTrace capacity
Event
 trigger
Pre-T Trace Post-T Trace
Trace capacity
Fig. 1. Pre-Triggering Trace and Post-Triggering Trace
  

 


  
	 
    
  
 

  
 




 





ï¬€

ï¬
ï¬‚

ï¬ƒ

 





ï¬€

     

 ! ! 

   "
 
 # #  
DesignWare VIP
   $
 
 %  
$
 
 % 
	  & '  (
)  * + , - +  .
 /
- * 
   0 1
 /
-
"
 
 # #  
 /
-
"
 
 # #  
 2  3 4 $
) 	

.
 5
	 6 7
 8 9
 1
 /
-
"
 
 # #  
:
! 7
  8
#
	  & '  (
 /
-
"
 
 # #  
An Embedded AXI Bus Tracer
;
$  <
Fig. 2. AXI Bus Tracer RTL Design Environment
and on-chip memory are used to configure scenario of the
AXI bus tracer. The proposed AXI bus tracer consists of an
abstraction module, a reduction module, a pack module, and a
FIFO module, as shown in Fig. 3. We combine the abstraction
levels in the timing dimension and the signal dimension that
provide four modes in different granularities. There are Mode
1, Mode 2, Mode 3, and Mode 4. At Mode 1, the tracer traces
all bus signals cycle-by-cycle so that user can observe the most
detailed bus activities. Full signals can be sampled at cycle
level. The trace depth is the shortest among the four modes.
At Mode 2, the tracer traces all signals only when their values
are changed. Full signals are sampled at transaction level at
cycle based. At Mode 3, the signals abstraction at bus state,
such as Wait, Address channel wait, Transfer, Data channel
wait. Bus state signals would be sampled at cycle based. At
Mode 4, the tracer uses bus state to represent bus transfer
activities in transaction level. Bus state signals can be sampled
at transaction level.
The compression module is used to reduce the trace size.
In accordance with cluster of bus signals encoded data, the
cluster of bus signals are classified according to AXI channel
and transaction protocol. Table I shows cluster types with
 1
å‡ºå¸­åœ‹éš›å­¸è¡“æœƒè­°å¿ƒå¾—å ±å‘Š                                
è¨ˆç•«ç·¨è™Ÿ NSC 98-2220-E-110-002- 
è¨ˆç•«åç¨± æœ‰å³æ™‚æ•ˆèƒ½/åŠŸï¥¡ç›£æ§åŠŸèƒ½çš„é«˜æ•ˆï¥¡å¯ç¨‹å¼åŒ–ä¸‰ç¶­é›»è…¦ç¹ªåœ–æ™¶ç‰‡ç³»çµ±ï¼šè»Ÿç¡¬é«”é–‹ç™¼åŠæ•´åˆï¼å­è¨ˆç•«ã„§ç³»çµ±æ™¶ç‰‡æ•´åˆèˆ‡åˆ†æ(3/3) 
å‡ºåœ‹äººå“¡å§“å 
æœå‹™æ©Ÿé—œåŠè·ç¨± 
é™³å»ºå® 
åœ‹ï§·ä¸­å±±å¤§å­¸è³‡è¨Šå·¥ç¨‹å­¸ç³»åšå£«ç”Ÿ 
æœƒè­°æ™‚é–“åœ°é» Songdo Convensia, Incheon, Korea(éŸ“åœ‹ä»å·å¸‚æ¾å³¶ Convensiaåœ‹éš›æœƒå±•ä¸­å¿ƒì†¡ë„ì»¨ë²¤ì‹œì•„) November 22-23, 2010 
æœƒè­°åç¨± International SoC Design Conference(ISOCC2010) 
ç™¼è¡¨ï¥æ–‡é¡Œç›® A Synthesizable AXI Protocol Checker for SoC Integration 
 
ä¸€ã€ï¥«åŠ æœƒè­°ç¶“é 
æœ¬æ¬¡å‡ºåœ‹ä¸»è¦çš„ç›®çš„æ˜¯å»ï¥«åŠ  2010ï¦ ISOCCåœ¨éŸ“åœ‹ä»å·å¸‚èˆ‰è¾¦ï¼Œè©²æœƒè­°è­°é¡Œæ˜¯é‡
å° SoCè¨­è¨ˆåŠæ‡‰ç”¨ç‚ºè¨ï¥ä¸»è»¸ï¼Œæ‰€æœ‰èˆ‡æœƒäººå“¡ï¨¦å¿…é ˆåœ¨ 11æœˆ 23æ—¥æ—©ä¸Šï¼Œåˆ°é”èˆ‰è¾¦çš„å ´
åœ°åšå ±åˆ°çš„æ‰‹çºŒï¼Œå› ç‚ºæ˜¯ç¬¬ä¸€æ¬¡è‡ªå·±è™•ï§¤å‡ºåœ‹æ‰‹çºŒï¼Œé¸æ“‡æå‰ä¸€å¤©åˆ°éŸ“åœ‹ä½å®¿ã€‚æœ¬æ¬¡æŠ•
ç¨¿çš„æ˜¯ Special Sectionçš„é‚€ç¨¿ï¼Œï¥æ–‡é¡Œç›®ç‚º A Synthesizable AXI Protocol Checker for SoC 
Integrationï¼Œè€Œå£é ­å ±å‘Š Oral Sectionæ˜¯è¢«å®‰æ’åœ¨æœƒè­°çš„ç¬¬ä¸€å¤©ä¸‹åˆ 5:00~6:30ï¼Œä¸€å…±æœ‰ï§‘
ä½å ±å‘Šäººï¼Œæˆ‘æ˜¯è¢«å®‰æ’åœ¨ç¬¬äº”é †åºå ±å‘Šï¼Œå¹³å‡æ¯ä½å¯ä»¥å ±å‘Š 15åˆ†é˜ï¼Œå…¶ä¸­åŒ…å«æå•è¨ï¥
3åˆ†é˜ã€‚åœ¨ï¥«åŠ æœƒè­°éç¨‹ä¸­ï¼Œä¹Ÿå»è§€æ‘©åœ‹éš›é–“åœ¨ SoCä¸Šçš„ç ”ç©¶åŠå…¶æ‡‰ç”¨ï¦´åŸŸä¸Šçš„è¶¨å‹¢ã€
æ–¹æ³•åŠç™¼å±•çš„ç¾æ³ã€‚ 
åŒæ™‚åœ¨æœƒå ´é€±é‚Šæœ‰ç›¸é—œ SoCåŠè‡ªå‹•åŒ–è¨­è¨ˆå» å•†é€²ï¨ˆå±•ç¤ºï¼Œå±•ç¤ºå…§å®¹å¤§å¤šä»¥è»Ÿã€ç¡¬é«”
é–‹ç™¼å¹³å°ç‚ºä¸»ï¼Œå¦å¤–é‚„æœ‰å¾®å‹æ©Ÿå™¨äººè‡ªå‹•æ§åˆ¶ç­‰å±•ç¤ºã€‚æœƒè­°é–‹å§‹å‰å°±å·²ç¶“æœ‰ç›¸é—œ Chip 
Design ContestéšŠä¼é€²ï¨ˆï¥¯æ˜åŠ Demoï¼Œï¥«è³½éšŠä¼å ±å‘Šè‡ªå·±çš„è¨­è¨ˆåŠå…§å®¹ã€‚å…¶ä¸­æœ‰ä¸€ï¥«è³½
éšŠä¼ï¦¨æˆ‘æ„Ÿåˆ°æœ‰èˆˆè¶£çš„ï¼Œæ˜¯ Korea Advanced Institute of Science and Technologyæ‰€è‡ªï¨ˆè¨­
è¨ˆçš„ 32bit RISCï¼Œå…·å‚™ Debug functionå¯é€é UARTèˆ‡ GDBï¦šæ¥ï¼Œä¸¦ä¸”å¯¦éš› Taped-out
æ™¶ç‰‡ï¼Œèƒ½èˆ‡ç›¸é—œç¡¬é«”é€±é‚Šè¨­å‚™ï¦šæ¥ã€‚é€™èˆ‡æœ¬å¯¦é©—å®¤æ‰€è‡ªï¨ˆè¨­è¨ˆçš„ ARM7-likeéå¸¸ç›¸ä¼¼ï¼Œ
è€Œæœ€å¤§çš„ï¥§åŒæ˜¯ Debug Hardware çš„è¨­è¨ˆï¼ŒåŠ Debug Communication Interfaceã€‚æˆ‘å€‘çš„
Debug Hardwareè¨­è¨ˆæ˜¯æŒ‰ç…§ JTAGæ¨™æº–åŠ ARM specificationï¼Œä»–å€‘ Debug Hardwareæ˜¯é€
éæ¯æ¿ä¸Šçš„ UARTèˆ‡ PCï¦šæ¥ï¼Œå†ç”± GDBæ“ä½œ Debug Functionã€‚èƒ½å¤ ï¥«åŠ æœ¬æ¬¡æœƒè­°ï¼Œå¾ˆ
æ„Ÿè¬å¯¦é©—å®¤åŠæŒ‡å°ï¤´å¸«æ‰€æä¾›çš„ç›¸é—œå”åŠ©åŠè³‡æºã€‚ 
   
åœ– 1 å» å•†ï¦—åˆï¥«å±• 
 3
Sessionæœƒè­°çš„ Chair - Dr. Yeong-Kang Lai (National Chung Hsing University, Taiwan)ï¼Œé‡å°
æˆ‘å€‘çš„ï¥æ–‡æå‡ºï¦ºé—œæ–¼ AXI Protocol Checkeræœƒï¥§æœƒæœ‰ Design Area Overflowçš„å•é¡Œï¼Œè€Œ
ç•¶æ™‚æˆ‘å›ç­”æ˜¯ï¥¯ç•¶ç„¶å¾ˆå®¹ï§ å°±æœƒé€ æˆ Overflowï¼Œå°±ç›®å‰æˆ‘å€‘çš„ AXI Protocol Checkeræ˜¯é‡
å°å–®å€‹ DUV IPé€²ï¨ˆæª¢é©—ï¼Œä½†æ˜¯ AXIç‰¹è‰²å°±æ˜¯ point-to-pointï¦šæ¥ï¼Œæœƒç‰½æ¶‰åˆ°å¦‚ä½•åˆ†æ•£å¼
æª¢é©—ï¼Œä»ç„¶æ˜¯å¾ˆå¤§çš„æŒ‘æˆ°ã€‚ä¸€èˆ¬ç›´è¦ºçš„è§£æ±ºæ–¹å¼ï¼Œæ˜¯çœ‹æœ‰å¤šå°‘å€‹ IPè¦æˆç‚ºæª¢é©—ç›®æ¨™ï¼Œå°±
æ•£ä½ˆå¤šå°‘å€‹ Checkerç¡¬é«”ï¼Œä½†æ˜¯å¾ˆå¯èƒ½æœƒé€ æˆ Checkeré¢ç©å¤§åˆ° Overflowã€‚å¦ä¸€å€‹è§£æ³•ï¼Œ
æ˜¯æ¡ç”¨ï§—ï§Šï¨€æ›æª¢é©—æ–¹å¼ï¼Œå…±äº«å–®ä¸€çµ„ Checkerï¼Œä½†æ˜¯é€™è¦æŠŠ Checkerçš„æª¢é©—é€Ÿï¨åŠï¨€æ›
æª¢é©—çš„ç®¡ï§¤åŠ é€Ÿï¼Œæ‰æœ‰è¾¦æ³•è§£æ±ºï§—ï§Šæª¢é©—å…±äº«çš„å•é¡Œï¼Œè€Œé€™ä¹Ÿæœƒé€ æˆç¡¬é«”åŸ·ï¨ˆé€Ÿï¨ä¸Šçš„
Overflowã€‚ 
   
åœ– 3 ç•¶å¤©æœƒè­°å ±å‘ŠåŠæœƒè­°ä¸»å¸­åˆç…§ 
 
ç¶“éé€™ä¸€æ¬¡æœƒè­°ï¥æ–‡æŠ•ç¨¿åŠï¥«èˆ‡ï¼Œé€™è®“è‡ªå·±å­¸ç¿’åˆ°å¦‚ä½•æŠ•ç¨¿ã€ä¿®ç¨¿ï¼Œä¸¦ä¸”å°‡æŠ•ç¨¿çš„
æ ¼å¼é€šé IEEEçš„æª¢é©—ï¼Œåˆ°æœƒè­°ï¥æ–‡çš„æŠ•å½±ç‰‡è£½ä½œï¼Œç›´åˆ°ç•¶å¤©çš„å ±å‘Šï¼Œä¸€ï¨€éç¨‹ç•¶ä¸­ï¼Œ
å­¸ç¿’åˆ°è¨±å¤šçè²´çš„ç¶“é©—ï¼Œä¹Ÿé †ï¥¥å­¸ç¿’åˆ¥äººå¦‚ä½•è¡¨ç¾å ±å‘Šæ–¹å¼ã€‚é€éåœ¨æœ¬æ¬¡çš„å­¸ç¿’æˆé•·ä¸­ï¼Œ
æœŸå¾…åœ¨ä¸‹ä¸€æ¬¡çš„æœƒè­°ï¥æ–‡æ™‚ï¼Œèƒ½æœ‰ï¤ä¸Šä¸€å±¤ï¥Œçš„è¡¨ç¾ã€‚ 
 
  -2- ISOCC 2010 
A
M
B
A
 A
X
I
 
Figure 1.  The proposed AXIChecker achitecture. 
The checking results are recorded in the error reference 
table (ERT) which is used for improving verification ability for 
FPGA-level or chip-level on-chip bus verification. The ERT 
can summarize total errors that have occurred. In addition, the 
GUI software analyzer is also developed to display error 
information in details. 
Table I. Contrasting features of AXI and AHB [1] 
AMBA 3.0 AXI AMBA 2.0 AHB 
Channel-based specification, 
with five separate channels 
for read address, read data, 
writes address, write data, 
and write response enabling 
flexibility in 
implementation. 
Explicit bus-based 
specification, with single 
shared address bus and 
separate read and write data 
buses. 
Burst mode requires 
transmitting address of only 
first data item on the bus. 
Requires transmitting 
address of every data item 
transmitted on the bus. 
Out-of-Order transaction 
completion provides native 
support for multiple, 
outstanding transactions. 
Simpler SPLIT transaction 
scheme provides limited and 
rudimentary outstanding 
transaction completion. 
Fixed burst mode for 
memory mapped I/O 
peripherals. 
No fixed burst mode. 
Exclusive data access 
(semaphore operation) 
support. 
No exclusive access support. 
Advanced security and 
cache hint support. 
Simple protection and cache 
hint support. 
Register slice support for 
timing isolation. 
No inherent support for 
timing isolation. 
Native low-power clock 
control interface. No low-power interface. 
Default bus matrix topology 
support. 
Default hierarchical bus 
topology support. 
In the table I show Contrasting features of AXI and AHB. 
The major difference as follow: (1) The AXI is five channels; 
The AHB is single shared address bus and data bus. In 
accordance with this difference, we must to modify from AHB 
bus tracer an address and a data encode expand into read/write 
address and read/write data encode for AXI bus tracer. (2)The 
AXI protocol is burst-based [15]. In accordance with burst-
based, we changed address encoding for AXI bus tracer.  
The rest of the paper is organized as follows. Section 2 
describes about the AMBA AXI Protocol Checker Architecture. 
Section 3 is verification strategy. Section 4 shows experimental 
results. Finally, Section 5 is our conclusion. 
II. AMBA AXI PROTOCOL CHECKER ARCHITECTURE 
The AXI protocol checker consists of configuration register, 
protocol checker, error reference table as figure 1 shows the 
architecture, called the AXIChecker. This section introduces 
the blocks of the AXIChecker, respectively. 
A. Protocol Checker 
AXIChecker is a rule-based protocol checker, thus how to 
establish a set of well-defined rules is very important. Hence, 
we refer to the Synopsys verification intellectual property (VIP) 
[16] to establish 44 rules, including 31 master-related rules, 12 
slave-related rules, and one default slave-related rule. 
Protocol Checker is the main core of the AXIChecker, the 
inputs are all AXI bus signals, and the outputs are 44-bits 
ERROR signals and correspondingly master and slave IDs. 
Each rule has its owned correspondingly bits because every 
cycle maybe occur more than one error. If the i-th bit of the 
ERROR is set, which indicates current bus signals violate i-th 
rule. If an error has been occurred, the AXIChecker will output 
the corresponded master ID number or slave ID number to 
indicate which master or slave violates the AXI protocol. 
Figure 1 shows sub-modules of the protocol checker. There 
are sixteen sub-modules in protocol checker. They are: ADDR, 
DefaultSlave, Interface, Stable, Burst, Exclusive, LOCK, 
Surprise data, Cache, Handshake, ORDER, WDATA, 
Concurrency, ID, Resetn, and WSTRB, respectively. The sub-
modules are described as follows. 
1) ADDR: This sub-module is to check ADDR related 
rules. The ADDR signal is very important to the system. For 
every transfer, the slave, based on the ADDR, either send to or 
receive from data to the master. 
2) DefaultSlave: This sub-module is to check default slave 
response DECERR or not, when master issue a invalid address. 
3) Interface: This sub-module is to check the multiple data 
send to slave exceeds data interleave depth or not. 
4) Stable: This sub-module is to check data or control 
signals remain stable or not when valid signals is assert. 
5) Burst: This sub-module is to check burst related rules. 
The AMBA AXI provides some burst type to the designer, 
FIXED, INCR and WRAP. In some SoC designs, the burst 
transfer is very important to the performance.  
  -4- ISOCC 2010 
IV. EXPERIMENTAL RESULTS 
We compare Synopsys bus monitor VIP, ARM AXI 
protocol checker with the proposed AXIChecker shown as 
Table I. Synopsys bus monitor VIP and ARM AXI protocol 
checker are un-synthesizable hardware module and they can  
 
Figure 3.  Execution screen of the AXIChecker analyzer. (a) Count total 
violation rules and indicate which masters or slaves are violated the rule; (b) 
Show violation information in details. 
TABLE I.  COMPARISION OF THE AXI VIERFICATION MONITORS 
IP Name 
Synopsys Bus 
Monitor VIP 
[15] 
ARM AXI 
Protocol Checker 
[16] 
The Proposed 
AXIChecker 
Synthesizable 
 
No No Yes 
Debugging 
Support Error Messages Error Messages 
ERT, Detect     
multiple errors, 
and GUI SW 
analyzer 
Number of 
Rules 44 127 44 
TABLE II.  SYNTHESIS RESULTS 
Max. Frequency 242 MHz 
Total Area 70.7K Gates 
Only output error messages when errors occurred. Our 
proposed AXIChecker is a synthesizable hardware module. We 
also provide error reference table and GUI software analyzer to 
achieve efficient verification in FPGA-level or chip-level 
environment.  
Figure 3 shows the execution screen of the AXIChecker 
analyzer, AXIChecker analyzer is GUI interface software that 
can analyze the error reference table (ERT), and then display 
the violation information in details. Figure 3 (a) shows the total 
violation rules and indicates which masters or slaves are 
violated the rule. Figure 3 (b) shows detail violations. Table II 
shows AXIChecker synthesis results, the total area is 70.7K 
gate counts. 
V. CONCLUSION 
In this paper, we have proposed an AMBA AXI on-chip 
protocol checker with an efficient verification mechanism 
based on monitored-based methodology. The proposed AXI 
on-chip bus protocol checker has 44 rules that provide AXI 
master, slave, and default slave issue. The proposed 
verification mechanism is used for improving verification 
ability. The proposed verification mechanism can summarize 
total errors that have been occurred in simulation. In addition, 
the GUI software analyzer is also developed that can be 
displayed error information in details. 
ACKNOWLEDGMENT 
The authors would like to thank Global Unichip Inc. for 
their generous financial and technical supports.  
REFERENCES 
[1] S. Pasricha, N. Dutt, On-Chip Communication Architectures: System on 
Chip Interconnect, Morgan Kaufmann, 2008. 
[2] E. M. Clarke, E. A. Emerson, and A. P. Sistla, â€œAutomatic verification 
of finite-state concurrent systems using temporal logic specifications,â€ 
ACM Transactions on Programming Languages and Systems (TOPLAS), 
vol. 8, pp. 244-263, 1986. 
[3] P. Chauhan, E. M. Clark, Y. Lu, and D. Wang, â€œVerifying IP-core based 
System-On-Chip designs,â€ In Proceedings of the Twelfth Annual IEEE 
International ASIC/SOC Conference, pp. 27-31, Sept. 1999. 
[4] A. Roychoudhury, T. Mitra, and S. R. Karri, â€œUsing formal techniques 
to debug the AMBA System-on-Chip bus protocol,â€ In Proceedings of 
the IEEE/ACM Design, Automation, and Test in Europe Conference & 
Exhibition (DATEâ€™03), 2003. 
[5] L. Ivanov and R. Nunna, â€œSpecification and formal verification of 
interconnect bus protocols,â€ In Proceedings of the 43rd IEEE Midwest 
Symposium on Circuits and Systems (MW-CASâ€™00), Vol. 1, Aug. 2000. 
[6] M. Kaufmann, A. Martin, and C. Pixley, â€œDesign constraints in 
symbolic model checking,â€ In Proceedings of the 10th International 
Conference on Computer Aided Verification, Springer-Verlag, 1998. 
[7] K. L. McMillan, â€œSymbolic Model Checking,â€ Kluwer Academic 
Publishers, 1993. 
[8] I. Ltd., â€˜â€˜Sugar formal property language reference manual.â€™â€™ [Online]. 
Available: http://www.haifa.il.ibm.com/projects/verification/sugar/ 
[9] S. Ltd., OpenVera LRM 2.0. [Online]. Available: 
http://www.openvera.com 
[10] Property Specification Language Reference Manual. [Online].Available: 
www.eda.org/vfv/docs/PSL-v1.1.pdf 
[11] Kanna, Shimizu, David L. Dill and Alan J. Hu. â€œA monitor-based formal 
specification of PCIâ€. Proceeding of the 3rd International Conference of 
Formal Methods in Computer-Aided Design, Nov. 2000. 
[12] Marcio T. Oliveira, Alan J. Hu. â€œHigh level specification and design: 
High-Level specification and automatic generation of IP interface 
monitorsâ€. Proceedings of the 39th conference on Design automation, 
June 2002. 
[13] M. S. Jahanpour, E. Cerny. â€œCompositional verification of an ATM 
switch module using interface recognizer/suppliers (IRS)â€. International 
High-Level Design, Validation, and Test Workshop, pp. 71-76. 2000. 
[14] M. Kaufmann, A. Martin, C. Pixley. â€œDesign constraints in symbolic 
model checkingâ€10th International Conference on Computer-Aided 
Verification, pp. 477-487. LNCS 1427. Springer, 1998. 
[15] ARM Ltd., â€œAMBA 3 AXI Protocol Checker: user guide,â€ ARM DUI 
0305B, ARM Ltd., 2006. 
[16] Synopsys Inc., â€œUsing the DesignWare Verification Models for the 
AMBA 3 AXI Protocol,â€ Version 5.60a, Synopsys Inc., April 2009. 
[17] Y.-T. Lin, C.-C. Wang, and I.-J. Huang, â€œAMBA AHB Bus Protocol 
Checker with Efficient Debugging Mechanism,â€ In Proceedings of the 
IEEE International Symposium on Circuits and Systems(ISCASâ€™08), 
May 2008, pp. 929-931.  
[18] ARM Ltd., â€œAMBA AXI Protocol Specification V1.0â€, ARM IHI 
0022B, ARM Ltd., 2004. 
[19] Harry Foster , David Lacey , Adam Krolnik, Assertion-Based Design, 
Kluwer Academic Publishers, Norwell, MA, 2003. 



98ï¦ï¨å°ˆé¡Œç ”ç©¶è¨ˆç•«ç ”ç©¶æˆæœå½™æ•´è¡¨ 
è¨ˆç•«ä¸»æŒäººï¼šé»ƒè‹±å“² è¨ˆç•«ç·¨è™Ÿï¼š98-2220-E-110-002- 
è¨ˆç•«åç¨±ï¼šå…·æœ‰å³æ™‚æ•ˆèƒ½/åŠŸï¥¡ç›£æ§åŠŸèƒ½çš„é«˜æ•ˆï¥¡å¯ç¨‹å¼åŒ–ä¸‰ç¶­é›»è…¦ç¹ªåœ–æ™¶ç‰‡ç³»çµ±ï¼šè»Ÿç¡¬é«”é–‹ç™¼åŠæ•´åˆ
--å­è¨ˆç•«ä¸€ï¼šç³»çµ±æ™¶ç‰‡æ•´åˆèˆ‡åˆ†æ(3/3) 
ï¥¾åŒ– 
æˆæœé …ç›® å¯¦éš›å·²é”æˆ
ï¥©ï¼ˆè¢«æ¥å—
æˆ–å·²ç™¼è¡¨ï¼‰
é æœŸç¸½é”æˆ
ï¥©(å«å¯¦éš›å·²
é”æˆï¥©) 
æœ¬è¨ˆç•«å¯¦
éš›è²¢ç»ç™¾
åˆ†æ¯” 
å–®ä½ 
å‚™ è¨» ï¼ˆ è³ª åŒ– ï¥¯
æ˜ï¼šå¦‚ï¥©å€‹è¨ˆç•«
å…±åŒæˆæœã€æˆæœ
ï¦œ ç‚º è©² æœŸ åˆŠ ä¹‹
å° é¢ æ•… äº‹ ...
ç­‰ï¼‰ 
æœŸåˆŠï¥æ–‡ 0 0 100%  
ç ”ç©¶å ±å‘Š/æŠ€è¡“å ±å‘Š 2 0 100%  
ç ”è¨æœƒï¥æ–‡ 0 0 100% 
ç¯‡ 
 
ï¥æ–‡è‘—ä½œ 
å°ˆæ›¸ 0 0 100%   
ç”³è«‹ä¸­ä»¶ï¥© 3 0 30%  å°ˆï§ å·²ç²å¾—ä»¶ï¥© 0 0 100% ä»¶  
ä»¶ï¥© 0 0 100% ä»¶  
æŠ€è¡“ç§»è½‰ 
æ¬Šï§ï¤Š 0 0 100% åƒå…ƒ  
ç¢©å£«ç”Ÿ 3 3 100%  
åšå£«ç”Ÿ 2 2 100%  
åšå£«å¾Œç ”ç©¶å“¡ 0 0 100%  
åœ‹å…§ 
ï¥«èˆ‡è¨ˆç•«äººï¦Š 
ï¼ˆæœ¬åœ‹ç±ï¼‰ 
å°ˆä»»åŠ©ï§¤ 0 0 100% 
äººæ¬¡ 
 
æœŸåˆŠï¥æ–‡ 5 0 20%  
ç ”ç©¶å ±å‘Š/æŠ€è¡“å ±å‘Š 0 0 20%  
ç ”è¨æœƒï¥æ–‡ 8 0 20% 
ç¯‡ 
 
ï¥æ–‡è‘—ä½œ 
å°ˆæ›¸ 0 0 100% ç« /æœ¬  
ç”³è«‹ä¸­ä»¶ï¥© 3 0 30%  å°ˆï§ å·²ç²å¾—ä»¶ï¥© 0 0 100% ä»¶  
ä»¶ï¥© 0 0 100% ä»¶  
æŠ€è¡“ç§»è½‰ 
æ¬Šï§ï¤Š 0 0 100% åƒå…ƒ  
ç¢©å£«ç”Ÿ 0 0 100%  
åšå£«ç”Ÿ 0 0 100%  
åšå£«å¾Œç ”ç©¶å“¡ 0 0 100%  
åœ‹å¤– 
ï¥«èˆ‡è¨ˆç•«äººï¦Š 
ï¼ˆå¤–åœ‹ç±ï¼‰ 
å°ˆä»»åŠ©ï§¤ 0 0 100% 
äººæ¬¡ 
 
 
