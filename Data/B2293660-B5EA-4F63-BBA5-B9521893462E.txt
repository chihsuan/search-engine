ä¸­æ–‡æ‘˜è¦
é•·ä¹…ä»¥ä¾†, æˆ‘å€‘ç¸½æ˜¯é¿å…å»ç›´æ¥åœ°å»æ±‚ NP-hard çš„å•é¡Œçš„æœ€ä½³è§£ã€‚ å¦‚ä»Š, æˆ‘å€‘è€ƒæ…®ä½¿ç”¨ä¸€äº›è¨­è¨ˆå›ºå®š
åƒæ•¸æ¼”ç®—æ³•çš„ç­–ç•¥, ç›´æ¥å»è§£é€™äº›æˆ‘å€‘éå»é¿è€Œä¸è«‡çš„å•é¡Œã€‚ ä¸€å€‹åƒæ•¸åŒ–å•é¡Œç‚ºä¸€èªè¨€ L âŠ‚ Î£âˆ— Ã— Î£âˆ—, å…¶
ä¸­ Î£ ç‚ºä¸€å€‹æœ‰é™çš„å­—æ¯é›†, è€Œç¬¬äºŒå€‹å…ƒç´ ç¨±ç‚ºæ­¤å•é¡Œ L ä¹‹åƒæ•¸ã€‚ ä¸€å€‹èƒ½åœ¨ f(k) Â· nO(1) çš„æ™‚é–“è¤‡é›œåº¦ä¸‹
è§£å‡ºä¸€å€‹åƒæ•¸åŒ–å•é¡Œçš„æ¼”ç®—æ³•è¢«ç¨±ç‚ºå›ºå®šåƒæ•¸æ¼”ç®—æ³•, å…¶ä¸­ f æ˜¯ä¸€å€‹åªè·Ÿ k ç›¸ä¾çš„å‡½æ•¸ã€‚ åœ¨éå»åå¹´ä¾†,
è­‰æ˜ä¸€å€‹å•é¡Œå­˜åœ¨å›ºå®šåƒæ•¸æ¼”ç®—æ³•å’Œè¨­è¨ˆå„ç¨®ä¸åŒå›ºå®šåƒæ•¸æ¼”ç®—æ³•çš„æ–¹æ³•èˆ‡æŠ€å·§, ä¸æ–·åœ°è¢«é–‹ç™¼å‡ºä¾†ã€‚
æ­¤å¤–,éš¨è‘—ç§‘æŠ€ä¸æ–·åœ°é€²æ­¥, æˆ‘å€‘ç„¡å¯é¿å…åœ°å¿…é ˆåœ¨çŸ­æ™‚é–“å…§å¿«é€Ÿåœ°è§£ä¸€äº›éœ€è¦è¼¸å…¥å¤§é‡è³‡æ–™çš„å•é¡Œã€‚
é€™äº›å•é¡Œåœ¨å¯¦éš›çš„æ‡‰ç”¨é¢ä¸Šæœ‰å…±åŒç‰¹æ€§: å®ƒå€‘çš„è³‡æ–™é‡éƒ½éå¸¸åœ°é¾å¤§, å³ä¾¿æˆ‘å€‘èŠ±ç·šæ€§æ™‚é–“å…§å»è®€å®Œæ‰€æœ‰
çš„è¼¸å…¥ä¸¦ä¸”è¼¸å‡ºä¸€å€‹è§£ä¾†, åœ¨å¯¦éš›çš„æ‡‰ç”¨ä¸Šéƒ½ç¨å«Œå¤ªæ…¢ã€‚ æ€§è³ªæ¸¬è©¦åœ¨è¨ˆç®—è¤‡é›œåº¦ç†è«–ä¸Šæ˜¯ä¸€å€‹æ–°çš„é ˜åŸŸ,
å®ƒå¯ä»¥åœ¨ä¸éœ€è¦çœ‹éæ‰€çš„æœ‰è¼¸å…¥è³‡æ–™çš„æƒ…æ³ä¸‹, é€éä¸€å®šæ¬¡æ•¸çš„æŸ¥è©¢éƒ¨åˆ†çš„è¼¸å…¥è³‡æ–™, æ¨è«–å‡ºä¸€å€‹åˆç†çš„
è§£ã€‚ çµ¦å®šä¸€å€‹å‡½æ•¸ f : Dâ†’ F ç‚ºè¼¸å…¥, å¦‚æœå­˜åœ¨ä¸€å€‹å‡½æ•¸ f â€² : Dâ†’ F æ»¿è¶³æ€§è³ª P ä¸” f â€² èˆ‡ f å°æ‡‰çš„å‡½æ•¸
å€¼ä¸åŒä¹‹è™•ä¸å¤šæ–¼ |D| å€‹ä½ç½®, æˆ‘å€‘ç¨± f ç‚º -æ¥è¿‘æ–¼æ€§è³ª P, å¦å‰‡æˆ‘å€‘ç¨±æˆ‘å€‘ç¨± f ç‚º -é é›¢æ–¼æ€§è³ª Pã€‚
çµ¦å®šä¸€å€‹äº‹å…ˆå®šç¾©å¥½çš„æ€§è³ª P, æ€§è³ªæ¸¬è©¦æœ€ä¸»è¦çš„å·¥ä½œå¦‚ä¸‹: é€éæŸ¥è©¢æˆ–å­˜å–çš„ä¸€å€‹æœªçŸ¥çš„å‡½æ•¸ f, æ±ºå®š f
æ˜¯å¦æ»¿è¶³æ€§è³ª P æŠ‘æˆ– f ç‚º -é é›¢æ–¼æ»¿è¶³æ€§è³ª Pã€‚ å‡å¦‚å°æ–¼è©²æ€§è³ªæŸ¥è©¢çš„è¤‡é›œåº¦å’Œå•é¡Œè¼¸å…¥çš„å¤§å°å½¼æ­¤æ˜¯
ç¨ç«‹çš„, æˆ‘å€‘ç¨±é€™å€‹æ€§è³ªæ˜¯å¯æ¸¬è©¦çš„ã€‚ å›ºå®šåƒæ•¸æ¼”ç®—æ³•è¤‡é›œåº¦å’Œæ€§è³ªæ¸¬è©¦æ˜¯å…©å€‹ç•¶ä»Šæ¼”ç®—æ³•ç ”ç©¶é ˜åŸŸä¸­æœ€
ç†±é–€çš„ä¸»é¡Œ, é€™å…©å€‹ç ”ç©¶ä¸»é¡Œä¸åƒ…ååˆ†æœ‰è¶£, è€Œä¸”æ›´é‡è¦çš„æ˜¯, å¦‚ä½•æ‰¾å‡ºé€™å…©å€‹ç ”ç©¶æ–¹æ³•ä¸­çš„é—œé€£ã€‚ åœ¨é€™å€‹
è¨ˆç•«ä¸­, æˆ‘å€‘å°‡æœƒé‡å°æ¼”åŒ–æ¨¹ç›¸å®¹æ€§å•é¡Œå’Œ Î»2,1 å¡—è‰²å•é¡Œç ”ç©¶æœ‰æ•ˆç‡çš„éš¨æ©Ÿå›ºå®šåƒæ•¸æ¼”ç®—æ³•å’Œæ€§è³ªæ¸¬è©¦
æ¸¬æ¼”ç®—æ³•, ä¸¦ä¸”è©¦è‘—çµåˆå›ºå®šåƒæ•¸æ¼”ç®—æ³•å’Œæ€§è³ªæ¸¬è©¦æ¼”ç®—æ³•, é€²è€Œæå‡ºä¸€å€‹æ–°çš„æ–¹æ³•å»è§£æ±º NP-hard çš„
å•é¡Œã€‚ ç›®å‰åœ¨å°ç£å¾ˆå°‘äººæŠ•å…¥é€™æ–¹é¢çš„ç ”ç©¶, æˆ‘å€‘ç›¸ä¿¡åœ¨é€™å€‹è¨ˆç•«æ›¸ä¸­æ‰€æå‡ºçš„ç ”ç©¶ä¸»é¡Œå°‡æœ‰æ‹‹ç£šå¼•ç‰çš„
æ•ˆæœ, ä¸¦å¼•ç™¼åœ‹å…§ç ”ç©¶æ¼”ç®—æ³•çš„åŒä»æŠ•å…¥é€™äº›ç ”ç©¶é ˜åŸŸçš„èˆˆè¶£ã€‚
é—œéµè©: å›ºå®šåƒæ•¸æ¼”ç®—æ³•, æ€§è³ªæ¸¬å®š, è¿‘ä¼¼æ¼”ç®—æ³•, éš¨æ©Ÿæ¼”ç®—æ³•, æ¼”åŒ–æ¨¹, Î»2,1-è‘—è‰²ã€‚
i
ç›®éŒ„
1 å‰è¨€ 1
2 ç ”ç©¶ç›®çš„ 4
3 æ–‡ç»æ¢è¨ 5
3.1 Property testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
3.1.1 Testing graph properties in dense graphs . . . . . . . . . . . . . . . . . 6
3.1.2 Testing graph properties in sparse graphs . . . . . . . . . . . . . . . . 8
3.2 Parameterized complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.3 Quartet consistency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
3.4 Triplet consistency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.5 Î»2,1-colorability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
4 ç ”ç©¶æ–¹æ³• 24
4.1 Efficient fixed-parameter algorithms for the MQI problem . . . . . . . . . . . 24
4.1.1 Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
4.1.2 An O(3.0446kn+ n4) Algorithm . . . . . . . . . . . . . . . . . . . . . . 25
4.1.3 An O(2.0162kn3 + n5) Algorithm . . . . . . . . . . . . . . . . . . . . . 26
4.1.4 An Oâˆ—((1+ )k) Algorithm . . . . . . . . . . . . . . . . . . . . . . . . 26
4.2 Testing tree-likeness of quartet topologies . . . . . . . . . . . . . . . . . . . . 27
4.2.1 Existence of a complete set of quartet topologies which is at least 0.04-
far from being tree-like . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.2.2 An O(nïœ³/) property tester for tree-likeness of quartet topologies . . 30
4.2.3 Concluding remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
5 çµæœèˆ‡è¨è«– 35
6 è¨ˆç•«æˆæœè‡ªè©• 35
7 åƒè€ƒæ–‡ç» 36
8 é™„éŒ„ 45
8.1 å‡ºå¸­åœ‹éš›å­¸è¡“æœƒè­°å¿ƒå¾—å ±å‘Š . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
8.1.1 å‡ºå¸­ IWPEC 2008 æœƒè­°å¿ƒå¾—å ±å‘Š . . . . . . . . . . . . . . . . . . . . . . . 45
8.1.2 å‡ºå¸­ IWOCA 2010 æœƒè­°å¿ƒå¾—å ±å‘Š . . . . . . . . . . . . . . . . . . . . . . 46
8.2 ç™¼è¡¨è‘—ä½œ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
iii
2. Î¨P returns â€œ FAILâ€ with probability at least 2/3 if âˆ†(f,P) > .
From the definition of property tester, we can see that the quality of the output is guar-
anteed only if input function has the property or is -far from the property. Preferably, a
tester should look at a portion of the input whose size is a function of  only. In other words,
the query complexity of a tester should be O(n) where n is the size of the function tested.
Notice that we consider the size of a function f, denoted by |f|, tested by a tester is the size
of the domain of the function. If the query complexity of a property tester is independent of
the input size |f|, we say that this property is testable.
To familiar readers with property testing, we give the monotonically increasing sequence
testing problem as an example. Let F : D â†’ R be a set of one-to-one functions with the
same domain D, where D = {1, 2, . . . ,n} and R is the set of real numbers. Notice that
the size of any function in F is n. Let P be a property of functions in F such that, for a
function f âˆˆ F satisfying property P, we have f(i) < f(j) for 1 6 i < j 6 n. We define FP
to be the class of functions in F satisfying the property P. We say that f is monotonically
increasing if f âˆˆ FP. Let Î´(Â·, Â·) be a distance function such that for two functions f,g âˆˆ F,
Î´(f,g) = |{i | f(i) 6= g(i), for 1 6 i 6 n}|/n, that is, the fraction of elements in D where f
and g have different values. Then we define âˆ† to be the distance function with respect to
property P such that for a function f âˆˆ F, âˆ†(f,P) = mingâˆˆFP Î´(f,g). To design a property
tester for monotonically increasing property of a function f âˆˆ F is closely related to the
following problem:
Input: A sequence of n integers L = (x1, x2, . . . , xn) and a constant 0 <  < 1.
Output: Determine whether L is monotonically increasing.
For example, a sequence of n = 6 integers L = [10, 18, 7, 23, 2, 37] can be considered as
a function f âˆˆ F, where f(1) = 10, f(2) = 18, f(3) = 7, f(4) = 23, f(5) = 2, and f(6) = 37.
The size of function f, denoted by |f|, is 6. Let fâ€²(i) = Lâ€²[i] for 1 6 i 6 n = 6 where
Lâ€² = [10, 18, 19, 23, 25, 37]. It is easy to see that Î´(f, fâ€²) = 26 =
1
3 and âˆ†(f,P) = Î´(f, f
â€²).
Therefore f is 13 -close to property P. In [45], a tester for monotonically increasing is given
whose query complexity and running time are both O( 1 Â· lgn).
Property testing can be viewed as an alternate type of an approximation problem. Such
an approximation might be just as good as an exact answer when the data is constantly
changing, or might be used as a fast sanity check to rule out very â€œbadâ€ inputs before running
a slow but more exact algorithm. Property testers and the techniques behind them have been
applied to constructing approximate probabilistically checkable proof systems (approximate
PCPs; see [46] for more detailed results). Some property testers have been converted to
give sublinear time approximation algorithms, for example for the Max-Cut problem [57]. It
is interesting to note that there are examples of problems that are NP-hard to approximate
but for which the property testing version of the problem can be decided in constant time.
There have been plenty of methods and results in property testing and some related fields
of research. Yet, the study of sublinear algorithms is still very new, and much remains to be
understood about their scope.
2
2 ç ”ç©¶ç›®çš„
For a long time, to cope with intractable problems, people have referred to several other
related algorithmic methodologies, such as approximation algorithms, average-case analysis,
or purely heuristic methods. In other words, they were usually scared away and gave up
solving these intractable problem exactly. In fact, we usually find that most instances of an
NP-hard problem are easy to be solved. Thus ideally, we aim for statements such as â€œif some
parameter k is small in an intractable problem X, then X can be solved efficientlyâ€. Now,
instead of being scared away, we consider the strategy, fixed-parameter algorithms, to solve
these problems exactly.
Definition 3 (parameterized problem). A parameterized problem is a language L âŠ‚ Î£âˆ— Ã— Î£âˆ—,
where Î£ is a finite alphabet. The second component is called the parameter of the problem.
Generally speaking, a fixed-parameter algorithm is an algorithm that solves a parameter-
ized problem in f(k) Â·nO(1) time for some computable function f depending solely on k. Such
algorithms then bring out a class of problems called fixed-parameter tractable. When random-
ization was considered, Fellows and Koblitz [50, 51] introduced the concept of randomized
fixed-parameter tractable.
The concept of property testing was introduced in Section 1. As we have mentioned, we
are interested in coping with problems with large data efficiently. We know now there are
two kinds of ways for solving hard problems. Hence the major objective of this project is
to delve into the relation between property testing and parameterized complexity by solving
these hard problems. Toward the objective, we foucs on parameterized complexity and prop-
erty testing on the following three properties and try to delve into the relationship between
parameterized complexity and property testing:
â€¢ quartet consistency;
â€¢ triplet compatibility;
â€¢ Î»2,1-colorability.
By studying the parameterized complexity and property testing of the above three prop-
erties, we will then verify whether the following conjecture proposed by us is true by using
the experience of designing fixed-parameter algorithms and property testers.
Conjecture: For some property P, it has a property tester if and only
if there exists a randomized fixed-parameter algorithm that solves the
property P modification problem in time g() Â· nO(1) where n = |D|
and g(.) is a computable function depending solely on .
4
Goldwasser, and Ron [57]. They showed that many graph properties, such as k-colorability,
bipartiteness, having a large clique, having a large cut, etc., are easily testable under the
adjacency-matrix model. There are also non-graph properties discussed in the field of prop-
erty testing, such as testing monotonically nondecreasing of a sequence of numbers [45],
testing constraint satisfiability [6], testing whether a language is regular [4] (the results are
then extended to the testing on read-once branching programs [84] and read-twice branch-
ing programs [55], which are testable and non-testable respectively), etc. In [22], Batu et
al. considered testing whether two distributions of n elements are closed. For more detailed
results on testing combinatorial properties, especially the graph theoretical properties, see
the excellent surveys [7, 48, 56, 91] for further references.
In the rest of this subsection, we will summarize the recent results on testing graph
properties in both dense graphs and sparse graphs.
3.1.1 Testing graph properties in dense graphs
For dense graphs, the adjacency-matrix model is a commonly used model. In this model, a
property tester is allowed to make queries, where each query is to examine the value of (u, v)
in the adjacent matrix that whether vertices u, v are adjacent or not in the corresponding
graph. We say that an n-vertex graph is -far from satisfying a graph property P if more than
n2 edge additions or deletions should be performed on the graph to make the graph have
the property. In [57], graph properties that can be modeled as a certain partition problem,
such as k-colorability, having a large cut, having a large clique, etc., are shown to be testable.
In [2] it is shown that every first-order graph property without a quantifier alternation of type
â€˜âˆ€âˆƒâ€™ is testable. Later there are further results on monotone graph properties and hereditary
graph properties. Monotone graph properties are the graph properties that are closed under
removal of vertices and edges, while hereditary graph properties are the graph properties
that are closed under removal of vertices. It is clear that a monotone graph property is
also hereditary. Monotone graph properties and hereditary graph properties are shown to
be testable respectively in [9] and [10] by using SzemereÂ´diâ€™s Regularity Lemma [98] and
its variant version proposed by Alon et al. [2]. However, by making use of the regularity
lemma, the upper bounds of query complexity are only guaranteed to be towers of towers of
exponents of height polynomial in 1/.
Some researchers attempted to seek for the possibilities of deriving an upper bound on the
query complexity polynomial in 1/, that is, to prove that certain testable graph properties
are easily testable. Goldreich et al. [57] showed that k-colorability (including bipartiteness,
of course) is easily testable. However, it is also shown in [57] that property testers for
some properties, such as having a large clique, having a large cut, etc., only have two-sided
error property testers, hence their easily testability is excluded. For the other results related
to easily testability, let us consider the properties PH and Pâˆ—H as follows. PH is a graph
property that a graph does not contain any subgraph isomorphic to H, while Pâˆ—H is a graph
property that a graph does not contain any induced subgraph isomorphic to H. Clearly, PH
6
and Pâˆ—H are monotone and hereditary respectively. When we consider undirected graphs,
PH is shown to be easily testable [1] if H is bipartite. As for directed graphs, Alon and
Shapira [5] showed that PH is testable for every fixed connected digraph H, and they also
gave a precise characterization of Hâ€™s such that PH is easily testable. The core of a digraph H
is the subgraph K ofHwith the smallest number of edges, for which there is a homomorphism
from H to K. Alon and Shapira [5] showed that if PH is easily testable if and only if H does
not have a 2-cycle or an oriented tree as its core. They also showed that for a digraph H,
deciding whether PH is testable, is NP-complete [5]. Let us go back to the discussion on
undirected graphs. In [8], Alon and Shapira gave a nearly complete characterizations of Hâ€™s
such that Pâˆ—H is easily testable, though it is still open that whether Pâˆ—P4 and P
âˆ—
C4
are easily
testable (P4 is a path of length 3, i.e., a path of four vertices, while C4 is a cycle of length
four, i.e., a cycle of four vertices. To delve into the possibilities of certain graph properties
being easily testable is one of our main goals in this proposal. Table 3.1.1 summarizes the
results on testing graph properties in dense undirected graphs.
3.1.2 Testing graph properties in sparse graphs
For sparse graphs, the bounded-degree incidence-list model is the commonly used model. To
be concise, we abbreviate this model to bounded-degree graphs. In this model, a query is like
the question that â€œwho is the ith neighbor of vertex v in the graph?â€ A property tester can
probe the incidence list of the vertices in the graph, where the maximum degree of the graph
is assumed to be bounded (say, at most d). When we consider bounded-degree graphs, we
say that an n-vertex graph G is -far from satisfying a graph property P if more than dn
edge ss additions and deletions should be performed to make G satisfy the property. Unlike
the adjacency-matrix model for dense graphs, there are only a few results on testing testing
graph properties in the bounded-degree graphs. Goldreich and Ron [62] presented property
testing in bounded-degree graphs for connectivity, k-edge-connectivity2, cycle-freeness, and
Eulerianess3, all with query complexity polynomial in 1/. They also established â„¦(
âˆš
n)
lower bounds on the query complexity of testing bipartiteness, cycle-freeness (for one-sided
error property testers), and expander properties. An â„¦(n1/3) lower bound on the query
complexity for testing acyclicity in directed bounded-degree graphs is also obtained by Ben-
der and Ron [29]. For k-colorability, Bogdanov et al. [27] gave an â„¦(n) lower bound on
the query complexity of testing 3-colorability. Table 3.1.2 summarizes the results on testing
graph properties in sparse undirected graphs.
A graph H is said to be a minor of a graph G if H can be obtained from G using a
sequence of vertex removals, edge removals and edge contractions. A graph G is said to be
H-minor free if every minor of G is not isomorphic to H. In [30], it is shown that for every
(finite) graph H, the property of being H-minor free is testable in the sparse model. In one
of the deepest results in graph theory, Robertson and Seymour proved the so called Graph-
2A graph is said to be k-edge-connected if there are k edge-disjoint paths between each pair of the graph.
3A graph G is Eulerian if there exists a path in G that traverses every edge in G exactly once.
8
Minor Theorem [96], which states that a graph satisfies P, there is a finite family of graphs
HP such that a graph satisfies P if and only if it is H-minor free for all H âˆˆ HP. Follows
this immediately, every minor-closed graph property is testable, however, the running time
of their property tester is O(22
2poly (1/ )
), and the analysis is quite complicated. Using the
locality lemma given in [86], Hassidim et al. [65] simplified the proof in [30] and provide a
better time bound on testing minor-closed properties, which is O(2poly(1/)).
It deserves to be noted that there have been some results on testing graph properties
in some special graph classes. Czumaj and Sohler [39] showed that any hereditary graph
property is testable if the input graph belongs to a non-expanding family of graphs.
3.2 Parameterized complexity
Downey and Fellowsâ€™ [42] work in 1999 is one of the best monographs for introducing
parameterized complexity. Later in 2006, Niedermeier [85] wrote an elaborate textbook
for introducing fixed-parameter algorithms and parameterized complexity. As to design and
analyze fixed-parameter algorithms, there have been plenty of useful techniques devised.
Here we summarized them as follows.
â€¢ data reduction and problem kernels [42]
â€¢ depth-bounded search trees [42, 82]
â€¢ dynamic programming [38, 101]
â€¢ tree-decompositions of graphs [94]
â€¢ color-coding [12] (also divide-and-color [79])
â€¢ integer linear programming [61]
â€¢ iterative compression [97]
â€¢ greedy localization [75]
â€¢ graph minor theory [40, 42, 44, 94]
â€¢ randomized algorithms [12, 20]
Basic definitions and facts are listed in the following paragraphs.
â€¢ Data reduction and problem kernels. To simplify matters, it is assumed here that the
parameter is a positive integer. Cases with more than one parameter being a number are
each handled analogously.
Definition 5. Let L be a parameterized problem, that is, L consists of input pairs (I, k),
where I is the problem instance and k is the parameter. Reduction to a problem kernel then
means to replace instance (I,k) by a â€œreducedâ€ instance (Iâ€²,kâ€²) (called problem kernel) such
that
kâ€² 6 k, |Iâ€²| 6 g(k)
for some function g only depending on k, and
(I, k) âˆˆ L iff (Iâ€²,kâ€²) âˆˆ L.
10
where d := max{d1, . . . ,di}. Now, we describe a simple scheme how to solve recurrence
equations in the form of 1. Let us assume that recurrence 1 has a solution of the form
Tn = Î±
n for some real or even complex number Î±. Setting n := d and plugging this into
recurrence 1 we obtain
Î±d = Î±dâˆ’d1 + . . .+ Î±dâˆ’di , (3)
that is, Î± is a zero of the characteristic polynomial 2. In the same way, it is also not hard to
see the converse direction if Î± is zero of the characteristic polynomial then Î±n is a solution
of the recurrence 1. Moreover, with some more effort one can show that if Î± is a jth zero of
the characteristic polynomial 2 then nl Â· Î±n for all 0 6 l < j is a solution of recurrence 1.
This finally leads to the following result.
Proposition 2. A depth-bounded search tree with branching vector (d1, . . . ,di) and its root
labeled with parameter value n has size nO(1) Â· |Î±|n, where Î± is the zero of the corresponding
characteristic polynomial.
The base Î± of the exponentially growing function in Proposition 2 is called the branching
number. Obviously, the ordering of the entries of a branching vector plays no role in the
mathematical analysis; it may only reflect the order of the recursive calls corresponding to
each vector entry.
â€¢ Dynamic programming. In a sense, dynamic programming makes exhaustive searchâ€”
which guarantees finding optimal solutionsâ€”more efficient by avoiding the computation of
solutions of subproblems more than once. Dynamic programming is a promising solution
strategy when a problem exhibits the property of having optimal substructure, that is, an
optimal solution to the problem contains within its optimal solutions to subproblems. More-
over, dynamic programming uses this property in a bottom-up fashion. Two properties usually
make dynamic programming particularly feasible:
- independence
- overlapping subproblems
By independence of subproblems we mean that the solution of one subproblem does not
affect the solution of another subproblem of the same problem. By overlapping subproblems
we mean that the same problem occurs as as subproblem of different problems, hence giv-
ing an advantage over recursive algorithms where these solutions of subproblems would be
computed more than once.
Dynamic programming applies to every problem that observes the principle of optimality.
In a nutshell, this means that solutions to subproblems can be optimally extended only with
regard to the current â€œstateâ€ of this solutionâ€”it is to date. Finally, a brief word about a
variation of dynamic programming: memoization. The basic difference from dynamic pro-
gramming in the classical sense here is that the flow of control changes: the dynamic pro-
gramming is filled with in a top-down manner instead of a bottom-up one. We maintain a
12
Figure 1: A graph together with a tree decomposition of width 2.
Lemma 1. Given a width-k and n-nodes tree decomposition of a graph G, one can find a width-
k and O(n)-nodes nice tree decomposition of G in O(n) time.
Tree decompositions of graphs are connected to another central concept in algorithmic
graph theory: graph separators. Graph separators are vertex sets whose removal from the
graph separates the graph into two or more connected components.
Definition 8. Let G = (V ,E) be a connected graph. A subset S âŠ† V is called a separator of
G if the subgraph G[V \ S] is disconnected.
Actually, each bag of a tree decomposition forms a separator of the corresponding graph.
Here, however, we are more interested in the reverse direction, that is, constructing tree
decompositions from graph separators. The fundamental idea is to find small separators of
the graph and to merge tree decompositions of the resulting subgraphs using the separator
sets as â€œinterfacesâ€.
For any given separator splitting a graph into different components, we obtain a simple
upper bound for the tree width of this graph which depends on the size of the separator and
the tree width of the resulting components.
Proposition 3. If a connected graph can be decomposed into components of treewidth of at most
t by means of a separator of size s, then the whole graph has treewidth of
â€¢ Color-coding. [12] Many graph problems are actually special versions of the Subgraph
Isomorphism Problem as follows.
Input: Two graphs G = (V ,E) and Gâ€² = (V â€²,Eâ€²).
Output: Determine whether there is a subgraph ofG that is isomorphic
to Gâ€².
14
number of variables can be solved in linear time. More precisely, with improvements due to
Ravi Kannan [77], we have the following theorem. It refers to the so-called Integer Linear
Programming Feasibility Problem where one has to decide on the existence of (not necessar-
ily optimal) solutions fulfilling all the constraints given by linear inequalities over a set of
integer-valued variables.
Theorem 2 ([81]). The Integer Linear Programming Feasibility Problem can be solved with
O(p9p/2L) arithmetic operations in integers of O(p2pL) bits in size, where p is the number of
ILP variables and L is the number of bits in the input.
Note that this fixed-parameter result with respect to p also needs space exponential in
the parameter p.
â€¢ Iterative compression. Iterative compression is a very new technique introduced by
Reed et al. [97] published in 2004. It has already led to significant breakthroughs in show-
ing fixed-parameter tractability results. For instance, in this way the Graph Bipartization
Problem, that is, the task of finding a minimum set of vertices whose deletion transforms
a graph into a bipartite graph, has been shown fixed-parameter tractable with respect to
the number of deleted vertices. For years this has been a central open problem in parame-
terized complexity. Moreover, ongoing research indicates that the corresponding algorithm,
improved by performance tuning through algorithm engineering, is competitive in practice.
In a nutshell, iterative compression can be described as follows. The technique serves for
developing fixed-parameter algorithms for minimization problems parameterized by the size
of the solution set. The basic idea is that it is sufficient to give a fixed-parameter algorithm
which, given a size-(k+ 1) solution, either constructs a size-k solution or proves that there is
no size-k solution. For example, one can show that, given an n-vertex graph and a bipartiza-
tion vertex set with k+ 1 vertices, one can find in O(3k Â·k Â·m) time a bipartization vertex set
with k vertices, or decide that there is no such vertex bipartization. This is the compression
step, the workhorse of the whole algorithm. Based on this compression step, the algorithm it-
eratively considers for i = 1, 2, . . . ,n the induced subgraphs Gi of the input graph G = (V ,E)
where V := {v1, . . . , vn} and Gi = G[{v1, . . . , vi}]. Clearly, the optimal vertex bipartization for
G1 is the empty set. For i > 1, if Gi has no vertex bipartization of size k, then neither has
Gi+1; otherwise, let X denote a vertex bipartization of Gi with |X| 6 k. Then, X âˆª {vi+1} is a
vertex bipartization of Gi+1. If the set Xâˆª {vi+1} has k+ 1 vertices, the algorithm attempts to
â€œcompressâ€ it to a set of size k. The running time of the algorithm is clearly O(3k Â· k Â·m Â· n).
Although the overall algorithmic strategy is very intuitive, a lot of technical work can lie in
showingâ€”if at all possibleâ€”that the compression step can be done in O(f(k) Â· nO(1)) time.
â€¢ Greedy localization. Different to the previous strategy, iterative compression, greedy
localization is another new method to attack maximization problems. This strategy was first
introduced by Jia et al. [75] in 2004, and further applications appeared in succession [43,
16
vertices on each side. The following two theorems are very interesting and crucial in the
graph minor theory.
Theorem 3 (The Graph Minor Theorem [76]). Let F be a family of finite graphs closed under
taking minors. Then there exists a finite â€œobstruction setâ€ of graphs OF = {H1,H2, . . . ,Ht} such
that
(G /âˆˆ F) â‰¡ (âˆƒ1 6 i 6 t : Hi 6m G).
Theorem 4. [76] Given an n-vertex graph G and a fixed k-vertex graph H, we can decide in
f(k) Â· n3 time whether H 6m G. Here f is a function depending only on k but not on f.
â€¢ Randomized algorithms. To illustrate a randomized fixed-parameter algorithm, let us
consider the Feedback Vertex Set Problem first as follows.
Input: Two graphs G = (V ,E) and a nonnegative integer k.
Question: Is there a subset V â€² âŠ† V with k or fewer vertices such that
each cycle in G contains at least one vertex from V â€²?
Thus removing the vertices in V â€² from G results in a forest.
A fairly simple and efficient randomized fixed-parameter algorithm for the Feedback Ver-
tex Set Problem was given by Beck et al. [20]. The key observations are as follows. First,
it is easy to eliminate vertices of degree at most two from the graph. Thus, assuming with-
out loss of generality a graph with minimum vertex degree three, the algorithm is based on
the easy-to-prove observation that if one picks an edge at random then there is a probabil-
ity of at least 1/2 that at least one of its two endpoints belongs to any feedback vertex set
searched for. This implies that with probability 1/4 a vertex chosen uniformly at random is
part of the desired feedback vertex set. This leads to a simple (Monte Carlo) randomized
algorithm that terminates with a feedback vertex set of size k with probability at least 1/4k.
Repeating the above algorithm independently c Â· 4k times results in an algorithm that after
O(c Â· 4k Â· n) steps finds a size-at-most-k feedback vertex setâ€”if it existsâ€”with probability at
least 1âˆ’ (1âˆ’ 1/4k)cÂ·4k .
Related work on demonstrating randomized fixed-parameter tractability of problems is
summarized as follows. Fellow and Koblitz [50, 51] showed that the Bounded Factor Fac-
torization Problem, the Polynomially Smooth Number Problem, and the Small Prime Di-
visor Problem (all with a positive integer k being the parameter) are in randomized FPT.
Brightwell and Winkler [31, 32] showed that the Linear Extension Count Problem is in ran-
domized FPT, yet not known to be in FPT.
3.3 Quartet consistency
Let S be a set of taxa and |S| = n. An evolutionary tree T on S is an unrooted, leaf-labeled tree
such that the leaves of T are bijectively labeled by the taxa in S, and each internal node of
T has degree three. A quartet is a size 4 subset {a,b, c,d} of the taxon set S and the quartet
18
3.4 Triplet consistency
Here we focus on rooted and binary evolutionary trees. Let S be a set of n taxa. An rooted
evolutionary tree T on S is a rooted, leaf-labeled binary tree such that the leaves of T are
bijectively labeled by the taxa in S, and each internal node of T has exactly two children. We
denote by a <T b that the a node a is a descendant of a node b in T . The lowest common
ancestor of x and y in T , denoted by lcaT (x,y), is an ancestor of x and y such that none of
its proper descendants is an ancestor of x and y. We call a set of three taxa in S a triple. If
lcaT (a,b) <T lcaT (a, c), then we say that the triple {a,b, c} has a triplet (or triple topology)
((ab)c) induced by T , and, equivalently, we say T satisfies ((ab)c). For example, consider
the rooted evolutionary tree T in Fig. 4, the triples {a,b, c} and {c,d, e} have induced triplets
((ab)c) and ((cd)e) respectively. Namely, a triplet is a rooted evolutionary tree with three
leaves. A triple {a,b, c} has a triplet either ((ab)c), ((ac)b), or ((bc)a) induced by a rooted
evolutionary tree, as Fig. 5 shows. Note that by the rules representing a rooted evolutionary
tree, we regard ((ab)c), ((ba)c), (c(ab)), and (c(ba)) as the same triplet.
Figure 4: A rooted evolutionary tree.
Let Y be a set of triplets over S such that each triple has at most one triplet in Y. We
denote by YT the set of all induced triplets in a rooted evolutionary tree T . We say that Y is
tree-consistent if there exists a rooted evolutionary tree T such that Y âŠ† YT . We say that a
rooted evolutionary tree T satisfies Y if all the triplets in Y are satisfied by T .
Figure 5: Possible triplets of {a,b, c}.
Given a set ofm constraints of the form lcaT (a,b) <T lcaT (c,d), where a,b, c,d âˆˆ S, Aho
et al. [11] focused on the problem of determining whether there exists a rooted evolutionary
tree T (yet not necessarily binary) satisfying all of the input constraints. They showed that
20
Î»2,1-coloring of graphs has been extensively studied during the past decade. These in-
clude bounds for general graphs [34, 80] as well as special graphs such as trees [34, 63],
chordal graphs [100], bipartite graphs [25], complete k-partite graphs [63], cographs [34],
k-almost trees [52], outerplanar and planar graphs [25, 54, 67, 83, 106], graphs of treewidth k,
permutation graphs and split graphs [25]; exact values for paths, cycles, hexagonal grids,
bidimensional grids, cellular grids, cartesian products and strong products of cycles, etc. [28,
63, 70, 71]. For a general graph G with maximum degree âˆ†, âˆ† > 2, Griggs and Yeh [63]
proved that Î»(G) 6 âˆ†2 + 2âˆ† and conjectured that Î»(G) 6 âˆ†2 in general. This upper
bound was later improved to Î»(G) 6 âˆ†2 + âˆ† by Chang and Kuo [34]. In 2003, KraÂ´l and
SË‡krekovski [80] improved this bound by showing Î»(G) 6 âˆ†2 + âˆ† âˆ’ 1. In 2005, KraÂ´l [78]
considered the generalized version of the Î»2,1-coloring problem and gave an exact algorithm
computing the bound for general graphs, although the running time is not polynomial. For
the class of chordal graphs, Sakai [100] showed that Î»(G) 6 (âˆ† + 3)2/4 for any chordal
graph G. Table 3 is the summary of previous results on the Î»2,1-coloring problem.
We say that a graph G is Î»2,1-colorable if G has a Î»2,1-coloring. Fiala et al. [52] showed
that for a general graph G, determine whether G is Î»2,1-colorable is NP-complete for every
fixed value Î» > 4. Junosza-Szaniawski and RzaÂ¸zË™ewski presented an Oâˆ—(3.3323n) exact algo-
rithm for finding a Î»2,1-coloring of a graph where the largest label Î» is as least as possible.
22
4 ç ”ç©¶æ–¹æ³•
4.1 Efficient fixed-parameter algorithms for the MQI problem
During execution of this project, by working on the parameterized complexity of the MQI
problem, we have some surprising results. Instead of designing a randomized fixed-parameter
algorithm for the parameterized MQI problem, we devised deterministic ones:
â€¢ an O(3.0446kn+ n4) time fixed-parameter algorithm,
â€¢ an O(2.0162kn3 + n5) time fixed-parameter algorithm, and
â€¢ an Oâˆ—((1+ )k) time fixed-parameter algorithm
for the parameterized MQI problem. We briefly describe our approaches in the following
subsections.
4.1.1 Preliminaries
A quintet is a set of five taxa in S, while a sextet is a set of six taxa in S. The quintet topology
of a quintet {a,b, c,d, e} induced by an evolutionary tree T is the path structure connecting
a, b, c, d, and e in T . Similarly, we have the sextet topology of a sextet. Without loss of
generality, assume that we have [bc|de] induced by T and another taxon a, we have five
possible quintet topologies (Figure 6). Thus it is clear that there are 15 possible quintet
topologies for a quintet. Two taxa a,b are siblings on an evolutionary tree T if a and b are
both adjacent to the same internal vertex in T . Here we consider the sextet topologies of
the sextet {a,b,w, x,y, z} where a,b are siblings. It is clear that there are 15 possible sextet
topologies with siblings a,b for a sextet {a,b,w, x,y, z} (Figure 7).
Figure 6: Five possible topologies for the quintet {a,b, c,d, e} when [ab|cd] is given.
Given a set of quartet topologiesQ over the taxon set S, we say that a quintet {a,b, c,d, e}
âŠ† S is resolved if there exists an evolutionary tree T â€², on which a,b, c,d, e are leaves, such
that all the quartet topologies induced by T â€² are in Q. Otherwise, we say that {a,b, c,d, e}
is unresolved. Similarly, we say that a sextet {a,b,w, x,y, z} âŠ† S is {a,b}-resolved if there
exists an evolutionary tree T â€²â€², on which a,b,w, x,y, z are leaves and a,b are siblings, such
that all quartet topologies induced by T â€²â€² are in Q. Otherwise, we say that {a,b,w, x,y, z} is
{a,b}-unresolved.
Theorem1 can be easily obtained by Bandelt and Dressâ€™ work [21], and Theorem 2 can
be derived in Gramm and Niedermeierâ€™s work in [60].
24
q = {a,b, c,d, e} âˆˆ Cf arbitrarily and then tries to make q resolved by the procedure update
according to all the possible 15 quintet topologies of q. The procedure update changes quar-
tet topologies according to the quartet topologies which Âµ stands for, and updates the set Cf
and the parameter k to be C â€²f and k
â€² respectively.
The algorithm works as a depth-bounded search tree. Each tree node has 15 branches
and each branch corresponds to a quintet topology. Since there are 243 possible topology
vectors of a quintet but 15 of them are in V, we have 228 possible branching vectors and the
corresponding branching numbers as well. It can be derived that the branching number in
the worst case is between 3.0445 and 3.0446. Thus the size of the search tree is O(3.0446k).
Then we obtain the following theorem by careful analysis.
Theorem 3. There exists anO(3.0446kn+n4) fixed-parameter algorithm for the parameterized
minimum quartet inconsistency problem.
4.1.3 An O(2.0162kn3 + n5) Algorithm
We define the two-siblings-determined minimum quartet inconsistency problem (2SDMQI) as
follows. Given a complete quartet topology set Q over a taxon set S, a parameter k and
two taxa a,b âˆˆ S as the input, determine whether there exists an evolutionary tree T on
which a and b are siblings such that QT differs from Q in at most k quartet topologies. For
this problem, we devised a fixed-parameter algorithm FPA-2SDMQI, which works as follows.
First, for every u, v âˆˆ S \ {a,b} such that [ab|uv] /âˆˆ Q, we change the quartet topology of
{a,b,u, v} to be [ab|uv] and decrease k by 1. Second, we build two lists Ca and V2, where
Ca is a list of unresolved quintets containing a while V2 is a list of {a,b}-reduced topologies
vectors of possible sextet topologies on which a,b are siblings. Then the algorithm calls a
recursive subroutine to resolve all {a,b}-unresolved sextets by changing at most k quartet
topologies. In each recursion of this subroutine, we arbitrarily select an unresolved quintet q
and try to make q âˆª {b} be {a,b}-resolved by the procedure update2 according to all possible
15 sextet topologies of qâˆª {b} having a,b as siblings. The procedure update2 updates the set
of unresolved quintets Ca and the parameter k.
By careful analysis, we obtain that the size of the search tree is O(2.0162k). Hence we
have anO(2.0162kn+n4) fixed-parameter algorithm for the 2SDMQI problem. Besides, since
every evolutionary tree with |S| > 4 leaves has at least two pairs of taxa which are siblings,
we have the following theorem.
Theorem 4. There exists an O(2.0162kn3 + n5) fixed-parameter algorithm for the parameter-
ized minimum quartet inconsistency problem.
4.1.4 An Oâˆ—((1+ )k) Algorithm
Let T denote an evolutionary tree on S such that QT differs from Q in at most k quartet
topologies. For an integer m > 2, we say that taxa a1, . . . ,am are adjacent if there exists
an edge e = (w, v) on T such that cutting e will produce a bipartition ({a1, . . . ,am},S \
26
those in Qâˆ— are called the quartet errors of Q, and we call the number of such quartet errors
the error number of Q for the sake of conciseness.
Let us recall the general concepts of property testing by considering functions as follows.
Let F be the set of all functions with the same domain D. Let P be a fixed property of func-
tions in F, which can be viewed as a subset of F. For two functions f,g âˆˆ F, let Î´(f,g) denote
the fraction of the domain elements in D where f and g have different values. Obviously the
range of Î´ is [0, 1]. Then for a function f âˆˆ F, we define that âˆ†(f,P) = mingâˆˆP Î´(f,g). We say
that f satisfies the property P if âˆ†(f,P) = 0. We say f is -far from satisfying P if âˆ†(f,P) > ,
otherwise f is said to be -close to satisfying P. The following is the general definition for a
property tester.
Definition 10 (Property testers [57]). Given a function f âˆˆ F and a parameter 0 <  6 1 as
the input, a property tester for P is an algorithmM such that the following conditions hold:
1. M makes o(|D|) queries;
2. M returns â€œyesâ€ with probability at least 2/3 if f âˆˆ P;
3. M returns â€œnoâ€ with probability at least 2/3 if âˆ†(f,P) > .
Moreover, we say that M is a one-sided-error property tester if it returns â€œyesâ€ whenever f
satisfies P with probability 1.
Throughout the following discussions, we assume thatQ is complete and |S| = n > 5. We
assume that an array of
(
n
4
)
entries is used for storing the topology for each quartet over S
such that a query for getting the topology of a quartet can be done in constant time. We
say that Q satisfies quartet consistency if Q is tree-like, that is, âˆ†(Q,Pq) = 0. We say that
Q is -far from satisfying quartet consistency if the error number of Q is at least 
(
n
4
)
, that
is, âˆ†(Q,Pq) > . For testing quartet consistency, a query means to examine the topology
of a quartet in Q, and we assume that it can be done in constant time. Similar to the
previous content introducing general property testers, we define a property tester for quartet
consistency as follows.
Definition 11. Given a complete set of quartet topologies Q. A property tester for quartet
consistency is an algorithmM making o(n4) queries, such that
i. M answers â€œyesâ€ with probability at least 2/3 if âˆ†(Q,Pq) = 0 (i.e., Q satisfies quartet
consistency);
ii. M answers â€œnoâ€ with probability at least 2/3 if âˆ†(Q,Pq) >  (i.e., the error number
of Q is at least 
(
n
4
)
).
Moreover, we say thatM is a one-sided-error property tester for quartet consistency if it returns
â€œyesâ€ with probability 1 whenever Q satisfies quartet consistency.
4.2.1 Existence of a complete set of quartet topologies which is at least 0.04-far
from being tree-like
Here we show that there exists a complete set of quartet topologies that is at least 0.04-far
from being tree-like, that is, its error number is at least 0.04
(
n
4
)
. The sketch of the proof
28
Theorem 9. There exists a set of quartet topologies Q which is at least 0.04-far from being
tree-like.
Proof. Let Qâˆ— be a tree-like set of quartet topologies over the taxon set S. We know that
there exists a set of quintets U over S of size at least 0.04
(
n
4
)
such that every two quintets
in U do not share any quartet (by Lemma 8). Then, for each quintet in U, we arbitrarily
pick one of its subset quartets and change its corresponding topology in Qâˆ— to one of the
other two possible topologies arbitrarily. LetQ denote the resulting set of quartet topologies.
Now, every quintet in U with respect to Q has exactly one subset quartet whose topology is
changed. Since one has to change at least two quartet topologies over a resolved quintet to
make this quintet resolved again (by Fact 1), every quintet in U is unresolved with respect
to Q. Furthermore, for each of these unresolved quintets in U, we have to change at least
one quartet topology of its subset quartets to make it resolved (otherwise, the unresolved
quintet stays the same). Hence at least |U| quartet topologies in Q have to be changed to
make the unresolved quintets in U with respect to Q resolved. Therefore, we obtain that the
error number of Q is at least |U| > 0.04
(
n
4
)
, hence Q is at least 0.04-far from being tree-like,
as claimed by the theorem.
2
4.2.2 An O(nïœ³/) property tester for tree-likeness of quartet topologies
Our property tester for tree-likeness of quartet topologies is presented in Table 4. Theo-
rem 10, which is mentioned in [37] and was implicitly proved in Bandelt and Dressâ€™ re-
sult [21], is the building block of our property tester.
1. Pick an arbitrary taxon ` âˆˆ S, and then repeat (a) and (b) for 72

n3 times.
(a) Pick four taxa s1, s2, s3, s4 âˆˆ S \ {`} uniformly at random.
(b) If the quintet {s1, s2, s3, s4, `} is not resolved, then return â€œnoâ€.
2. Return â€œyesâ€.
Table 4: A property tester for tree-likeness of quartet topologies.
Theorem 10 ([21]). Given a set of taxa S, a complete set of quartet topologies Q over S, and a
fixed taxon ` âˆˆ S, Q is tree-like if and only if every quintet containing ` is resolved.
Remarks. It follows from Theorem 10 that we can determine whether Q is tree-like by
examining quintets with respect to Q. If Q is not tree-like (i.e., the error number of Q is at
least one), by Theorem 10, we know that for any fixed taxon ` âˆˆ S, there exists an unresolved
quintet containing `. Hence it is clear that the number of unresolved quintets with respect
to Q is at least â„¦(n), which yields an O(n4) deterministic algorithm to see if Q is tree-like.
Intuitively, we expect more unresolved quintets when the error number of Q gets larger. In
particular, if the error number of Q is at least cn4 for some constant c, we expect to have
30
The following theorem shows that the algorithm given in Table 4 is a non-adaptive prop-
erty tester which is of one-sided error and makes at most O(n3/) queries.
Theorem 12. The algorithm in Table 4 is a non-adaptive one-sided-error property tester for
tree-likeness of quartet topologies, which makes at most O(n3/) queries.
Proof. If Q is tree-like, then the algorithm will never find an unresolved quintet, it will
always return â€œyesâ€, hence it is of one-sided-error. As for the case that Q is -far from being
tree-like, consider an arbitrarily fixed taxon ` âˆˆ S. By Theorem 11, the number of unresolved
quintets containing ` with respect to Q is more than n/36. In each iteration of the loop of
the algorithm, the probability of finding an unresolved quintet is at least (n/36)/
(
nâˆ’1
4
)
>
(/36)/n3. For simplicity, let Î± denote (/36)/n3. Once an unresolved quintet is found
during these 2/Î± iterations, the algorithm returns â€œnoâ€, otherwise, it returns â€œyesâ€, with
probability at most (1 âˆ’ Î±)2/Î± 6 eâˆ’2 < 1/3, where we use the fact that (1 âˆ’ t)âˆ’1/t > e
for any t > 0 (Note that eâˆ’1 = limtâ†’0(1 âˆ’ t)1/t). Moreover, checking whether a quintet is
resolved or not requires at most five queries, thus at most O(n3/) queries are made by the
algorithm. Since the algorithm makes each query without knowing the results of previous
ones, it is clearly non-adaptive. The theorem is proved. 2
4.2.3 Concluding remarks
We propose a one-sided error property tester for tree-likeness of quartet topologies, which is
non-adaptive and utilizes at most O(n3/) queries. However, for the moment, whether the
query complexity of testing tree-likeness of quartet topologies can be proved to be indepen-
dent of n still remains open.
Figure 9: The tree structure with the quartet topology [ab|cd]. T1, T2, T3, T4, and T5 are subtrees.
One might be curious about whether our results can be extended to incomplete sets of
quartet topologies. Unfortunately, it seems to be impossible since Theorem 10 is not true
when the set of quartet topologies Q is incomplete. Let us say a quintet is partially resolved
if the set of quartet topologies over this quintet in Q is tree-consistent (but not necessarily
tree-like). The following example illustrates that there exists an incomplete set of quartet
topologies Q, such that Q is not tree-consistent even when each quintet is partially resolved
with respect to Q.
32
over S = {a,b, c,d, e, f}. There are only two quartets which do not have topologies in Q
(i.e., {a,b, c,d} and {a,d, e, f}). We observe that Q is â€œdenseâ€ in this case. To be precise, for
each quintet, at least four of its subset quartets have topologies in Q. Similar to the previ-
ous example, we observe from Fig. 12 that each quintet is partially resolved. However, Q
is not tree-consistent due to the following observation. Consider the topology of the quintet
{a,b, c,d, e}. The evolutionary tree with the quartet topology [ab|ce] is depicted in Fig. 11.
Since [ab|de], [ad|ce] âˆˆ Q, the taxon d has to be in T3. Similarly, we derive that f has to be
in T2 since [ae|bf] âˆˆ Q. Then we obtain that the induced topology of the quartet {a, c,d, f} on
the evolutionary tree can only be [af|cd], which contradicts the assumption that [ac|df] âˆˆ Q.
Figure 12: A set of thirteen quartet topologies Q, where only two quartets {a,b, c,d} and {a,d, e, f} do
not have topologies in Q. Each quintet over S = {a,b, c,d, e, f} is partially resolved.
By the above two examples, we conclude that when the input set of quartet topologies
is not complete, â€œlocal consistencyâ€ (i.e., the property that each quintet is partially resolved)
does not guarantee â€œglobal consistencyâ€ (i.e., the property that Q is tree-consistent).
34
Computing Systems é€™æœŸåˆŠæ‰€æ¥å—ç™¼è¡¨ã€‚
å¤§è‡´è€Œè¨€, æœ¬è¨ˆç•«çš„ç ”ç©¶å…§å®¹èˆ‡åŸè¨ˆç•«ç›¸ç¬¦ç¨‹åº¦ç”šé«˜, ç ”ç©¶æˆæœæ·±å…·å­¸è¡“åƒ¹å€¼, è¨ˆæœ‰ä¸€ç¯‡åœ‹éš›ç ”è¨æœƒ
è«–æ–‡ä»¥åŠå…©ç¯‡åœ‹éš›æœŸåˆŠè«–æ–‡çš„è‘—ä½œç™¼è¡¨ã€‚ é›–ç„¶å› å•é¡Œå›°é›£è€Œæ™‚é–“æœ‰é™,æˆ‘å€‘æœªèƒ½å®Œæˆè¨ˆç•«çš„æ‰€æœ‰é æœŸç›®æ¨™,
ä½†æ˜¯åœ¨è¨ˆç•«åŸ·è¡ŒæœŸé–“,æˆ‘å€‘è—‰ç”±èˆ‡åœ‹å¤–å­¸è€…çš„åˆä½œèˆ‡è¨è«–,é™¤äº†æœ‰è«–æ–‡ç™¼è¡¨ä»¥å¤–,æˆ‘å€‘å¾—åˆ°è¨±å¤šèˆ‡åœ‹å¤–å­¸è€…
åˆä½œçš„å¯¶è²´ç¶“é©—, åŒæ™‚ä¹ŸæŒæ¡äº†ç›®å‰ä¸–ç•Œä¸Šç†è«–è¨ˆç®—æ©Ÿç§‘å­¸ç•Œçš„ç ”ç©¶è¶¨å‹¢, ä½¿æˆ‘å€‘æœªä¾†åœ¨ç›¸é—œç ”ç©¶å•é¡Œä¸Š,
èƒ½å¤ æ›´æœ‰ä¿¡å¿ƒè§£æ±ºç›¸é—œçš„å•é¡Œã€‚ æ­¤å¤–, åœ¨æœ¬è¨ˆç•«åŸ·è¡ŒæœŸé–“, åƒèˆ‡è¨ˆç•«çš„åšå£«ç­å­¸ç”Ÿæ—èŠå‚‘èµ´ IWPEC æœƒè­°
è² è²¬å ±å‘Šç ”ç©¶æˆæœ, é”åˆ°äº†è¨“ç·´å…¶åœ¨åœ‹éš›ç ”è¨æœƒä¸Šæ¼”è¬›èƒ½åŠ›çš„ç›®çš„, å°å…¶æ—¥å¾Œçš„å­¸è¡“ç ”ç©¶æœ‰ç›¸ç•¶å¤§çš„åŠ©ç›Šã€‚
7 åƒè€ƒæ–‡ç»
[1] N. Alon: Testing subgraphs in large graphs. Random Structures Algorithms 21 (2002)
359â€“370.
[2] N. Alon, E. Fischer, M. Krivelevich, and M. Szegedy: Efficient testing of large graphs.
Combinatorica 20 (2000) 451â€“476.
[3] N. Alon and M. Krivelevich: Testing k-colorability. SIAM J. Discrete Math. 15 (2002)
211â€“227.
[4] N. Alon, M. Krivelevich, I. Newman, and M. Szegedy: Regular languages are testable
with a constant number of queries. SIAM J. Comput. 30 (2001) 1842â€“1862.
[5] N. Alon and A. Shapira: Testing subgraphs in directed graphs. In Proceedings of the
35th Annual Symposium on Theory of Computing (STOCâ€™03), San Diego, California, pp.
700-709. Also: J. Comput. System Sci. 69 (2004) 354â€“382.
[6] N. Alon and A. Shapira: Testing satisfiability. J. Algorithms 47 (2003) 87â€“103.
[7] N. Alon and A. Shapira: Homomorphisms in graph property testing - A survey. Elec-
tronic Colloquium on Computational Complexity (ECCC 2005). Report No. 85.
[8] N. Alon and A. Shapira: A characterization of easily testable induced subgraphs. Com-
bin. Probab. Comput. 15 (2006) 791â€“805.
[9] N. Alon and A. Shapira: Every monotone graph property is testable. SIAM J. Comput.
38 (2008) 505â€“522.
[10] N. Alon and A. Shapira: A characterization of the (natural) graph properties testable
with one-sided error. SIAM J. Comput. 37 (2008) 1703â€“1727.
[11] A. V. Aho, Y. Sagiv, T. G. Szymanski, and J. D. Ullman: Inferring a tree from lowest
common ancestors with an application to the optimization of relational expressions.
SIAM J. Comput. 10 (1981) 405â€“421.
[12] N. Alon, R. Yuster, and U. Zwick: Color-coding. J. ACM 42 (1995) 844â€“856.
36
[26] M. Blum, M. Luby, and R. Rubinfeld: Self-testing/correcting with applications to nu-
merical problems. J. Comput. System Sci. 47 (1993) 549â€“595.
[27] A. Bogdanov, K. Obata, and L. Trevisan: A lower bound for testing 3-colorability in
bounded-degree graphs. In Proceedings of the 43rd IEEE Symposium on Foundations of
Computer Science (FOCSâ€™02), pp. 93â€“102.
[28] A. A. Bertossi, C. Pinotti, and R. B. Tan: L(2, 1)-labeling and L(2, 1, 1)-labeling of graphs
with application to channel assignment in wireless networks. In Proceedings of the 4th
International Workshop on Discrete Algorithms and Methods for Mobile Computing and
Communications (DIAL-M 2000), Boston, August 2000.
[29] M. Bender and D. Ron: Testing properties of directed graphs: acyclicity and connectiv-
ity. Random Structures Algorithms 20 (2002) 184â€“205.
[30] I. Benjamini, O. Schramm, and A. Shapira: Every minor-closed property of sparse
graphs is testable. In Proceedings of the 40th Annual ACM Symposium on Theory of
Computing (STOC 2008), pp. 393â€“402. See also Adv. Math. 223 (2010) 2200â€“2218.
[31] G. Brightwell and D. Winkler: Counting linear extensions is #P -complete. In Pro-
ceedings of the 23rd Annual ACM Symposium on Theory of Computing (STOC 1991),
pp. 175â€“181.
[32] G. Brightwell and D. Winkler: Counting linear extensions. Order 8 (1992) 225â€“242.
[33] B. Cho: From quartets to phylogenetic trees. In Proceedings of the 25th Conference on
Current Trends in Theory and Practice of Informatics (SOFSEM 1998), Lecture Notes in
Comput. Sci., Vol. 1521, Springer, Berlin, 1998, pp. 36â€“53.
[34] G. J. Chang and D. Kuo: The L(2, 1)-labeling problem on graphs. SIAM J. Discrete Math.
9 (1996) 309â€“316.
[35] J. Chen, I. A. Kanj, and G. Xia: Improved Parameterized Upper Bounds for Vertex Cover.
Theoret. Comput. Sci. 411 (2010) 3736â€“3756.
[36] G. J. Chang and S. C. Liaw: The L(2, 1)-labeling problem on ditrees. Ars Combin. 66
(2003) 23â€“31.
[37] Maw-Shang Chang (å¼µè²¿ç¿”), Chuang-Chieh Lin (æ—èŠå‚‘), and Peter Rossmanith: New
fixed-parameter algorithms for the minimum quartet inconsistency problem. Theory of
Computing Systems 47 (2010) 342â€“368.
[38] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein: Introduction to Algorithms.
MIT Press, 2001.
[39] A. Czumaj, A. Shapira, and C. Sohler: Testing hereditary properties of nonexpanding
bounded-degree graphs. SIAM J. Comput. 38 (2009) 2499â€“2510.
38
[52] J. Fiala, T. Kloks, and J. KratochvÂ´Ä±l: Fixed-parameter complexity of Î»-labelings. Discrete
Appl. Math. 113 (2001) 59â€“72.
[53] E. Fischer and I. Newman: Testing versus estimation of graph properties. SIAM J. Com-
put. 37 (2007) 482â€“501.
[54] D. A. Fotakis, S. E. Nikoletseas, V. G. Papadopoulou and P. G. Spirakis: NP-completeness
results and efficient approximations for radiocoloring in planar graphs. In Proceed-
ings 25th International Symposium on the Mathematical Foundations of Computer Sci-
ence (MFCS 2000), Lecture Notes in Comput. Sci., Vol. 1893, Springer Verlag, 2000,
pp. 363â€“372.
[55] E. Fischer, I. Newman, and J. Sgall: Functions that have read-twice constant width
branching programs are not necessarily testable. Random Structures Algorithms 24
(2004) 175â€“193.
[56] O. Goldreich: â€œCombinatorial property testing (a survey),â€ Randomization methods in
algorithm design (Eds., P. Pardalos, S. Rajaseekaran, and J. Rolin), DIMACS Series in
Discrete Mathematics and Theoretical Computer Science, AMS, Providence, Vol. 43,
45â€“59. 1998.
[57] O. Goldreich, S. Goldwasser, and D. Ron: Property testing and its connection to learning
and approximation. J. ACM 45 (1998) 653â€“750.
[58] L. GaÂ¸sieniec, J. Jansson, A. Lingas, and A. OÂ¨stlin: On the complexity of constructing
evolutionary trees. J. Comb. Optim. 3 (1999) 183â€“197.
[59] S. Guillemot and M. Mnich: Kernel and fast algorithm for dense triplet inconsistency.
In Proceedings of the 7th Annual Conference on Theory and Applications of Model of
Computation (TAMC 2010).
[60] J. Gramm and R. Niedermeier: A fixed-parameter algorithm for minimum quartet in-
consistency. J. Comput. System Sci. 67 (2003) 723â€“741.
[61] J. Gramm, R. Niedermeier, and P. Rossmanith: Fixed-parameter algorithms for Closest
String and related problems. Algorithmica 37 (2003) 25â€“42.
[62] O. Goldreich and D. Ron: Property Testing in Bounded Degree Graphs. Algorithmica 32
(2002) 302â€“343.
[63] J. R. Griggs and R. K. Yeh: Labeling graphs with a condition at distance 2. SIAM J.
Discrete Math. 5 (1992) 586â€“595.
[64] W. K. Hale: Frequency assignment: theory and applications. In Proceedings of the IEEE,
Vol. 68, 1980, pp. 1497â€“1514.
[65] A. Hassidim, J. A. Kelner, H. N. Nguyen, and K. Onak: Local graph partitions for approx-
40
[79] J. Kneis, D. MoÂ¨lle, Stefan Richter, and P. Rossmanith: Divide-and-Color. In Proceedings
of the 32nd International Workshop on Graph-Theoretic Concepts in Computer Science
(WG 2006), Lecture Notes in Comput. Sci., Vol. 4271, Springer-Verlag, 2006, pp. 58â€“
67.
[80] D. KraÂ´l and R. SË‡krekovski: A theorem about the channel assignment problem. SIAM J.
Discrete Math. 16 (2003) 426â€“437.
[81] H. W. Lenstra: Integer programming with a fixed number of variables. Math. Oper. Res.
8 (1983) 538â€“548.
[82] K. Mehlhorm: Data Structures and Algorithms, Volume 2: NP-Completeness and Graph
Algorithms. EATCS Monographs on Theoretical Computer Science, Springer-Verlag.
[83] M. Molloy and M. R. Salavatipour: A bound on the chromatic number of the square of
a plannar graph. J. Combin. Theory Ser. B 94 (2005) 189â€“213.
[84] I. Newman: Testing of functions that have small width branching programs. In Pro-
ceedings of the 41st IEEE Symposium on Foundations of Computer Science (FOCS 2000),
2000, pp. 251â€“258.
[85] R. Niedermeier: Invitation to Fixed-Parameter Algorithms. Oxford University Press,
2006.
[86] H. N. Nguyen and K. Onak: Constant-time approximation algorithms via local improve-
ments. Proceedings of the 49th Annual IEEE Symposium on Foundations of Computer
Science (FOCS 2008), pp. 327â€“336.
[87] M. P. Ng and N. C.Wormald: Reconstruction of rooted trees from subtrees. Discrete
Appl. Math. 69 (1996) 19â€“31.
[88] M. Parnas and D. Ron: Testing the diameter of graphs. Random Struct. Alg. 20 (2002)
165â€“183.
[89] M. Parnas, D. Ron and R. Rubinfeld: Tolerant property testing and distance approxima-
tion, J. Comput. System Sci. 72 (2006) 1012â€“1042.
[90] E. Prieto, and C. Sloper: Looking at the stars. In Proceedings of the 1st International
Workshop on Parameterized and Exact Computation (IWPEC 2004), Lecture Notes in
Comput. Sci., Vol. 3162, Springer-Verlag, 2004, pp. 138â€“148.
[91] D. Ron: Property testing, in Handbook of Randomized Computing, Vol. II. S. Ra-
jasekaran, P. M. Pardalos, J. H. Reif, and J. D. P. Rolim, eds., Kluwer Academic Publish-
ers, Dordrecht, The Netherlands, 2001, 597â€“649.
[92] V. RoÂ¨dl and R. Duke: On graphs with small subgraphs of large chromatic number.
Graphs Combin. 1 (1985) 91â€“96.
42
[108] G. Wu, J-H. You, and G. Lin: A polynomial time algorithm for the minimum quartet
inconsistency problem with O(n) quartet errors. Inform. Process. Lett. 100 (2006) 167â€“
171.
[109] Y. Yoshida nad H. Ito: Property testing on k-vertex-connectivity of graphs. In Pro-
ceedings of the 35th International Colloquium on Automata, Languages and Program-
ming (ICALP 2008). Lecture Notes in Comput. Sci., Vol. 5125, Springer-Verlag, 2008,
pp. 539â€“550.
44
å¾—åº•ä¸‹çš„è½çœ¾å¤§å¤šèƒ½å¸æ”¶æˆ‘çš„æ¼”è¬›å…§å®¹ã€‚ å¦å¤–å€¼å¾—ä¸€æçš„æ˜¯,æˆ‘çš„æŠ•å½±ç‰‡æ˜¯ä½¿ç”¨ Latex Beameræ‰€è£½ä½œè€Œ
æˆçš„ pdfæª”,æ’­æ”¾ä¸Šéå¸¸é †åˆ©,æ²’æœ‰ä»»ä½•å•é¡Œã€‚ é€™æ¬¡çš„æœƒè­°ç•¶ä¸­,è¨±å¤šæ¼”è¬›è€…ä½¿ç”¨Microsoft Powerpoint
è£½ä½œçš„æŠ•å½±ç‰‡, ç¶“å¸¸æœƒæœ‰ç›¸å®¹æ€§çš„å•é¡Œ, é€ æˆæ’­æ”¾æ•ˆæœä¸å¦‚é æœŸ, æˆ–æ˜¯æ ¹æœ¬ç„¡æ³•æ’­æ”¾, å¿…é ˆæ›´æ›æˆè‡ªå·±çš„
notebook, è²»äº†ä¸€ç•ªåŠŸå¤«ä¹‹å¾Œæ‰èƒ½é †åˆ©é€²è¡Œæ¼”è¬›ã€‚ å¸Œæœ›é€éæˆ‘çš„é€™å€‹ç¶“é©—, å¾—ä»¥çµ¦åœ‹å…§çš„å­¸è€…æº–å‚™æ¼”è¬›æˆ–
è£½ä½œæŠ•å½±ç‰‡çš„å‰è»Šä¹‹é‘‘ã€‚
8.1.2 å‡ºå¸­ IWOCA 2010 æœƒè­°å¿ƒå¾—å ±å‘Š
46
2ç”Ÿï¼Œé “æ™‚è®“æˆ‘ä¸è¦ºå¾—æœ‰é›¢å®¶è¬é‡Œçš„æ„Ÿè¦ºã€‚
å¤§æœƒç¸½å…±æ¥å—ä¸‰åä¸€ç¯‡å£é ­ç™¼è¡¨çš„è«–æ–‡ï¼Œå…«ç¯‡ä»¥ poster å½¢å¼ç™¼è¡¨çš„ç²¾ç°¡
è«–æ–‡(æ”¶éŒ„æ–¼æœƒè­°è«–æ–‡é›†)ï¼Œä»¥åŠäº”ç¯‡ poster è«–æ–‡ã€‚ä¸‰å¤©çš„è«–æ–‡ç™¼è¡¨æœŸé–“ï¼Œå¤§æœƒ
å¦å¤–å®‰æ’äº†å››å ´é‚€è«‹æ¼”è¬› (invited talks) éƒ½å¾ˆç²¾å½©ã€‚
åœ¨å£é ­è«–æ–‡ç™¼è¡¨ä»¥åŠé‚€è«‹æ¼”è¬›çš„ç©ºæª”ï¼Œä¸å°‘å­¸è€…ã€å­¸ç”Ÿä¾†è§€çœ‹æˆ‘çš„ poster
ä¸¦é€²è¡Œè¨è«–ï¼Œé —æœ‰æ”¶ç©«ã€‚æœƒè­°æœŸé–“ï¼Œèªè­˜ä¸€ä½æ­£åœ¨ Kingâ€™s College London è¨ªå•
çš„æ—¥æœ¬ Kysuhu university çš„åŠ©ç†æ•™æˆ å°é‡ å»£éš† (Hirotaka Ono)ï¼Œä»–ç ”ç©¶çš„
é ˜åŸŸèˆ‡æˆ‘å¾ˆç›¸è¿‘ï¼Œç ”ç©¶æˆæœå¾ˆå¥½ï¼Œæˆ‘å£é ­é‚€è«‹ä»–è¨ªå•æˆ‘å€‘å­¸æ ¡ã€‚å¦å¤–èªè­˜ä¸€ä½
ç”±æ³°åœ‹ä»¥åŠä¸€ä½ç”±è¶Šå—èµ´æ—¥ç•™å­¸çš„å…©ä½æ—¥æœ¬å­¸ç”Ÿï¼Œç¶“éèˆ‡ä»–å€‘äº¤è«‡ï¼Œç™¼è¦ºæ—¥æœ¬
æ•™è‚²ç•Œä»¥çå­¸é‡‘å¸å¼•ä¸å°‘æ±å—äºçš„å­¸å­èµ´æ—¥ç•™å­¸ã€‚
é–‹å®Œæœƒçš„éš”å¤©ï¼Œå³æ­æ©Ÿè¿”åœ‹ã€‚
äºŒã€èˆ‡æœƒå¿ƒå¾—
æ„Ÿè¬åœ‹ç§‘æœƒä»¥åŠå­¸æ ¡çš„ç¶“è²»è´ŠåŠ©ï¼Œè®“æˆ‘å¯ä»¥åƒåŠ é€™æ¬¡å­¸è¡“æœƒè­°ã€‚é€™æ˜¯å€‹èˆ‡
æˆ‘çš„ç ”ç©¶é ˜åŸŸç›¸ç•¶å¥‘åˆçš„å­¸è¡“æœƒè­°ï¼Œé™¤äº†ç™¼è¡¨è«–æ–‡å¢åŠ èƒ½è¦‹åº¦å¤–ï¼Œé€éèˆ‡èˆ‡æœƒ
è€…çš„äº¤æµè®“æˆ‘æ›´äº†è§£é€™å€‹é ˜åŸŸçš„ç™¼å±•ç¾æ³ï¼Œä¹Ÿç²å¾—ä¸€äº›ç ”ç©¶çš„æ–°æ–¹å‘ï¼Œå°æˆ‘çš„
ç ”ç©¶å¾ˆæœ‰å¹«åŠ©ã€‚
é™¤äº†å°ˆæ¥­ä¸Šçš„æ”¶ç©«ä¹‹å¤–ï¼Œæˆ‘ä¹Ÿæœ‰ä¸€äº›å°æ–¼æ­ç¾å­¸è¡“ç•Œçš„è§€å¯Ÿã€‚æœ€è¿‘å¹¾å¹´åƒ
åŠ æ­ã€ç¾èˆ‰è¾¦çš„å­¸è¡“æœƒè­°ä¹‹å¾Œï¼Œç™¼è¦ºæ­ç¾å­¸è€…åœ¨ç ”ç©¶ä¸Šäº¤æµéå¸¸å¯†åˆ‡ã€‚ç›¸åŒé ˜
åŸŸçš„å­¸è€…ç¶“å¸¸åˆä½œç™¼è¡¨è«–æ–‡ã€‚èˆ‡åœ‹å…§å¤§å¤šç”±æ•™æˆå¸¶é ˜è‡ªå·±å­¸ç”Ÿåšç ”ç©¶çš„æƒ…å½¢å¤§
ç•°å…¶è¶£ã€‚é€™æ¬¡èˆ‡åƒåŠ æœƒè­°çš„ä¸€ä½æ³•åœ‹å­¸è€…äº¤è«‡ï¼Œæ‰çŸ¥é“ä»–ä¸¦æ²’æœ‰æŒ‡å°ä»»ä½•ç¢©å£«
ç”Ÿæˆ–åšå£«ç”Ÿï¼Œä½†æ˜¯ä»–é‚„æ˜¯æ¯å¹´å¯ä»¥ç™¼è¡¨ä¸€å…©ç¯‡æœŸåˆŠè«–æ–‡ä»¥åŠå…©ä¸‰ç¯‡æœƒè­°è«–æ–‡ï¼Œ
é€™äº›è«–æ–‡æˆæœï¼Œéƒ½æ˜¯é€éèˆ‡åŒäº‹ç”šè‡³è‹±ã€ç¾ã€æ¾³æ´²ã€åŠ æ‹¿å¤§ç­‰åŒè¡Œçš„åˆä½œçš„æˆ
æœã€‚ç ”ç©¶å¾ˆä¸å®¹æ˜“æœ‰æˆæœçš„ï¼Œé€éäº¤æµé›†å¤šæ•¸äººçš„æ™ºæ…§å¯ä»¥äº‹åŠåŠŸå€ï¼Œé€™æ˜¯æˆ‘
å€‘å¿…é ˆå­¸ç¿’çš„ï¼Œä¹Ÿç”±æ–¼å¦‚æ­¤æˆ‘å€‘æ‰æœ‰å¯èƒ½åœ‹éš›åŒ–ï¼Œæ‰èƒ½æå‡æˆ‘å€‘çš„ç«¶çˆ­åŠ›ã€‚åœ‹
å…§å­¸è€…é›–å¤šï¼Œä½†æ˜¯ç›¸è¼ƒæ–¼å…¨ä¸–ç•Œçš„å­¸è€…ä»å±¬å°‘æ•¸ã€‚ç”±æ–¼ç ”ç©¶é ˜åŸŸåˆ†å·¥ç²¾ç´°ï¼Œåœ¨
åœ‹å…§ä¸å®¹æ˜“æ‰¾åˆ°ç›¸åŒé ˜åŸŸçš„å­¸è€…ä¸€èµ·åˆä½œï¼Œé€™æ™‚å€™æƒŸæœ‰é€éåœ‹éš›äº¤æµï¼Œæ‰æ¯”è¼ƒ
æœ‰æ©Ÿæœƒæ‰¾åˆ°å¿—åŒé“åˆçš„ç ”ç©¶å¤¥ä¼´ä¸€èµ·åˆä½œã€‚å‡å¦‚æˆ‘å€‘ä¸ç©æ¥µé€²è¡Œåœ‹éš›äº¤æµï¼Œæˆ‘
å€‘çš„å­¸è¡“ç ”ç©¶æˆæœå¾ˆé›£åœ¨åœ‹éš›ä¸Šå±•éœ²é ­è§’ã€‚æ­ç¾å­¸è¡“ç•Œæ‡‰è©²å·²ç¶“çœ‹å‡ºé€™é»ï¼Œå› 
æ­¤ä»–å€‘å­¸è¡“äº¤æµç¶“è²»éå¸¸å……è£•ã€‚æ ¹æ“šæˆ‘å€‘ç•™è‹±çš„å­¸ç”Ÿçš„èªªæ³•ï¼Œä»–çš„æŒ‡å°æ•™æˆä¸€
å¹´å‡ºåœ‹é–‹å­¸è¡“æœƒè­°é€²è¡Œäº¤æµçš„æ—…è²»é ç®—å¹¾ä¹æ²’æœ‰ä¸Šé™ï¼Œä»Šå¹´ä»–ä¹Ÿå·²ç¶“éš¨è‘—æŒ‡å°
æ•™æˆå‡ºåœ‹é–‹å­¸è¡“æœƒè­°å…©ã€ä¸‰æ¬¡ä»¥ä¸Šï¼Œä»–çš„æŒ‡å°æ•™æˆä¸€å¹´å‡ºåœ‹é–‹æœƒä¸ƒã€å…«æ¬¡ä»¥ä¸Šã€‚
å¦å¤–æˆ‘ä¹Ÿç™¼è¦ºæ­ç¾å­¸è¡“ç•Œç†±ä¸­èˆ‰è¾¦å­¸è¡“æœƒè­°ã€‚èˆ‰è¾¦å­¸è¡“æœƒè­°è‹¥å¯ä»¥å¸å¼•å…¨ä¸–ç•Œ
8.2 ç™¼è¡¨è‘—ä½œ
åœ‹éš›ç ”è¨æœƒè«–æ–‡
1. Maw-Shang Chang (å¼µè²¿ç¿”), Chuang-Chieh Lin (æ—èŠå‚‘), and Peter Rossmanith: New
fixed-parameter algorithms for the minimum quartet inconsistency problem. In Pro-
ceedings of the 3rd International Workshop on Exact and Parameterized Computation
(IWPEC 2008, Victoria B.C., Canada; 14â€“16 May), Lecture Notes in Computer Science,
Vol. 5018, Springer-Verlag, pp. 66â€“77.
2. Maw-Shang Chang (å¼µè²¿ç¿”) and Ling-Ju Hung (æ´ªç¶¾ç ): Recognition of Probe Ptolemaic
Graphs. To appear in Proceedings of the 21st International Workshop on Combinatorial
Algorithms (IWOCA 2010).
æœŸåˆŠè«–æ–‡
1. Maw-Shang Chang (å¼µè²¿ç¿”), Chuang-Chieh Lin (æ—èŠå‚‘), and Peter Rossmanith: New
fixed-parameter algorithms for the minimum quartet inconsistency problem. Theory of
Computing Systems 47 (2010) 342â€“368.
2. Maw-Shang Chang (å¼µè²¿ç¿”), Chuang-Chieh Lin (æ—èŠå‚‘), and Peter Rossmanith: A prop-
erty tester for tree-likeness of quartet topologies. Theory of Computing Systems. Ac-
cepted for publication. Online first. DOI: 10.1007/s00224-010-9276-5
49
New Fixed-Parameter Algorithms 67
[bc|de] induced by T and another taxon a, then there are ï¬ve possible quintet
topologies since there are ï¬ve positions for inserting a into the tree structure of
[bc|de] (see Fig. 3 for an illustration).
Fig. 1. The quartet topology of {a, b, c, d} in-
duced by evolutionary tree T
There are 15 possible quintet
topologies for a quintet {a, b, c,
d, e}. A quintet has ï¬ve quartets,
and hence a quintet topology has
5 diï¬€erent induced quartet topolo-
gies. Two taxa a, b are siblings on
an evolutionary tree T if a and b
are both adjacent to the same in-
ternal vertex in T . Here we con-
sider sextet topologies of the sextet
{a, b, w, x, y, z} where a, b are sib-
lings. It is clear that there are 15 possible sextet topologies with siblings a, b
(refer to Fig. 4).
Fig. 2. Three topologies for the
quartet {a, b, c, d}
Given a set of quartet topologies Q over
the taxon set S, we say that a quintet
{a, b, c, d, e} âŠ† S is resolved if there exists
an evolutionary tree T â€², on which a, b, c, d, e
are leaves, such that all the quartet topolo-
gies induced by T â€² are in Q. Otherwise, we
say that {a, b, c, d, e} is unresolved. Similarly,
we say that a sextet {a, b, w, x, y, z} âŠ† S is
{a, b}-resolved if there exists an evolutionary
tree T â€²â€², on which a, b, w, x, y, z are leaves and a, b are siblings, such that all quar-
tet topologies induced by T â€²â€² are in Q. Otherwise, we say that {a, b, w, x, y, z} is
{a, b}-unresolved.
Fig. 3. Five possible topologies for the
quintet {a, b, c, d, e} when [ab|cd] is given
Let QT be the set of quartet topolo-
gies induced by T . If there exists an
evolutionary tree T such that Q âŠ† QT ,
we say that Q is tree-consistent [2]
(with T ) or T satisfies Q. If there exists
a tree T such that Q = QT , we say that
Q is tree-like [2]. Q is called complete
if Q contains exactly one topology for
every quartet, otherwise, incomplete. For two complete sets of quartet topologies
Q and Qâˆ— where Qâˆ— is tree-like but Q is not, the quartet errors of Q with respect
to Qâˆ— are the quartet topologies in Q that diï¬€er from those in Qâˆ—. We denote
the number of quartet errors of Q with respect to Qâˆ— by Î”(Q,Qâˆ—). The number
of quartet errors of Q is deï¬ned to be min{Î”(Q,Qâˆ—) : Qâˆ— is tree-like}.
1.1 Related Work
The Quartet Compatibility Problem (QCP) is to determine if there exists an evo-
lutionary tree T on S satisfying all quartet topologies Q. The QCP problem can
New Fixed-Parameter Algorithms 69
ï¬xed-parameter algorithm for the parameterized MQI problem. In Sect. 4, we will
introduce the two-siblings-determined minimum quartet inconsistency problem
(2SDMQI), then an O(2.0162kn+n4) ï¬xed-parameter algorithm for this problem
will be given. At the end of this section, we will present an O(2.0162kn3 + n5)
ï¬xed-parameter algorithm for the parameterized MQI problem by solving the
2SDMQI problem. Finally in Sect. 5, we will present an Oâˆ—((1 + )k) ï¬xed-
parameter algorithm for the parameterized MQI problem, where  > 0 is an
arbitrarily small constant. For the sake of brevity, many proofs are omitted in
this extended abstract, but can be found in the full paper.
2 Preliminaries
Recall that S is a set of taxa and |S| = n. Let Q denote the complete set
of quartet topologies over S. The set Q is of size
(
n
4
)
. We say that a set of
quartet topologies Qâ€² over S involves a taxon f if there exists at least one quartet
topology t = [v1v2|v3v4] âˆˆ Qâ€², where v1, v2, v3, v4 âˆˆ S, such that f = vi for some
i âˆˆ {1, 2, 3, 4}. If a set of quartet topologies is not tree-consistent, we say that
it has a conflict. We say that a set of three topologies has a local conflict if it is
not tree-consistent.
Lemma 1. [8] A set of three quartet topologies involving more than five taxa is
tree-consistent.
Theorem 1. [8] Given a set of taxa S and a complete set of quartet topologies
Q over S, and some taxon f âˆˆ S, then Q is tree-like if and only if every set of
three quartet topologies in Q that involves f has no local conflict.
Lemma 2. Assume that q âŠ† S is a quintet such that f âˆˆ q and let Qq âŠ† Q
denote the set of quartet topologies of quartets in q. Then q is resolved if and
only if every set of three quartet topologies in Qq has no local conflict.
Corollary 1. Given a set of taxa S, a complete set of quartet topologies Q
over S, and some taxon f âˆˆ S, then Q is tree-like if and only if every quintet
containing f is resolved.
There are ten sets of three quartets with respect to a quintet {a, b, c, d, e}. Check-
ing whether a set of three quartet topologies has a local conï¬‚ict requires only
constant time [8]. It is then clear that checking whether a quintet is resolved
requires only constant time. Given a taxon f âˆˆ S which is ï¬xed, there are (nâˆ’14
)
quintets containing f . Thus we have the following theorem.
Theorem 2. Given a set S of taxa, some taxon f âˆˆ S, and a complete set Q of
quartet topologies, then all unresolved quintets involving f can be found in O(n4)
time.
Let â‰º be some order (e.g. lexicographic order) on the taxon set S. For the three
possible topologies of a quartet, we denote them by type 0, 1, and 2 according to
New Fixed-Parameter Algorithms 71
Algorithm 1: FPA1-MQI (a complete set of quartet topologies Q, an integer
parameter k, a list Cf of unresolved quintets)
1: if Cf is empty and k â‰¥ 0 then
2: return ACCEPT;
3: else if k â‰¤ 0 then
4: return;
5: end if
6: Extract an unresolved quintet q from Cf ;
7: for each Î¼ âˆˆ V do
8: (Qâ€², Câ€²f , kâ€²) â† update(Q, Cf ,q, Î¼, k);
9: FPA1-MQI (Qâ€², kâ€², Câ€²f );
10: end for
in the search tree such that some quartet, which has been marked, must be
changed in all the possible 15 branches to make an unresolved quintet resolved,
the algorithm stops branching here and just returns. Let QÂµ be the set of quartet
topologies changed according to Î¼. The procedure update obtains the updated
set of unresolved quintets Câ€²f by removing the newly resolved quintets and adding
the newly unresolved quintets, and gets the updated parameter kâ€² = k âˆ’ |QÂµ|.
By Corollary 1, we know Cf is empty if and only if the set of quartet topologies
is tree-like. Algorithm FPA1-MQI branches in all possible ways to eliminate each
unresolved quintet in Cf and it changes at most k quartet topologies from the
root to each branch node in the search tree. Thus it is easy to see that the
algorithm is correct.
The Time Complexity. The algorithm works as a depth-bounded search tree.
Each tree node has 15 branches and each branch corresponds to a quintet
topology. Since there are 243 possible topology vectors of a quintet but 15 of
them are in V , we have 228 possible branching vectors and the correspond-
ing branching numbers as well. Consider the case that the algorithm selects a
quintet q = {a, b, c, d, e} which has induced quartet topologies [ab|cd], [ac|be],
[ae|bd], [ad|ce], and [bc|de] in Q. By comparing its corresponding topology vector
(0,1,2,1,0) with each topology vector Î¼ âˆˆ V , we obtain the numbers of quartet
topologies changed by Algorithm FPA1-MQI, and then we have a branching vec-
tor (3, 3, 4, 3, 3, 3, 4, 3, 3, 4, 4, 3, 3, 4, 3) hence a branching number between 2.3004
and 2.3005 is obtained. It can be derived that the branching number in the worst
case is between 3.0445 and 3.0446. Thus the size of the search tree is O(3.0446k).
Then we obtain the following theorem by careful analysis.
Theorem 3. There exists an O(3.0446kn + n4) fixed-parameter algorithm for
the parameterized minimum quartet inconsistency problem.
4 An O(2.0162kn3 + n5) Algorithm
We deï¬ne the two-siblings-determined minimum quartet inconsistency problem
(2SDMQI) as follows. Given a complete quartet topology set Q over a taxon set
New Fixed-Parameter Algorithms 73
Algorithm 3: Resolve (a complete set of quartet topologies Q, an integer
parameter k, a list Ca of unresolved quintets, two taxa a, b)
1: if Ca is empty and k â‰¥ 0 then
2: return ACCEPT;
3: else if k â‰¤ 0 then
4: return;
5: end if
6: Extract an unresolved quintet q from Ca;
7: if b âˆˆ q then q â† q âˆª {s}, for some arbitrary taxon s /âˆˆ q; else q â† q âˆª {b};
8: for each Î½ âˆˆ V2 do
9: (Qâ€², Câ€²a, kâ€²) â† update2(Q, Ca,q, Î½, k);
10: Resolve(Qâ€², kâ€², Câ€²a, a, b);
11: end for
5 An Oâˆ—((1 + )k) Algorithm
The Algorithm. At the beginning of this section, let us consider some additional
preliminaries. Let T denote an evolutionary tree on S such that QT diï¬€ers from
Q in at most k quartet topologies. For an integer m â‰¥ 2, we say that taxa
a1, . . . , am are adjacent if there exists an edge e = (w, v) on T such that cutting e
will produce a bipartition ({a1, . . . , am}, S \{a1, . . . , am}) of S. In Fig. 5, cutting
the edge e will derive four adjacent taxa a1, a2, a3, and a4. After e = (w, v) is
cut, two binary trees will be produced which are rooted at w and v respectively.
Note that two taxa on T are adjacent if and only if they are siblings on T .
Lemma 3. Given an evolutionary tree T and an integer 2 â‰¤ Ï‰ â‰¤ n/2, there
exists a set of m adjacent taxa as leaves on T , where Ï‰ â‰¤ m â‰¤ 2Ï‰ âˆ’ 2.
By extending the idea of Algorithm FPA2-MQI to consider m â‰¥ 3 adjacent
taxa, we obtain another ï¬xed-parameter algorithm, called FPA3-MQI, with two
subroutines Algorithm MAKE-ADJ and Algorithm ADJ-Resolve. Assume that
Am = {a1, . . . , am} is a set of adjacent taxa on T . We introduce the main
concepts of Algorithm FPA3-MQI as follows.
(2, 2)-cleaning: For every two taxa ai, aj âˆˆ Am and every two taxa u, v âˆˆ
S \Am, we modify the topology of {ai, aj , u, v} to be [aiaj |uv]. We call this part
of the algorithm (2, 2)-cleaning.
(3, 1)-cleaning: Assume the parameter is kâ€². For ah, ai, aj âˆˆ Am and s âˆˆ
S \ Am, without loss of generality we denote the type of quartet topology
[ahai|ajs] by 0, [ahaj |ais] by 1, and [ahs|aiaj ] by 2. We construct a set of all
possible evolutionary trees Tm+1 on the taxa in Am âˆª {x}, where x is an arbi-
trary taxon in S \Am, such that each T â€² âˆˆ Tm+1 has at most kâ€² diï¬€erent induced
quartet topologies from Q. Afterwards, for each T â€² âˆˆ Tm+1, we change the type
of topology of every quartet {ah, ai, aj, s} into the same type of topology as
{ah, ai, aj, x} has on T â€². We call this part of the algorithm (3, 1)-cleaning.
(1, 3)-cleaning: Without loss of generality, we denote the type of quartet
topology [aiw|xy] by 0, [aix|wy] by 1, and [aiy|wx] by 2 for ai âˆˆ Am and
New Fixed-Parameter Algorithms 75
Algorithm 4: FPA3-MQI (a complete set of quartet topologies Q, an integer
parameter k, a list of unresolved quintets Ca1 , an arbitrary integer m)
1: Qâˆ— â† Q; Câˆ—a1 â† Ca1 ; kâˆ— â† k;
2: for every set of m taxa Am = {a1, . . . , am} âŠ† S do
3: for every two taxa ai, aj âˆˆ Am and every two taxa u, v âˆˆ S \Am do
4: if k â‰¤ 0 then return; else Change the quartet topology of {ai, aj , u, v} in Qâˆ—
to be [aiaj |uv] if [aiaj |uv] /âˆˆ Qâˆ—, and then update Câˆ—a1 and kâˆ— â† kâˆ— âˆ’ 1;
5: end for
6: Build a set of all possible evolutionary trees Tm+1 such that each T â€² âˆˆ Tm+1 is
an evolutionary tree on Am âˆª {x}, where x is an arbitrary taxon in S \Am and
|QT â€² \ Qâˆ—| â‰¤ kâˆ—;
7: Build a list Bm of sets of three taxa w, x, y âˆˆ S \ Am such that topologies of
{ai, w, x, y} in Qâˆ— are not all the same for all 1 â‰¤ i â‰¤ m;
8: Qâˆ—âˆ— â† Qâˆ—; Câˆ—âˆ—a1 â† Câˆ—a1 ; kâˆ—âˆ— â† kâˆ—;
9: if Tm+1 = âˆ… then
10: return;
11: else
12: for each T â€² âˆˆ Tm+1 do
13: kâˆ—âˆ— â† kâˆ—âˆ— âˆ’ |QT â€² \Qâˆ—âˆ—|;
14: Change the quartet topologies in Qâˆ—âˆ— over Am to those in QT â€² ;
15: For every taxon s âˆˆ S \ Am and every three taxa ah, ai, aj âˆˆ Am, change
the topology of {ah, ai, aj , s} to the one of the same type as {ah, ai, aj , x}
has; update Câˆ—âˆ—a1 ;
16: if MAKE-ADJ(Qâˆ—âˆ—, Câˆ—âˆ—a1 , kâˆ—âˆ—) returns ACCEPT then
17: return ACCEPT;
18: else
19: Restore (Qâˆ—âˆ—, Câˆ—âˆ—a1 ) to (Qâˆ—, Câˆ—a1), and kâˆ—âˆ— â† kâˆ—;
20: end if
21: end for
22: end if
23: Restore (Qâˆ—, Câˆ—a1) to (Q,Ca1), delete Bm, and kâˆ— â† k;
24: end for
Algorithm 5: MAKE-ADJ (a complete set of quartet topologies Q, a list of
unresolved quintets Ca1 , an integer parameter k)
1: if Ca1 is empty and k â‰¥ 0 then
2: return ACCEPT;
3: else if k â‰¤ 0 then
4: return;
5: end if
6: while Bm 	= âˆ… do
7: Extract {w, x, y} from Bm;
8: for each type i âˆˆ {0, 1, 2} do
9: Change all the topologies of {a1, w, x, y}, . . . , {am, w, x, y} to topologies of
type i; let Qâ€², Câ€²a1 , kâ€² be the changed Q, Ca1 , k respectively;
10: MAKE-ADJ(Qâ€², Câ€²a1 , kâ€²);
11: end for
12: end while
13: if ADJ-Resolve(Q,k, Ca1) returns ACCEPT then return ACCEPT;
New Fixed-Parameter Algorithms 77
Acknowledgments. We thank the anonymous referees for their helpful
comments.
References
1. Ben-Dor, A., Chor, B., Graur, D., Ophir, R., Pelleg, D.: From four-taxon trees to
phylogenies: The case of mammalian evolution. In: Proceedings of the RECOMB,
pp. 9â€“19 (1998)
2. Bandelt, H.J., Dress, A.: Reconstructing the shape of a tree from observed dissim-
ilarity date. Adv. Appl. Math. 7, 309â€“343 (1986)
3. Berry, V., Jiang, T., Kearney, P.E., Li, M., Wareham, H.T.: Quartet cleaning: Im-
proved algorithms and simulations. In: NesË‡etrË‡il, J. (ed.) ESA 1999. LNCS, vol. 1643,
pp. 313â€“324. Springer, Heidelberg (1999)
4. Cho, B.: From quartets to phylogenetic trees. In: Rovan, B. (ed.) SOFSEM 1998.
LNCS, vol. 1521, pp. 36â€“53. Springer, Heidelberg (1998)
5. Downey, R.G., Fellows, M.R.: Parameterized Complexity. Springer, Heidelberg
(1999)
6. ErdoËs, P., Steel, M., SzeÂ´kely, L., Warnow, T.: A few logs suï¬ƒce to build (almost)
all trees (Part 1). Random Struct. Alg. 14, 153â€“184 (1999)
7. Greene, D.H., Knuth, D.E.: Mathematics for the Analysis of Algorithms, 2nd edn.
Progress in Computer Science. Birkhauser, Boston (1982)
8. Gramm, J., Niedermeier, R.: A ï¬xed-parameter algorithm for minimum quartet
inconsistency. J. Comput. System Sci. 67, 723â€“741 (2003)
9. Jiang, T., Kearney, P.E., Li, M.: Some open problems in computational molecular
biology. J. Algorithms 34, 194â€“201 (2000)
10. Jiang, T., Kearney, P.E., Li, M.: A polynomial time approximation scheme for
inferring evolutionary tree from quartet topologies and its application. SIAM J.
Comput. 30, 1942â€“1961 (2001)
11. Steel, M.: The complexity of reconstructing trees from qualitative characters and
subtrees. J. Classiï¬cation 9, 91â€“116 (1992)
12. Niedermeier, R.: Invitation to Fixed-Parameter Algorithms. Oxford University
Press, Oxford (2006)
13. Niedermeier, R., Rossmanith, P.: A general method to speed up ï¬xed-parameter
algorithms. Inform. Process. Lett. 73, 125â€“129 (2000)
14. Wu, G., You, J.-H., Lin, G.: A lookahead branch-and-bound algorithm for the
maximum quartet consistency problem. In: Casadio, R., Myers, G. (eds.) WABI
2005. LNCS (LNBI), vol. 3692, pp. 65â€“76. Springer, Heidelberg (2005)
15. Wu, G., You, J.-H., Lin, G.: A polynomial time algorithm for the minimum quartet
inconsistency problem with O(n) quartet errors. Inform. Process. Lett. 100, 167â€“
171 (2006)
Table 1. Some results and open problems on probe graphs. Here n and m are the
number of vertices and the number of edges in a given probe graph and |P| denotes the
number of vertices labeled P in a fully partitioned probe graph.
Graph class Fully partitioned Unpartitioned
probe chordal O(|P|m) [3] O(m2) [3]
probe strongly chordal Poly. [5] Open
probe chordal bipartite Poly. [5] Open
probe interval O(n + m) [14] Poly. [8]
Probe DHG O(n2) [4] O(nm) [10]
probe cographs O(n + m) [13] O(n + m) [13]
Probe bipartite DHG O(n2) [4] O(nm) [9]
probe ptolemaic O(nm) [this paper] O(nm) [this paper]
probe comparability O(nm) [6] Open
probe co-comparability O(n3) [6] Open
probe permutation O(n2) [7] Open
probe trivially-perfect O(n + m) [2] O(n + m) [2]
probe threshold O(n + m) [2] O(n + m) [2]
r
r
r
r
r
 @
r
r r
r
r
@ 

Q
Q
r
r
r r
r
r
r
r
r r
rHHH



L
L
L
J
J





Fig. 1. A house, a hole, a domino, and a gem.
which some NP-hard problems can be solved in polynomial time. As the first
step of the study of probe G graphs, we developed polynomial time recognition
algorithms. In Table 1, we list some recent results and open problems on the
recognition of probe graphs of different graph classes. In this paper we give an
O(nm)-time algorithm to recognize partially partitioned probe ptolemaic graphs.
Distance-hereditary graphs are those graphs having no house, hole, domino,
or gem as an induced subgraph [1]. Ptolemaic graphs are those graphs that are
chordal and have no gem as an induced subgraph [12]. Ptolemaic graphs are a
subclass of chordal graphs and distance-hereditary graphs.
Let G = (V, E) be a graph. For v âˆˆ V , NG(v) consists of all vertices adjacent
to v in G, NG[v] = NG(v)âˆª{v}, and for X âŠ† V , NG(X) =
â‹ƒ
vâˆˆX NG(v)âˆ’X . A
module X is a vertex set of G such that NG(v)âˆ’X is the same for every v âˆˆ X .
A twin is a pair of vertices u and v such that {u, v} is a module, the pair is a true
twin if u and v are adjacent and a false twin otherwise. A clique X in G is a vertex
subset such that every two distinct vertices in X are adjacent. A clique module X
of G is a vertex set of G that is both a module and a clique of G. A clique module
is trivial if it consists of exactly a vertex. A universal vertex is a vertex adjacent
to all other vertices. Suppose v is a vertex of ptolemaic graph G = (V, E) where
v is a non-universal vertex. Let C be a minimal component of G[V âˆ’ NG[v]]
where G[V âˆ’NG[v]] is a subgraph of G induced by V âˆ’NG[v] and NG(C) does
not properly contain NG(C
â€²) for any component Câ€² of G[V âˆ’NG[v]]. Then either
NG(C) is a non-trivial clique module of G or NG(C) consists of exactly a vertex
that is a cut vertex of G. Notice that NG(C) âŠ† NG(v). If NG(C) is a non-trivial
clique module, then there is at least a pair of true twins in NG(C).
2
We sketch the algorithm in the following:
1. If the size of P is small, we solve the problem by brute force.
2. If P is unpartitioned, arbitrarily select an edge (u, v). Generate two partially
partitioned probe graphs. They are obtained from P by relabeling u and v
as probes, respectively. Then P is a probe ptolemaic graph iff one of them
is. They can be checked by the algorithm for partially partitioned case.
3. If P is partially or fully partitioned, there is a probe p. If p is a universal
vertex, then P is a probe trivially perfect graph and can be determined in
linear time [2]. Otherwise we reduce the problem instance to smaller partially
or fully partitioned probe graphs according to the cases given in Theorem 1.
Theorem 2. There exists an O(nm)-time algorithm to check if a probe graph
P is a probe ptolemaic graph.
References
1. H. J. Bandelt, and H. M. Mulder, Distance-hereditary graphs, Journal of Combi-
natorial Theory, Series B 41 (1986), pp. 182â€“208.
2. D. Bayer, V. B. Le, and H.N. de Ridder, Probe threshold and probe trivially perfect
graphs, Theoretical Computer Science 410 (2009), pp. 4812â€“4822.
3. A. Berry, M. C. Golumbic, and M. Lipshteyn, Recognizing Chordal Probe Graphs
and Cycle-Bicolorable Graphs, SIAM J. Discrete Math. 21 (2007), pp. 573â€“591.
4. D. B. Chandler, M.-S. Chang, T. Kloks, J. Liu, and S.-L. Peng, Recognition of
probe cographs and partitioned probe distance hereditary graphs, Proceedings of
AAIM 2006, LNCS 4041, pp. 267â€“278.
5. D. B. Chandler, J. Guo, T. Kloks, and R. Niedermeier, Probe matrix problems:
totally balanced matrices, Proceeding of AAIM 2007, LNCS 4508, pp. 368â€“377.
6. D. B. Chandler, M.-S. Chang, T. Kloks, J. Liu, and S.-L. Peng, Partitioned probe
comparability graphs, Theoretical Computer Science 396 (2008), pp. 212â€“222.
7. D. B. Chandler, M.-S. Chang, A. J.J. Kloks, J. Liu, and S.-L. Peng, On probe
permutation graphs, Discrete Applied Mathematics 157 (2009), pp. 2611â€“2619.
8. G. J. Chang, A. J. J. Kloks, J. Liu, and S.-L. Peng, The PIGs full monty - a floor
show of minimal separators, Proceedings STACS 2005, LNCS 3404, pp. 521â€“532.
9. M.-S. Chang, L.-J. Hung, and P. Rossmanith, Probe bipartite distance-hereditary
graphs, in Proceedings of NCS 2009: Workshop on Algorithms and Bioinformatics,
pp. 16â€“27.
10. M.-S. Chang, L.-J. Hung, and P. Rossmanith, Probe distance-hereditary graphs,
Proceedings of CATS 2010, CRPIT 109, pp. 55â€“64.
11. M.C. Golumbic, H. Kaplan, and R. Shamir, Graph sandwich problems, Journal of
Algorithms 19 (1995), pp. 449â€“473.
12. E. Howorka, A characterization of ptolemaic graphs, Journal of Graph Theory, 5
(1981), pp. 323â€“331.
13. V. B. Le and H. N. de Ridder, Characterisations and linear-time recognition of
probe cographs. Proceedings of WG 2007, LNCS 4769, pp. 226â€“237.
14. R. M. McConnell and Y. Nussbaum, Linear-time recognition of probe interval
graphs, in Proceedings of ESA 2009, LNCS 5757, pp. 349â€“360.
15. P. E. Zhang, A. Schon, S. G. Fischer, E. Cayanis, J. Weiss, S. Kistler, and
E. Bourne, An algorithm based on graph theory for the assembly of contigs in
physical mapping of DNA, CABIOS 10 (1994), pp. 309â€“317.
4
Theory Comput Syst (2010) 47: 342â€“367 343
1 Introduction
Nowadays, to determine the evolutionary relationship of a set of taxa is very impor-
tant in biological research, especially in computational biology. For this relationship,
an evolutionary tree is a common model, which is widely considered. Let S be a set
of taxa and |S| = n. An evolutionary tree T on S is an unrooted, leaf-labeled tree
such that the leaves of T are bijectively labeled by the taxa in S, and each inter-
nal node of T has degree three. In the past decade, quartet methods for building an
evolutionary tree for a set of taxa have received much attention [1, 3, 4, 6, 8â€“11, 14].
A quartet is a set of four taxa {a, b, c, d} in the taxon set S. The quartet topology
for {a, b, c, d} induced by T is the path structure connecting a, b, c, and d in T
(see Fig. 1 for an illustration). A quartet {a, b, c, d} has three possible topologies
[ab|cd], [ac|bd] and [ad|bc], which are the bipartitions of {a, b, c, d} (hence [ab|cd],
[ba|cd], [ab|dc], [ba|dc], [cd|ab], [dc|ab], [cd|ba], [dc|ba] are viewed as the same
topologies of the quartet {a, b, c, d}). Figure 2 is an illustration for the three possible
topologies of the quartet {a, b, c, d}.
A quintet is a set of five taxa in S, while a sextet is a set of six taxa in S. The quin-
tet topology of a quintet {a, b, c, d, e} induced by an evolutionary tree T is the path
structure connecting a, b, c, d , and e in T . Similarly, we have the sextet topology of
a sextet. Without loss of generality, assume that we have [bc|de] induced by T and
another taxon a, then there are five possible quintet topologies since there are five po-
sitions for inserting a into the tree structure of [bc|de] (see Fig. 3 for an illustration).
Since there are three different topologies for the quartet {a, b, c, d}, there are 15 pos-
sible quintet topologies for a quintet {a, b, c, d, e}. A quintet has (54
) = 5 quartets, and
hence a quintet topology has five different induced quartet topologies. Two taxa a, b
are siblings on an evolutionary tree T if a and b are both adjacent to the same inter-
nal vertex in T . Here we consider the sextet topologies of the sextet {a, b,w,x, y, z}
where a, b are siblings. It is clear that there are 15 possible sextet topologies with
siblings a, b for a sextet {a, b,w,x, y, z} (see Fig. 4 for an illustration).
Fig. 1 The quartet topology of {a, b, c, d} induced by evolutionary tree T
Fig. 2 Three topologies for the
quartet {a, b, c, d}
Theory Comput Syst (2010) 47: 342â€“367 345
that the number of quartet errors of Q with respect to QT is minimized. The MQC
problem and the MQI problem are both NP-hard [3], however, the MQC problem has
a polynomial time approximation scheme (PTAS) [10], while the best approximation
ratio found so far for the MQI problem is O(n2) [9]. Ben-Dor et al. gave an O(3nn4)
algorithm to solve the MQI problem by dynamic programming [1]. For the case that
Q has less than (n âˆ’ 3)/2 quartet errors, Berry et al. [3] devised an O(n4) algorithm
for the MQI problem. Furthermore, if Q has at most cn quartet errors, Wu et al. [15]
compute the optimal solution for the MQI problem in O(n5 +24cn12c+2) time, where
c is some positive constant. While this is a polynomial time algorithm, the degree of
the polynomial in the runtime grows quickly. Therefore parameterized algorithms are
faster for practical values of k and n.
Provided with a positive integer k as an additional part of the input, the parame-
terized MQI problem is to determine whether there exists an evolutionary tree T such
that the number of quartet errors of Q is at most k. Gramm and Niedermeier proved
that the parameterized MQI problem is fixed parameter tractable [8], and they pro-
posed a O(4kn + n4) fixed parameter algorithm [8]. In [14], Wu et al. presented a
lookahead branch-and-bound algorithm for the MQC problem which runs in time
O(4kâ€²n2kâ€² + n4), where kâ€² is an upper bound on the number of quartet errors of Q.
1.2 Our Result
In this paper, we focus on the parameterized MQI problem as follows. Given a com-
plete set of quartet topologies Q and a parameter k as the input, determine whether
there is a tree-like quartet topology set that differs from Q in at most k quartet topolo-
gies, that is, determine whether Q has at most k quartet errors. Using the depth-
bounded search tree strategy [12], we propose an O(3.0446kn+ n4) fixed-parameter
algorithm for this problem. With slight refinement, we obtain an O(2.0162kn3 + n5)
algorithm. Furthermore, by applying the depth-bounded search tree technique again,
we obtain an Oâˆ—((1 + )k) time fixed-parameter algorithm1 with arbitrarily small
 > 0. The running time of the third algorithm has an exponential term with an ar-
bitrarily small base, which can be very close to 1, yet its polynomial factor grows
quickly as the base of the exponential term decreases.
In this paper, we present three fixed-parameter algorithms in an incremental way,
since the second one is obtained by extending the first one, and the third one is gen-
eralization of the second one. The paper is organized as follows. In Sect. 2, we will
give additional theoretical background for the MQI problem, and introduce the depth-
bounded search tree strategy for designing fixed-parameter algorithms as well. In
Sect. 3, we present an O(3.0446kn + n4) fixed-parameter algorithm for the parame-
terized MQI problem. In Sect. 4, first we will introduce the two-siblings-determined
minimum quartet inconsistency problem (2SDMQI), which is a variation of the pa-
rameterized MQI problem. We will present an O(2.0162kn + n4) fixed-parameter
algorithm for the 2SDMQI problem, and then we will give an O(2.0162kn3 + n5)
fixed-parameter algorithm for the parameterized MQI problem by solving the 2SD-
MQI problem. Finally in Sect. 5, we will present an Oâˆ—((1 + )k) fixed-parameter
1For two functions f,g : (N,N) â†’ R, we write f = Oâˆ—(g) if f (n, k) = O(poly(n, k) Â· g(n, k)).
Theory Comput Syst (2010) 47: 342â€“367 347
constant time [8]. It is then clear that checking whether a quintet is resolved requires
only constant time. With a taxon f âˆˆ S which is fixed, there are (nâˆ’14
)
quintets con-
taining f . Thus we have the following theorem.
Theorem 3 Given a set S of taxa, some taxon f âˆˆ S, and a complete set Q of quartet
topologies, then all unresolved quintets involving f can be found in O(n4) time.
Let â‰º be a total order on the taxon set S. Without loss of generality, every set of l
taxa is represented according to â‰º. That is, we denote a set of taxa by {s1, s2, . . . , sl} if
s1 â‰º s2 â‰º Â· Â· Â· â‰º sl . A quartet topology is represented by [s1s2|s3s4] if s1 â‰º s3, s1 â‰º s2,
and s3 â‰º s4. For the three possible topologies of a quartet, we denote them by type
0, 1, and 2 according to â‰º. Consider a quartet {a, b, c, d} âŠ‚ S as an example. If
a â‰º b â‰º c â‰º d , we denote [ab|cd] by 0, [ac|bd] by 1, and [ad|bc] by 2.
Let â‰ºl be the lexicographic order on the Cartesian product of lâ€™s S according
to the total order â‰º. For a quintet {s1, s2, s3, s4, s5}, where s1 â‰º s2 â‰º s3 â‰º s4 â‰º s5,
we define its topology vector to be an ordered sequence (r1, r2, r3, r4, r5), where r1,
r2, r3, r4, and r5 are the types of quartet topologies of {s1, s2, s3, s4}, {s1, s2, s3, s5},
{s1, s2, s4, s5}, {s1, s3, s4, s5}, and {s2, s3, s4, s5} respectively (i.e., the quartets in the
order of â‰º5). For example, consider a quintet {a, b, c, d, e} âŠ† S, where a â‰º b â‰º c â‰º
d â‰º e. Assume that [ab|cd], [ae|bc], [ab|de], [ae|cd], and [bd|ce] are in Q, then
the topology vector of {a, b, c, d, e} is (0,2,0,2,1). Recall that there are 15 possible
quintet topologies for a quintet {s1, s2, s3, s4, s5}. We denote by V the set of topology
vectors of all the possible quintet topologies of a quintet, then we have
V = {(0,0,0,0,0), (1,1,0,0,0), (2,2,0,0,0), (2,2,1,1,0), (2,2,2,2,0),
(0,0,0,1,1), (2,0,1,1,1), (1,0,2,1,1), (1,1,2,0,1), (1,2,2,2,1),
(0,0,0,2,2), (0,2,2,2,2), (0,1,1,2,2), (1,1,1,0,2), (2,1,1,1,2)}.
Note that the size of V is far less than the number of possible topology vectors of a
quintet, which is 35 = 243.
Assume that s1, s2 are siblings in an evolutionary tree over S, and hence that we
have 15 sextet topologies for the sextet {s1, s2, s3, s4, s5, s6} âŠ† S. There are
(6
4
) = 15
quartets with respect to the sextet {s1, s2, s3, s4, s5, s6}, yet
(4
2
) = 6 of them have
fixed quartet topologies since s1, s2 are siblings. For example, the quartet topol-
ogy of {s1, s2, s3, s4} must be [s1s2|s3s4]. Given two siblings s1, s2, the {s1, s2}-
reduced topology vector of sextet {s1, s2, s3, s4, s5, s6} is an ordered sequence of
types of the quartet topologies which are not fixed. For example, consider a sex-
tet {a, b,w,x, y, z} âŠ† S with siblings a, b such that [aw|xy], [ax|wz], [az|wy],
[ay|xz], [bw|xy], [bx|wz], [bz|wy], [by|xz], and [wx|yz] are in Q. The {a, b}-
reduced topology vector of {a, b,w,x, y, z} is (0,1,2,1,0,1,2,1,0). Let us denote
by V2 the set of {a, b}-reduced topology vectors of all possible sextet topologies of
{a, b,w,x, y, z}. Then we have
V2 = {(0,0,0,0,0,0,0,0,0), (1,1,0,0,1,1,0,0,0), (2,2,0,0,2,2,0,0,0),
(2,2,1,1,2,2,1,1,0), (2,2,2,2,2,2,2,2,0), (0,0,0,1,0,0,0,1,1),
Theory Comput Syst (2010) 47: 342â€“367 349
Theorem 4 [7, 12, 13] A depth-bounded search tree with branching vector (d1, d2,
. . . , di) and its root labeled with parameter k has size kO(1) Â·Î±k , where Î± is the great-
est characteristic root the corresponding characteristic polynomial. Furthermore, if
Î± is unique, then the size of the search tree is O(Î±k).
For simplicity, we call the base of the exponentially growing function in Theo-
rem 4, i.e., Î±, the branching number. Let Ï(v) denote the branching number cor-
responding to a branching vector v. Note that the ordering of a branching vector
does not affect the corresponding branching number. The following theorem concerns
about the relation between a branching vector its corresponding branching number.
Theorem 5 Given two branching vectors v = (d1, d2, . . . , di) and vâ€² = (d â€²1, d â€²2,
. . . , d â€²i ), where dj â‰¤ d â€²j for 1 â‰¤ j â‰¤ i. Then Ï(v) â‰¥ Ï(vâ€²).
Proof The reflected characteristic polynomial of v and vâ€² are 1 âˆ’ âˆ‘ij=1 zdj and
1 âˆ’ âˆ‘ij=1 zd
â€²
j respectively. Let z0 and zâ€²0 be the roots of 1 âˆ’
âˆ‘i
j=1 zdj and 1 âˆ’
âˆ‘i
j=1 z
d â€²j respectively, then we have
âˆ‘i
j=1 z0dj = 1 and
âˆ‘i
j=1 zâ€²0
dj = 1. Since
z0 < 1 and dj â‰¤ d â€²j for 1 â‰¤ j â‰¤ i, we have z0d
â€²
j â‰¤ z0dj for all 1 â‰¤ j â‰¤ i, and hence
âˆ‘i
j=1 z0
d â€²j â‰¤ 1. Thus zâ€²0 must be greater than or equal to z0. Therefore, Ï(v) =
1/z0 â‰¥ 1/zâ€²0 = Ï(vâ€²). 
3 An O(3.0446kn + n4) Fixed-Parameter Algorithm for the Parameterized
MQI Problem
3.1 The Algorithm
Our first fixed-parameter algorithm is called FPA1-MQI, which runs recursively. The
concepts of the algorithm are as follows. We build a list of unresolved quintets Cf
containing some fixed taxon f and the list V of topologies vectors of possible quintet
topologies for a quintet as preprocessing steps. In each recursion, the algorithm se-
lects an unresolved quintet q = {a, b, c, d, e} âˆˆ Cf arbitrarily and then tries to make q
resolved by the procedure update according to all the possible 15 quintet topologies
of q.
Recall that each topology vector Î¼ âˆˆ V represents a quintet topology of a quintet.
The procedure update changes quartet topologies according to the quartet topologies
which Î¼ stands for, and updates the set Cf and the parameter k to be Câ€²f and kâ€² re-
spectively. For example, assume that we have [ab|cd], [ae|bc], [ab|de], [ae|cd], and
[bd|ce] in Q for the quintet {a, b, c, d, e} (the corresponding topology vector is then
(0,2,0,2,1)), and assume that Î¼ = (2,1,1,1,2). The procedure update changes
these quartet topologies to [ad|bc], [ac|be], [ad|be], [ad|ce], and [be|cd] respec-
tively, according to Î¼, and these quartets are marked so that their topologies will
not be changed again. However, if there is a branch node in the search tree such
that some quartet topology, whose corresponding quartet has been marked, must be
Theory Comput Syst (2010) 47: 342â€“367 351
Table 1 Some possible branching vectors and branching numbers of FPA1-MQI
Topology vector Branching vector Branching number
(0,1,2,1,0) (3,3,4,3,3,3,4,3,3,4,4,3,3,4,3) 2.30042. . .
(0,0,1,0,1) (2,4,4,4,5,2,2,3,3,4,3,4,3,3,4) 2.46596. . .
(0,0,1,0,2) (2,4,4,4,5,3,3,4,4,5,2,3,2,2,3) 2.54314. . .
(0,0,1,0,0) (1,3,3,3,4,3,3,4,4,5,3,4,3,3,4) 2.55234. . .
(0,0,1,1,2) (3,5,5,3,5,2,2,3,5,5,2,3,2,3,2) 2.67102. . .
(0,0,0,0,1) (1,3,3,5,5,1,3,3,3,4,2,4,4,4,5) 3.04454. . .
case, the algorithm selects a quintet q = {a, b, c, d, e} which has induced quartet
topologies [ab|cd], [ac|be], [ae|bd], [ad|ce], and [bc|de] in Q. By comparing its
corresponding topology vector (0,1,2,1,0) with each topology vector Î¼ âˆˆ V , we
obtain that the numbers of quartet topologies changed by Algorithm FPA1-MQI are
3, 3, 4, 3, 3, 3, 4, 3, 3, 4, 4, 3, 3, 4, and 3 respectively. Hence we have a branching
vector (3,3,4,3,3,3,4,3,3,4,4,3,3,4,3) and then we can compute a branching
number between 2.3004 and 2.3005. It can be derived that the branching number in
the worst case is greater than 3.0445 and less than 3.0446. Thus the size of T (k) is
O(3.0446k).
3.2.3 The Procedure update
For Î¼ âˆˆ V , since there are n âˆ’ 4 quintets involving a fixed quartet, there are at most
|QÎ¼|(n âˆ’ 4) quintets involving quartet topologies in QÎ¼. Thus the procedure update
runs only in O(n) time.
From the above analysis, we derive that the time complexity of Algorithm FPA1-
MQI is O(3.0446kn + n4). Thus the following theorem follows.
Theorem 6 There exists an O(3.0446kn + n4) fixed-parameter algorithm for the
parameterized minimum quartet inconsistency problem.
4 An O(2.0162kn3 + n5) Fixed-Parameter Algorithm for the Parameterized
MQI Problem
4.1 The Two-Siblings-Determined Minimum Quartet Inconsistency Problem
We define the two-siblings-determined minimum quartet inconsistency problem as
follows. Given a complete quartet topology set Q over a taxon set S, a parameter k
and two taxa a, b âˆˆ S as the input, determine whether there exists an evolutionary
tree T on which a and b are siblings such that QT differs from Q in at most k quartet
topologies. As we have mentioned in Sect. 1, we abbreviate this problem as 2SDMQI
for the readersâ€™ convenience.
We present a fixed-parameter algorithm called FPA-2SDMQI for the 2SDMQI
problem as follows. First, for every u,v âˆˆ S \{a, b} such that [ab|uv] /âˆˆ Q, we change
Theory Comput Syst (2010) 47: 342â€“367 353
Algorithm Resolve works recursively. In each recursion, it arbitrarily selects an
unresolved quintet q. It is clear that q âˆª {b} is {a, b}-unresolved. Then Algorithm
Resolve tries to make q âˆª {b} be {a, b}-resolved by the procedure update2 according
to all the possible 15 sextet topologies of q âˆª {b} having a, b as siblings. Similar to
the procedure update in Sect. 3, we mark the quartets whose topologies are changed,
and if there is a branch node in the search tree such that some quartet, which has been
marked, must be changed in all the possible 15 branches to make q âˆª {b} be {a, b}-
resolved, the algorithm stops branching here and just returns (by the same reason
mentioned in Sect. 3.1).
Each {a, b}-reduced topology vector Î½ âˆˆ V2 represents a sextet topology of a sextet
with siblings a, b. The procedure update2 changes quartet topologies according to the
quartet topologies that Î½ stands for, marks these quartets so that their topologies will
not be changed again, and updates the set Ca and the parameter k to be Câ€²a and kâ€²
respectively. We denote by QÎ½ the set of quartet topologies changed according to Î½.
The procedure update2 gets the updated Câ€²a by removing the newly resolved quintets
and adding the newly unresolved quintets from Ca , and gets the updated parameter
kâ€² by letting kâ€² = k âˆ’ |QÎ½ |. Similar to the analysis of Algorithm FPA1-MQI, we can
derive easily that Algorithm FPA-2SDMQI is correct.
4.2 Time Complexity
4.2.1 Nonrecursive Steps
Execution of lines 6â€“13 in Algorithm FPA-2SDMQI costs O(n2) time. Building Ca
requires O(n4) time by Theorem 3. Furthermore, it is obvious that building V2 costs
only constant time.
4.2.2 The Recursive Structure of Algorithm FPA-2SDMQI
The algorithm (i.e., Algorithm Resolve) again works as a depth-bounded search tree.
Each tree node has 15 branches and each branch corresponds to a sextet topology
with siblings a, b. The root of the search tree is labeled by k. Let us denote the size
of the search tree rooted at a node labeled r to be the T2(r). For each Î½ âˆˆ V2, we
have T2(r) = âˆ‘Î½âˆˆV2 T2(r âˆ’ |QÎ½ |), that is, the branching vector is (|QÎ½ |)Î½âˆˆV2 . There
are 39 = 19683 possible {a, b}-reduced topology vectors of a sextet containing a, b.
By ignoring {a, b}-reduced topology vectors in V2, there are 19668 possible branch-
ing vectors as well as 19668 branching numbers left. Actually, there are only 141
different branching numbers among these 19668 ones (this can be easily checked
by a small program). Table 2 lists part of the branching vectors and the correspond-
Table 2 Some possible branching vectors and branching numbers of FPA-2SDMQI
Topology vector Branching vector Branching number
(0,0,1,1,1,1,2,2,0) (6,6,8,6,6,6,6,5,6,6,6,6,5,6,6) 1.58005. . .
(0,0,1,0,1,2,2,1,0) (5,6,6,5,6,6,6,5,6,6,7,6,7,6,7) 1.58142. . .
. . . . . . . . .
(0,0,0,0,0,0,0,1,0) (1,5,5,7,8,2,6,6,8,9,3,7,7,8,8) 2.00904. . .
(0,0,0,0,0,0,0,0,1) (1,5,5,9,9,2,6,6,6,8,3,7,7,7,9) 2.01615. . .
Theory Comput Syst (2010) 47: 342â€“367 355
Theorem 8 There exists an O(2.0162kn3 + n5) fixed-parameter algorithm for the
parameterized minimum quartet inconsistency problem.
5 An Oâˆ—((1 + )k) Fixed-Parameter Algorithm for the Parameterized MQI
Problem
5.1 The Algorithm
At the beginning of this section, let us consider some additional preliminaries. Let
T denote an evolutionary tree on S such that QT differs from Q in at most k quar-
tet topologies. For an integer m â‰¥ 2, we say that taxa a1, . . . , am are adjacent if
there exists an edge e = (w,v) on T such that cutting e will produce a bipartition
({a1, . . . , am}, S \ {a1, . . . , am}) of S. In Fig. 6, cutting the edge e will derive four
adjacent taxa a1, a2, a3, and a4. In addition, after e = (w,v) is cut, two binary trees,
which are rooted at w and v respectively, will be produced. Note that two taxa on T
are adjacent if and only if they are siblings on T .
Lemma 3 Given an evolutionary tree T and an integer 2 â‰¤ Ï‰ â‰¤ n/2, there exists a
set of m adjacent taxa as leaves on T , where Ï‰ â‰¤ m â‰¤ 2Ï‰ âˆ’ 2.
Proof If there exists Ï‰ adjacent taxa on T , the lemma holds. Otherwise, assume that
there is no subtree of T which has exactly m taxa as leaves. Let T (s) denote the
subtree of T which is rooted at a tree node s. There must exist some edge eâˆ— = (w,v)
such that cutting eâˆ— will produce a bipartition (A,S \ A), where |A| > Ï‰, T (v) has
A as its leaf set and two subtrees of T (v) have both less than Ï‰ taxa as their leaves
(otherwise, assume that t is one child of v such that T (t) has more than Ï‰ taxa
as leaves. Then we can recursively find a subtree of T (t) rooted at some tree node
x descendant of t until both two subtrees of T (x) have less than Ï‰ taxa as their
leaves). Assume that v has two children u and t , and T (u) and T (t) have p and pâ€²
taxa as leaves respectively, where p,pâ€² < Ï‰. Since |A| > Ï‰, we have p + pâ€² > Ï‰.
Furthermore, p + pâ€² â‰¤ 2Ï‰ âˆ’ 2 since p and pâ€² are both less than Ï‰. So we have
Ï‰ + 1 â‰¤ p + pâ€² â‰¤ 2Ï‰ âˆ’ 2. Therefore the lemma follows. 
Recall that Algorithm FPA2-MQI copes with siblings on an evolutionary tree first.
In this section, we extend the idea of Algorithm FPA2-MQI to consider m â‰¥ 3 ad-
jacent taxa. We obtain another fixed-parameter algorithm called FPA3-MQI with
two subroutines Algorithm MAKE-ADJ and Algorithm ADJ-Resolve. Assume that
Fig. 6 An evolutionary tree
with adjacent taxa a1, a2, a3, a4
Theory Comput Syst (2010) 47: 342â€“367 357
Algorithm 6 MAKE-ADJ (A complete set of quartet topologies Q, a list of unresolved
quintets Ca1 , an integer parameter k)
1: if Ca1 is empty and k â‰¥ 0 then
2: Return ACCEPT;
3: else if k â‰¤ 0 then
4: Return;
5: end if
6: while Bm = âˆ… do
7: Extract {w,x, y} from Bm;
8: for each type i âˆˆ {0,1,2} do
9: Change all the topologies of {a1,w,x, y}, . . . , {am,w,x, y} to topologies of
type i; let Qâ€², Câ€²a1 , kâ€² be the changed Q, Ca1 , k respectively;
10: MAKE-ADJ(Qâ€², Câ€²a1 , kâ€²);
11: end for
12: end while
13: if ADJ-Resolve(Q,k, Ca1) returns ACCEPT then
14: Return ACCEPT;
15: end if
Algorithm 7 ADJ-Resolve (A complete set of quartet topologies Q, an integer para-
meter k, a list Ca1 of unresolved quintets)
1: if Ca1 is empty and k â‰¥ 0 then
2: Return ACCEPT;
3: else if k â‰¤ 0 then
4: Return;
5: end if
6: Extract an unresolved quintet q from Ca1 ;
7: for each Î¼ âˆˆ V do
8: (Qâ€², Câ€²a1 , kâ€²) â† updatem(Q, Ca1 ,q,Î¼, k);
9: ADJ-Resolve(Qâ€², kâ€², Câ€²a1);
10: end for
5.1.2 (3,1)-Cleaning
Assume the parameter is kâ€². For ah, ai, aj âˆˆ Am and s âˆˆ S \ Am, without loss of
generality we denote the type of quartet topology [ahai |aj s] by 0, [ahaj |ais] by 1,
and [ahs|aiaj ] by 2. We construct a set of all possible evolutionary trees Tm+1 on the
taxa in Am âˆª {x}, where x is an arbitrary taxon in S \ Am, such that each T â€² âˆˆ Tm+1
has at most kâ€² different induced quartet topologies from Q. Afterwards, for each
T â€² âˆˆ Tm+1, we change the type of topology of every quartet {ah, ai, aj , s} into the
same type of topology as {ah, ai, aj , x} has on T â€². We call this part of the algorithm
(3,1)-cleaning.
Theory Comput Syst (2010) 47: 342â€“367 359
Fig. 8 Possible topologies for
the quintet {a1, a2, a3, x, y}
we obtain the other two quintet topologies in (b) and (c) of Fig. 8. So the quintet
{a1, a2, a3, x, y} must be also resolved. Then a contradiction occurs.
Third, without loss of generality we assume q = {a1, a2, a3, a4, s}, where
a1, a2, a3, a4 âˆˆ Am and s âˆˆ S \ Am. Recall that for some fixed taxa x âˆˆ S \ Am, the
tree topology of Am âˆª {x} is determined because of (3,1)-cleaning of the algorithm.
Moreover, all the quartets in {a1, a2, a3, a4, s} have the same type of quartet topolo-
gies as {a1, a2, a3, a4, x} have. So the quintet {a1, a2, a3, a4, s} must be resolved.
Then a contradiction occurs again. As to the fourth case of the proof, i.e., the quintets
involving five taxa in Am, their topologies are also determined by (3,1)-cleaning of
the algorithm, so they must be resolved. Therefore, we have shown that as long as
(2,2)-cleaning, (3,1)-cleaning, and (1,3)-cleaning of the algorithm are done, there
is no unresolved quintet in Ca1 containing taxa in Am except a1. Hence the lemma
follows. 
Note that there do not always exist Ï‰ adjacent taxa in an evolutionary tree for an
arbitrary integer Ï‰. By Lemma 3, we know there must be m taxa which are adjacent
in an evolutionary tree, where Ï‰ â‰¤ m â‰¤ 2Ï‰ âˆ’ 2. Assume that we are given an integer
Ï‰ as an additional input. Then to solve the parameterized MQI problem, first we
build a list of unresolved quintet involving s for each s âˆˆ S, then we run Algorithm
FPA3-MQI for every m âˆˆ {Ï‰, . . . ,2Ï‰ âˆ’ 2}.
By Lemma 4 we know that each unresolved quintet q âˆˆ Ca1 contains a1 and the
other four taxa from S \ Am. The procedure updatem is similar to the procedure
update in Sect. 3. Yet if a quartet topology of {a1,w,x, y}, where w,x, y âˆˆ q \ a1,
is changed, the procedure not only changes quartet topologies according to Î¼, but
also changes the topologies of {a2,w,x, y}, {a3,w,x, y}, . . . , {am,w,x, y} together
into the same type as {a1,w,x, y} has. Let d denote the number of quartet topologies
changed by updatem. Then the procedure updates the set Ca1 and the parameter k to
be Câ€²a1 and kâ€² respectively, where kâ€² is k âˆ’ d .
5.1.5 Correctness
Recall that we use T to denote an evolutionary tree on S such that QT differs from Q
in at most k quartet topologies. Given an arbitrary integer 2 â‰¤ Ï‰ â‰¤ n/2, there exists
m adjacent taxa in T , where Ï‰ â‰¤ m â‰¤ 2Ï‰ âˆ’ 2. So we can assume that there is a set
of adjacent taxa Am = {a1, . . . , am} âŠ† S on T . Since the taxa in Am are adjacent, the
path connecting every two taxa ai, aj âˆˆ Am and the path connecting two taxa u,v âˆˆ
S \Am will be disjoint and hence the topology of {ai, aj , u, v} must be [aiaj |uv]. So
(2,2)-cleaning is valid. In addition, once the topology of {ah, ai, aj , x} is fixed for
ah, ai, aj âˆˆ Am and some x âˆˆ S \ Am, the quartets {ah, ai, aj , s} must have the same
type of quartet topologies as {ah, ai, aj , x} has one T . Hence (3,1)-cleaning is valid.
Theory Comput Syst (2010) 47: 342â€“367 361
(1,3)-cleaning branches on these three types to make every quartet {ai,w,x, y},
where ai âˆˆ Am, have the same type of topology. Then (1,3)-cleaning of the algo-
rithm has a recurrence of T (k) = T (k âˆ’ (m1 + m2)) + T (k âˆ’ (m0 + m2)) + T (k âˆ’
(m0 + m1)). So we have a branching vector (m1 + m2,m0 + m2,m0 + m1). Let
r0 = m1 + m2, r1 = m1 + m2 and r2 = m0 + m1. Since the order of a branching
vector does not change its branching number, without loss of generality we assume
that 0 < r0 â‰¤ r1 â‰¤ r2 â‰¤ m. Since m0 + m1 + m2 = m, we have r0 + r1 + r2 = 2m
and r1, r2 â‰¥ m/2. The next lemma shows that the size of the depth-bounded search
tree of (1,3)-cleaning is O((1 + 5mâˆ’1/4)k). Moreover, it can be proved to be
O((1 + 2mâˆ’1/2)k) if m â‰¥ 19.
Lemma 5 Given a branching vector (r0, r1, r2), where 0 < r0 â‰¤ r1 â‰¤ r2 â‰¤ m, r0 +
r1 + r2 = 2m and r1, r2 â‰¥ m/2, then we have a branching number Î± < 1 + 5mâˆ’1/4.
Furthermore, Î± < 1 + 2mâˆ’1/2 if m â‰¥ 19.
Proof The reflected characteristic polynomial of (r0, r1, r2) is 1 âˆ’ zr0 âˆ’ zr1 âˆ’ zr2 .
Let f (z) = 1 âˆ’ zr0 âˆ’ zr1 âˆ’ zr2 . We have f (0) = 1 and f (1) = âˆ’2, so there is
a root of f (z) in [0,1]. The derivative f â€²(z) = âˆ’r0zr0âˆ’1 âˆ’ r1zr1âˆ’1 âˆ’ r2zr2âˆ’1.
We can derive that f (z) is monotonically decreasing in [0,1] since f â€²(z) â‰¤ 0 for
0 â‰¤ z â‰¤ 1. Let us define g(z) = 1 âˆ’ z âˆ’ 2zm/2. Similarly, g(z) has a root in [0,1]
and is monotonically decreasing in [0,1]. Since zr0 â‰¤ z and zr1 , zr2 â‰¤ zm/2, we have
g(z) â‰¤ f (z). We can then derive that there is a root of g(z) which is smaller than the
root of f (z).
Let 0 â‰¤ z0 â‰¤ 1 be a root of g(z), i.e., g(z0) = 0. Let z1 = 1 âˆ’ mâˆ’1/4 and
z2 = 1âˆ’mâˆ’1/2, so 0 â‰¤ z1, z2 â‰¤ 1. Then we have g(z1) = mâˆ’1/4 âˆ’2(1âˆ’mâˆ’1/4)m/2 >
mâˆ’1/4 âˆ’ 2eâˆ’m3/4/2, and g(z2) = mâˆ’1/2 âˆ’ 2(1 âˆ’mâˆ’1/2)m/2 > mâˆ’1/2 âˆ’ 2eâˆ’m1/2/2. So
g(z1) > 0 when m â‰¥ 3 and g(z2) > 0 when m â‰¥ 19. If g(z1) > 0, then z0 must
be bigger than z1 because g(z) is monotonically decreasing in [0,1]. So we have
z0 > 1 âˆ’ mâˆ’1/4 for m â‰¥ 3. Similarly, we have z0 > 1 âˆ’ mâˆ’1/2 if m â‰¥ 19. There-
fore, the branching number Î± is smaller than 1/(1 âˆ’ mâˆ’1/4) < 1 + 5mâˆ’1/4. Further-
more, if m â‰¥ 19, Î± is smaller than 1/(1 âˆ’ mâˆ’1/2) < 1 + 2mâˆ’1/2. The lemma is then
proved. 
Quintet cleaning by the recursive algorithm ADJ-Resolve Assume that the list
of unresolved quintets is Ca1 . Let q = {a1,w,x, y, z} be an unresolved quintet
in Ca1 , and let vq = (vq(1),vq(2),vq(3),vq(4),vq(5)) denote the topology vec-
tor of q, where vq(1), vq(2), vq(3), vq(4), and vq(5) are the types of topolo-
gies of {a1,w,x, y}, {a1,w,x, z}, {a1,w,y, z}, {a1, x, y, z}, and {w,x, y, z} re-
spectively, with respect to Q. Recall that V = {Î¼1, . . . ,Î¼15} is a set of topol-
ogy vectors of 15 possible quintet topologies for a quintet, such that each Î¼i =
(Î¼i(1),Î¼i(2),Î¼i(3),Î¼i(4),Î¼i(5)) âˆˆ V stands for the ith topology vector in V .
If q is resolved, there exists exactly one Î¼i âˆˆ V such that vq(j) = Î¼i(j) for each
1 â‰¤ j â‰¤ 5. Let vq(j) âŠ• Î¼i(j) denote whether vq(j) and Î¼i(j) are different. That is,
for 1 â‰¤ j â‰¤ 5 we denote vq(j) âŠ• Î¼i(j) = 1 if vq(j) = Î¼i(j) and vq(j) âŠ• Î¼i(j) = 0
otherwise.
For an unresolved quintet q, let b(q) denote the branching vector of the recurrence
of the quintet cleaning for q. By the descriptions of quintet cleaning and the procedure
Theory Comput Syst (2010) 47: 342â€“367 363
m adjacent taxa Am is given, since it costs O(mn) time at each node in the search
tree, the time complexity for the search tree is O((1 + 2mâˆ’1/2)kmn). Assume that
1 + 2mâˆ’1/2 â‰¤ 1 +  for some constant  > 0. We obtain m â‰¥ (2/)2. Thus after the
lists of unresolved quintets {Cs | s âˆˆ S} are built, we run Algorithm FPA3-MQI for
every (2/)2 â‰¤ m â‰¤ 2(2/)2 âˆ’ 2 and every set of m taxa in S. Let Ï‰ denote (2/)2.
By the analysis in the previous subsection, we obtain the overall time complexity of
the algorithm as follows
O
(
n5 +
2Ï‰âˆ’2âˆ‘
m=Ï‰
(
n
m
)(
m2n3 + mn3 + h(m) Â·
(
m4n + m3n2 + (1 + )kmn
)))
= O(n5 + (Ï‰ âˆ’ 1)n2Ï‰âˆ’2(4Ï‰2n3 + 2Ï‰n3
+ h(2Ï‰) Â· (16Ï‰4n + 8Ï‰3n2 + 2(1 + )kÏ‰n)))
= O((1 + )kn2Ï‰âˆ’1 + n2Ï‰+1 + n5)
= O((1 + )kn8/2âˆ’1 + n8/2+1 + n5).
Consider the first line of above deduction. Recall that the term n5 comes from
building Cs for s âˆˆ S. The summation and the term
(
n
m
)
arise due to exhaustively tak-
ing all the possibilities of Am (i.e., the set of m adjacent taxa) into consideration. The
term m2n3 comes from (2,2)-cleaning. The term mn3 comes from the preprocessing
of (1,3)-cleaning and quintet-cleaning. The term h(m) arises from the construction
of all possible evolutionary trees on Am âˆª {x}, where x is a taxon not in Am. The
terms m4n and m3n2 arise from (3,1)-cleaning. The rest term (1 + )kmn in the first
line is derived from the analysis of the size of depth-bounded search tree of (1,3)-
cleaning and quintet-cleaning. The second equality holds since m < 2Ï‰ âˆ’ 2 < 2Ï‰
and
(
n
m
) = O(nm). Therefore we have an Oâˆ—((1 + )k) fixed-parameter algorithm
for the parameterized MQI problem. Hence the following concluding theorem fol-
lows.
Theorem 9 There exists an Oâˆ—((1 + )k) time fixed-parameter algorithm for the pa-
rameterized minimum quartet inconsistency problem, where  is an arbitrarily small
constant and the degree of the involved polynomial in the running time has depen-
dence on .
Acknowledgement The authors thank anonymous referees for their careful reading and for their many
helpful comments.
Appendix
We list all the possible branching vectors as well as the corresponding branching
numbers for Algorithm FPA1-MQI in Tables 3â€“5. Note that we abbreviate topology
vectors, branching vectors and branching numbers to be t.v., b.v., and b.n. respec-
tively, and NB means there is no branching for the topology vector.
Theory Comput Syst (2010) 47: 342â€“367 365
Table 4 The possible branching vectors and branching numbers of Algorithm FPA1-MQI (part 2)
t.v. b.v. b.n. t.v. b.v. b.n.
(0,2,2,2,0) (3,4,3,3,1,4,5,4,4,2,3,1,3,5,5) 3.04454 (0,2,2,2,1) (4,5,4,4,2,3,4,3,3,1,3,1,3,5,5) 3.04454
(0,2,2,2,2) NB NB (1,0,0,0,0) (1,1,2,4,4,3,4,3,3,4,3,5,5,3,5) 3.04454
(1,0,0,0,1) (2,2,3,5,5,2,3,2,2,3,3,5,5,3,5) 2.67102 (1,0,0,0,2) (2,2,3,5,5,3,4,3,3,4,2,4,4,2,4) 2.54314
(1,0,0,1,0) (2,2,3,3,4,2,3,2,4,4,3,5,5,4,4) 2.54314 (1,0,0,1,1) (3,3,4,4,5,1,2,1,3,3,3,5,5,4,4) 3.04454
(1,0,0,1,2) (3,3,4,4,5,2,3,2,4,4,2,4,4,3,3) 2.46596 (1,0,0,2,0) (2,2,3,4,3,3,4,3,4,3,2,4,4,4,5) 2.46596
(1,0,0,2,1) (3,3,4,5,4,2,3,2,3,2,2,4,4,4,5) 2.54314 (1,0,0,2,2) (3,3,4,5,4,3,4,3,4,3,1,3,3,3,4) 2.55234
(1,0,1,0,0) (2,2,3,3,4,4,3,3,3,4,4,5,4,2,4) 2.46596 (1,0,1,0,1) (3,3,4,4,5,3,2,2,2,3,4,5,4,2,4) 2.54314
(1,0,1,0,2) (3,3,4,4,5,4,3,3,3,4,3,4,3,1,3) 2.55234 (1,0,1,1,0) (3,3,4,2,4,3,2,2,4,4,4,5,4,3,3) 2.46596
(1,0,1,1,1) (4,4,5,3,5,2,1,1,3,3,4,5,4,3,3) 3.04454 (1,0,1,1,2) (4,4,5,3,5,3,2,2,4,4,3,4,3,2,2) 2.54314
(1,0,1,2,0) (3,3,4,3,3,4,3,3,4,3,3,4,3,3,4) 2.30042 (1,0,1,2,1) (4,4,5,4,4,3,2,2,3,2,3,4,3,3,4) 2.46596
(1,0,1,2,2) (4,4,5,4,4,4,3,3,4,3,2,3,2,2,3) 2.46596 (1,0,2,0,0) (2,2,3,4,3,4,4,2,2,3,4,4,5,3,5) 2.54314
(1,0,2,0,1) (3,3,4,5,4,3,3,1,1,2,4,4,5,3,5) 3.04454 (1,0,2,0,2) (3,3,4,5,4,4,4,2,2,3,3,3,4,2,4) 2.46596
(1,0,2,1,0) (3,3,4,3,3,3,3,1,3,3,4,4,5,4,4) 2.55234 (1,0,2,1,1) NB NB
(1,0,2,1,2) (4,4,5,4,4,3,3,1,3,3,3,3,4,3,3) 2.55234 (1,0,2,2,0) (3,3,4,4,2,4,4,2,3,2,3,3,4,4,5) 2.46596
(1,0,2,2,1) (4,4,5,5,3,3,3,1,2,1,3,3,4,4,5) 3.04454 (1,0,2,2,2) (4,4,5,5,3,4,4,2,3,2,2,2,3,3,4) 2.54314
(1,1,0,0,0) NB NB (1,1,0,0,1) (3,1,3,5,5,3,4,3,1,3,4,5,4,2,4) 3.04454
(1,1,0,0,2) (3,1,3,5,5,4,5,4,2,4,3,4,3,1,3) 3.04454 (1,1,0,1,0) (3,1,3,3,4,3,4,3,3,4,4,5,4,3,3) 2.55234
(1,1,0,1,1) (4,2,4,4,5,2,3,2,2,3,4,5,4,3,3) 2.54314 (1,1,0,1,2) (4,2,4,4,5,3,4,3,3,4,3,4,3,2,2) 2.46596
(1,1,0,2,0) (3,1,3,4,3,4,5,4,3,3,3,4,3,3,4) 2.55234 (1,1,0,2,1) (4,2,4,5,4,3,4,3,2,2,3,4,3,3,4) 2.46596
(1,1,0,2,2) (4,2,4,5,4,4,5,4,3,3,2,3,2,2,3) 2.54314 (1,1,1,0,0) (3,1,3,3,4,5,4,4,2,4,5,5,3,1,3) 3.04454
(1,1,1,0,1) (4,2,4,4,5,4,3,3,1,3,5,5,3,1,3) 3.04454 (1,1,1,0,2) NB NB
(1,1,1,1,0) (4,2,4,2,4,4,3,3,3,4,5,5,3,2,2) 2.54314 (1,1,1,1,1) (5,3,5,3,5,3,2,2,2,3,5,5,3,2,2) 2.67102
(1,1,1,1,2) (5,3,5,3,5,4,3,3,3,4,4,4,2,1,1) 3.04454 (1,1,1,2,0) (4,2,4,3,3,5,4,4,3,3,4,4,2,2,3) 2.46596
(1,1,1,2,1) (5,3,5,4,4,4,3,3,2,2,4,4,2,2,3) 2.54314 (1,1,1,2,2) (5,3,5,4,4,5,4,4,3,3,3,3,1,1,2) 3.04454
(1,1,2,0,0) (3,1,3,4,3,5,5,3,1,3,5,4,4,2,4) 3.04454 (1,1,2,0,1) NB NB
(1,1,2,0,2) (4,2,4,5,4,5,5,3,1,3,4,3,3,1,3) 3.04454 (1,1,2,1,0) (4,2,4,3,3,4,4,2,2,3,5,4,4,3,3) 2.46596
(1,1,2,1,1) (5,3,5,4,4,3,3,1,1,2,5,4,4,3,3) 3.04454 (1,1,2,1,2) (5,3,5,4,4,4,4,2,2,3,4,3,3,2,2) 2.54314
(1,1,2,2,0) (4,2,4,4,2,5,5,3,2,2,4,3,3,3,4) 2.54314 (1,1,2,2,1) (5,3,5,5,3,4,4,2,1,1,4,3,3,3,4) 3.04454
(1,1,2,2,2) (5,3,5,5,3,5,5,3,2,2,3,2,2,2,3) 2.67102 (1,2,0,0,0) (2,1,1,3,3,4,5,4,3,3,4,4,5,3,5) 3.04454
(1,2,0,0,1) (3,2,2,4,4,3,4,3,2,2,4,4,5,3,5) 2.54314 (1,2,0,0,2) (3,2,2,4,4,4,5,4,3,3,3,3,4,2,4) 2.46596
(1,2,0,1,0) (3,2,2,2,3,3,4,3,4,3,4,4,5,4,4) 2.46596 (1,2,0,1,1) (4,3,3,3,4,2,3,2,3,2,4,4,5,4,4) 2.46596
(1,2,0,1,2) (4,3,3,3,4,3,4,3,4,3,3,3,4,3,3) 2.30042 (1,2,0,2,0) (3,2,2,3,2,4,5,4,4,2,3,3,4,4,5) 2.54314
(1,2,0,2,1) (4,3,3,4,3,3,4,3,3,1,3,3,4,4,5) 2.55234 (1,2,0,2,2) (4,3,3,4,3,4,5,4,4,2,2,2,3,3,4) 2.46596
(1,2,1,0,0) (3,2,2,2,3,5,4,4,3,3,5,4,4,2,4) 2.54314 (1,2,1,0,1) (4,3,3,3,4,4,3,3,2,2,5,4,4,2,4) 2.46596
(1,2,1,0,2) (4,3,3,3,4,5,4,4,3,3,4,3,3,1,3) 2.55234 (1,2,1,1,0) (4,3,3,1,3,4,3,3,4,3,5,4,4,3,3) 2.55234
(1,2,1,1,1) (5,4,4,2,4,3,2,2,3,2,5,4,4,3,3) 2.54314 (1,2,1,1,2) (5,4,4,2,4,4,3,3,4,3,4,3,3,2,2) 2.46596
(1,2,1,2,0) (4,3,3,2,2,5,4,4,4,2,4,3,3,3,4) 2.46596 (1,2,1,2,1) (5,4,4,3,3,4,3,3,3,1,4,3,3,3,4) 2.55234
(1,2,1,2,2) (5,4,4,3,3,5,4,4,4,2,3,2,2,2,3) 2.54314 (1,2,2,0,0) (3,2,2,3,2,5,5,3,2,2,5,3,5,3,5) 2.67102
(1,2,2,0,1) (4,3,3,4,3,4,4,2,1,1,5,3,5,3,5) 3.04454 (1,2,2,0,2) (4,3,3,4,3,5,5,3,2,2,4,2,4,2,4) 2.54314
Theory Comput Syst (2010) 47: 342â€“367 367
References
1. Ben-Dor, A., Chor, B., Graur, D., Ophir, R., Pelleg, D.: From four-taxon trees to phylogenies: the
case of mammalian evolution. In: Proceedings of the RECOMB, pp. 9â€“19 (1998)
2. Bandelt, H.J., Dress, A.: Reconstructing the shape of a tree from observed dissimilarity data. Adv.
Appl. Math. 7, 309â€“343 (1986)
3. Berry, V., Jiang, T., Kearney, P.E., Li, M., Wareham, H.T.: Quartet cleaning: Improved algorithms
and simulations. In: Proceedings of the 7th Annual European Symposium on Algorithms (ESA 99).
Lecture Notes in Comput. Sci., vol. 1643, pp. 313â€“324. Springer, Berlin (1999)
4. Cho, B.: From quartets to phylogenetic trees. In: Proceedings of the 25th Conference on Current
Trends in Theory and Practice of Informatics (SOFSEM). Lecture Notes in Comput. Sci., vol. 1521,
pp. 36â€“53. Springer, Berlin (1998)
5. Downey, R.G., Fellows, M.R.: Parameterized Complexity. Springer, Berlin (1999)
6. ErdoËs, P., Steel, M., SzÃ©kely, L., Warnow, T.: A few logs suffice to build (almost) all trees (Part 1).
Random Struct. Algorithms 14, 153â€“184 (1999)
7. Greene, D.H., Knuth, D.E.: Mathematics for the Analysis of Algorithms, 2nd edn. Progress in Com-
puter Science. BirkhÃ¤user, Boston (1982)
8. Gramm, J., Niedermeier, R.: A fixed-parameter algorithm for minimum quartet inconsistency. J. Com-
put. Syst. Sci. 67, 723â€“741 (2003)
9. Jiang, T., Kearney, P.E., Li, M.: Some open problems in computational molecular biology. J. Algo-
rithms 34, 194â€“201 (2000)
10. Jiang, T., Kearney, P.E., Li, M.: A polynomial time approximation scheme for inferring evolutionary
tree from quartet topologies and its application. SIAM J. Comput. 30, 1942â€“1961 (2001)
11. Steel, M.: The complexity of reconstructing trees from qualitative characters and subtrees. J. Classif.
9, 91â€“116 (1992)
12. Niedermeier, R.: Invitation to Fixed-Parameter Algorithms. Oxford University Press, London (2006)
13. Niedermeier, R., Rossmanith, P.: A general method to speed up fixed-parameter algorithms. Inf.
Process. Lett. 73, 125â€“129 (2000)
14. Wu, G., You, J.-H., Lin, G.: A lookahead branch-and-bound algorithm for the maximum quartet con-
sistency problem. In: Proceedings of WABI 2005. Lecture Notes in Comput. Sci., vol. 3692, pp. 65â€“
76. Springer, Berlin (2005)
15. Wu, G., You, J.-H., Lin, G.: A polynomial time algorithm for the minimum quartet inconsistency
problem with O(n) quartet errors. Inf. Process. Lett. 100, 167â€“171 (2006)
Theory Comput Syst
1 Introduction
1.1 Property Testing
Let F be the set of all functions with the same domain D. Let P be a fixed property
of functions in F , which can be viewed as a subset of F . For two functions f,g âˆˆ F ,
let Î´(f, g) denote the fraction of elements in D for which f and g have different
values. Obviously the range of Î´ is [0,1]. Then for a function f âˆˆ F , we define
(f, P) = mingâˆˆP Î´(f, g). We say that f satisfies the property P if (f, P) = 0.
We say that f is -far from satisfying P if (f, P) â‰¥ , otherwise f is said to be
-close to satisfying P . The complexity measure we concern is the query complexity,
where a query is an examination of the function value of an element of D, and we
assume that a query takes only constant time. The following definition of a property
tester is given by Goldreich et al. [16].
Definition 1 ([16]) Given a function f âˆˆ F and a parameter 0 <  < 1, a property
tester for P is an algorithm M making o(|D|) queries, such that
1. M returns â€œyesâ€ with probability at least 2/3 if f âˆˆ P ;
2. M returns â€œnoâ€ with probability at least 2/3 if (f, P) â‰¥ .
Moreover, we say that M is a one-sided-error property tester if it returns â€œyesâ€ when-
ever f satisfies P with probability 1. If M makes queries without knowing the results
of previous ones, we say that M is non-adaptive.
As clarified in [13, 20], the success probability â€˜2/3â€™ in Definition 1 can be sub-
stituted by any arbitrary constant strictly greater than 1/2. In order to have success
probability of 1 âˆ’ Ï for any Ï < 1/3, we can simply execute M for O(log(1/Ï))
times and return the majority of these outputs.
As mentioned in [20], property testing may be useful in some scenarios. For ex-
ample, suppose we have a slow exact decision procedure and a property tester for a
function. If the property tester answers â€œnoâ€, then we know that with high probability
the function does not have the property. In particular, for one-sided-error property
testers, such a negative answer provides a witness that the function does not have
the property, and therefore it is not necessary to run the slow decision procedure.
Property testing is also useful when we can tolerate a small number of errors of the
function values. In such a scenario, we only care whether the function is â€œgoodâ€ (i.e.,
has the property) or â€œvery badâ€ (i.e., -far from having the property).
The general notion of property testing was first formulated by Rubinfeld and Su-
dan [21], who were motivated by the connection to program checking [7]. The study
on testing combinatorial objects was first introduced by Goldreich, Goldwasser, and
Ron [16]. Property testing is a very active field in theoretical computer science, espe-
cially in testing graph properties. See [1, 13, 15, 20] for surveys.
1.2 Quartets, Quintets, and Tree-Likeness
Determining the evolutionary relationship of a set of taxa is a very essential topic in
computational biology. In order to model such relationships, evolutionary trees are
Theory Comput Syst
Fig. 2 Three topologies for the
quartet {a, b, c, d}
Fig. 3 The fifteen topologies
for a quintet {a, b, c, d, e}
S = {a, b, c, d, e, f } and Q = {[ab|cd], [ab|ce], [ab|cf ], [ab|de], [ab|df ], [ab|df ],
[ab|ef ], [ac|de], [af |cd], [af |ce], [af |de], [bc|de], [bf |cd], [bf |ce], [bf |de],
[cf |de]}, then Q is tree-like since it is exactly the set of quartet topologies induced
by T in Fig. 1(i). Let Ï’ be the set of all tree-like sets of quartet topologies over S.
We call minQâˆ—âˆˆÏ’ |Q \ Qâˆ—| the error number of Q. We call the quartet topologies
in Q \ Qâˆ— the quartet errors of Q if |Q \ Qâˆ—| equals to the error number of Q for
Qâˆ— âˆˆ Ï’ . Note that the number |Q \ Qâˆ—| is equal to |Qâˆ— \ Q| since Q and Qâˆ— are
complete (if a quartet has a topology is in Q \ Qâˆ— then there must be a different one
of this quartet in Qâˆ— \ Q).
A quintet is a set of five taxa in S. Given a complete set of quartet topologies Q
over the taxon set S, we say that a quintet {a, b, c, d, e} âŠ† S is resolved with respect
to Q if the set of quartet topologies over {a, b, c, d, e} in Q is tree-like. Otherwise, we
say that {a, b, c, d, e} is unresolved with respect to Q. Similar to the quartet topology,
the quintet topology of a quintet {a, b, c, d, e} induced by an evolutionary tree T is the
path structure connecting a, b, c, d , and e in T . Without loss of generality, assume
that we have [ab|cd] induced by T , then there are five quintet topologies for the
quintet {a, b, c, d, e} induced by T since there are five positions for inserting e into
the tree structure of [ab|cd]. Since there are three different topologies for the quartet
{a, b, c, d}, there are fifteen quintet topologies for a quintet {a, b, c, d, e} (see Fig. 3).
Consider quintet topology (v) and quintet topology (x) in Fig. 3. Quintet topology (v)
induces five quartet topologies [ab|cd], [ab|ce], [ab|de], [ac|de], and [bc|de], while
quintet topology (x) induces [ac|bd], [ac|be], [ab|de], [ac|de], and [bc|de], so there
are two quartets (i.e., {a, b, c, d} and {a, b, c, e}) whose topologies induced by quintet
topology (v) are different from those induced by quintet topology (x). By exhaustively
observing their induced quartet topologies, we obtain the following fact.
Fact 1 Any two topologies of a quintet differ in at least two induced quartet topolo-
gies.
Theory Comput Syst
exists a complete set of quartet topologies which is 0.04-far from being tree-like.
This fact suggests that for  = (1) testing tree-likeness of quartet topologies is not
trivial.2 Afterwards, we present the first property tester for this property, which is of
one-sided error and non-adaptive. The impossibility of extending our results to deal
with incomplete sets of quartet topologies is also clarified.
The rest of this paper is organized as follows. In Sect. 2, we prove the existence a
complete set of quartet topologies which is at least 0.04-far from being tree-like. In
Sect. 3, we give a non-adaptive property tester for tree-likeness of quartet topologies,
which uses O(n3/) queries and has only one-sided error. Finally, in Sect. 4 we give
some concluding remarks and clarify the impossibility of extending our results to
incomplete sets of quartet topologies.
2 Existence of a Complete Set of Quartet Topologies which is at Least 0.04-far
from Being Tree-Like
In this section, we show that there exists a complete set of quartet topologies that is
at least 0.04-far from being tree-like, that is, its error number is at least 0.04
(
n
4
)
. The
sketch of the proof is as follows. First, we show that there exists a set of Î³
(
n
4
)
quintets
U over S for some constant Î³ , such that every two quintets of U do not share any
quartet. We present two ways for constructing such a set U and show that Î³ â‰¥ 0.04.
Second, by considering an arbitrary tree-like set Qâˆ—, for each quintet u âˆˆ U with
respect to Qâˆ—, we change one quartet topology of the subset quartets of u to make u
unresolved. We show that the error number of the resulting set of quartet topologies
is at least 0.04
(
n
4
)
.
A Simple Construction of U Let us label the taxa in S by S = {s1, s2, . . . , sn}. Let U
denote the set {{sn/5+i1, s2n/5+i2 , s3n/5+i3 , s4n/5+i4 , si1+i2+i3+i4} | 1 â‰¤ i1, i2, i3, i4 â‰¤
n/20}. Clearly the five taxa of every element of U are distinct, U is indeed a set of
quintets over S. Moreover, each 4-tuple (i1, i2, i3, i4) corresponds to a quintet in U ,
so the size of U is (n/20)4 = n4/160000 > 0.0015(n4
)
.
Lemma 1 Any two quintets in U do not share any quartet.
Proof Assume the contrary that two quintets u,v in U share a quartet. Let u =
{sn/5+i1 , s2n/5+i2 , s3n/5+i3 , s4n/5+i4 , si1+i2+i3+i4} and v = {sn/5+j1 , s2n/5+j2 , s3n/5+j3 ,
s4n/5+j4 , sj1+j2+j3+j4} respectively, where 1 â‰¤ i1, . . . , i4, j1, . . . , j4 â‰¤ n/20. If u and
v share the quartet {sn/5+i1, s2n/5+i2 , s3n/5+i3 , s4n/5+i4}, that is, i1 = j2, i2 = j2,
i3 = j3, i4 = j4, we have i1 + i2 + i3 + i4 = j1 + j2 + j3 + j4. Then u and v are actu-
ally the same quintets, so a contradiction occurs. As for the other possibilities that u
and v share a quartet, without loss of generality, we assume that they share the quartet
{sn/5+i1 , s2n/5+i2 , s3n/5+i3 , si1+i2+i3+i4}. We obtain that i1 = j1, i2 = j2, i3 = j3 and
i1 + i2 + i3 + i4 = j1 + j2 + j3 + j4, then we also have i4 = j4. Hence u and v are the
same quintet, and then another contradiction occurs. Thus, the lemma is proved. 
2If any complete set of quartet topologies is Î·-close to be tree-like for some Î· = o(1), then for any  =
(1) a trivial algorithm that always answers â€œyesâ€ suffices to be a property tester for this property.
Theory Comput Syst
Table 1 A property tester for
tree-likeness of quartet
topologies
1. Pick an arbitrary taxon 
 âˆˆ S, and then repeat (a) and (b) for 72 n3
times.
(a) Pick four taxa s1, s2, s3, s4 âˆˆ S \ {
} uniformly at random.
(b) If the quintet {s1, s2, s3, s4, 
} is not resolved, then
return â€œnoâ€.
2. Return â€œyesâ€.
Theorem 2 ([3]) Given a set of taxa S, a complete set of quartet topologies Q over S,
and a fixed taxon 
 âˆˆ S, Q is tree-like if and only if every quintet containing 
 is
resolved.
Remarks It follows from Theorem 2 that we can determine whether Q is tree-like
by examining quintets with respect to Q. If Q is not tree-like (i.e., the error number of
Q is at least one), by Theorem 2, we know that for any fixed taxon 
 âˆˆ S, there exists
an unresolved quintet containing 
. Hence it is clear that the number of unresolved
quintets with respect to Q is at least (n), which yields an O(n4) deterministic
algorithm to see if Q is tree-like. Intuitively, we expect more unresolved quintets
when the error number of Q gets larger. In particular, if the error number of Q is at
least cn4 for some constant c, we expect to have a large number (e.g., câ€²n5 for some
constant câ€²) of unresolved quintets with respect to Q since each quartet is contained
in n âˆ’ 4 quintets. The more unresolved quintets exist, the less queries are required to
find one of them. However, it is difficult to give an accurate estimate of the number
of unresolved quintets due to the following reason. Assume that Qâˆ— is a tree-like set
of quartet topologies such that |Q \ Qâˆ—| is equal to the error number of Q. Clearly,
Q can be derived from Qâˆ— by changing the quartet topologies in Qâˆ— \ Q one by one.
However, changing a quartet topology may either make a set of unresolved quintets
resolved or make a set of resolved quintets unresolved. After |Q \ Qâˆ—| changes, it is
difficult to say how many unresolved quintets exist with respect to Q.
We now consider the case that Q is -far from being tree-like. That is, one has to
change at least 
(
n
4
)
quartet topologies to make Q tree-like. The following theorem
provides an improved lower bound on the number of unresolved quintets.
Theorem 3 If Q is -far from being tree-like, then for an arbitrary taxon 
 âˆˆ S, there
exist more than n/36 unresolved quintets containing 
.
Proof Assume that Q is -far from being tree-like. First, fix an arbitrary taxon 
. Let
Sâˆ— be a maximal subset of S containing 
 such that the subset QSâˆ— of Q over Sâˆ—
is tree-like, and let Sâ€² = S \ Sâˆ—. It is clear that adding any further taxon of Sâ€²
into Sâˆ— will cause inconsistency (i.e., the set of quartet topologies over Sâˆ— is not
tree-like). The size of Sâ€² can never be o(n), otherwise, Q can be modified to be
tree-like by simply changing the quartet topologies {[a1a2|a3b] | a1, a2, a3 âˆˆ Sâˆ—, b âˆˆ
Sâ€²} âˆª {[a1a2|b1b2] | a1, a2 âˆˆ Sâˆ—, b1, b2 âˆˆ Sâ€²} âˆª {[ab1|b2b3] | a âˆˆ Sâˆ—, b1, b2, b3 âˆˆ Sâ€²} âˆª
{[b1b2|b3b4] | b1, b2, b3, b4 âˆˆ Sâ€²}, and the number of these changes of quartet topolo-
gies is at most
(
nâˆ’o(n)
3
) Â· (o(n)1
) + (nâˆ’o(n)2
) Â· (o(n)2
) + (nâˆ’o(n)1
) Â· (o(n)3
) + (o(n)4
) = o(n4),
which contradicts the assumption that the error number of Q is at least 
(
n
4
)
. Thus
Theory Comput Syst
Fig. 4 The tree structure with
the quartet topology [ab|cd]. T1,
T2, T3, T4, and T5 are subtrees
Fig. 5 Q = {[ab|cd], [ab|ce],
[ad|bf ], [be|df ], [cd|ef ]}.
Each quintet over
S = {a, b, c, d, e, f } is partially
resolved
ment, whether the query complexity of testing tree-likeness of quartet topologies can
be proved to be independent of n still remains open.
One might be curious about whether our results can be extended to incomplete
sets of quartet topologies. Unfortunately, it seems to be impossible since Theorem 2
is not true when the set of quartet topologies Q is incomplete. Let us say a quintet
is partially resolved if the set of quartet topologies over this quintet in Q is tree-
consistent (but not necessarily tree-like). The following example illustrates that there
exists an incomplete set of quartet topologies Q, such that Q is not tree-consistent
even when each quintet is partially resolved with respect to Q.
Let Q = {[ab|cd], [ab|ce], [ad|bf ], [be|df ], [cd|ef ]} be a set of quartet topolo-
gies over S = {a, b, c, d, e, f }. Obviously, Q is not complete. The (65
) = 6 quintets
over S are {a, b, c, d, e}, {a, b, c, d, f }, {a, b, c, e, f }, {a, b, d, e, f }, {a, c, d, e, f },
and {b, c, d, e, f }. Let us first observe the possible topologies of the quintet
{a, b, c, d, e}. Figure 4 depicts the evolutionary tree with the quartet topology
[ab|cd]. Since [ab|ce] âˆˆ Q, as Fig. 4 shows, e has to be in T3, T4, or T5. Simi-
larly, f has to be in T2. Then the induced topology of the quartet {b, d, e, f } on the
evolutionary tree can only be [bf |de]. Since this conflicts with the assumption that
[be|df ] âˆˆ Q, we derive that Q is not tree-consistent (Q is clearly not tree-like since
Q is incomplete). However, as Fig. 5 shows, each of these six quintets is partially
resolved.
In the above example, each quintet has at most two of its subset quartets with
topologies in Q. One might conjecture that if the input Q is â€œdense enoughâ€, that is,
almost all the subset quartets of each quintet have topologies in Q, then we might
be able to derive that Q is tree-consistent if and only if each quintet is partially re-
solved. However, the following example disproves this conjecture. Let Q = {[ab|ce],
[ac|bf ], [ab|de], [ad|bf ], [ae|bf ], [ad|ce], [ac|df ], [af |ce], [bd|ce], [bf |cd],
[bf |ce], [bf |de], [ce|df ]} be a set of quartet topologies over S = {a, b, c, d, e, f }.
Theory Comput Syst
phylogenies from quartets: elucidation of eutherian superordinal relationships. J. Comput. Biol. 5,
377â€“390 (1998)
5. Berry, V., Gascuel, O.: Inferring evolutionary trees with strong combinatorial evidence. Theor. Com-
put. Sci. 240, 271â€“298 (2000)
6. Berry, V., Jiang, T., Kearney, P.E., Li, M., Wareham, H.T.: Quartet cleaning: improved algorithms
and simulations. In: Proceedings of the 7th Annual European Symposium on Algorithms (ESA 99).
Lecture Notes in Comput. Sci., vol. 1643, pp. 313â€“324. Springer, Berlin (1999)
7. Blum, M., Luby, M., Rubinfeld, R.: Self-testing/correcting with applications to numerical problems.
J. Comput. Syst. Sci. 47, 549â€“595 (1993)
8. Bryant, D., Steel, M.: Constructing optimal trees from quartets. J. Algorithms 38, 237â€“259 (2001)
9. Chor, B.: From quartets to phylogenetic trees. In: Proceedings of the 25th Conference on Current
Trends in Theory and Practice of Informatics (SOFSEM). Lecture Notes in Comput. Sci., vol. 1521,
pp. 36â€“53. Springer, Berlin (1998)
10. Chang, M.-S., Lin, C.-C., Rossmanith, P.: New fixed-parameter algorithms for the minimum quartet
inconsistency problem. Theory Comput. Syst. 47, 342â€“368 (2010)
11. Colonius, H., Schulze, H.H.: Tree structures for proximity data. Br. J. Math. Stat. Psychol. 34, 167â€“
180 (1981)
12. ErdoËs, P., Steel, M., SzÃ©kely, L., Warnow, T.: A few logs suffice to build (almost) all trees (Part 1).
Random Struct. Algorithms 14, 153â€“184 (1999)
13. Fischer, E.: The art of uninformed decisions: A primer to property testing. Bull. Eur. Assoc. Theor.
Comput. Sci. (EATCS) 75, 97â€“126 (2001)
14. Felsenstein, J.: Inferring Phylogenies. Sinauer Associates, Inc., Sunderland
15. Goldreich, O.: Combinatorial property testingâ€”a survey. In: Pardalos, P., Rajaseekaran, S., Rolin, J.
(eds.) Randomization Methods in Algorithm Design. DIMACS Series in Discrete Mathematics and
Theoretical Computer Science, vol. 43, pp. 45â€“59. AMS, Providence (1998)
16. Goldreich, O., Goldwasser, S., Ron, D.: Property testing and its connection to learning and approxi-
mation. J. ACM 45, 653â€“750 (1998)
17. Gramm, J., Niedermeier, R.: A fixed-parameter algorithm for minimum quartet inconsistency. J. Com-
put. Syst. Sci. 67, 723â€“741 (2003)
18. Jiang, T., Kearney, P.E., Li, M.: Some open problems in computational molecular biology. J. Algo-
rithms 34, 194â€“201 (2000)
19. Jiang, T., Kearney, P.E., Li, M.: A polynomial time approximation scheme for inferring evolutionary
tree from quartet topologies and its application. SIAM J. Comput. 30, 1942â€“1961 (2001)
20. Ron, D.: Property testing. In: Rajasekaran, S., Pardalos, P.M., Reif, J.H., Rolim, J.D.P. (eds.) Hand-
book of Randomized Computing, vol. II, pp. 597â€“649. Kluwer Academic, Dordrecht (2001)
21. Rubinfeld, R., Sudan, M.: Robust characterization of polynomials with applications to program test-
ing. SIAM J. Comput. 25, 252â€“271 (1996)
22. Steel, M.: The complexity of reconstructing trees from qualitative characters and subtrees. J. Classif.
9, 91â€“116 (1992)
23. Verwer, R.W.H., Pelt, J.V.: Analysis of binary trees when occasional multifurcations can be considered
as aggregates of bifurcations. Bull. Math. Biol. 52, 629â€“641 (1990)
2ç”Ÿï¼Œé “æ™‚è®“æˆ‘ä¸è¦ºå¾—æœ‰é›¢å®¶è¬é‡Œçš„æ„Ÿè¦ºã€‚
å¤§æœƒç¸½å…±æ¥å—ä¸‰åä¸€ç¯‡å£é ­ç™¼è¡¨çš„è«–æ–‡ï¼Œå…«ç¯‡ä»¥ poster å½¢å¼ç™¼è¡¨çš„ç²¾ç°¡
è«–æ–‡(æ”¶éŒ„æ–¼æœƒè­°è«–æ–‡é›†)ï¼Œä»¥åŠäº”ç¯‡ poster è«–æ–‡ã€‚ä¸‰å¤©çš„è«–æ–‡ç™¼è¡¨æœŸé–“ï¼Œå¤§æœƒ
å¦å¤–å®‰æ’äº†å››å ´é‚€è«‹æ¼”è¬› (invited talks) éƒ½å¾ˆç²¾å½©ã€‚
åœ¨å£é ­è«–æ–‡ç™¼è¡¨ä»¥åŠé‚€è«‹æ¼”è¬›çš„ç©ºæª”ï¼Œä¸å°‘å­¸è€…ã€å­¸ç”Ÿä¾†è§€çœ‹æˆ‘çš„ poster
ä¸¦é€²è¡Œè¨è«–ï¼Œé —æœ‰æ”¶ç©«ã€‚æœƒè­°æœŸé–“ï¼Œèªè­˜ä¸€ä½æ­£åœ¨ Kingâ€™s College London è¨ªå•
çš„æ—¥æœ¬ Kysuhu university çš„åŠ©ç†æ•™æˆ å°é‡ å»£éš† (Hirotaka Ono)ï¼Œä»–ç ”ç©¶çš„
é ˜åŸŸèˆ‡æˆ‘å¾ˆç›¸è¿‘ï¼Œç ”ç©¶æˆæœå¾ˆå¥½ï¼Œæˆ‘å£é ­é‚€è«‹ä»–è¨ªå•æˆ‘å€‘å­¸æ ¡ã€‚å¦å¤–èªè­˜ä¸€ä½
ç”±æ³°åœ‹ä»¥åŠä¸€ä½ç”±è¶Šå—èµ´æ—¥ç•™å­¸çš„å…©ä½æ—¥æœ¬å­¸ç”Ÿï¼Œç¶“éèˆ‡ä»–å€‘äº¤è«‡ï¼Œç™¼è¦ºæ—¥æœ¬
æ•™è‚²ç•Œä»¥çå­¸é‡‘å¸å¼•ä¸å°‘æ±å—äºçš„å­¸å­èµ´æ—¥ç•™å­¸ã€‚
é–‹å®Œæœƒçš„éš”å¤©ï¼Œå³æ­æ©Ÿè¿”åœ‹ã€‚
äºŒã€èˆ‡æœƒå¿ƒå¾—
æ„Ÿè¬åœ‹ç§‘æœƒä»¥åŠå­¸æ ¡çš„ç¶“è²»è´ŠåŠ©ï¼Œè®“æˆ‘å¯ä»¥åƒåŠ é€™æ¬¡å­¸è¡“æœƒè­°ã€‚é€™æ˜¯å€‹èˆ‡
æˆ‘çš„ç ”ç©¶é ˜åŸŸç›¸ç•¶å¥‘åˆçš„å­¸è¡“æœƒè­°ï¼Œé™¤äº†ç™¼è¡¨è«–æ–‡å¢åŠ èƒ½è¦‹åº¦å¤–ï¼Œé€éèˆ‡èˆ‡æœƒ
è€…çš„äº¤æµè®“æˆ‘æ›´äº†è§£é€™å€‹é ˜åŸŸçš„ç™¼å±•ç¾æ³ï¼Œä¹Ÿç²å¾—ä¸€äº›ç ”ç©¶çš„æ–°æ–¹å‘ï¼Œå°æˆ‘çš„
ç ”ç©¶å¾ˆæœ‰å¹«åŠ©ã€‚
é™¤äº†å°ˆæ¥­ä¸Šçš„æ”¶ç©«ä¹‹å¤–ï¼Œæˆ‘ä¹Ÿæœ‰ä¸€äº›å°æ–¼æ­ç¾å­¸è¡“ç•Œçš„è§€å¯Ÿã€‚æœ€è¿‘å¹¾å¹´åƒ
åŠ æ­ã€ç¾èˆ‰è¾¦çš„å­¸è¡“æœƒè­°ä¹‹å¾Œï¼Œç™¼è¦ºæ­ç¾å­¸è€…åœ¨ç ”ç©¶ä¸Šäº¤æµéå¸¸å¯†åˆ‡ã€‚ç›¸åŒé ˜
åŸŸçš„å­¸è€…ç¶“å¸¸åˆä½œç™¼è¡¨è«–æ–‡ã€‚èˆ‡åœ‹å…§å¤§å¤šç”±æ•™æˆå¸¶é ˜è‡ªå·±å­¸ç”Ÿåšç ”ç©¶çš„æƒ…å½¢å¤§
ç•°å…¶è¶£ã€‚é€™æ¬¡èˆ‡åƒåŠ æœƒè­°çš„ä¸€ä½æ³•åœ‹å­¸è€…äº¤è«‡ï¼Œæ‰çŸ¥é“ä»–ä¸¦æ²’æœ‰æŒ‡å°ä»»ä½•ç¢©å£«
ç”Ÿæˆ–åšå£«ç”Ÿï¼Œä½†æ˜¯ä»–é‚„æ˜¯æ¯å¹´å¯ä»¥ç™¼è¡¨ä¸€å…©ç¯‡æœŸåˆŠè«–æ–‡ä»¥åŠå…©ä¸‰ç¯‡æœƒè­°è«–æ–‡ï¼Œ
é€™äº›è«–æ–‡æˆæœï¼Œéƒ½æ˜¯é€éèˆ‡åŒäº‹ç”šè‡³è‹±ã€ç¾ã€æ¾³æ´²ã€åŠ æ‹¿å¤§ç­‰åŒè¡Œçš„åˆä½œçš„æˆ
æœã€‚ç ”ç©¶å¾ˆä¸å®¹æ˜“æœ‰æˆæœçš„ï¼Œé€éäº¤æµé›†å¤šæ•¸äººçš„æ™ºæ…§å¯ä»¥äº‹åŠåŠŸå€ï¼Œé€™æ˜¯æˆ‘
å€‘å¿…é ˆå­¸ç¿’çš„ï¼Œä¹Ÿç”±æ–¼å¦‚æ­¤æˆ‘å€‘æ‰æœ‰å¯èƒ½åœ‹éš›åŒ–ï¼Œæ‰èƒ½æå‡æˆ‘å€‘çš„ç«¶çˆ­åŠ›ã€‚åœ‹
å…§å­¸è€…é›–å¤šï¼Œä½†æ˜¯ç›¸è¼ƒæ–¼å…¨ä¸–ç•Œçš„å­¸è€…ä»å±¬å°‘æ•¸ã€‚ç”±æ–¼ç ”ç©¶é ˜åŸŸåˆ†å·¥ç²¾ç´°ï¼Œåœ¨
åœ‹å…§ä¸å®¹æ˜“æ‰¾åˆ°ç›¸åŒé ˜åŸŸçš„å­¸è€…ä¸€èµ·åˆä½œï¼Œé€™æ™‚å€™æƒŸæœ‰é€éåœ‹éš›äº¤æµï¼Œæ‰æ¯”è¼ƒ
æœ‰æ©Ÿæœƒæ‰¾åˆ°å¿—åŒé“åˆçš„ç ”ç©¶å¤¥ä¼´ä¸€èµ·åˆä½œã€‚å‡å¦‚æˆ‘å€‘ä¸ç©æ¥µé€²è¡Œåœ‹éš›äº¤æµï¼Œæˆ‘
å€‘çš„å­¸è¡“ç ”ç©¶æˆæœå¾ˆé›£åœ¨åœ‹éš›ä¸Šå±•éœ²é ­è§’ã€‚æ­ç¾å­¸è¡“ç•Œæ‡‰è©²å·²ç¶“çœ‹å‡ºé€™é»ï¼Œå› 
æ­¤ä»–å€‘å­¸è¡“äº¤æµç¶“è²»éå¸¸å……è£•ã€‚æ ¹æ“šæˆ‘å€‘ç•™è‹±çš„å­¸ç”Ÿçš„èªªæ³•ï¼Œä»–çš„æŒ‡å°æ•™æˆä¸€
å¹´å‡ºåœ‹é–‹å­¸è¡“æœƒè­°é€²è¡Œäº¤æµçš„æ—…è²»é ç®—å¹¾ä¹æ²’æœ‰ä¸Šé™ï¼Œä»Šå¹´ä»–ä¹Ÿå·²ç¶“éš¨è‘—æŒ‡å°
æ•™æˆå‡ºåœ‹é–‹å­¸è¡“æœƒè­°å…©ã€ä¸‰æ¬¡ä»¥ä¸Šï¼Œä»–çš„æŒ‡å°æ•™æˆä¸€å¹´å‡ºåœ‹é–‹æœƒä¸ƒã€å…«æ¬¡ä»¥ä¸Šã€‚
å¦å¤–æˆ‘ä¹Ÿç™¼è¦ºæ­ç¾å­¸è¡“ç•Œç†±ä¸­èˆ‰è¾¦å­¸è¡“æœƒè­°ã€‚èˆ‰è¾¦å­¸è¡“æœƒè­°è‹¥å¯ä»¥å¸å¼•å…¨ä¸–ç•Œ
ç„¡è¡ç”Ÿç ”ç™¼æˆæœæ¨å»£è³‡æ–™
å…¶ä»–æˆæœ 
(ç„¡æ³•ä»¥ï¥¾åŒ–è¡¨é”ä¹‹æˆ
æœå¦‚è¾¦ï§¤å­¸è¡“æ´»å‹•ã€ç²
å¾—çé …ã€é‡è¦åœ‹éš›åˆ
ä½œã€ç ”ç©¶æˆæœåœ‹éš›å½±éŸ¿
ï¦ŠåŠå…¶ä»–å”åŠ©ç”¢æ¥­æŠ€
è¡“ç™¼å±•ä¹‹å…·é«”æ•ˆï¨—äº‹
é …ç­‰ï¼Œè«‹ä»¥æ–‡å­—æ•˜è¿°å¡«
ï¦œã€‚) 
ç„¡ 
 æˆæœé …ç›® ï¥¾åŒ– åç¨±æˆ–å…§å®¹æ€§è³ªç°¡è¿° 
æ¸¬é©—å·¥å…·(å«è³ªæ€§èˆ‡ï¥¾æ€§) 0  
èª²ç¨‹/æ¨¡çµ„ 0  
é›»è…¦åŠç¶²ï¤·ç³»çµ±æˆ–å·¥å…· 0  
æ•™æ 0  
èˆ‰è¾¦ä¹‹æ´»å‹•/ç«¶è³½ 0  
ç ”è¨æœƒ/å·¥ä½œåŠ 0  
é›»å­å ±ã€ç¶²ç«™ 0  
ç§‘ 
æ•™ 
è™• 
è¨ˆ 
ç•« 
åŠ  
å¡« 
é … 
ç›® è¨ˆç•«æˆæœæ¨å»£ä¹‹ï¥«èˆ‡ï¼ˆé–±è½ï¼‰äººï¥© 0  
