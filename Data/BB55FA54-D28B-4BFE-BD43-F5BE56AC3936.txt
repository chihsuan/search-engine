II
ä¸­æ–‡æ‘˜è¦
é»å°é»ç³»çµ±æ˜¯ä¸€ç¨®åˆ†æ•£å¼ç³»çµ±ï¼Œå…¶ä¸­æ¯å€‹ä½¿ç”¨è€…ä¾¿æ˜¯ä¸€å€‹ç¯€é»ï¼Œå½¼æ­¤çš†èƒ½åˆ†äº«è³‡
æºã€‚çµ¦å®šå€‹ç¯„åœï¼Œä¸€å€‹ç¯„åœæŸ¥è©¢å°‡æœƒæ‰¾ä»»ä½•å€¼åœ¨æ­¤ç¯„åœå…§çš„è³‡æ–™ã€‚ç„¶è€Œï¼Œä¸€æ—¦å€
é–“è³‡æ–™é€éé›œæ¹Šå‡½æ•¸è€Œåˆ†ä½ˆåœ¨é€™å€‹é»å°é»ç³»çµ±ä¸Šæ™‚ï¼Œå€é–“è³‡æ–™æœ¬æœ‰çš„é€£çºŒç‰¹æ€§ä¸¦
ä¸ä¿è­‰æœƒå­˜åœ¨ã€‚å› æ­¤ï¼Œæ‰¾æ•£å¸ƒåœ¨å„å€åŸŸçš„å€é–“è³‡æ–™æ˜¯ç›¸ç•¶è€—æˆæœ¬çš„ã€‚åˆ†æ•£å€æ®µæ¨¹
(Distributed Segment Treeï¼Œç°¡ç¨± DST)è—‰ç”±å€æ®µæ¨¹çš„çµæ§‹ä¿ç•™äº†æ¯å€‹ç¯€é»ä¸Šå€
é–“è³‡æ–™çš„å€åŸŸé€£çºŒæ€§ã€‚æ­¤æ–¹æ³•é‹ç”¨äº†åˆ†æ•£é›œæ¹Šè¡¨çš„é‚è¼¯ã€‚ç„¶è€Œï¼ŒDST æœƒæœ‰è³‡æ–™é‡
ç–Šã€é€å‡ºå¤šé¤˜æŸ¥è©¢è¨Šæ¯ã€ç©ºé–“å€åŸŸæ€§çš„å–ªå¤±å’Œè² è¼‰ä¸å¹³è¡¡ç­‰å•é¡Œã€‚å› æ­¤ï¼Œåœ¨é€™å€‹
è¨ˆåŠƒçš„ç¬¬ä¸‰å¹´ï¼Œæˆ‘å€‘æå‡ºäº†çµæ§‹å€æ®µæ¨¹(Structured Segment Treeï¼Œç°¡ç¨± SST)
çš„æ–¹æ³•ã€‚SST ä¸å†é‹ç”¨åˆ†æ•£é›œæ¹Šè¡¨ï¼Œç³»çµ±æ‰€æ§‹æˆçš„æ‹“æ¨¸å³æ˜¯å€æ®µæ¨¹çš„çµæ§‹ï¼Œå®ƒèƒ½
å……ä»½åæ˜ å‡ºå€æ®µæ¨¹çš„ç‰¹æ€§ã€‚æ¯å€‹ç¯€é»ä¾¿æ˜¯å€æ®µæ¨¹ä¸Šçš„ç¯€é»ã€‚æ­¤å¤–ï¼Œæˆ‘å€‘é‚„åŠ å…¥äº†
sibling link ä¾†ä¿ç•™ç©ºé–“å€åŸŸæ€§(spatial locality)å’Œå¢é€²æœå°‹æ•ˆç‡ã€‚é—œæ–¼è³‡
æ–™è² è¼‰çš„è­°é¡Œï¼ŒSST è¡¨ç¾å¾—æ¯” DST ä¾†å¾—æ›´ç‚ºå¹³è¡¡ã€‚åœ¨æˆ‘å€‘çš„æ¨¡æ“¬å¯¦é©—ä¸­ï¼Œé¡¯ç¤ºå‡º
äº† SST æ¯” DST èµ°è¨ªè¼ƒå°‘çš„ç¯€é»æ•¸ç›®ï¼Œä¾¿èƒ½æœå°‹åˆ°è³‡æ–™ã€‚æ¨¡æ“¬å¯¦é©—ä¹Ÿé¡¯ç¤ºå‡ºè³‡æ–™è² 
è¼‰åœ¨ SST ä¸­ä¾†å¾—æ¯” DST æ›´åŠ å¹³è¡¡ã€‚
(é—œéµè©ï¼šåˆ†æ•£é›œæ¹Šè¡¨ï¼Œè² è¼‰å¹³è¡¡ï¼Œé»å°é»ï¼Œç¯„åœæœå°‹ï¼Œå€æ®µæ¨¹)
1å‰è¨€
åœ¨å‚³çµ±çš„ä¸»å¾å¼æ¶æ§‹ä¸­ï¼Œè³‡æ–™é›†ä¸­å­˜æ”¾æ–¼ä¼ºæœå™¨ä¸­ï¼Œä½¿ç”¨è€… (å®¢æˆ¶ç«¯) ç™»å…¥
ä¼ºæœå™¨å»ä½¿ç”¨é€™äº›è³‡æ–™ã€‚é€™ç¨®ä¸»å¾å¼æ¶æ§‹æ™®éå­˜åœ¨æ–¼ç¾ä»Šçš„ç¶²éš›ç¶²è·¯å’Œå…¶ä»–ç¶²è·¯
ä¸­ã€‚ç„¶è€Œï¼Œåœ¨é€™ç¨®æ¶æ§‹ä¸‹ï¼Œä¼ºæœå™¨éœ€è¦ç®¡ç†å¦‚æ­¤å¤§è¦æ¨¡çš„è³‡æ–™ï¼Œæ‰€ä»¥æ•ˆç‡å’Œæ•ˆèƒ½
å°±è¢«é™åˆ¶ä½äº†ã€‚åœ¨ä¸»å¾å¼ç¶²è·¯ä¸­ï¼Œæ‰€æœ‰çš„è³‡æ–™éƒ½è¢«æ”¾åœ¨ä¼ºæœå™¨ä¸­ã€‚æ‰€æœ‰ä½¿ç”¨è€…çš„
å­˜å–å‹•ä½œéƒ½é›†ä¸­åœ¨ä¼ºæœå™¨ä¸Šé‹ä½œï¼Œæ‰€æœ‰çš„ä¼ºæœå™¨ã€ç¶²è·¯å’Œè³‡æ–™åº«å¿…é ˆå…·æœ‰é«˜é€Ÿåº¦
ä»¥åŠé«˜å®¹é‡ã€‚å› æ­¤ï¼Œç•¶é€™å€‹ç¶²è·¯çš„è¦æ¨¡è®Šå¾—è¶Šå¤§ï¼Œæ•ˆèƒ½å°±æœƒè®Šå¾—æ›´å·®ã€‚é€™æ¨£ä¹Ÿæœƒ
å¢åŠ ä¸»å¾å¼ç³»çµ±çš„è² æ“”ï¼Œä¸”æœå‹™çš„å›æ‡‰æ™‚é–“è®Šé•·ã€‚
P2P (Peer-to-Peer, é»å°é») ç³»çµ±æä¾›äº†å¾ˆå¤šåŸºæ–¼å®ƒç¶²è·¯æ¶æ§‹çš„å„ªå‹¢ï¼ŒåŒ…æ‹¬é¡¯
è‘—çš„åœ°é™ä½è³‡æ–™åº«çš„èŠ±è²»ï¼Œå’Œå…¶ä»–ä¼ºæœå™¨ç›¸é—œçš„èŠ±è²»ã€‚åœ¨é»å°é»ç³»çµ±ç¶²è·¯ä¸­ï¼Œå€‹
åˆ¥çš„ä½¿ç”¨è€…é›»è…¦ (ç¯€é») è‡ªå·±å„²å­˜è³‡æ–™ã€‚å› æ­¤ï¼Œä¼ºæœå™¨åªéœ€è¦ç®¡ç†ç´¢å¼•ï¼Œä»¥ç”¨ä¾†
å¿«é€ŸæŸ¥è©¢å„²å­˜æ–¼é€™äº›ç¯€é»çš„ç‰©ä»¶ã€‚ä¹Ÿå°±æ˜¯èªªï¼Œä¼ºæœå™¨ä¸éœ€è¦è‡ªå·±å„²å­˜ç®¡ç†é€™äº›å¤§
é‡çš„è³‡æ–™ã€‚è³‡æ–™åœ¨å„å€‹ç¯€é»é–“å‚³é€ï¼Œå–ä»£ç”±ä¼ºæœå™¨å‚³é€çš„æ–¹å¼ã€‚åªè¦æœ‰ä¸€å€‹å¾ˆå°
çš„ç´¢å¼•ä¼ºæœå™¨ï¼Œå¤§é‡ P2P è³‡æ–™å°±èƒ½äº’ç›¸å‚³é€æ–¼ç¶²è·¯ä¹‹ä¸­ã€‚é»å°é»ç³»çµ±æ˜¯ä¸€ç¨®åˆ†æ•£
å¼ç³»çµ±ï¼Œå…¶ä¸­çš„åƒèˆ‡è€…æ‰®æ¼”ç›¸ä¼¼çš„è§’è‰²[7]ã€‚åœ¨é»å°é»ç³»çµ±ä¸­ï¼Œæ¯å€‹ä½¿ç”¨è€…ä¾¿æ˜¯ä¸€
å€‹ç¯€é»ï¼Œå½¼æ­¤çš†èƒ½åˆ†äº«è³‡æº[4]ã€‚æ¯å€‹ç¯€é»æœƒå‹•æ…‹åœ°é€²å‡ºé€™å€‹é»å°é»ç³»çµ±ï¼Œç³»çµ±ä¸­
çš„è³‡æ–™ä¹Ÿè·Ÿéš¨åœ°å¢æ¸›è€Œæœ‰æ‰€è®ŠåŒ–[1]ã€‚
Chord æ˜¯ä¸€ç¨®åŸºæ–¼ç’°ç‹€çµæ§‹çš„çµæ§‹åŒ– P2P ç³»çµ±ï¼Œå®ƒèƒ½æœ‰æ•ˆç‡çš„æ‰¾åˆ°å­˜è‘—æŸå€‹
è³‡æºçš„ç¯€é»ã€‚ç„¶è€Œï¼ŒChord ç³»çµ±æ˜¯åˆ©ç”¨éœæ…‹é›œæ¹Šå‡½æ•¸é…ç½®è³‡æ–™ï¼Œå¯èƒ½é€ æˆå¤§éƒ¨åˆ†
è³‡æ–™å°æ‡‰åˆ°ç›¸åŒçš„é…ç½®è™•è€Œç”¢ç”Ÿå¤§é‡çš„ç¢°æ’å•é¡Œï¼Œå°è‡´ç³»çµ±ä¸Šç¯€é»çš„è² è¼‰ä¸å¹³
è¡¡ã€‚æ‰€ä»¥ï¼Œåœ¨é€™å€‹è¨ˆåŠƒä¸­çš„ç¬¬ä¸€å¹´ï¼Œæˆ‘å€‘æå‡ºäº†ä¸€å€‹ä»¥ Chord ç³»çµ±ç‚ºåŸºæœ¬æ¶æ§‹ï¼Œ
åˆ©ç”¨å‹•æ…‹é›œæ¹Šä¾†é”æˆè³‡æ–™çš„é…ç½®ï¼Œä½¿å¾—ç¯€é»å’Œç¯€é»é–“çš„è² è¼‰ç¶­æŒå¹³è¡¡ç‹€æ…‹ã€‚å†å‰‡ï¼Œ
åœ¨ P2P ç³»çµ±ä¸­ï¼Œç©ºé–“è³‡æ–™ç™¼ç”Ÿåœ¨è¨±å¤šé‡è¦ä¸”ä¸åŒçš„æ‡‰ç”¨ä¸Šï¼Œä¾‹å¦‚: åœŸåœ°ç™¼å±•è¨ˆç•«ã€‚
å› æ­¤ï¼Œå¦‚ä½•å¿«é€Ÿæœ‰æ•ˆç‡åœ°å–å¾—ç©ºé–“è³‡æ–™æ‰€åœ¨çš„ä½ç½®å°±é¡¯å¾—æ ¼å¤–é‡è¦ã€‚é›–ç„¶ï¼Œ
P2PR-tree å·²ç¶“è¢«æå‡ºï¼Œä½†æ˜¯ï¼Œå®ƒå»ç„¡æ³•è§£æ±ºç©ºé–“è³‡æ–™å½¼æ­¤é–“ overlap çš„å•é¡Œã€‚è¿‘
å¹´ä¾†ï¼Œå°æ–¼ç©ºé–“è³‡æ–™çš„å­˜å–ï¼ŒNA-treeï¼Œå·²ç¶“è¢«æå‡ºã€‚å®ƒæ²’æœ‰ R-tree ä¸­ overlap çš„
å•é¡Œã€‚Chord æ˜¯ä¸€å€‹é›œæ¹Šçš„æ–¹æ³•ï¼Œå®ƒèƒ½å¤ å®¹æ˜“åœ°è™•ç†è³‡æ–™å¢æ¸›æ™‚åªåšå€åŸŸæ€§çš„æ›´
æ”¹ã€‚ç„¶è€Œï¼Œç›®å‰çš„ Chord ç³»çµ±ç„¡æ³•æœ‰æ•ˆç‡åœ°è™•ç†å€åŸŸè³‡æ–™ï¼Œå› ç‚ºï¼Œå®ƒåªè™•ç†å–®ä¸€
key å€¼ã€‚å› æ­¤ï¼Œåœ¨é€™å€‹è¨ˆåŠƒä¸­çš„ç¬¬äºŒå¹´ï¼Œæˆ‘å€‘æå‡ºåœ¨ Chord ç³»çµ±ä¸­ï¼Œä½¿ç”¨åœ¨é›œæ¹Š
å‡½æ•¸ä¸Šï¼Œé‡å°è³‡æ–™ key å€¼çš„éƒ¨ä»½ï¼Œåˆ©ç”¨ NA-tree å°ç©ºé–“å€åŸŸè³‡æ–™åšç·¨ç¢¼çš„æ–¹å¼åš
è³‡æ–™çš„æœå°‹ã€‚
å¦ä¸€æ–¹é¢ï¼Œä½¿ç”¨è€…å¯èƒ½æœƒæƒ³æœå°‹æŸå€æ®µç¯„åœçš„è³‡æ–™ï¼Œå¦‚â€œæœå°‹æŸæ­Œæ‰‹ 1995
å¹´è‡³ 2006 å¹´æ‰€ç™¼è¡Œçš„å°ˆè¼¯â€ã€‚ä¸€æ®µç¯„åœçš„è³‡æ–™ï¼Œæ˜¯å±¬æ–¼é€£çºŒæ€§çš„è³‡æ–™ã€‚ç„¶è€Œï¼Œç¶“
ç”± DHT(Distributed Hash Table)ä¾†åˆ†æ´¾è³‡æ–™ï¼Œæœƒç ´å£é€™å€‹ç‰¹æ€§ã€‚æ‰€ä»¥ï¼Œåœ¨é€™å€‹è¨ˆåŠƒ
ä¸­çš„ç¬¬ä¸‰å¹´ï¼Œæˆ‘å€‘è¨­è¨ˆåœ¨ P2P ç³»çµ±ä¸Šæ”¯æ´ç¯„åœæœå°‹ï¼Œä¸”èƒ½ä¿æŒè² è¼‰å¹³è¡¡çš„æ¼”ç®—æ³•ã€‚
æˆ‘å€‘å¿…é ˆé¢å°çš„å›°é›£æ˜¯ï¼Œå¦‚ä½•åœ¨ P2P ç³»çµ±ä¸­ï¼Œç›¡é‡ç¶­æŒç¯„åœè³‡æ–™ä¹‹é€£çºŒæ€§ä¸è¢«ç ´
å£ã€‚
3åœ– ä¸€ã€Structured Segment Tree æ¶æ§‹åœ–
åœ– äºŒã€sibling link çš„é€£çµæ–¹å¼
åœ¨æ¨¡æ“¬æ¸¬è©¦ä¸­ï¼Œæˆ‘å€‘æ¯”è¼ƒåˆ†æ•£å€æ®µæ¨¹æ–¹æ³•(DST)å’Œçµæ§‹å€æ®µæ¨¹æ–¹æ³•(SST)åœ¨é€²
è¡Œç²¾ç¢ºæœå°‹ã€ç¯„åœæœå°‹é‚„æœ‰è³‡æ–™è² è¼‰ä¸‰æ–¹é¢çš„è¡¨ç¾ã€‚æœå°‹æˆæœ¬å®šç¾©ç‚ºæœå°‹æ™‚æ‰€éœ€
ç¶“éçš„ç¯€é»æ¬¡æ•¸[5]ï¼Œç³»çµ±æ‰€èƒ½æ”¯æ´çš„è³‡æ–™ç¯„åœå¤§å°è¨­å®šç‚º 210ã€‚åœ¨æ¯”è¼ƒç²¾ç¢ºæœå°‹
æˆæœ¬æ™‚ï¼Œå°‡ç³»çµ±çš„ç¯€é»æ•¸å¾ 21 - 1 å¢åŠ åˆ° 210 â€“ 1ï¼Œä¸¦è®“æ¯å€‹ç¯€é»å°‹æ‰¾ç³»çµ±æ‰€èƒ½
æ”¯æ´çš„è³‡æ–™ç¯„åœå…§çš„å„å€‹è³‡æ–™å€¼ã€‚ç„¶å¾Œå†æ¯”è¼ƒå…¶å¹³å‡çš„æœå°‹æˆæœ¬ã€‚å¦‚åœ–ä¸‰æ‰€ç¤ºï¼Œ
éš¨è‘—ç¯€é»æ•¸çš„å¢åŠ ï¼Œæœå°‹æˆæœ¬ä¹Ÿè·Ÿè‘—å¢åŠ ï¼Œä½† SST ç¸½èƒ½æ¯” DST ä»¥è¼ƒå°‘çš„æˆæœ¬æ‰¾åˆ°
æ‰€è¦çš„è³‡æ–™ã€‚
åœ¨æ¯”è¼ƒç¯„åœæœå°‹æˆæœ¬æ™‚ï¼Œè¨­å®šç³»çµ±ä¸­ç¯€é»æ•¸ç‚º 25 â€“ 1ï¼Œä¸¦è®“æ¯å€‹ç¯€é»å°‹æ‰¾
5åœ– å››ã€é€²è¡Œç¯„åœæœå°‹æ™‚çš„æˆæœ¬æ¯”è¼ƒåœ–
åœ– äº”ã€è³‡æ–™åˆ†å¸ƒçš„æ¯”è¼ƒåœ–ã€‚
åœ– å…­ã€ç•¶é–€æª»å€¼ç‚º 1500 æ™‚çš„è³‡æ–™åˆ†å¸ƒæ¯”è¼ƒåœ–
åƒè€ƒæ–‡ç»
[1] K. Aberer and M. Hauswirth, â€An Overview on Peer-to-Peer Information
System,â€Workshop on Distributed Data and Structures (WDAS), pp. 171-188,
2002.
7æˆæœå ±å‘Šè‡ªè©•
è«‹ä¾å­¸è¡“æˆå°±ã€æŠ€è¡“å‰µæ–°ã€ç¤¾æœƒå½±éŸ¿ç­‰æ–¹é¢ï¼Œè©•ä¼°ç ”ç©¶æˆæœä¹‹å­¸è¡“æˆ–æ‡‰ç”¨åƒ¹å€¼ï¼ˆç°¡
è¦æ•˜è¿°æˆæœæ‰€ä»£è¡¨ä¹‹æ„ç¾©ã€åƒ¹å€¼ã€å½±éŸ¿æˆ–é€²ä¸€æ­¥ç™¼å±•ä¹‹å¯èƒ½æ€§ï¼‰ï¼ˆä»¥ 500 å­—ç‚ºé™ï¼‰
åœ¨é›†ä¸­å¼ç³»çµ±ç’°å¢ƒä¸‹ï¼Œå®Œå…¨ç¬¦åˆæœå°‹èˆ‡ç¯„åœæœå°‹ç‚ºå‚³çµ±æŸ¥è©¢æœ€å¸¸ç”¨ä¸”é‡è¦çš„æŠ€
è¡“ï¼Œä¾‹å¦‚ï¼šæ‰¾å‡ºæŸå€‹å“¡å·¥çš„æ¥­ç¸¾å°±æ˜¯å®Œå…¨ç¬¦åˆæœå°‹ï¼Œæ‰¾å‡ºæ¥­ç¸¾ä»‹æ–¼ 1,000,000
è‡³ 2,000,000 å…ƒçš„å“¡å·¥ç¯„åœæŸ¥è©¢ã€‚å¦é»å°é» (Peer-to-Peer, P2P) è³‡è¨Šç³»çµ±å‰‡
æ˜¯æ–°èˆˆçš„ç¶²è·¯æ‡‰ç”¨æ¨¡å¼ï¼Œå„ç¶²è·¯ç¯€é»èƒ½åŒæ™‚æ‰®æ¼”ç”¨æˆ¶ç«¯ã€ä¼ºæœç«¯æˆ–ä¸­ç¹¼è€…ç­‰å¤šé‡
è§’è‰²ï¼Œå› æ­¤æ¯”å‚³çµ±çš„æ‡‰ç”¨æ¨¡å¼æ›´å…·å¤šæ¨£æ€§ï¼Œå› æ­¤åœ¨é»å°é»è³‡è¨Šç³»çµ±ä¸­ä¹Ÿå­˜åœ¨å®Œå…¨
ç¬¦åˆæœå°‹èˆ‡ç¯„åœæœå°‹çš„éœ€æ±‚ã€‚ç„¶è€Œï¼Œé»å°é»ç³»çµ±(å¦‚ Chord)é€éé›œæ¹Šå‡½æ•¸ä¾†æ´¾é€
è³‡æ–™ï¼Œä¸€æ—¦å€é–“è³‡æ–™é€éé›œæ¹Šå‡½æ•¸è€Œåˆ†ä½ˆåœ¨é€™å€‹é»å°é»ç³»çµ±ä¸Šæ™‚ï¼Œå€é–“è³‡æ–™æœ¬æœ‰
çš„é€£çºŒç‰¹æ€§ä¸¦ä¸ä¿è­‰æœƒå­˜åœ¨ã€‚å› æ­¤ï¼Œæ‰¾åˆ†æ•£åœ¨å„å€åŸŸçš„å€é–“è³‡æ–™æ˜¯ç›¸ç•¶è€—æˆæœ¬
çš„ï¼Œè‹¥èƒ½ä¿ç•™äº†æ¯å€‹ç¯€é»ä¸Šå€é–“è³‡æ–™çš„å€åŸŸé€£çºŒæ€§å°‡æœƒç¸®çŸ­ç¯„åœæœå°‹çš„æ™‚é–“ã€‚åœ¨
æˆ‘å€‘çš„ç ”ç©¶æˆæœä¸­ï¼Œåˆ©ç”¨çµæ§‹å€æ®µæ¨¹(Structured Segment Treeï¼Œç°¡ç¨± SST)çš„
æ–¹æ³•ï¼Œæ¯å€‹ç¯€é»ä¾¿æ˜¯å€æ®µæ¨¹ä¸Šçš„ç¯€é»ï¼Œå› æ­¤æ¯å€‹ç¯€é»ä¿ç•™å€é–“è³‡æ–™çš„å€é–“çºŒæ€§ã€‚
å¦æˆ‘å€‘é‚„åŠ å…¥äº† sibling link ä¾†ä¿ç•™ç©ºé–“å€åŸŸæ€§(spatial locality)å’Œå¢é€²æœ
å°‹æ•ˆç‡ã€‚å› æ­¤ï¼Œæˆ‘å€‘çš„ç ”ç©¶èƒ½å¢é€²é»å°é»ç³»çµ±çš„ç›¸é—œæ‡‰ç”¨æœ‰é—œå®Œå…¨ç¬¦åˆæœå°‹èˆ‡ç¯„
åœæœå°‹çš„åŠŸèƒ½ï¼Œé€²è€Œæé«˜æ•´é«”ç³»çµ±çš„æ•ˆç‡ã€‚
[0,7]
[0,3]
[0,1]
[4,7]
[2,3] [4,5] [6,7]
[1,1] [2,2] [3,3] [4,4] [5,5] [6,6] [7,7][0,0]
Figure 1. Distributed segment tree of length 8
II. RELATED WORK
The Distributed Segment Tree (DST) method [6] is one
of these famous methods for range queries. It preserves the
local continuity of range data by using a segment tree and
provides a method, Range Splitting Algorithm, to break any
given data range into the minimum number of node intervals
whose union constitutes that range. It works based on the
Distributed Hash Table (DHT) logic; therefore, it can be
applied in any DHT-based P2P system. Based on the above
properties, the DST method extends the DHT-based P2P
systems so that these systems can support to answer range
queries. Moreover, the DST method designs a Downward
Load Stripping Mechanism for load balance.
The segment tree representing the range of length L has a
height H = log L+1. Fig. 1 shows an example of the DST
of length 8. Each node on the DST represents a node interval
[sl,k, tl,k], where l âˆˆ [0, logL] and k âˆˆ [0, 2lâˆ’1]. Its length
is ll,k = tl,kâˆ’sl,k +1. Each non-leaf node has two children.
The left child and the right child represent the intervals
[sl,k, b
sl,k+tl,k
2 c] and [b
sl,k+tl,k
2 c+1, tl,k], respectively. The
union of the two children covers the same interval as the
parent does. For neighboring nodes on the same layer, we
have sl,k âˆˆ (tl,kâˆ’1 +1) for any k âˆˆ [1, 2lâˆ’1]. This property
ensures the continuity of the segment tree. All the nodes
from the same layer span the whole segment tree range, i.e.,
for any l âˆˆ [0, log L]. This property ensures the integrity of
the segment tree.
In the DST, the segment tree structure is distributed onto
the distributed hash table (DHT): The node interval [s, t] is
assigned to the DHT node (i.e., a peer) associated with the
key Hash([s, t]) using the underlying DHT logic.
For example, if users want to search range [2,6], they
will send a range query for [2,6]. The range query will be
processed by the range splitting algorithm, which means to
construct the union of minimum node intervals that expand
the range. As a result of the process, the users get nodes
labeled [2,3] , [4,5], [6,6], whose union covers the range
[2,6]. Next, these node intervals will be hashed. Moreover,
users nally learn about the peers which they should send
requests for.
However, the DST method still has some disadvantages.
Figure 2. Range search in the Chord system
Since it works based on the DHT logic, the data interval of
a node may be different from the underlying hash function.
If the hash function performs poorly, it will result in many
cases of overlapping data intervals and cause load unbalance
among peers. In addition, the search cost depends on the
applied DHT-based P2P systems.
For example, assuming that the DST method is applied
in the Chord system [9], which is one of well-known DHT-
based P2P systems, as shown in Fig. 2. In this example, due
to the unsuitable hash function, the data intervals of each
peer are overlapped. The problem of overlapping will lead
to inefcient nding of data locations and we will discuss
the problem in detail later. In Fig. 2, peer 1 searches for
data range [2,6]. Then, the requested data range [2,6] will be
broken into data intervals [2,3], [4,5] and [6,6] based on the
Range Splitting Algorithm. Next, these data intervals will be
taken as inputs of a given hash function. Each data interval
processed by the hash function will get a key, which means
the location of the peer which covers that data interval. In
this example, data intervals [2,3], [4,5] and [6,6] get keys
6, 0 and 0, respectively. Up to this point, the requesting
peer knows the locations of the requested data and sends 3
independent requests to peer 6 (1 time) and peer 0 (2 times).
In this example, we can see that the DST method will
convert one range query into several exact queries. Because
the applied DHT-based P2P systems mainly search for keys
independently, rather than the original data range, the conti-
nuity and locality of the data range do not exist after data is
distributed. The more number of data intervals a requested
data range is divided into, the more number of exact queries
will be executed independently in the underlying DHT-
based P2P systems. How the requests route for nding the
requested data keys is dependent on the applied DHT-based
P2P systems.
III. STRUCTURED SEGMENT TREE
Based on the proposed method for range queries in P2P
systems, this section rst presents the details of our data
structure. Next, it presents the related information stored at
a peer.
92
P1
P2 P3
P4 P5
P8 P9 P10 P11
P6 P7
P12 P13 P14 P15
Level 0
Level 1
Level 2
Level 3
: forward sibling links
: backward sibling links
Figure 5. Sibling links
P1
P2 P3
P4 P5
P8 P9 P10 P11
P6 P7
P12 P13 P14 P15
Level 0
Level 1
Level 2
Level 3
: ascendant links
Figure 6. Ascendant links
Similar to the function of the sibling links, the ascendant
links also can improve the search efciency. The sibling
links can forward a request quickly among peers at the
same level, while the ascendant links can forward a request
quickly among different levels. A peer at level h has at most
h ascendant links. They connect to the ascendant peers. For
example, in Fig. 6, peer P10 at level 3 has 3 ascendant links
connecting to peers P5, P2 and P1.
IV. PEER MANAGEMENT
In this section, we describe how to manage the peers so
that they can maintain the structure of an SST. The peer
management handles the joining and leaving of peers. It
ensures that the current peers can maintain the structure of an
SST at any time. Before describing the joining and leaving
of peers, we describe how to nd the maximum position
identier, which is needed to maintain the structure of an
SST.
A. Find the Maximum Position Identier
In order to maintain the structure of an SST, the peers
need to know the Maximum Position Identier, MaxPID,
when they join and leave the P2P system. MaxPID has
the greatest value among the PIDs in the current system.
If a peer with PID equal to MaxPID, it means that the
peer is the last peer joining the system. MaxPID is at the
last level of an SST.
When a peer wants to know the MaxPID, it will rst
check whether it is a leaf peer or not. A non-leaf peer will
check the number of the children it has. If two children
exists, a Finding message will be forwarded to the right
child. Otherwise, a Finding message will be forwarded to
the left child. The Finding message will be continually
forwarded until it reaches a leaf peer. When an SST is a
complete binary tree, a leaf peer may be at the last level or
the last second level. Because MaxPID is at the last level,
a leaf peer needs to check whether it is at the last level
or not. It asks the neighbor peers whether they have any
children. If any one of these neighbor peers has children,
the neighbor peer will respond to the leaf peer. The leaf
peer forwards the Finding message to the neighbor peer
with the greatest value of PID among them. The neighbor
peer again forwards the Finding message to its children.
As a result, the Finding message arrives the last level.
When a peer at the last level receives the Finding mes-
sage, the peer will again forward the Finding message to its
neighbor peers with the greatest value of PID through the
sibling links. The process will be repeated until the Finding
message reaches a peer without any forward sibling link.
Such a peer is the last one joining the system, and it owns
MaxPID. As a result, MaxPID is found.
When a peer joins the system, it will take the position
next to the peer with MaxPID. When a peer leaves the
system, the peer with MaxPID will take the position of
the leaving peer. Therefore, no matter peer joining or peer
leaving, the structure of an SST is a complete binary tree.
An SST is maintained at any time.
B. Joining of Peers
When a peer, Pin, wants to join the system, it needs to
know one existing peer, Pknown, in the current system. Peer
Pin sends a Joining request to peer Pknown. After peer
Pknown receives the Joining request, it will nd MaxPID.
A joining peer will take the position next to the peer with
MaxPID. The subsequent PID after MaxPID equals
(MaxPID + 1). This may be the PID of peer Pin. The
peer, Ptarget, with PID=bMaxPID+12 c may be the parent
of peer Pin. Peer Pin should connect to peer Ptarget. These
computations are performed by peer Pknown. Peer Pknown
forwards the Joining request to peer Ptarget. Peer Ptarget
will decide whether it should accept the request of peer Pin.
If there is no any other Joining request in the waiting
queue, it will accept and respond to peer Pin. Otherwise,
peer Ptarget will nd another target peer and complete the
task similar to what peer Pknown has done. After peer Pin
connects to peer Ptarget, peer Pin will get its own PID and
the half data interval of peer Ptarget.
For example, as shown in Fig. 7-(a), peer Pin wants to
join the system. It knows that peer P2 is an existing peer
and sends a Joining request to peer P2. After receiving the
Joining request, as shown in Fig. 7-(b), peer P2 will nd
out that the MaxPID is 5, which is owned by peer P5.
Then, in Fig. 7-(c), peer P2 calculates and knows that (5
94
P1
P2 P3
P4 P5 P6 P7
P1
P2 P3
P4 P5 P6 P7
(a) (b)
Figure 9. Data Insertion: (a) standard; (b) threshold.
continues until the data key arrives peer Ptarget. Peer Ptarget
is the peer at the same level whose data interval covers data
key k. Then, peer Ptarget forwards data key k to its ancestors
and descendants. As a result, data key k is stored at the peers
whose data interval covers it.
In addition, to prevent from load unbalance, each non-leaf
peer can choose to store the data key or not. A non-leaf peer
can set a threshold to limit the load. However, the leaf peers
have no choice, because they have the minimum size of the
data interval. That is, the leaf peers have the lightest loads
among all the peers. With this mechanism, in Fig. 9-(b), P1
chooses not to store the data key.
B. Data Deletion
The process of deleting data from an SST is quite similar
to that of the data insertion. That is, the data key is removed
from all the peers whose data interval covers it. When a
peer wants to delete a data key k, it checks its neighbor
peers through the sibling links. Then, it forwards a Deleting
message to the neighbor peer whose data interval covers or
most close to that data key k. The process will be repeated
until the Deleting message is arrived at the peer whose data
interval covers the data key k at the same level. Finally, the
peer forwards the Deleting message to all its ancestors and
all its descendants. The peers which receive the Deleting
message will delete the data key k.
VI. DATA LOOKUP
To look up a requested data key is an important issue in
P2P systems. We will describe how an SST handles exact
queries and range queries.
A. Exact Query
According to the properties of an SST, a data key is stored
at all the peers whose data interval covers it. These peers
contain a leaf peer and all its ancestors. Therefore, the data
key can be found at every level. In the previous section, we
have learned the relationship between a PID and a data
interval. Given a data key k, we can nd the peers whose
data interval covers it. For example, given data key 6 and
level 2, the size of the whole data range [0, 7] is 8, and the
load size at level 2 is 2 (= 8/22). Data key 6 is stored at the 4
(= b6/2c+1) th peer at level 2. Its PID is 22 + 4âˆ’ 1(= 7).
As a result, we know that peer P7 at level 2 covers data key
6.
Figure 10. An example of data lookup
Since each peer of an SST has its own sibling links, the
requested data key will be rst located through these links.
That is, the search process starts at the same level. When a
user at level h wants to nd data key k, it rst locates a peer
at the same level h through the sibling links. For example,
in Fig. 10, peer P4, at level 2, wants to look up data key
6. It nds out that at the same level, peer P7 has the data
key. Then, peer P4 checks whether peer P7 is a neighbor
peer. It checks the sibling links and knows peer P7 is not
a neighbor peer. The neighbor peers of peer P4 through the
forward sibling links are peer P5 and peer P6. Since peer P6
is closer to peer P7 than peer P5 is, peer P4 will forward the
exact query to peer P6. The exact query is executed again at
Peer P6. Since peer P7 is a neighbor peer of peer P6, peer
P6 will forward the exact query to peer P7. If peer P7 has
the data key, it will return the data key to peer P4.
A leaf node may have no sibling link to forward an exact
query. If such a leaf node receives an exact query, it will
pass the exact query to its parent or any of its ancestors. For
example, in Fig. 10, the leaf peer P10 wants to look up the
same data key 6. It nds out that at the same level, peer P15
has the data key. But peer P10 has no forward sibling links.
Actually, peer P10 is the peer with MaxPID and peer P15
does not exist. So peer P10 learns that peer Pb15/2c should
be the target peer and then peer P10 forwards the exact query
to its parent peer P5. Then, the search process of peer P5
is similar to that of peer P4. Finally, peer P10 will nd out
that peer P7 has the requested data key.
Although peer Ptarget is the target peer whose data
interval covers the requested data key, it may not have the
requested data key. In this case, peer Ptarget will forward
the exact query to its descendants until the requested data
key is found or a leaf node is reached.
B. Range Query
Given an exact query for a data key, a peer whose data
interval covers it is returned. While a range query for a data
interval [A, B] is given, peers are returned. The PID values
of these returned peers are successive. If we denote the peer
whose data interval covers data key A as peer Pbegin and
the peer whose data interval covers data key B as peer Pend,
the returned peers will range from peer Pbegin to peer Pend.
When a peer asks for a data interval [A, B], we will rst
nd peer Pbegin and peer Pend by executing exact query. If
96
0.0
5.0
10.0
15.0
20.0
25.0
1 2 3 4 5 6 7 8 9 10
The range span (QR = 2x)
Se
ar
ch
 c
os
t
DST
SST
(a)
0.0
5.0
10.0
15.0
20.0
25.0
30.0
1 2 3 4 5 6 7 8 9 10
The range span (QR = 2x)
Se
ar
ch
 c
os
t
DST
SST
(b)
0.0
5.0
10.0
15.0
20.0
25.0
1 2 3 4 5 6 7 8 9
The range span (QR = 2x)
Se
ar
ch
 c
os
t DSTSST
(c)
Figure 11. A comparison of the range search: (a) with RS = 1024 and
N = 31; (b) with RS = 1024 and N = 63; (c) with RS = 512 and N =
63.
expected. Even so, the average number of data stored at a
peer of DST is greater than that of SST in this experiment.
Fig. 12-(b) shows the standard deviation. In this gure, we
see the value of standard deviation of SST is less than that
of DST. It means that the load of SST is more balanced than
that of DST.
In Fig. 13-(a), the condition of this experiment is the same,
except that we set the value of parameter Î³ to 1500. In
this case, the average number of data stored at a peer of
SST is greater than that of DST. When the total number
of the generated data reaches 30000, 40000, and 50000,
the average number of data of SST reaches its threshold.
Comparing with Fig. 12-(a), we can see the average number
of data stored at a peer falls down greatly. This is because the
0
2000
4000
6000
8000
10000
10000 20000 30000 40000 50000
The number of  generated data
Th
e 
av
er
ag
e 
nu
m
be
r o
f
da
ta
 a
t a
 p
ee
r
DST
SST
(a)
0
2000
4000
6000
8000
10000
12000
14000
10000 20000 30000 40000 50000
The number of  generated data
St
an
da
rd
  d
ev
ia
tio
n
DST
SST
(b)
Figure 12. A comparison of the load balance: (a) the average number of
data at a peer; (b) standard deviation.
threshold can efciently cut down the load size and shorten
the difference. Fig. 13-(b) shows the standard deviation. In
this gure, we see the value of the standard deviation of
SST is still less than that of DST. After the total number
of the generated data reaches 30000, all the peers of SST
have the number of data equal to the threshold. So the
value of standard deviation becomes zero. By comparing the
performance shown in Fig. 13-(b) with that shown in Fig.
12-(b), the standard deviation decreases. This is because the
main difference mainly comes from the different levels. The
peers at the low level usually have much more data than
those at the high levels. The threshold can limit the load
size and makes the difference small.
VIII. CONCLUSION
In this paper, we proposed a Structured Segment Tree to
handle range queries in P2P systems. It does not use the
DHT logic, but embeds the structure of the segment tree
into the P2P system. The topology of a Structured Segment
Tree is actually the structure of a segment tree. It can fully
reect the properties of the original segment tree. Each peer
in a Structured Segment Tree represents a node of a segment
tree. Node intervals at the same level are continuous and will
not overlap. The union of node intervals at a level with full
nodes is the whole range which the P2P system can support.
When searching a data range, the Structured Segment Tree
method sends as many number of requests as needed. In
addition, we add sibling links to preserve the locality and
98
 1 
åƒåŠ  WCE 2011 å¿ƒå¾—å ±å‘Š 
å³æŒ¯å½° 
 
ä¸€ ã€ åƒ åŠ  æœƒ è­° ç¶“ é  
ç”±åœ‹éš›å·¥ç¨‹å¸«å”æœƒ(the International Association of Engineers, IAENG)ä¸»è¾¦çš„ 2011 
ä¸–ç•Œå·¥ç¨‹æœƒè­°(World Congress on Engineering 2011)ï¼Œæ–¼ 2011 ï¦ 7 æœˆ 5 æ—¥è‡³ 8 æ—¥
åœ¨è‹±åœ‹å€«æ•¦çš„å€«æ•¦çš‡å®¶å­¸é™¢é›£è‚¯è¾›é “æ ¡å€(the South Kensington campus, Imperial 
College London)èˆ‰ï¨ˆã€‚æœ¬æ¬¡æœƒè­°æŠ•ç¨¿è«–æ–‡ç¯‡ï¥©é” 1328 ç¯‡ï¼Œç¶“ç¯©é¸å¾Œå…±ç™¼è¡¨ç´„ 756 
ç¯‡è«–æ–‡ï¼Œæ¥å—ç‡ç‚º 56.93%ã€‚æœ¬æ¬¡æœƒè­°æ˜¯ç”± 15 å€‹ä¸åŒçš„ï¦´åŸŸçš„ç ”è¨æœƒæ‰€åˆè¾¦è€Œæˆï¼Œ
å…¶å„ç ”è¨æœƒçš„åç¨±å¦‚ä¸‹ï¼š 
 
ICAEM'11 The 2011 International Conference of Applied and Engineering Mathematics 
ICCIIS'11 The 2011 International Conference of Computational Intelligence and Intelligent Systems 
ICCSDE'11 The 2011 International Conference of Computational Statistics and Data Engineering 
ICCSE'11 The 2011 International Conference of Computer Science and Engineering 
ICDMKE'11 The 2011 International Conference of Data Mining and Knowledge Engineering(åƒèˆ‡ç™¼è¡¨) 
ICEEE'11 The 2011 International Conference of Electrical and Electronics Engineering 
ICFE'11 The 2011 International Conference of Financial Engineering 
ICIE'11 The 2011 International Conference of Information Engineering 
ICISIE'11 The 2011 International Conference of Information Security and Internet Engineering 
ICME'11 The 2011 International Conference of Mechanical Engineering 
ICMEEM'11 The 2011 International Conference of Manufacturing Engineering and Engineering Management 
ICPDC'11 The 2011 International Conference of Parallel and Distributed Computing 
ICSBB'11 The 2011 International Conference of Systems Biology and Bioengineering 
ICSIE'11 The 2011 International Conference of Signal and Image Engineering 
ICWN'11 The 2011 International Conference of Wireless Networks 
 
 3 
 
ä¸‰ ã€ å»º è­°  
ç„¡ 
å›› ã€ æ”œ å› è³‡ æ–™ å ç¨± åŠ å…§ å®¹  
1. æœƒè­°è«–æ–‡é›†ä¹™ä»½ 
2. è«–æ–‡é›†å…‰ç¢Ÿç‰‡ä¹™å¼µ 
äº” ã€ å…¶ ä»–  
ç„¡ 
 
TABLE I
A SAMPLE OF THE ACCESS HISTORY
Access Time Object ID Music Group Transaction
2001/4/06 AM 11:47:03 1 B T1
2001/4/06 AM 11:47:03 23 C T1
2001/4/12 AM 10:11:25 7 D T2
2001/4/12 AM 10:11:25 5 C T2
2001/4/12 AM 10:11:25 32 B T2
2001/4/16 AM 09:51:33 16 A T3
2001/4/16 AM 09:51:33 19 B T3
2001/4/16 AM 09:51:33 42 A T3
2001/4/20 AM 08:31:12 31 D T4
2001/4/20 AM 08:31:12 63 C T4
2001/4/20 AM 08:31:12 26 A T4
2001/4/22 AM 10:24:49 53 B T5
2001/4/22 AM 10:24:49 12 A T5
TABLE II
NUMBER OF MUSIC OBJECTS TO THE RECOMMENDED IN EACH GROUP
Music Group Number of Recommended Music Objects
A 8
B 6
C 4
D 4
and B. We find group A appearing many times in the early
transactions. On the other hand, group B appears one time
in the latest transaction. But the group weight of group B is
larger than the group weight of group A in the CB method,
the result is not conventional. Observing the result of the CB
method, we can find when the music group B appears once
in the later transaction, it will have larger group weight than
the group weight of the music group A which appears many
times in the earlier transaction. This result may be not good
for some users, because the purpose of the CB method is to
recommend the music object which the users are interested.
When the count of music group is large in the userâ€™s access
history, it means that this user is interested in this group, too.
Therefore, in this paper, we propose the TICI (Transaction-
Interest-Count-Interest) method to improve the performance
of the CB method. In our TICI method, for the same access
history shown in Table III, we can decide the rank of the
music group weight between groups A and B. And we put
two parameters: Count-Interest
 
and Transaction-Interest


in our TICI method to let user choose which weight they
want to emphasize. From the simulation results, we show
that our TICI method could provide better performance than
the CB method in terms of the weight differences. That is,
our TICI method can decide the rank of the group weight
precisely.
The rest of the paper is organized as follows. Section
2 gives a survey of some music recommendation systems.
Section 3 presents the proposed TICI method. Section 4
TABLE III
A SAMPLE OF THE ACCESS HISTORY H1
Transaction Music Group
T1 AA
T2 AC
T3 DEF
T4 GHI
T5 JK
T6 B
TABLE IV
A SAMPLE OF THE ACCESS HISTORY
Access Time Object ID Music Group Transaction
2001/4/06 AM 11:47:03 1 B T1
2001/4/06 AM 11:47:03 23 C T1
2001/4/12 AM 10:11:25 7 D T2
2001/4/12 AM 10:11:25 5 C T2
2001/4/12 AM 10:11:25 32 B T2
2001/4/16 AM 09:51:33 16 A T3
2001/4/16 AM 09:51:33 19 B T3
2001/4/16 AM 09:51:33 42 A T3
2001/4/20 AM 08:31:12 31 D T4
2001/4/20 AM 08:31:12 63 C T4
2001/4/20 AM 08:31:12 26 A T4
2001/4/22 AM 10:24:49 53 B T5
2001/4/22 AM 10:24:49 12 A T5
makes a comparison between our TICI method and CB
method. Finally, Section 5 gives the conclusions.
II. RELATED WORK
The music objects in the database of the Music Recom-
mendation System (MRS), as well as the incoming music
objects, are candidates for music recommendation. When a
new music object is inserted in the database of the MRS,
it goes through the track selector and the feature extractor.
According to the extracted features, the incoming music
object is properly assigned to certain music group by the
classifier function block. When the user accesses a music
object from the list of music objects or the recommendation
results, the profile manager will record the object information
into the access history. An example of the access history is
shown in Table IV. As shown in Table IV, the information of
each accessed music object, i.e., the access time, the object
ID, the corresponding music group which the object belongs
to, and the corresponding transaction is recorded in the
access history. Note that the transaction ID is monotonically
increasing.
Arbee L.P. Chen et al. have proposed the CB method
to recommend the music objects that belong to the music
groups the user is recently interested in [4]. Instead of textual
descriptions, they consider the perceptual properties of music
objects, such as pitch, duration, and loudness, which can
be directly extracted from the music objects. For users,
the preferences are derived from the access histories and
recorded in profiles.
To capture the recent interests of the user, they analyze
the latest transactions in the access history as follows. Each
transaction is assigned a different weight, where the latest
transaction has the highest weight. The weight  of music
group 	 is computed as follows:








 (1)
where


 is the weight of transaction

 ,  is the number
of latest transactions used for analysis, ï¬ï¬€ï¬‚  is the number
of music objects which belong to music group ï¬ƒ in trans-
action

 . These weights will be recorded in a preference
table for the user. The MRS ranks all the music groups.
To avoid recommending a large number of music objects
to users, the MRS limits the number of music objects for
Proceedings of the World Congress on Engineering 2011 Vol III 
WCE 2011, July 6 - 8, 2011, London, U.K.
ISBN: 978-988-19251-5-2 
ISSN: 2078-0958 (Print); ISSN: 2078-0966 (Online)
WCE 2011
TABLE IX
PARAMETERS USED IN THE EXPERIMENT
Parameters Meaning
N The number of transactions in the access history
M The number of music groups
MinT The minimum length of the transaction
MaxT The maximum length of the transaction
TABLE X
THE ACCESS HISTORY OF USER U1
Transaction Music Group
T1 A,B,C,D,E
T2 A,C,E
T3 A,B,C,D,E
T4 C,E,K
T5 A,D,E,M
where Count-Interest
 
( ï¬€NM
 
M
I
) and Transaction-
Interest


( ï¬€OM


M
I
) are assigned by users,


= 1 -
 
. According to each userâ€™s preferences, our formula adds
two parameters
 
and


to let users decide the importance
of the time and count.
IV. PERFORMANCE
In this section, we study the performance of the proposed
TICI. We also make a comparison with the CB method. The
simulation was performed on an Intel Pentium Core2 1.86G
Hz CPU computer with 1GB of RAM, and the operation
system is Microsoft Windows XP service pack 3.
A. Generation of Synthetic Data
We generated synthetic access histories to evaluate the
performance of the methods. The parameters used in the
generation of the synthetic data are shown in Table IX. The
length of a transaction is chosen randomly between MinT
and MaxT. For the TICI method, the MinT and MaxT is
2 and 5, respectively. In the comparison between the CB
method and the TICI method, the music group will appear
one time in a transaction or appear more than one time
in a transaction. Therefore, for the music group appears
more than one time in a transaction, we choose the music
group in the set of music group randomly. For the music
group appears one time in a transaction, we use the flag to
record the appearance of the music group so that the music
group will not appear again in a transaction. This way can
achieve the goal that the music group appears one time in a
transaction. For generating synthetic data, we assign an occur
rate Orate, and we generate a random real number which
is between 0 and 1. If the random number is larger than
Orate, the generation runs normally. If the random number
is smaller than or equal to Orate, we let the music group
which never appears in the earlier transactions appear in the
last transaction. The larger Orate is, the larger repeatability
of the music group is. We call this synthetic data DataType1.
B. Simulation Results of Synthetic Data
In this subsection, we make a comparison of our TICI
method with the CB method by using the synthetic data
DataType1. We study the impact of five parameters on Table
TABLE XI
THE ACCESS HISTORY OF USER U2
Transaction Music Group
T1 A,B,C,D,E
T2 B,C,E
T3 A,B,C,D,E
T4 C,E,K
T5 B,D,E,M
0
10
20
30
40
50
60
70
80
1000 2000 3000 4000 5000
Transaction size
W
e
ig
ht
 d
if
fe
re
nc
e
TICI CI=0.7
TICI CI=0.5
TICI CI=0.3
CB
Fig. 1. A comparison of the group weight difference under the case that
the music group appears more than one time in a transaction
0
10
20
30
40
50
60
70
80
1000 2000 3000 4000 5000
Transaction size
W
e
ig
ht
 d
if
fe
re
nc
e
TICI CI=0.7
TICI CI=0.5
TICI CI=0.3
CB
Fig. 2. A comparison of the group weight difference under the case that
the music group only appears one time in a transaction
IX. We let M be 50 because the numbers of music groups
are not more than 50 in the current environment and we let
MinT = 2 and MaxT = 5. Moreover, we make the comparison
between the TICI method and the CB method under the two
cases. One case is that the music group can appear more than
one time in a transaction, another case is that the music group
can only appear one time in a transaction. A comparison of
the music group weight difference in the TICI method and
CB method is shown in Figure 1 and Figure 2.
Note that our TICI method has three cases: CI = 0.3,
CI = 0.5 and CI = 0.7 to compare the change of the
result that emphasizes weight of transaction and the weight
of count. We use the group weight difference to be our
performance measure. The group weight difference is the
difference between the group weights of the group weight
rank which are decided by the methods and we add all group
weight differences to be the results of comparison between
our TICI method and the CB method. When the group weight
difference is larger, it means that the method can decide the
rank of the group weight clearly.
Proceedings of the World Congress on Engineering 2011 Vol III 
WCE 2011, July 6 - 8, 2011, London, U.K.
ISBN: 978-988-19251-5-2 
ISSN: 2078-0958 (Print); ISSN: 2078-0966 (Online)
WCE 2011
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•«è¡ç”Ÿç ”ç™¼æˆæœæ¨å»£è³‡æ–™è¡¨
æ—¥æœŸ:2011/08/01
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•«
è¨ˆç•«åç¨±: é»å°é»è³‡è¨Šç³»çµ±ä¸­è² è¼‰å¹³è¡¡ï¼Œå®Œå…¨ç¬¦åˆæœå°‹èˆ‡ç¯„åœæœå°‹æŠ€è¡“ä¹‹è¨­è¨ˆèˆ‡åˆ†æ
è¨ˆç•«ä¸»æŒäºº: å¼µç‰ç›ˆ
è¨ˆç•«ç·¨è™Ÿ: 97-2221-E-110-058-MY3 å­¸é–€é ˜åŸŸ: è³‡æ–™åº«ç³»çµ±åŠè³‡æ–™å·¥ç¨‹
ç„¡ç ”ç™¼æˆæœæ¨å»£è³‡æ–™
åœ‹å¤– ï¥æ–‡è‘—ä½œ æœŸåˆŠï¥æ–‡ 3 0 100% ç¯‡ 
Ye-In Chang, 
Chen-Chang Wu, and 
Ching-I Wang, 
2009, ï¼‡ ï¼‡ Spatial 
Exact Match Query 
Based on the NA-tree 
Approach in P2P 
Systems,ï¼‡ï¼‡ Proc. of 
the 22th Int. Conf. on 
Industrial, 
Engineering &amp ï¼›
Other Applications of 
Applied Intelligent 
Systems, pp. 1-10. 
(Lecture Notes in 
Artificial 
Intelligence: 
Next-Generation 
Applied Intelligence 
(EI), Vol. 5579, pp. 
409-418, 2009.)  
  
Ye-In Chang, 
Chen-Chang Wu, and 
Ching-I Wang, 2010, 
Oct. ï¼‡ï¼‡Spatial Exact 
Match Query in P2P 
Systems Using an 
NA-tree Structureï¼‡ï¼‡ 
Journal of Internet 
Technology (SCI), Vol. 
11, No. 5, pp. 711-720.
 
Ye-In Chang, Lee-Wen 
Huang, and Hung-Ze 
Liu, 
2009, ï¼‡ï¼‡AKDB--tree: 
An Adjustable KDB-tree 
for Efficiently 
Supporting Nearest 
Neighbor Queries in 
P2P Systems,ï¼‡ï¼‡ Proc. 
of the 22th Int. Conf. 
on Industrial, 
Engineering &amp ï¼›
Other Applications of 
Applied Intelligent 
Systems, pp. 101-106. 
(Studies in 
Computational 
Intelligence: 
Opportunities and 
Ch ll f
å…¶ä»–æˆæœ 
(ç„¡æ³•ä»¥ï¥¾åŒ–è¡¨é”ä¹‹
æˆæœå¦‚è¾¦ï§¤å­¸è¡“æ´»
å‹•ã€ç²å¾—çé …ã€é‡è¦
åœ‹éš›åˆä½œã€ç ”ç©¶æˆæœ
åœ‹éš›å½±éŸ¿ï¦ŠåŠå…¶ä»–
å”åŠ©ç”¢æ¥­æŠ€è¡“ç™¼å±•
ä¹‹ å…· é«” æ•ˆ ï¨— äº‹ é …
ç­‰ï¼Œè«‹ä»¥æ–‡å­—æ•˜è¿°å¡«
ï¦œã€‚) 
Ye-In Chang and Hue-Ling Chen, Sih-Ning Li and Hung-Ze Liu, 2008, ï¼‡ï¼‡A 
Dynamic Hashing Approach to Supporting Load Balance in P2P Systemsï¼‡ï¼‡, 
Proc. of the second IEEE International Workshop on Cooperative Distributed 
Systems, pp.1-6. 
 
Ye-In Chang, Lee-Wen Huang, and Hung-Ze Liu, 2009, ï¼‡ï¼‡AKDB--tree: An 
Adjustable KDB-tree for Efficiently Supporting Nearest Neighbor Queries 
in P2P Systems, ï¼‡ ï¼‡ Proc. of the 22th Int. Conf. on Industrial, 
Engineering &ampï¼› Other Applications of Applied Intelligent Systems, pp. 
101-106. (Studies in Computational Intelligence: Opportunities and 
Challenges for Next-Generation Applied Intelligence , Vol. 214, 
pp.133-138, 2009.)  
 
  
Ye-In Chang, Chen-Chang Wu, Jun-Hong Shen, and Tzu-Lun Huang, 
2010, ï¼‡ï¼‡Range Queries Based on a Structured Segment Tree in P2P 
Systems,ï¼‡ï¼‡ Proc. of the 17th IEEE International Conference on 
Engineering of Computer-Based Systems, pp. 91-99.  
  
Ye-In Chang, Chen-Chang Wu, and Ching-I Wang, 2009, ï¼‡ï¼‡Spatial Exact 
Match Query Based on the NA-tree Approach in P2P Systems,ï¼‡ï¼‡ Proc. of 
the 22th Int. Conf. on Industrial, Engineering &ampï¼› Other Applications 
of Applied Intelligent Systems, pp. 1-10. (Lecture Notes in Artificial 
Intelligence: Next-Generation Applied Intelligence (EI), Vol. 5579, pp. 
409-418, 2009.)  
  
Ye-In Chang, Chen-Chang Wu, and Ching-I Wang, 2010, Oct. ï¼‡ï¼‡Spatial Exact 
Match Query in P2P Systems Using an NA-tree Structureï¼‡ï¼‡ Journal of 
Internet Technology (SCI), Vol. 11, No. 5, pp. 711-720. 
 æˆæœé …ç›® ï¥¾åŒ– åç¨±æˆ–å…§å®¹æ€§è³ªç°¡è¿° 
æ¸¬é©—å·¥å…·(å«è³ªæ€§èˆ‡ï¥¾æ€§) 0  
èª²ç¨‹/æ¨¡çµ„ 0  
é›»è…¦åŠç¶²ï¤·ç³»çµ±æˆ–å·¥å…· 0  
æ•™æ 0  
èˆ‰è¾¦ä¹‹æ´»å‹•/ç«¶è³½ 0  
ç ”è¨æœƒ/å·¥ä½œåŠ 0  
é›»å­å ±ã€ç¶²ç«™ 0  
ç§‘ 
æ•™ 
è™• 
è¨ˆ 
ç•« 
åŠ  
å¡« 
é … 
ç›® è¨ˆç•«æˆæœæ¨å»£ä¹‹ï¥«èˆ‡ï¼ˆé–±è½ï¼‰äººï¥© 0  
