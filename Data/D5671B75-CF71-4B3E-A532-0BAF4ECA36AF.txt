 2 
 
ä¸­æ–‡æ‘˜è¦ 
æœ¬ç ”ç©¶è¨ˆç•«ç ”ç©¶å…¬é–‹å¼å»£æ’­åŠ å¯†ç³»çµ±ï¼Œç¾ä»Š
æœ€å¥½çš„å…¬é–‹å¼å»£æ’­åŠ å¯†ç³»çµ±çš„ç§å¯†é‡‘é‘°å¤§
å°ã€å…¬é–‹é‡‘é‘°å’Œå‚³è¼¸é‡èƒ½ç„¡æ³•å’Œç§å¯†å¼çš„å»£
æ’­ç³»çµ±ç›¸æ¯”ï¼Œæˆ‘å€‘è¦ºå¾—å¯ä»¥ä½¿ä¹‹é”åˆ°æ›´ä½³çš„
æ•ˆç‡ï¼šåˆ†åˆ¥ç‚º O(r), O(log n) å’Œ O(1)ï¼ŒåŒ
æ™‚è¨ˆç®—é‡ä¹Ÿå¯æ§åˆ¶åœ¨åˆç†çš„ç¯„åœä¹‹å…§ï¼Œä¸åƒ
BGWçš„æ–¹æ³•éœ€è¦ O(n)ã€‚ 
  ç¬¬ä¸€å¹´åº¦æˆ‘å€‘ç™¼å±•å‡ºå…©å€‹å…¬é–‹å»£æ’­åŠ å¯†
å”å®šï¼Œç¬¬ä¸€å€‹å”å®šå¯ä»¥é”åˆ° O(r)å¯†æ–‡é•·åº¦ï¼Œ
O(log n)ç§å¯†é‡‘é‘°åŠ O(1)å…¬é–‹é‡‘é‘°ï¼Œè¨ˆç®—é‡
éœ€è¦ O(r)ã€‚ç¬¬äºŒå€‹å”å®šå¯ä»¥é”åˆ° O(r)å¯†æ–‡é•·
åº¦ï¼ŒO(log2 n)ç§å¯†é‡‘é‘°åŠ O(1)å…¬é–‹é‡‘é‘°ï¼Œè¨ˆ
ç®—é‡åªéœ€è¦ O(1)ã€‚è«–æ–‡å·²åœ¨ 2008 çš„ PKC æœƒ
è­°ä¸Šç™¼è¡¨ã€‚ç¬¬äºŒå¹´åº¦æˆ‘å€‘å°‡å”å®šä¿®æ”¹ï¼ŒåŠ å¼·
å…¶å®‰å…¨åº¦é”åˆ° IND-CCA2çš„ç­‰ç´šï¼Œç›®å‰æŠ•ç¨¿åˆ°
çŸ¥åçš„æœŸåˆŠï¼Œæ­£åœ¨å¯©ç¨¿ä¸­ã€‚ 
ç¬¬äºŒå¹´åº¦ï¼Œæˆ‘å€‘é‚„é€²è¡Œäº†æœ‰é—œæ„Ÿæ¸¬ç¶²è·¯
é‡‘é‘°å»ºç«‹çš„å•é¡Œï¼Œæˆ‘å€‘æå‡ºä¸€å€‹å’Œç¾æœ‰è«–æ–‡
å®Œå…¨ä¸åŒçš„æ”»æ“Šæ¨¡å‹ï¼Œå†æ“šæ­¤æå‡ºä¸€å€‹å®‰å…¨
çš„é‡‘é‘°å»ºç«‹å”å®šä¸¦æ¢è¨å…¶å®‰å…¨æ€§ï¼Œçµæœç™¼è¡¨
åœ¨ IEEE Trans.Wireless Communications
ä¸Šã€‚ 
ç¬¬ä¸‰å¹´åº¦æˆ‘å€‘å° permutation codeï¼ˆPCï¼‰
åšäº†è©³ç´°çš„ç ”ç©¶ï¼Œæå‡ºè¨±å¤š PCç¢¼çš„æ€§è³ªåŠå¥½
çš„ç·¨è§£ç¢¼æ–¹æ³•ï¼Œçµæœç™¼è¡¨åœ¨ IEEE Trans. 
Information Theoryä¸Šã€‚ 
é—œéµè©ï¼šå»£æ’­åŠ å¯†ã€å…¬é–‹é‡‘é‘°ã€æ’åºç¢¼ã€é‡‘
é‘°å»ºç«‹ã€‚ 
è‹±æ–‡æ‘˜è¦ 
In this project we study the public-key 
broadcast encryption system, in which one can 
broadcast to a set of authorized users. To our 
best knowledge, the best public-key broadcast 
encryption system is not very efficient in the 
size of the header, public key and private key of 
users, compared to the secret-key broadcast 
encryption system. One of the goals of this 
research is to design and analyze efficient 
public-key broadcast encryption schemes. 
In 2008, we we designed two efficient 
public-key broadcast encryption schemes. The 
first scheme achieves O(1) public-key size, O(r) 
header size and O(log n) private keys per user. 
The decryption time is reasonably O(r). Our 
second scheme achieves O(1) public-key size, 
O(r) header size and O(log
2
 n) private keys per 
user. Although the private key size is less 
efficient than the first one, its decryption time 
is remarkably O(1). The paper of these results 
has been published in prestigious PKC 
conference. In 2009, we improve one of our 
designed schemes to achieve the IND-CCA2 
security and give a very strict proof. We have 
submitted the improved result to a prestigious 
journal. 
In 2009, we also spent time on the 
problem of key establishment problem in the 
wireless sensor networks. We explore a very 
novel security model in which the adversary is 
instead storage-bounded, not computing-power 
constraint. By this model, we propose a very 
simple and secure key establishment protocol. 
The protocol does not require the sensors to 
pre-load secret. This result has been accepted 
and published in IEEE Trans. Wireless 
Communications. 
In 2010, we studied the error correcting 
coding problem for permutation codes. We 
found many interesting properties and proposed 
efficient decoding algorithms. The result has 
been accepted by IEEE Trans. Information 
Theory. 
Keywords: Broadcast encryption, public key 
system, permutation code, key establishment. 
ä¸€ã€ è¨ˆç•«ç·£èµ·åŠç›®çš„ 
 4 
ç”±ä¸Šè¿°å…©ç¨®æ–¹æ³•æˆ‘å€‘è§€å¯Ÿå¯å¾—çŸ¥ï¼Œç•¶æ¯
å€‹ä½¿ç”¨è€…é‡‘é‘°å„²å­˜é‡å°‘çš„æ™‚å€™ï¼Œå‚³è¼¸é‡å¤šï¼›
ç•¶å„²å­˜é‡å°‘ä¹‹æ™‚ï¼Œæ‰€éœ€å‚³è¼¸é‡å°±å¤§ï¼Œè€Œå¦‚ä½•
èƒ½æœ‰å€‹å¥½æ–¹æ³•èƒ½åœ¨é€™å…©è€…é–“å–å¾—å¹³è¡¡ï¼Ÿäº¦æˆ–
æ˜¯ä½¿é€™å…©è€…åƒæ•¸çš†å°ï¼Œä¸¦åœ¨è¨ˆç®—é‡ä¸Šæ‰€éœ€æœ€
å°ï¼Œä¾¿æ˜¯æˆ‘å€‘ç ”ç©¶çš„ä¸»è¦èª²é¡Œã€‚ 
äºŒã€ ç ”ç©¶æˆæœ 
ç¬¬ä¸€å¹´åº¦æˆ‘å€‘ç™¼å±•å‡ºå…©å€‹å…¬é–‹å»£æ’­åŠ å¯†
å”å®šï¼Œç¬¬ä¸€å€‹å”å®šå¯ä»¥é”åˆ° O(r)å¯†æ–‡é•·åº¦ï¼Œ
O(log n)ç§å¯†é‡‘é‘°åŠ O(1)å…¬é–‹é‡‘é‘°ï¼Œè¨ˆç®—é‡
éœ€è¦ O(r)ã€‚ç¬¬äºŒå€‹å”å®šå¯ä»¥é”åˆ° O(r)å¯†æ–‡é•·
åº¦ï¼ŒO(log2 n)ç§å¯†é‡‘é‘°åŠ O(1)å…¬é–‹é‡‘é‘°ï¼Œè¨ˆ
ç®—é‡åªéœ€è¦ O(1)ã€‚è«–æ–‡å·²åœ¨ 2008 çš„ PKC æœƒ
è­°ä¸Šç™¼è¡¨ã€‚ç¬¬äºŒå¹´åº¦æˆ‘å€‘å°‡å”å®šä¿®æ”¹ï¼ŒåŠ å¼·
å…¶å®‰å…¨åº¦é”åˆ° IND-CCA2çš„ç­‰ç´šï¼Œç›®å‰æŠ•ç¨¿åˆ°
çŸ¥åçš„æœŸåˆŠï¼Œæ­£åœ¨å¯©ç¨¿ä¸­ã€‚ 
ç¬¬äºŒå¹´åº¦ï¼Œæˆ‘å€‘é€²è¡Œäº†æœ‰é—œæ„Ÿæ¸¬ç¶²è·¯é‡‘
é‘°å»ºç«‹çš„å•é¡Œï¼Œæˆ‘å€‘æå‡ºä¸€å€‹å’Œç¾æœ‰è«–æ–‡å®Œ
å…¨ä¸åŒçš„æ”»æ“Šæ¨¡å‹ï¼Œå†æ“šæ­¤æå‡ºä¸€å€‹å®‰å…¨çš„
é‡‘é‘°å»ºç«‹å”å®šä¸¦æ¢è¨å…¶å®‰å…¨æ€§ã€‚é€™ç¯‡è«–æ–‡ä¸»
è¦æ˜¯æ¢è¨ storage-bounded æ”»æ“Šè€…çš„æ¨¡å¼
ä¸‹ï¼Œå»ºç«‹ç¯€é»é–“é‡‘é‘°çš„æ–¹æ³•ï¼Œæˆ‘å€‘ç™¼ç¾ç¯€é»
é–“ä¸éœ€è¦äº‹å…ˆè¼‰å…¥ç§˜å¯†å€¼å°±å¯å»ºç«‹å®‰å…¨çš„é€š
è¨Šé‡‘é‘°ï¼Œæˆ‘å€‘ä½¿ç”¨äº†æ©Ÿç‡å¼çš„åˆ†ææ–¹æ³•ä¾†è¨
è«–é‡‘é‘°çš„å®‰å…¨è¡Œï¼Œæˆ‘å€‘æ˜¯ç¬¬ä¸€å€‹åœ¨æ„Ÿæ¸¬ç¶²è·¯
ä¸Šä½¿ç”¨é€™å€‹åˆ†ææ–¹æ³•ã€‚çµæœç™¼è¡¨åœ¨ IEEE 
Trans.Wireless Communicationsä¸Šã€‚ 
ç¬¬ä¸‰å¹´åº¦æˆ‘å€‘å° permutation codeï¼ˆPCï¼‰
åšäº†è©³ç´°çš„ç ”ç©¶ï¼Œæå‡ºè¨±å¤š PCç¢¼çš„æ€§è³ªåŠå¥½
çš„ç·¨è§£ç¢¼æ–¹æ³•ï¼Œçµæœç™¼è¡¨åœ¨ IEEE Trans. 
Information Theoryä¸Šã€‚ 
ä¸‰ã€ è¨ˆç•«æˆæœè‡ªè©• 
æœ¬è¨ˆåŠƒæˆ‘å€‘ç™¼è¡¨äº†å››ç¯‡é«˜æ°´æº–çš„æœƒè­°åŠ
æœŸåˆŠè«–æ–‡ï¼Œé‚„æœ‰ä¸€ç¯‡åœ¨å¯©ç¨¿ä¸­ï¼Œä»¥æˆæœä¾†çœ‹ï¼Œ
æˆ‘å€‘é”æˆäº†è¨ˆåŠƒçš„é å®šç›®æ¨™ã€‚ 
 
 
 
 
é™„ä»¶ 
1. Y.-R. Liu, W.-G. Tzeng. Public key 
broadcast encryption with low number of 
keys and constant decryption time.  In 
Proceedings of International Workshop on 
Practice and Theory in Public-Key 
Cryptography (PKC 08), LNCS 4939, 
pp.380-396, 2008.  
2. S.-C. Tsai, W.-G. Tzeng, Kun-Yi Zhou. 
"Key Establishment Schemes Against 
Storage-Bounded Adversaries in Wireless 
Sensor Networks," IEEE Transactions on 
Wireless Communications 8(3), 
pp.1218-1222, 2009. 
3. Yi-Ruei Chen and Wen-Guey Tzeng. A 
Public-Key Traitor Tracing Scheme with an 
Optimal Transmission Rate, In Proceedings 
of the 11th International Conference on 
Information and Communications Security 
(ICICS 09), LNCS 5927, pp.121-134, 2009. 
4. T. KlÃ¸ve, T.-T. Lin, S.-C. Tsai, W.-G. 
Tzeng. "Permutation Arrays Under the 
Chebyshev Distance," IEEE Transactions 
on Information Theory 56(6), pp.2611-2617, 
2010. 
 
Public Key Broadcast Encryption with Low Number of Keys 381
broadcasted messages can be decrypted by authorized users only. Broadcast en-
cryption has many applications, such as pay-TV systems, encrypted ï¬le sharing
systems, digital right management, content protection of recordable data, etc.
A broadcasted message M is sent in the form ã€ˆHdr(S,m), Em(M)ã€‰, where
m is a session key for encrypting M via a symmetric encryption method E. An
authorized user in S can use his private keys to decrypt the session key m from
Hdr(S,m). Since the size of Em(M) is pretty much the same for all broadcast
encryption schemes, we are concerned about the header size. The performance
measures of a broadcast encryption scheme are the header size, the number of
private keys held by each user, the size of public parameters of the system (public
keys), the time for encrypting a message, and the time for decrypting the header
by an authorized user. A broadcast encryption scheme should be able to resist
the collusion attack from revoked users. A scheme is fully collusion-resistant if
even all revoked users collude, they get no information about the broadcasted
message.
Broadcast encryption schemes can be stateless or stateful. For a stateful
broadcast encryption scheme, the private keys of a user can be updated from
time to time, while the private keys of a user in a stateless broadcast encryption
scheme remain the same through the lifetime of the system. Broadcast encryp-
tion schemes can also be public key or secret key. For a public key BE scheme,
any one (broadcaster) can broadcast a message to an arbitrary group of autho-
rized users by using the public parameters of the system, while for a secret key
broadcast encryption scheme, only the special dealer, who knows the system
secrets, can broadcast a message.
In this paper we refer â€stateless public key broadcast encryptionâ€ as â€public
key BEâ€.
1.1 Our Contribution
We propose three public key BE schemes that have eï¬ƒcient complexity measures.
The ï¬rst scheme, called the BE-PI scheme (broadcast encryption with polyno-
mial interpolation), has O(r) header size, O(1) public keys, and O(logN) private
keys per user1, where r is the number of revoked users. This is the ï¬rst public
key BE scheme that has both public and private keys under O(logN) while the
header size is O(r). These complexity measures match those of eï¬ƒcient secret
key BE schemes [11,20,21]. The idea is to run logN copies of the basic scheme
in [17,19,22] in parallel for lifting the restriction on a priori ï¬xed number of
revoked users. Nevertheless, if we implement the logN copies straightforwardly,
we would get a scheme of O(N) public keys. We are able to use the properties
of bilinear maps as well as special private key assignment to eliminate the need
of O(N) public keys and make it a constant number.
Our second scheme, called the PK-SD-PI scheme (public key SD broadcast en-
cryption with polynomial interpolation), is constructed by combining the polyno-
mial interpolation technique and the subset cover method in the SD scheme [16].
1 log is based on 2 if the base is not speciï¬ed.
Public Key Broadcast Encryption with Low Number of Keys 383
polynomial interpolation (in fact, the Reed-Solomon code) to any linear code for
constructing public key BE schemes. The schemes in [7,13,14,17,19,22] all have
O(k) public keys, O(1) private keys, and O(r) header size, r â‰¤ k. However, k is
a-priori ï¬xed during the system setting and the public key size depends on it.
These schemes can withstand the collusion attack of up to k revoked users only.
They are not fully collusion-resistant.
Yoo, et al. [21] observed that the restriction of a pre-ï¬xed k can be lifted by
running logN copies of the basic scheme with diï¬€erent degrees (from 20 to N) of
polynomials. They proposed a scheme of O(logN) private keys and O(r) header
size such that r is not restricted. However, their scheme is secret key and the
system has O(N) secret values. In the public key setting, the public key size is
O(N).
Recently Boneh, et al. [4] proposed a public key BE scheme that has O(1)
header size, O(1) private keys, and O(N) public keys. By trading oï¬€ the header
size and public keys, they gave another scheme with O(
âˆš
N) header size, O(1)
private keys and O(
âˆš
N) public keys. Lee, et al. [15] proposed a better trade-oï¬€
by using receiver identiï¬ers in the scheme. It achieves O(1) public key, O(logN)
private keys, but, O(r logN) header size. Boneh and Waters [5] proposed a
scheme that has the traitor tracing capability. This type of schemes [4,5,15]
has the disadvantage that the public keys are needed by a user in decrypting the
header. Thus, the de-facto private key of a user is the combination of the public
key and his private key.
It is possible to transform a secret key BE scheme into a public key one.
For example, Dodis and Fazio [6] transformed the SD and LSD schemes [12,16]
into public key SD and LSD schemes, shorted as PK-SD and PK-LSD. The
transformation employs the technique of hierarchical identity-based encryption
to substitute for the hash function. Instantiated with the newest constant-size
hierarchical identity-based encryption [2], the PK-SD scheme has O(r) header
size, O(1) public keys and O(log2 N) private keys. The PK-LSD scheme has
O(r/) header size, O(1) public keys and O(log1+ N) private keys, where 0 <
 < 1 is a constant. The decryption costs of the PK-SD and PK-LSD schemes
are both O(logN), which is the time for key derivation incurred by the original
relation of private keys. If we apply the HIBE technique to the secret key BE
schemes of O(logN) or O(1) private keys [1,11,20], we would get their public
key versions with O(N) private keys and O(N) decryption time.
2 Preliminaries
Bilinear map. We use the properties of bilinear maps. Let G and G1 be two
(multiplicative) cyclic groups of prime order q and eË† be a bilinear map from
G Ã— G to G1. Then, eË† has the following properties.
1. For all u, v âˆˆ G and x, y âˆˆ Zq, eË†(ux, vy) = eË†(u, v)xy.
2. Let g be a generator of G, eË†(g, g) = g1 = 1 is a generator of G1.
Public Key Broadcast Encryption with Low Number of Keys 385
In the above the adversary A is static since it chooses the target set Sâˆ— of
users before the system setup. Let Advind-ccaA,Î  (z) be the advantage that A wins
the above game, that is,
Advind-ccaA,Î  (z) = 2 Â· Pr[AO(PK,SKU\Sâˆ— ,m0,m1,Hdr(Sâˆ—,m)) = b :
Sâˆ— âŠ† U , (PK,SKU) â† Setup(1z, Id,U),
Hdr(Sâˆ—,m) â† Encâˆ—(PK,Sâˆ—), b uâ† {0, 1}] âˆ’ 1,
where SKU = {SKi : 1 â‰¤ i â‰¤ N} and SKU\Sâˆ— = {SKi : Ui âˆˆ Sâˆ—}.
Deï¬nition 1. A public key BE scheme Î =(Setup, Enc, Dec) is (t, , qD)-IND-
CCA secure if for all t-time bounded adversary A that makes at most qD decryp-
tion queries, we have Advind-ccaA,Î  (z) < .
In this paper we ï¬rst give schemes with one-way security against chosen plaintext
attacks (OW-CPA security) and then transform them to have IND-CCA security
via the Fujisaki-Okamoto transformation [9]. The OW-CPA security is deï¬ned
as follows.
Init. The adversary A chooses a system identity Id and a target set Sâˆ— âŠ† U
of users to attack.
Setup. The challenger C runs Setup(1z, Id, U) to generate a public key PK
and private key sets SK1, SK2, . . . , SKN . The challenger C gives SKi to A,
where Ui âˆˆ Sâˆ—.
Challenge. The challenger C runs Encâˆ—(PK,Sâˆ—) and outputs Hdr(Sâˆ—, m),
where m is randomly chosen.
Guess. A outputs a guess mâ€² for m.
Since A can always encrypt a chosen plaintext by himself, the oracle of en-
crypting a chosen plaintext does not matter in the deï¬nition. Let Advow-cpaA,Î  (z)
be the advantage that A wins the above game, that is,
Advow-cpaA,Î  (z) = Pr[A(PK,SKU\Sâˆ—,Hdr(Sâˆ—,m)) = m : Sâˆ— âŠ† U ,
(PK,SKU) â† Setup(1z, Id,U),Hdr(Sâˆ—,m) â† Encâˆ—(PK,Sâˆ—)].
Deï¬nition 2. A public key BE scheme Î =(Setup, Enc, Dec) is (t, )-OW-CPA
secure if for all t-time bounded adversary A, we have Advow-cpaA,Î  (z) < .
3 The BE-PI Scheme
Let G and G1 be the bilinear groups with the pairing function eË†, where q is
a large prime. Let H1, H2 : {0, 1}âˆ— â†’ G1 be two hash functions and E be a
symmetric encryption with key space G1.
The idea of our construction is as follows. For a polynomial f(x) of degree
t, we assign each user Ui a share f(i). The secret is f(0). We can compute the
secret f(0) from any t+1 shares. If we want to revoke t users, we broadcast their
Public Key Broadcast Encryption with Low Number of Keys 387
3. Dec(SKk,Hdr(S,m), C): Uk âˆˆ S. The user Uk does the following.
â€“ Compute b0 = eË†(gr, grk,Î±fÎ±(k)) = g
rrk,Î±fÎ±(k)
1 .
â€“ Compute bj = eË†(grk,Î± , grfÎ±(ij)) = g
rrk,Î±fÎ±(ij)
1 , 1 â‰¤ j â‰¤ L.
â€“ Use the Lagrange interpolation method to compute
g
rrk,Î±fÎ±(0)
1 =
Lâˆ
j=0
b
Î»j
j , (1)
where Î»j =
(âˆ’i0)(âˆ’i1)Â·Â·Â·(âˆ’ijâˆ’1)(âˆ’ij+1)Â·Â·Â·(âˆ’iL)
(ijâˆ’i0)(ijâˆ’i1)Â·Â·Â·(ijâˆ’ijâˆ’1)(ijâˆ’ij+1)Â·Â·Â·(ijâˆ’iL) (mod q), i0 = k.
â€“ Compute the session key
meË†(gÏ, hÎ±)r Â· grrk,Î±fÎ±(0)1
eË†(gr, grk,Î±fÎ±(0)hÏÎ±)
=
meË†(gÏ, hÎ±)r Â· grrk,Î±fÎ±(0)1
eË†(gr, hÏÎ±) Â· grrk,Î±fÎ±(0)1
= m. (2)
â€“ Use m to decrypt the ciphertext body C to obtain the message M .
Correctness. We can easily see that the scheme is correct by Equation (2).
3.1 Performance Analysis
For each system, the public key is (Id, H1, H2, E,G,G1, eË†, g, gÏ), which is of
size O(1). Since all systems can use the same (H,E,G,G1, eË†, g), the public key
speciï¬c to a system is simply (Id, gÏ). Each system dealer has a secret Ï for
assigning private keys to its users. Each user Uk holds private keys SKk =
{sk,0, sk,1, . . . , sk,log N}, each corresponding to a share of polynomial fi in the
masked form, 0 â‰¤ i â‰¤ logN . The number of private keys is O(logN). When r
users are revoked, we choose the polynomial fÎ± of degree 2Î± for encrypting the
session key, where 2Î±âˆ’1 < r â‰¤ 2Î±. Thus, the header size is O(2Î±) = O(r). It is
actually no more than 2r.
To prepare a header, the broadcaster needs to compute one pairing function,
2Î±+2 hash functions, and 2Î±+2 modular exponentiations, which is O(r) modular
exponentiations.
For a user in S to decrypt a header, with a little re-arrangement of Equation
(1) as
Lâˆ
j=0
b
Î»j
j = b
Î»0
0 Â· eË†(grk,Î± ,
Lâˆ
j=1
(grfÎ±(ij))Î»j ),
the user needs to perform 3 pairing functions and 2Î± modular exponentiations,
which is O(r) modular exponentiations. The evaluation of Î»j â€™s can be done in
O(L) = O(2r) if the header consists of
Î»Ëœj =
(âˆ’i1) Â· Â· Â· (âˆ’ijâˆ’1)(âˆ’ij+1) Â· Â· Â· (âˆ’iL)
(ij âˆ’ i1) Â· Â· Â· (ij âˆ’ ijâˆ’1)(ij âˆ’ ij+1) Â· Â· Â· (ij âˆ’ iL) mod q, 1 â‰¤ j â‰¤ L.
The user can easily compute Î»j â€™s from Î»Ëœj â€™s. Inclusion of Î»Ëœj â€™s in the header does
not aï¬€ect the order of the header size.
Public Key Broadcast Encryption with Low Number of Keys 389
If the query has ever been asked, we return the stored hash value for the query.
For other non-queried inputs, we return random values in G.
We should check whether the distributions of the parameters in our reduction
and those in the system are equal. We only check those related to Î± since the
others are correctly distributed. Since Ï„, w1, w2, . . . , wL are randomly chosen,
ga
(Î±)
i , 0 â‰¤ i â‰¤ L are uniformly distributed over GL+1. Due to the random oracle
model, their corresponding system parameters are also uniformly distributed
over GL+1. Since Îº, Î¼1, Î¼2, . . . , Î¼L are randomly chosen, the distribution of hÎ±
and gri,Î± , 1 â‰¤ i â‰¤ L, are uniform over GL+1, which is again the same as that
of the corresponding system parameters. The distributions of gr in the header
and gÏ in the public key are both uniform over G since they are set from the
given input gc and ga, respectively. Since the session key m is chosen randomly
from G1, meË†(gÏ, hÎ±)r is distributed uniformly over G1. We set it to a random
value y âˆˆ G1. Even though we donâ€™t know about m, it does not aï¬€ect the
reduction. Other parameters are dependent on what have been discussed. We
can check that they are all computed correctly. So, the reduction preserves the
right distribution.
If the revoked users compute m from the header with probability , we can
solve the BDH problem with the same probability 1 =  by computing the
following:
y Â· mâˆ’1 Â· eË†(ga, gc)âˆ’Îº = eË†(gÏ, hÎ±)r Â· eË†(g, g)âˆ’acÎº
= eË†(ga, gb+Îº)c Â· eË†(g, g)âˆ’acÎº
= eË†(g, g)abc. (3)
Let tâ€² be the time for this reduction and the solution computation in Equation
(3). We can see that tâ€² is polynomially bounded. Thus, if the collusion attack of the
revoked users takes t1 âˆ’ tâ€² time, we can solve the BDH problem within time t1.
4 The BE-PI Scheme with IND-CCA Security
In Theorem 1, we show that the session key in the header is one-way secure
against any collusion of revoked users. There are some standard techniques of
transforming OW-CPA security to IND-CCA security. Here we present such a
scheme Î  â€² based on the technique in [9].
The IND-CCA security of the Fujisaki-Okamoto transformation depends only
on the OW-CPA security of the public key encryption scheme, the FG security
of a symmetric encryption scheme E , and the Î³-uniformity of the public key
encryption scheme. The FG-security is the counterpart of the IND-security for
symmetric encryption. A public key encryption scheme is Î³-uniform if for every
key pair (pk, sk), every message x, and y âˆˆ {0, 1}âˆ—, Pr[Epk(x) = y] â‰¤ Î³. Before
applying the transformation, we check the following things:
1. The transformation applies to public key encryption, while ours is public key
broadcast encryption. Nevertheless, if the authorized set S is ï¬xed, our public
Public Key Broadcast Encryption with Low Number of Keys 391
the subsets in C, that is, S = âˆªwi=1Sw, where Si âˆˆ C are disjoint, 1 â‰¤ i â‰¤ w. Each
subset Si in C is associated with a private key ki. A user is assigned a set of keys
such that he can derive the private keys of the subsets to which he belongs. The
subset keys ki cannot be independent. Otherwise, each user may hold too many
keys. It is preferable that the subset keys have some relations, for example, one
can be derived from another. Thus, each user Uk is given a set SKk of keys so
that he can derive the private key of a subset to which he belongs. A subset-cover
based broadcast encryption scheme plays the art of choosing a collection C of
subsets, assigning subset and user keys, and ï¬nding subset covers.
5.1 The PK-SD-PI Scheme
We now present our PK-SD-PI scheme, which is constructed by using the poly-
nomial interpolation technique on the collection of subsets in [16]. The system
setup is similar to that of the BE-PI scheme. Consider a complete binary tree T
of logN + 1 levels. The nodes in T are numbered diï¬€erently. Each user in U is
associated with a diï¬€erent leaf node in T . We refer to a complete subtree rooted
at node i as â€subtree Tiâ€. For each subtree Ti of Î· levels (level 1 to level Î· from
top to bottom), we deï¬ne the degree-1 polynomials
f
(i)
j (x) = a
(i)
j,1x + a
(i)
j,0 (mod q),
where a(i)j,0 = lgH2(Idâ€–iâ€–jâ€–0) and a(i)j,1 = lgH2(Idâ€–iâ€–jâ€–1), 2 â‰¤ j â‰¤ Î·. For a user
Uk in the subtree Ti of Î· levels, he is given the private keys
sk,i,j = (grk,i,j , grk,i,jf
(i)
j (ij), grk,i,jf
(i)
j (0)hÏ)
for 2 â‰¤ j â‰¤ Î·, where nodes i1, i2, . . . , iÎ· are the nodes in the path from node i
to the leaf node for Uk (including both ends). We can read sk,i,j as the private
key of Uk for the jth level of subtree Ti. In Figure 1, the private keys (in the
unmasked form) of U1 and U3 for subtree Ti with Î· = 4 are given. Here, we use
hÏ in all private keys in order to save space in the header.
Recall that in the SD scheme, the collection C of subsets is
{Si,t : node i is a parent of node t, i = t},
where Si,t denotes the set of users in subtree Ti, but not in subtree Tt. By our
design, if the header contains a masked share for f (i)j (t), where node t is in the
j-th level of subtree Ti, only user Uk in Si,t can decrypt the header by using his
private key sk,i,j , that is, the masked form of f
(i)
j (s), for some s = t. In Figure 1,
the share f (i)3 (t) is broadcasted so that only the users in Si,t can decrypt the
header.
For a set R of revoked users, let Si1,t1 , Si2,t2 , . . ., Siz ,tz be a subset cover for
U\R, the header is
(meË†(gÏ, h)r, gr, (i1, t1, g
rf
(i1)
j1
(t1)), . . . , (iz, tz, grf
(iz)
jz
(tz))),
where node tk is in the jk-th level of subtree Tik , 1 â‰¤ k â‰¤ z.
Public Key Broadcast Encryption with Low Number of Keys 393
and H2, all polynomials are independent. Thus, we can simply consider a partic-
ular SÎ±,t in the subset cover for Sâˆ— = U\R, where t is at level Î² of subtree TÎ±.
The corresponding polynomial is f(x) = f (Î±)Î² (x) = a1x + a0 (mod q). Wlog, let
{U1, U2, . . . , Ul} be the set of revoked users that have the secret share about f(t).
The reduction to the BDH problem is as follows. Recall that the public key of the
PK-SD-PI method is (Id, H1, H2, E,G,G1, eË†, g, gÏ).
1. Let g be the generator in the system and gÏ = ga.
2. Set f(t) = w and compute gf(t) = gw, where w is randomly chosen from Zq.
3. Let ga0 = gf(0) = ga Â· gÏ„ , where Ï„ is randomly chosen from Zq.
4. Compute ga1 from gf(t) and ga0 via the Lagrange interpolation.
5. The (random) hash values H2(Idâ€–Î±â€–Î²â€–0) and H2(Idâ€–Î±â€–Î²â€–1) are set as ga0
and ga1 respectively.
6. Set h = gb Â· gÎº, where Îº is randomly chosen from Zq.
7. The f(x)-related secret share of Ui, 1 â‰¤ i â‰¤ l, is computed as (gri , grif(t),
grif(0)hÏ), where gri = gâˆ’b Â· gÎ¼i and Î¼i is randomly chosen from Zq. Note
that grif(0)hÏ = ga(Î¼i+Îº)âˆ’bÏ„+Î¼iÏ„ can be computed from the setting in the
previous steps.
8. The non-f(x)-related secret shares of Ui, 1 â‰¤ i â‰¤ l, can be set as follows.
Let f â€² be a polynomial related to subtree Î±â€² and level Î²â€², where tâ€² is in the
Î²â€²-th level and Ui âˆˆ SÎ±â€²,tâ€² . The secret share (grâ€²i , grâ€²if â€²(tâ€²), grâ€²if â€²(0)hÏ) of Ui is
computed from (gri , grif(t), grif(0)hÏ). Let f â€²(tâ€²) = wâ€², f â€²(0) = f(0)+ aâ€² and
râ€²i = ri + r
â€², where wâ€², aâ€², and râ€² are randomly chosen from Zq. Thus, gr
â€²
i =
gri Â·grâ€² , grâ€²if â€²(tâ€²) = (grâ€²i)wâ€² and grâ€²if â€²(0)hÏ = (grif(0)hÏ)Â·grâ€²f(0)Â·griaâ€² Â·grâ€²aâ€² . Note
that the hash values H2(Idâ€–Î±â€²â€–Î²â€²â€–0) and H2(Idâ€–Î±â€²â€–Î²â€²â€–1) can be answered
accordingly.
9. Set the challenge as
(y, gc, (i1, t1, g
cf
(i1)
j1
(t1)), (i2, t2, g
cf
(i2)
j2
(t2)), . . . , (iz, tz, gcf
(iz)
jz
(tz))),
where y is randomly chosen from G and thought as meË†(gÏ, h)c. Note that
g
cf
(ik)
jk
(tk), 1 â‰¤ k â‰¤ z, can be computed since f (ik)jk (tk) is a number randomly
chosen from Zq, as described in Step 2.
If the revoked users U1, U2, . . . , Ul can together compute the session key m
from the challenge with probability 1, we can compute
y Â· mâˆ’1 Â· eË†(ga, gc)âˆ’Îº = eË†(gÏ, h)c Â· eË†(g, g)âˆ’acÎº
= eË†(ga, gb+Îº)c Â· eË†(g, g)âˆ’acÎº = eË†(g, g)abc (4)
with the same probability 1. This contradicts the BDH assumption.
Let tâ€² be the time for the reduction and solution computation in Equation
(4), where tâ€² is polynomially bounded. Thus, if the collusion attack takes t1 âˆ’ tâ€²,
we can solve the BDH problem in time t1.
Similarly, we can modify our PK-SD-PI scheme to have IND-CCA security like
Section 4
Public Key Broadcast Encryption with Low Number of Keys 395
With the same extension in [12], we can have a PK-LSD-PI scheme that
has O(1) public keys and O(log1+) private keys, for any constant 0 <  < 1.
The header size is O(r/), which is O(r) for a constant . The decryption cost
excluding the time of scanning the header is again O(1).
6 Conclusion
We have presented very eï¬ƒcient public key BE schemes. They have low public
and private keys. Two of them even have a constant decryption time. Our results
show that the eï¬ƒciency of public key BE schemes is comparable to that of
private-key BE schemes.
We are interested in reducing the ciphertext size while keeping other com-
plexities low in the future.
Acknowledgement
We thankEikeKiltz andMichelAbdalla for valuable comments on themanuscript.
References
1. Attrapadung, N., Imai, H.: Graph-decomposition-based frameworks for subset-
cover broadcast encryption and eï¬ƒcient instantiations. In: Roy, B. (ed.) ASI-
ACRYPT 2005. LNCS, vol. 3788, pp. 100â€“120. Springer, Heidelberg (2005)
2. Boneh, D., Boyen, X., Goh, E.-J.: Hierarchical identity based encryption with
constant size ciphertext. In: Cramer, R.J.F. (ed.) EUROCRYPT 2005. LNCS,
vol. 3494, pp. 440â€“456. Springer, Heidelberg (2005)
3. Boneh, D., Franklin, M.: An eï¬ƒcient public key traitor tracing scheme. In: Wiener,
M.J. (ed.) CRYPTO 1999. LNCS, vol. 1666, pp. 338â€“353. Springer, Heidelberg
(1999)
4. Boneh, D., Gentry, C., Waters, B.: Collusion resistant broadcast encryption with
short ciphertexts and private keys. In: Shoup, V. (ed.) CRYPTO 2005. LNCS,
vol. 3621, pp. 258â€“275. Springer, Heidelberg (2005)
5. Boneh, D., Waters, B.: A fully collusion resistant broadcast, trace, and revoke
system. In: Proceedings of the ACM Conference on Computer and Communications
Security - CCS 2006, pp. 211â€“220. ACM Press, New York (2006)
6. Dodis, Y., Fazio, N.: Public key broadcast encryption for stateless receivers. In:
Feigenbaum, J. (ed.) DRM 2002. LNCS, vol. 2696, pp. 61â€“80. Springer, Heidelberg
(2003)
7. Dodis, Y., Fazio, N.: Public key broadcast encryption secure against adaptive cho-
sen ciphertext attack. In: Desmedt, Y.G. (ed.) PKC 2003. LNCS, vol. 2567, pp.
100â€“115. Springer, Heidelberg (2002)
8. Fiat, A., Naor, M.: Broadcast encryption. In: Stinson, D.R. (ed.) CRYPTO 1993.
LNCS, vol. 773, pp. 480â€“491. Springer, Heidelberg (1994)
9. Fujisaki, E., Okamoto, T.: Secure integration of asymmetric and symmetric en-
cryption schemes. In: Wiener, M.J. (ed.) CRYPTO 1999. LNCS, vol. 1666, pp.
537â€“554. Springer, Heidelberg (1999)
A Public-Key Traitor Tracing Scheme with an
Optimal Transmission Rate
Yi-Ruei Chen and Wen-Guey Tzeng
Department of Computer Science
National Chiao Tung University
Hsinchu, Taiwan 30010, ROC
yrchen.cs98g@nctu.edu.tw, wgtzeng@cs.nctu.edu.tw
Abstract. The way of transmitting the encrypted digital content to
the legitimate subscribers over a broadcast channel has wide commer-
cial applications, such as Pay-TV, DVD, etc. In order to discourage
the legitimate subscribers from giving away their decryption keys, the
traitor tracing scheme comes up. In this paper, we propose a public-key
traitor tracing scheme that has optimal transmission rate. In other words,
our scheme enables everyone to transmit the encrypted digital contents
almost without any redundancy. As for tracing, our scheme supports
black-box tracing, i.e., identifying colluders without opening the pirate
decoder. Moreover, in our scheme, the storage requirement for legitimate
subscribers and digital content broadcasters is smaller than that of pre-
vious schemes.
Keywords: Traitor tracing, transmission rate, ï¬ngerprinting code.
1 Introduction
Consider the scenario that a data supplier distributes the digital content over
a broadcast channel. The data supplier gives a secret key to each legitimate
subscriber. Then the data supplier broadcasts the encrypted digital content and
the legitimate subscribers decrypt the digital content by their secret keys. The
protection for some Pay-TV, CD-ROM, DVD, and online databases is based on
this scenario. However, some malicious subscribers (called traitors) might give
copies of their secret keys to illegitimate users (called pirates). Then the pirates
decrypt the digital content for free. In order to solve the problem above, the
traitor tracing scheme comes up.
The goal of traitor tracing schemes is to discourage legitimate subscribers from
giving away their secret keys. One approach is to give each subscriber a unique
set of secret keys that both decrypt the encrypted digital content and identify
(â€œtraceâ€) the subscribers. To avoid being traced by a tracer, the traitors may
collude to obfuscate their secret keys and generate a new secret key set (called
 The research was supported in part by projects NSC 96-2628-E-009-011-MY3 and
98-2219-E-009-003-
S. Qing, C.J. Mitchell, and G. Wang (Eds.): ICICS 2009, LNCS 5927, pp. 121â€“134, 2009.
cÂ© Springer-Verlag Berlin Heidelberg 2009
A Public-Key Traitor Tracing Scheme with an Optimal Transmission Rate 123
Table 1. Scheme Comparison
transmission user-key public-key black-box traceability
rate size size tracing
BF99 [2] 2t + 1 2t 2t + 1 ineï¬ƒcient private
BSW06 [4] 6
âˆš
N 1 4
âˆš
N + 2 O public
KY02 [13] âˆ¼ 3 2 4 O private
CPP05 [8] âˆ¼ 1 2  + 1 X private
FNP07 [11] âˆ¼ 1 2 10 O private
Ours âˆ¼ 1  + 2 2 + 1 O private
â€  : the codeword length in ï¬ngerprinting code
â€  N : the total number of legitimate subscribers
requirements in our scheme for user-keys and pubic-keys are smaller than previ-
ous schemes that have the constant (or optimal) transmission rate. Our scheme
is based on a ï¬ngerprinting code, and an all-or-nothing transformation [6,7,19].
The idea is to encrypt a block of the output of an all-or-nothing transformation
by a special public-key scheme. The encryption does not entail much overhead
and allows us to feed indistinguishable messages for tracing. The comparison
with other related schemes is given in Table 1. We show that our scheme is se-
mantically secure based on the DDH assumption and the indistinguishability of
PKE-AONT. We also show that our traitor tracing scheme is t-collusion resistant
under the DDH assumption.
2 Preliminaries
Notations. A function f : N â†’ R is negligible if for every constant c âˆˆ N, there
exists an integer k0 âˆˆ N such that f(k) â‰¤ kâˆ’c for all k â‰¥ k0, denoted by neg(k).
We use x $â†âˆ’ X to denote that x is chosen from the set X uniformly. Let M be
the plaintext space.
Fingerprinting Codes. The ï¬ngerprinting technique with ï¬ngerprinting codes
embeds a speciï¬c ï¬ngerprint (codeword) to each document copy so that one can
identify which copy of document by examining the embedded ï¬ngerprint. The
codeword is a collection of some alphabets. The traitors will collude and try to
modify their codewords to avoid being identiï¬ed. However, the coalition of the
traitors is restricted by the marking assumption: the traitors are only able to com-
pare their codewords and make a modiï¬cation from their respective codewords
diï¬€ering in some positions. Under the marking assumption, the possible modiï¬ed
codeword set from t traitorâ€™s codewords set W is called a feasible set of W .
â€“ For a codeword w âˆˆ {0, 1}, we write w = w1w2...w, where wi âˆˆ {0, 1}.
â€“ Let W = {w(1), ..., w(t)} âŠ† {0, 1}. We say that a codeword wÂ¯ is feasible for
W if âˆ€i âˆˆ {1, 2, ...} âˆƒj âˆˆ {1, 2, ..., t} s.t. wÂ¯i = w(j)i . For example, if W =
{0101, 1111}, the codewords {0101, 0111, 1101, 1111} are feasible for W .
â€“ For a codeword set W âŠ† {0, 1}, we say that the feasible set of W , denoted
by F (W ), is the set of all codewords that are feasible for W .
A Public-Key Traitor Tracing Scheme with an Optimal Transmission Rate 125
3 The Notion for Public-Key Traitor Tracing Scheme
A public-key traitor tracing scheme is a 4-tuple of probabilistic polynomial-time
algorithms (Setup,Encrypt,Decrypt,Trace), where
Setup(1Î», N). The setup takes as input a security parameter Î» and N , the
number of users in the system. The algorithm outputs a public broadcast-key
BK, a secret trace-key TK, and the private user-key SKu for each legitimate
subscriber u.
Encrypt(BK,M). The encryption algorithm takes as input the public broadcast-
key BK and a message M âˆˆ M. The algorithm outputs a ciphertext C.
Decrypt(SKu, C). The decryption algorithm takes as input the private user-key
SKu of user u and a ciphertext C. The algorithm outputs a message M or
âŠ¥.
TraceD(TK). The tracing algorithm takes as input the private trace-key TK and
queries the pirate decoder D as a black-box oracle. The algorithm outputs a
traitor set S which is a subset of {1, ..., N}.
Moreover, the scheme must satisfy the correctness property as follows:
For all u âˆˆ {1, ..., N} and for all M âˆˆ M: if ã€ˆBK,TK, (SK1, ...,SKN )ã€‰ $â†âˆ’
Setup(1Î», N) and C $â†âˆ’ Encrypt(BK,M), then Decrypt(SKu, C) = M .
Semantic Security Game
â€“ Setup. The challenger runs Setup, and gives BK to the adversary.
â€“ Challenge. The adversary chooses two plaintexts M0,M1 âˆˆ M to the chal-
lenger. Then the challenger ï¬‚ips a coin b âˆˆ {0, 1}, and gives a ciphertext
Cb
$â†âˆ’ Encrypt(BK,Mb) to the adversary.
â€“ Guess. The adversary returns a guess bâ€² âˆˆ {0, 1} of b to the challenger.
The advantage of winning this game by the adversary is AdvTTSSS := |Pr[bâ€² =
b]âˆ’ 12 |
Deï¬nition 1 (Semantically secure). An N -user public-key traitor tracing
scheme is semantically secure if for all polynomial time adversaries A, AdvTTSSS
is a negligible function of the security parameter.
Traceable against t-collusion Game
â€“ Setup. The challenger runs Setup and gives BK to the adversary. The ad-
versary chooses a traitor set T = {u1, ..., ut} âŠ† {1, ..., N} to the challenger.
Then the challenger gives the adversary SKu1 , ...,SKut to produce a pirate
decoder D.
â€“ Trace. By taking a pirate decoder D as a decryption oracle, the challenger
runs the algorithm TraceD(TK) to obtain a traitor set S âŠ† {1, ..., N}.
The adversary wins this game if (1) D decrypts all valid ciphertext with a con-
stant probability Î´, i.e., Pr[D(Encrypt(BK,M)) = M ] â‰¥ Î´, and (2) S âˆ© T = âˆ….
The probability of adversary winning this game is AdvTTSTR .
A Public-Key Traitor Tracing Scheme with an Optimal Transmission Rate 127
â€“ Setup. Algorithm B is given as input an instance (g, gu, gv, X) of the DDH
assumption, and it wants to determine whether X = guv or X is a random
element in   (  has prime order q). B chooses a0, a1 $â†âˆ’ âˆ—q and sets bk =
ã€ˆg, (gu, ga1)ã€‰ to A. (we see that f(x) = u + a1x (mod q))
â€“ Challenge. A chooses two plaintexts m0,m1 âˆˆ M to B, then B ï¬‚ips a coin
b âˆˆ {0, 1}, and sets the challenge cb = ã€ˆmbX, gv, (j,X(gv)a1j)ã€‰ to A, where
j
$â†âˆ’ âˆ—q .
â€“ Guess. A outputs bâ€² âˆˆ {0, 1} to B. If bâ€² = b, B answers that X = guv; else B
answers that X is a random element in  .
If X = guv, A gets a valid ciphertext cb = ã€ˆmbguv, gv, (j, gv(u+a1j))ã€‰. Therefore,
A answers bâ€² = b successfully with probability 12 + ;
If X is a radom element in  , A gets an invalid ciphertext. In this case, A
answers bâ€² = b successfully with probability 12 .
Hence, B solves the DDH problem with non-negligible advantage . This is a
contradiction to the DDH assumption. So we conclude that such adversary A
does not exist.
Theorem 2. The 2-PK-TTS scheme is traceable against 1-collusion under the
DDH assumption.
Proof. By contradiction, assume that there exists an adversary A that, given
the public-key bk and one of user-keys skÏƒ in 2-PK-TTS scheme, A produces
a pirate decoder D that decrypts all valid ciphertexts perfectly, i.e., Pr[D(2-
Encrypt(bk,m)) = m : D $â†âˆ’ A(bk, skÏƒ), Ïƒ âˆˆ {0, 1}] = 1. But when given a probe
ciphertext cË†, D outputs a diï¬€erent value from the pre-computed values in 2-Trace
algorithm with non-negligible probabilistic  > 0, i.e., Pr[D(cË†) = A/VÏƒ] = . We
construct an algorithm B that breaks the DDH assumption with non-negligible
advantage 2 as follows:
â€“ Setup. Algorithm B is given as input an instance (g, gu, gv, X) of DDH as-
sumption, and it wants to determine whether X = guv or X is a random
element in  . B chooses i, z $â†âˆ’ âˆ—q and gives A bk = ã€ˆg, (gu, ga1 = ( g
z
gu )
iâˆ’1)ã€‰.
A chooses a traitor set T = {0} or {1} to B. Then B gives A sk = ã€ˆi, zã€‰ to
produces a pirate decoder D.
â€“ Trace. By taking a pirate decoder D as a decryption oracle, B runs the
modiï¬ed 2-Trace as follows:
1. Choose A $â†âˆ’   , and j $â†âˆ’ âˆ—q , where j = i. Compute W = X( (g
v)z
X )
jiâˆ’1
and set the ciphertext as cÂ¯ â† ã€ˆA, gv, (j,W )ã€‰.
2. Pre-compute V â† W âˆ’ijâˆ’i (gv)z âˆ’jiâˆ’j .
3. If D(cÂ¯) = A/V , B answers that X = guv or X is a random element in  
randomly; else B answers that X is a random element in  .
If X = guv, ciphertext cÂ¯ is a valid ciphertext, since
X(
(gv)z
X
)ji
âˆ’1
= guv(
(gv)z
guv
)ji
âˆ’1
= guv((
gz
gu
)i
âˆ’1
)vj = guv(ga1)vj = gv(u+a1j).
In this case, D(cÂ¯) = A/V , B gives the correct answer with probability 12 ;
A Public-Key Traitor Tracing Scheme with an Optimal Transmission Rate 129
Our traitor tracing scheme for N users Î  = (Setup,Encrypt,Decrypt,Trace) is
as follows:
Setup(1Î», N). Given a security parameter Î» and user number N , the algorithm
generates a ï¬ngerprinting code Î“ = {w(1), ..., w(N)} âˆˆ ({0, 1})N for some .
Then it runs 2-Setup  times to generate the keys ã€ˆ(bki, tki, (sk0,i, sk1,i))Ni=1ã€‰
(but use the same q, , g, i0, i1) and sets
â€“ Public broadcast-key BK := ã€ˆg, (ga0,j , ga1,j )j=1ã€‰
(we denote the k-th key of BK by BKk = (g, (ga0,k, ga1,k)))
â€“ Secret trace-key TK := ã€ˆ(fj(x))j=1ã€‰
â€“ User-key SKu := ã€ˆw(u), i0, i1, (fj(iw(u)j )

j=1ã€‰, âˆ€u âˆˆ {1, 2, ..., N}
(we denote k-th key of SKu by SKu,k = (iw(u)k
, fk(iw(u)k
)))
Encrypt(BK,M â€²). Given BK and a plaintext M â€² âˆˆMâ€² , the algorithm chooses a
random string Ï $â†âˆ’ {0, 1}Ï„ , and computes Î£(M â€²; Ï) = M = m1||...||m. Then
it chooses a position index k $â†âˆ’ {1, 2, ..., }, and computes the ciphertext
C
$â†âˆ’ ã€ˆk, 2-Encrypt(BKk,mk),MINUSk(M)ã€‰.
Decrypt(SKu, C). Given a ciphertext C = ã€ˆk, ck, Y ã€‰, user u computes mk â†
2-Decrypt(SKu,k, ck) and M â€² = Î£âˆ’1(COMBk(Y,mk)).
TraceD(TK). Given a pirate decoder D that decrypts all valid ciphertext per-
fectly as a decryption oracle. The algorithm does:
â€“ For each position index k âˆˆ {1, 2, ..., },
1. Compute Î£(M â€²; Ï) = M = m1||m2||...||m, where M â€² $â†âˆ’ Mâ€² and
Ï
$â†âˆ’ {0, 1}Ï„ .
2. Call 2-TrEncrypt(BKk,mk)
$âˆ’â†’ cË†k = ã€ˆAk = mkgra0,k , R=gr, (j, WË†k =
grË†fk(j)))ã€‰. Set the probe ciphertext as CË† $â†âˆ’ ã€ˆk, cË†k, Y = MINUSk(M)ã€‰.
3. âˆ€Ïƒ âˆˆ {0, 1}, pre-compute Mk,Ïƒ = COMBk(Y,Ak/WË†
âˆ’iÏƒ
jâˆ’iÏƒ
k R
fk(iÏƒ)
âˆ’j
iÏƒâˆ’j ).
4. âˆ€Ïƒ âˆˆ {0, 1}, if Î£(D(CË†); Ï) = Mk,Ïƒ, set wâˆ—k = Ïƒ; else set wâˆ—k = 0 for
convenience.
â€“ Recover wâˆ— = wâˆ—1w
âˆ—
2 ...w
âˆ—
 , then call the tracing algorithm in ï¬ngerprint-
ing code by taking wâˆ— as the input to obtain collude codewords. Finally,
output the corresponding traitor set S.
5.2 Security Analysis of Our Scheme
Theorem 3. The scheme Î  is semantically secure under the semantic security
of 2-PK-TTS and the indistingushability of PKE-AONT.
Proof. For each position index k âˆˆ {1, 2, ..., }, we use two games to bound the
advantage of semantically secure in Î  with Adv2-PK-TTSSS and Adv
PKE-AONT
ind as
follows:
Game G0. Deï¬ne G0 as the original semantic security game and let S0 be the
event where bâ€² = b, i.e., AdvÎ SS := |Pr[S0]âˆ’ 12 |.
A Public-Key Traitor Tracing Scheme with an Optimal Transmission Rate 131
Hence, by the discussion above and the triangle inequality,
|Pr[S0]| = |Pr[S0]âˆ’ Pr[S1] + Pr[S1]|
â‰¤ |Pr[S0]âˆ’ Pr[S1]|+ |Pr[S1]|
= 2Adv2-PK-TTSSS + Adv
PKE-AONT
ind +
1
2
.
Since Adv2-TTSSS and Adv
PKE-AONT
ind are two negligible functions of Î», we conclude
that the advantage of A winning the semantic security game is bounded by a
negligible function of Î».
Theorem 4. The scheme Î  is traceable against t-collusion under the DDH as-
sumption.
Proof. By contradiction, assume that there exists an adversaryA that, given the
public key BK, t of user keys {SKu1 , SKu2 , ...,SKut} and an AONT Î£, produces
a pirate decoder D that decrypts all valid ciphertexts perfectly. But when given
a probe ciphertext, D outputs a diï¬€erent value from the pre-computed values
in Trace algorithm with non-negligible probabilistic  > 0, i.e., Pr[Î£(D(CË†); Ï) =
Mk,Ïƒ] = . We construct an algorithm B that breaks the DDH assumption with
non-negligible advantage 2 as follows:
â€“ Setup. Algorithm B is given as input an instance (g, gu, gv, X) of DDH
assumption, and it wants to determine whether X = guv or X is a ran-
dom element in   (  has prime order q). B chooses a position index k $â†âˆ’
{1, 2, ..., }, chooses fj(x) = a0,j + a1,jx (modq), where a0,j, a1,j $â†âˆ’ âˆ—q , âˆ€j âˆˆ
{1, 2, ..., }, chooses i0, i1, z $â†âˆ’ âˆ—q and gives A BK = ã€ˆg, (ga0,j , ga1,j )j=1ã€‰
but repalces ga0,k by gu and ga1,k by ( g
z
gu )
iâˆ’1Ïƒ , where Ïƒ $â†âˆ’ {0, 1}. A chooses
a traitor set T âŠ† {1, ..., N} of size t to B. Then B chooses t codewords
w(u1), w(u2), ..., w(ut)
$â†âˆ’ Î“ (even if Î“ is public, the information of which user
get which codeword can be hiden, so B can choose t codewords by his own)
satisfy w(u1)k = w
(u2)
k = ... = w
(ut)
k = Ïƒ (the existence of these codewords is
guaranteed by the ï¬ngerprinting codes) and sets A the keys
SKu1 = ã€ˆw(u1), i0, i1, (f1(iw(u1)1 ), ..., fkâˆ’1(iw(u1)kâˆ’1 ), z, fk+1(iw(u1)k+1 ), ..., f(iw(u1) ))ã€‰,
SKu2 = ã€ˆw(u2), i0, i1, (f1(iw(u2)1 ), ..., fkâˆ’1(iw(u2)kâˆ’1 ), z, fk+1(iw(u2)k+1 ), ..., f(iw(u2) ))ã€‰,
...
SKut = ã€ˆw(ut), i0, i1, (f1(iw(ut)1 ), ..., fkâˆ’1(iw(ut)kâˆ’1 ), z, fk+1(iw(ut)k+1 ), ..., f(iw(ut) ))ã€‰,
to produces a pirate decoder D.
â€“ Trace. By taking a pirate decoder D as a decryption oracle, B runs the
modiï¬ed Trace algorithm as follows:
A Public-Key Traitor Tracing Scheme with an Optimal Transmission Rate 133
2. Boneh, D., Franklin, M.K.: An eï¬ƒcient public key traitor scheme (Extended
abstract). In: Wiener, M. (ed.) CRYPTO 1999. LNCS, vol. 1666, pp. 338â€“353.
Springer, Heidelberg (1999)
3. Boneh, D., Naor, M.: Traitor tracing with constant size ciphertext. In: Ning, P.,
Syverson, P.F., Jha, S. (eds.) ACM Conference on Computer and Communications
Security, pp. 501â€“510. ACM, New York (2008)
4. Boneh, D., Sahai, A., Waters, B.: Fully collusion resistant traitor tracing with short
ciphertexts and private keys. In: Vaudenay, S. (ed.) EUROCRYPT 2006. LNCS,
vol. 4004, pp. 573â€“592. Springer, Heidelberg (2006)
5. Boneh, D., Shaw, J.: Collusion-secure ï¬ngerprinting for digital data. IEEE Trans-
actions on Information Theory 44(5), 1897â€“1905 (1998)
6. Boyko, V.: On the security properties of oaep as an all-or-nothing transform. In:
Wiener, M. (ed.) CRYPTO 1999. LNCS, vol. 1666, pp. 503â€“518. Springer, Heidel-
berg (1999)
7. Canetti, R., Dodis, Y., Halevi, S., Kushilevitz, E., Sahai, A.: Exposure-resilient
functions and all-or-nothing transforms. In: Preneel, B. (ed.) EUROCRYPT 2000.
LNCS, vol. 1807, pp. 453â€“469. Springer, Heidelberg (2000)
8. Chabanne, H., Phan, D.H., Pointcheval, D.: Public traceability in traitor tracing
schemes. In: Cramer, R. (ed.) EUROCRYPT 2005. LNCS, vol. 3494, pp. 542â€“558.
Springer, Heidelberg (2005)
9. Chor, B., Fiat, A., Naor, M.: Tracing traitors. In: Desmedt, Y.G. (ed.) CRYPTO
1994. LNCS, vol. 839, pp. 257â€“270. Springer, Heidelberg (1994)
10. Chor, B., Fiat, A., Naor, M., Pinkas, B.: Tracing traitors. IEEE Transactions on
Information Theory 46(3), 893â€“910 (2000)
11. Fazio, N., Nicolosi, A., Phan, D.H.: Traitor tracing with optimal transmission rate.
In: Garay, J.A., Lenstra, A.K., Mambo, M., Peralta, R. (eds.) ISC 2007. LNCS,
vol. 4779, pp. 71â€“88. Springer, Heidelberg (2007)
12. Furukawa, J., Attrapadung, N.: Fully collusion resistant black-box traitor revocable
broadcast encryption with short private keys. In: Arge, L., Cachin, C., JurdzinÂ´ski,
T., Tarlecki, A. (eds.) ICALP 2007. LNCS, vol. 4596, pp. 496â€“508. Springer, Hei-
delberg (2007)
13. Kiayias, A., Yung, M.: Traitor tracing with constant transmission rate. In: Knud-
sen, L.R. (ed.) EUROCRYPT 2002. LNCS, vol. 2332, pp. 450â€“465. Springer, Hei-
delberg (2002)
14. Kurosawa, K., Desmedt, Y.G.: Optimum traitor tracing and asymmetric schemes.
In: Nyberg, K. (ed.) EUROCRYPT 1998. LNCS, vol. 1403, pp. 145â€“157. Springer,
Heidelberg (1998)
15. Naor, M., Pinkas, B.: Threshold traitor tracing. In: Krawczyk, H. (ed.) CRYPTO
1998. LNCS, vol. 1462, pp. 502â€“517. Springer, Heidelberg (1998)
16. Naor, M., Pinkas, B.: Eï¬ƒcient trace and revoke schemes. In: Frankel, Y. (ed.) FC
2000. LNCS, vol. 1962, pp. 1â€“20. Springer, Heidelberg (2001)
17. Phan, D.H.: Traitor tracing for stateful pirate decoders with constant ciphertext
rate. In: NguyeË†n, P.Q. (ed.) VIETCRYPT 2006. LNCS, vol. 4341, pp. 354â€“365.
Springer, Heidelberg (2006)
18. Phan, D.H., Safavi-Naini, R., Tonien, D.: Generic construction of hybrid public
key traitor tracing with full-public-traceability. In: Bugliesi, M., Preneel, B., Sas-
sone, V., Wegener, I. (eds.) ICALP 2006. LNCS, vol. 4052, pp. 264â€“275. Springer,
Heidelberg (2006)
1Key Establishment Schemes Against
Storage-Bounded Adversaries in Wireless Sensor
Networks
Shi-Chun Tsai, Wen-Guey Tzeng, Kun-Yi Zhou
Abstractâ€”In this paper we re-examine the attacking scenario
about wireless sensor networks. It is generally assumed that the
adversary picks up all radio communications of sensor nodes
without any loss and stores the eavesdropped messages for later
use. We suggest that in some situations the adversary may not
be able to pick up all radio communications of sensor nodes.
Therefore, we propose the storage-bounded adversary model for
wireless sensor networks, in which the adversaryâ€™s storage is
bounded.
We propose two key establishment schemes for establishing
shared keys for neighboring sensor nodes in the storage-bounded
adversary model. The first scheme needs special beacon nodes
for broadcasting random bits. In the second scheme, some sensor
nodes play the role of beacon nodes. Our results are theoretical
in some sense. Nevertheless, we can adjust them for realistic
consideration.
Index Termsâ€”Bounded-storage model, key establishment, un-
conditional security, wireless sensor network.
I. INTRODUCTION
A wireless sensor network usually consists of a large
number of small autonomous sensor nodes. Each sensor node
has some level of computing power, a limited size of storage,
a set of sensors for exploring the environment and a small
antenna for communicating with the outside world. One way of
deploying a wireless sensor network is to scatter senor nodes in
the field randomly. Then, these sensor nodes form a network
autonomously via their built-in programs. Due to restriction
of small antenna, each sensor node can communicate with its
geographic neighbors only. We say that two sensor nodes are
neighbored if they can communicate with each other via radio
directly. In some situations, we may deploy a set of special
nodes, called beacon nodes, for broadcasting instructions and
data to the sensor nodes. A beacon node is more powerful so
that its radio signal could cover a larger area.
There are some security issues about wireless sensor net-
works, such as, communication security, message authentica-
tion, node authentication, etc. We are concerned about the key
establishment problem, which is to establish a shared (secret)
The authors are with Computer Science Department, National Chiao Tung
University, Hsinchu, Taiwan 30050. Their emails are sctsai@cs.nctu.edu.tw,
wgtzeng@cs.nctu.edu.tw, and kyzhou@cs.nctu.edu.tw. The corresponding au-
thor is Professor Wen-Guey Tzeng
Research supported in part by projects NSC-96-2628-E-009-011-
MY3, NSC-97-2221-E-009-064-MY3 NSC-97-2219-E-009-006 (TWISC),
and MoE-97W803.
Manuscript received August 06, 2008; revised October 02, 2008; accepted,
November 08, 2008.
The corresponding Associate Editor is Professor Dapeng Wu.
key for two neighboring sensor nodes via the public radio link.
The established key is later used for secure communication
(encryption) or authentication. The key establishment problem
for wireless sensor networks has been studied actively. In this
paper we re-examine the attacking scenario about wireless
sensor networks. It is generally assumed that the adversary
picks up all radio communications of sensor nodes without any
loss and stores the eavesdropped messages for later use. We
suggest that this may not be the case. For example, the radio
quality of a sensor node is not very good and its coverage area
is small. It is hard for the adversary to get all communications
between sensor nodes. Therefore, we propose the storage-
bounded adversary model for wireless sensor networks to
capture the nature of incomplete eavesdropping. In this model,
the adversary cannot eavesdrop all communications of the
sensor nodes. We could conceptually think that the adversaryâ€™s
storage is limited so that it cannot store all communications.
The storage-bounded adversary model has been studied in
the cryptographic field for its advanced view. It explores the
possibility of encryption in the era of quantum computation.
We bring the model to wireless sensor networks for exploring
an alternative adversary model.
By considering the storage-bounded adversary, we propose
two key establishment schemes. The first scheme needs some
special beacon nodes for broadcasting random bits. In the
second scheme, some sensor nodes play the role of beacon
nodes. Our results are theoretical in some sense. Nevertheless,
we can adjust them for realistic consideration.
Our key establishment schemes have the following prop-
erties. Firstly, they do not pre-load secrets to sensor nodes.
This saves quite a lot of setup work before sensor nodes
are deployed to the field. Secondly, the connectivity rate of
neighboring sensor nodes is very high and the probability
of repeated keys is very low. Thirdly, even if the adversary
captures a large fraction of the deployed sensor nodes, almost
all of the shared keys of un-compromised links remain secure.
We note that most key pre-distribution schemes allow only
a small fraction of sensor nodes to be compromised by the
adversary. Finally, the shared keys in the first scheme are
unconditionally secure. Furthermore, since all shared keys are
generated in the field without pre-loaded secrets in sensor
nodes, shared keys can be updated from time to time.
We do not consider the adversary that applies other types
of attacks, such as node impersonation, node replication, etc.
There have been many proposed countermeasures [5]â€“[7]. If
we need them, we can simply use them without too much
31) B1 generates and broadcasts Î± random bits on the fly.
2) Each Vi, 1 â‰¤ i â‰¤ m, randomly stores Âµ bits
ri1ri2 Â· Â· Â· riÂµ . Let Si = {i1, i2, . . . , iÂµ}.
3) Each Vi, 1 â‰¤ i â‰¤ m, does the following:
a) Exchange Si with each of its neighbors Vj via their
direct radio link;
b) Let Si,j = Si âˆ© Sj = {s1, s2, . . . , sl}. If |Si,j | =
l â‰¥ Îº, compute Ki,j = H(rs1rs2 Â· Â· Â· rsl).
c) Erase the stored bits ri1ri2 Â· Â· Â· riÂµ from its memory.
Fig. 2. KEB-SB: Steps of establishing shared keys between neighboring sensor
nodes within the radio range of the beacon node B1.
beacon nodes do the same thing. The idea is that B1 broadcasts
Î± random bits and each sensor node randomly stores Âµ bits.
Then, two neighboring sensor nodes exchange the indices of
their stored bits and find their common bits. Finally, they
compute the shared key from the common bits by taking
the hash value of the common bits. It is easy to check that
Ki,j = Kj,i since Vi and Vj found their common bits from
the publicly exchanged indices.
It is critical that some sensor nodes V lie within the radio
coverage areas of many beacon nodes, say, B1,B2, . . . ,BÏ„ .
Assume that Biâ€™s use different frequencies for broadcasting
so that they wonâ€™t interfere with each other. In this case,
V establishes shared keys with its neighboring sensor nodes
within various beacon nodes Bk, 1 â‰¤ k â‰¤ Ï„ . Thus, a network
that connects all sensor nodes can be formed. For example, the
sensor node V1 has a shared key K1,3 with V3 within B1 and a
shared key K1,7 with V7 within B3. V1 plays as a connecting
node between the sensor nodes within B1 and the sensor nodes
within B3.
Probability of Establishing Shared Keys. In the scheme
each sensor node within a beacon node stores Âµ = 2
âˆš
ÎºÎ±
broadcasted bits randomly. Two neighboring sensor nodes
within a beacon node will have 4Îº common bits on average.
Furthermore, the probability that two neighboring sensor nodes
have at least Îº common bits is 1âˆ’eâˆ’Îº/4 at least. For Îº = 128,
1âˆ’eâˆ’Îº/4 â‰ˆ 1. The following lemma shows this fact, where S
and T are the sets of indices of stored bits by two neighboring
sensor nodes, respectively.
Lemma 1 ( [4]): If S and T are randomly chosen from
the 2
âˆš
ÎºÎ±-element subsets over {1, 2, . . . , Î±}, then, for suf-
ficiently large Î±,
Pr
S,T
[|S âˆ© T | < Îº] < eâˆ’Îº/4.
Security of Shared Keys. Assume that the adversary stores
Î² = Î´Î± bits of the broadcasted Î± bits, where Î´ < 1 is a
constant. The security of shared keys depends on Î´ and Îº. Two
neighboring sensor nodes within a beacon node have l = 4Îº
common bits on average and the adversary gets a fraction
Î´l of them on average. Although the number l of common
stored bits is a random variable, we take the average l = 4Îº
for simplifying analysis. We show that the probability that the
adversary gets up to (Î´+ Â²)l common bits is very low, where
Î´ + Â² < 1.
Let A âŠ‚ {1, 2, . . . , Î±} be the set of indices of the stored
bits by the adversary, |A| = Î², and B the set of indices of
the commonly stored bits by two neighboring sensor nodes,
|B| = l. We fix A first. The probability that the adversary
stores (Î´ + Â²)l common bits is, for Î´ + Â² < 1 and integer
l(Î´ + Â²),
Pr
B
[|A âˆ©B| â‰¥ (Î´ + Â²)l] =
lâˆ‘
i=(Î´+Â²)l
(
Î²
i
)(
Î±âˆ’Î²
lâˆ’i
)(
Î±
l
) .
It is hard to derive a closed form for the above equation.
Nevertheless, we can compute a pretty tight upper bound. In
the above computation the elements in B are randomly chosen
one by one from {1, 2, . . . , Î±} without replacement. However,
if Î± is much larger than l, we can think that the elements are
randomly chosen one by one with replacement. Let Bâ€² be a
multi-set with l elements randomly chosen one by one from
{1, 2, . . . , Î±} with replacement. Since Î± is indeed much large
than l in our schemes, we can safely say that
Pr
B
[|A âˆ©B| â‰¥ (Î´ + Â²)l] â‰ˆ Pr
Bâ€²
[|A âˆ©Bâ€²| â‰¥ (Î´ + Â²)l],
which is bounded by the following lemma.
Lemma 2: Let A be a fixed subset of {1, 2, . . . , Î±} with
|A| = Î² and Bâ€², |Bâ€²| = l Â¿ Î², a multi-subset randomly
chosen from {1, 2, . . . , Î±} with replacement. It holds that
Pr
Bâ€²
[|A âˆ©Bâ€²| â‰¥ (Î´ + Â²)l] â‰¤ eâˆ’lÂ²2/(3Î´).
Proof: Let Xi be the indicator random variable for
whether the ith chosen element of Bâ€² is in A, 1 â‰¤ i â‰¤ l.
We have |A âˆ© Bâ€²| = âˆ‘li=1Xi and E(âˆ‘li=1Xi) = Î´l. Since
Xiâ€™s are independent, by the Chernoff bound, we have
Pr
Bâ€²
[|A âˆ©Bâ€²| â‰¥ (Î´ + Â²)l] = Pr[
lâˆ‘
i=1
Xi â‰¥ (Î´ + Â²)l]
= Pr[
lâˆ‘
i=1
Xi â‰¥ Î´l(1 + Â²/Î´)] â‰¤ eâˆ’Î´l(Â²/Î´)2/3
= eâˆ’lÂ²
2/(3Î´).
Since the above holds for any fixed A, the probability holds
no matter how the adversary stores broadcasted bits. For Îº =
128, Î´ = 2/3, Â² = 1/4, we have
Pr
Bâ€²
[|A âˆ©Bâ€²| â‰¥ (11/12)l] < eâˆ’16.
In this case, the adversary does not know at least (1âˆ’Î´âˆ’Â²)l â‰ˆ
43 common bits of two neighboring sensor nodes within a
beacon node.
Probability of Complete Connectivity. We now compute the
number of beacon nodes that are needed for high pcomplete.
The most important factor for pcomplete is the size of the
overlapping area of radio coverage since the sensor nodes
within the overlapping area connect sensor nodes within
different beacon nodes. Let R be the radius of the field and r
be the radius of the radio coverage of a beacon node. Recall
that there are z beacon nodes. We take a very conservative
and ideal estimate for the required z. Here, we assume that
5Density of Beaming Nodes. The larger p is, the higher
pcomplete is. Nevertheless, we want to have a smaller p so
that the expected number np of beaming nodes is as small
as possible. Assume that r is the radius of radio range of a
beaming node and R is the radius of the deployment field.
Note that this r is smaller than that of a beacon node in the
KEB-SB scheme. The expected number of beaming nodes is
np, which is equivalent to z, the number beacon nodes. By
Equation (1), we need
z = np â‰¥ nR
2
nr2 âˆ’ 2cR2 ,
where c is the expected number of connecting nodes in the
overlapping area of two beaming nodes. Thus, we have
p â‰¥ R
2
nr2 âˆ’ 2cR2 .
V. DISCUSSION
Our schemes are designed on an abstract model of wireless
sensor networks. Many details are omitted. Comparison be-
tween the conventional and storage-bounded adversary model
is uncalled-for since their basic assumptions are fundamentally
different. Even though our schemes are theoretical, we can
use some techniques to improve their performance on energy
consumption, storage requirement and computation cost.
1) No re-send: It is possible that a sensor node does not
receive some random bits from beacon or beaming
nodes. The sensor node can simply ignore a lost bit
and continues to wait for the next one. This does not
affect its functionality since only a very small fraction
of broadcasted bits are stored by each sensor node. Thus,
the beacon and beaming nodes can broadcast in a â€rawâ€
mode.
2) Sleeping: In our schemes, random bits are broadcasted
for a relatively long period of time. But, the sensor
nodes do not store all of them. Thus, the sensor nodes
can use the random sleeping technique to reduce energy
consumption. Each sensor node stays in a state of very
low energy consumption for most time and wakes up to
receive bits from time to time.
Furthermore, when a sensor node needs to receive broad-
casted random bits from different beacon or beaming
nodes in different frequencies, it can switch to a different
frequency in each wake-up. Thus, the beacon or beaming
nodes can broadcast random bits at different frequencies
without worrying about whether their neighboring sensor
nodes can receive them simultaneously.
3) Pseudorandomness: In our schemes, all kinds of nodes
need some random bits. Beacon and beaming nodes
need to generate random bits for broadcasting and sensor
nodes need to generate random indices for picking up
broadcasted random bits. In fact, pseudorandom bits can
replace random bits for better efficiency. A node can
sample a short random seed s from the environment
and uses the pseudorandom bit generator G to generate
pseudorandom bits G(s).
It should be noted that if we use pseudorandom bits in
the scheme, the storage-bounded adversary should be
polynomial-time bounded also, instead of computing-
unboundedness. This is because a computing-unlimited
adversary can search the seed by the eavesdropped
pseudorandom bits and the pseudorandom generator G.
In reality, an adversary may jam the media to block the
process of key establishment. It is hard for wireless commu-
nications to resist this kind of denial of service attacks. Due
to sensor nodesâ€™ low hardware profile, it is not practical for
them to receive the random bits from a satellite. In the above
we only discuss how to establish shared keys for the sensor
nodes that are within the radio range of beacon and beaming
nodes. For others that are neighbored can establish direct link
through the path-key finding process.
VI. CONCLUSIONS
We have introduced the storage-bounded adversary model to
wireless sensor networks and proposed two key establishment
schemes in this model. We are interested in improving effi-
ciency of the schemes for practicability in the future. We are
also interested in proposing different kinds of security schemes
for wireless sensor networks in this model.
REFERENCES
[1] R. Blom. An optimal clas of symmetric key generation systems, EURO-
CRYPT 84, pp. 335-338, 1984.
[2] C. Cachin, U.M. Maurer. Unconditional security against memory-bounded
adversaries, CRYPTO 97, pp.292-306, 1997.
[3] H. Chan, A. Perrig, D. Song. Random key predistribution for sensor
networks, IEEE Symposium on Security and Privacy 03, pp.197-213,
2003.
[4] Y.Z. Ding. Oblivious transfer in the bounded storage model, CRYPTO 01,
pp.155-170, 2001.
[5] W. Du, J. Deng, Y.S. Han, P. Varshney. A pairwise key pre-distribution
scheme for wireless sensor networks, ACM CCS 03, pp.42-51, 2003.
[6] L. Eschenauer, V.D. Gilgor. A key-mamnagement scheme for distributed
sensor networks, ACM CCS 02, pp.41-47, 2002.
[7] D. Liu, P. Ning. Eatablishing pairwise keys in distributed sensor networks,
ACM CCS 03, pp.52-61, 2003.
[8] U.M. Maurer. Conditionally-perfect secrecy and a provably-secure ran-
domized cipher. Journal of Cryptology 5(1), pp.53-66, 1992.
[9] M.J. Miller, N.H. Vaidya. Leveraging channel diversity for key establish-
ment in wireless sensor networks, IEEE INFOCOM 06, pp.1-12, 2006
[10] S. Meguerdichian, F. Koushanfar, M. Potkonjak, B. Srivastava. Coverage
problems in wireless ad-hoc sensor networks, IEEE INFOCOM 01,
pp.1380-1387, 2001.
[11] M. Mitzenmacher, E. Upfal. Probability and Computing: Randomized
Algorithms and Probabilistic Analysis. University of Cambridge Press,
2005.
[12] K. Ren, K. Zeng, W. Lou. A new approach for random key pre-
distribution in large scale wireless sensor networks. Wireless Commu-
nications and Mobile Computing 6(3), pp.307-318, 2006.
2Theorem 2: If n = ad+ b, where 0 â‰¤ b < d, then
P (n, d) â‰¥ ((a+ 1)!)b(a!)dâˆ’b.
Example 1: For d = 2, we get
P (2a, 2) â‰¥ (a!)2.
We note that if 2d > n, then a = 1 and b = n âˆ’ d and
so |C| = 2nâˆ’d. If 2d = n, then a = 2, b = 0, and we
have |C| = 2d = 2nâˆ’d as well. However, if 2d < n, then
|C| > 2nâˆ’d. Especially, when d is small relative to n, |C|
is much larger than 2nâˆ’d. For example, for n = 30, d = 2,
|C|/2nâˆ’d â‰ˆ 6.37Ã— 1015.
This construction has a very simple error correcting algo-
rithm. For d â‰¥ 2t + 1, we can correct error up to size t
in any coordinate. For coordinate i, the codeword has value
pii â‰¡ i (mod d). Suppose that this coordinate is changed into
Ïƒ = pii + u, where |u| â‰¤ t. Then pii is the integer congruent
to i which is closest to Ïƒ. Therefore, decoding of position i
is done by first computing
a â‰¡ iâˆ’ Ïƒ (mod d),
where âˆ’(d âˆ’ 1)/2 â‰¤ a â‰¤ (d âˆ’ 1)/2. Then a = âˆ’u, and so
we decode into Ïƒ + a = pii.
B. First recursive construction
Let C be an (n, d) PA of size M , and let r â‰¥ 2 be an
integer. We define an (rn, rd) PA, Cr, of size Mr as follows:
for each multi-set of r code words from C,
(pi(j)1 , . . . , pi
(j)
n ), j = 0, 1, . . . , r âˆ’ 1,
let
Ïj = (rpi
(j)
1 âˆ’ j, . . . , rpi(j)n âˆ’ j), j = 0, 1, . . . , r âˆ’ 1,
and include (Ï0|Ï1| . . . |Ïrâˆ’1) as a codeword in Cr. It is clear
that under this construction the distance between any two
distinct Ïj , Ïjâ€² is at least rd. It is also easy to check that
(Ï0|Ï1| . . . |Ïrâˆ’1) âˆˆ Srn. Hence |Cr| =Mr. In particular, we
get the following bound.
Theorem 3: If n > d and r â‰¥ 2, then
P (rn, rd) â‰¥ P (n, d)r.
Proof: Let C be an (n, d) PA of size P (n, d). Then
the construction above gives an (rn, rd) PA of Cr. Hence
P (rn, rd) â‰¥ |Cr| = |C|r = P (n, d)r.
C. Second recursive construction
For a permutation pi = (pi1, pi2, . . . , pin) âˆˆ Sn and an integer
m, 1 â‰¤ m â‰¤ n+ 1 define
Ï•m(pi) = (m,piâ€²1, pi
â€²
2, . . . , pi
â€²
n) âˆˆ Sn+1
by
piâ€²i = pii if pii â‰¤ m,
piâ€²i = pii + 1 if pii > m.
Let C be an (n, d) PA, and let
1 â‰¤ s1 < s2 < Â· Â· Â· < st â‰¤ n+ 1
be integers. Define
C[s1, s2, . . . , st] = {Ï•sj (pi) | 1 â‰¤ j â‰¤ t, pi âˆˆ C}.
Theorem 4: If C is an (n, d) PA of size M and
sj + d â‰¤ sj+1 for 1 â‰¤ j â‰¤ tâˆ’ 1,
then C[s1, s2, . . . , st] is an (n+ 1, d) PA of size tM .
Theorem 5: If C is an (n, d) PA of size M and n â‰¤ 2d,
then C[d] is an (n+ 1, d+ 1) PA of size M .
Proof: If j > jâ€², then
dmax(Ï•sj (pi), Ï•sjâ€² (Ïƒ)) â‰¥ sj âˆ’ sjâ€² â‰¥ d.
Next, consider jâ€² = j. If pi, Ïƒ âˆˆ C, pi 6= Ïƒ, then w.l.o.g, there
exist an i such that pii â‰¥ Ïƒi + d. Hence
dmax(Ï•sj (pi), Ï•sj (Ïƒ)) â‰¥
{
pii âˆ’ Ïƒi + 1 > d if pii > sj â‰¥ Ïƒi,
pii âˆ’ Ïƒi â‰¥ d otherwise.
This proves Theorem 4. To complete the proof of Theorem 5
we note that
pii â‰¥ Ïƒi + d â‰¥ d+ 1 > d,
and
Ïƒi â‰¤ pii âˆ’ d â‰¤ nâˆ’ d â‰¤ d.
Hence pii > d â‰¥ Ïƒi and so
dmax(Ï•sj (pi), Ï•sj (Ïƒ)) â‰¥ d+ 1.
The constructions imply bounds on P (n, d).
Theorem 6: If n > d â‰¥ 1, then
P (n+ 1, d) â‰¥
(âŒŠn
d
âŒ‹
+ 1
)
P (n, d).
Proof: Let t = bn/dc + 1. Then (t âˆ’ 1)d + 1 â‰¤ n + 1.
If C is an (n, d) PA of size P (n, d), then Theorem 4 implies
that C[1, d+ 1, 2d+ 1, . . . , (tâˆ’ 1)d+ 1] is an (n+ 1, d) PA
of size tP (n, d). Hence P (n+ 1, d) â‰¥ tP (n, d).
Example 2: In Example 1 we showed that the explicit con-
struction implied that P (2a, 2) â‰¥ (a!)2. Combining Theorem
6 and search, we can improve this bound. We have found that
P (7, 2) â‰¥ 582, see the table at the end of the next section.
From repeated use of Theorem 6 we get
P (2a, 2) â‰¥ (a(aâˆ’ 1) Â· Â· Â· 5)2 Â· 4P (7, 2) â‰¥ 97
24
(a!)2.
Theorem 5 implies the following bound.
Theorem 7: If d < n â‰¤ 2d, then
P (n+ 1, d+ 1) â‰¥ P (n, d).
Proof: Let C be an (n, d) PA of size P (n, d). By Theorem
5, C[d] is an (n+ 1, d+ 1) PA of size P (n, d). Hence
P (n+ 1, d+ 1) â‰¥ |C[d]| = P (n, d).
Theorem 7 shows in particular that for a fixed r,
P (d+ 1 + r, d+ 1) â‰¥ P (d+ r, d) for d â‰¥ r. (1)
We will show that P (d + r, d) is bounded. We show the
following theorem.
4Remark. By a more involved analysis, we can improve
this bound somewhat. For example, we see that two new
permutations can contribute at most 4râˆ’3 to the total support.
We can now complete the proof of Theorem 8. Let C be a
(d+r, r) code of size cr. By Lemma 3, |Ï‡(C)| â‰¤ cr(2râˆ’1)+1.
If d > 1 + cr(2r âˆ’ 1) âˆ’ r, then d + r > |Ï‡(C)|. Hence,
by Lemma 2, P (d âˆ’ 1 + r, d âˆ’ 1) = P (d + r, d). Therefore,
dr â‰¤ 1+cr(2râˆ’1)âˆ’r, that is, (3) is satisfied. This completes
the proof of Theorem 8.
Theorem 9: We have P (d+ 1, d) = 3 for d â‰¥ 2.
Proof: We use the same notation as in the proof of Lemma
2. Let C be an (d + 1, d) PA. The only potent elements are
1 and n. W.lo.g. we may assume the first permutation in C
is (1, n, âˆ—, âˆ—, . . .) where âˆ— denotes some unspecified integer in
the range 2, 3, . . . , d. W.l.o.g, a second permutation has one
of three forms:
(n, 1, âˆ—, âˆ—, . . .), (n, âˆ—, 1, âˆ—, . . .), (âˆ—, 1, n, âˆ—, . . .).
We see that if the second permutation is of the first form, there
cannot be more permutations. If the second permutation is of
the form (n, âˆ—, 1, âˆ—, . . .), then there is only one possible form
for a third permutation, namely (1, âˆ—, n, âˆ—, . . .). Hence we see
that P (d+ 1, d) â‰¤ 3 and that P (d+ 1, d) = 3 for d â‰¥ 2.
To determine P (d + r, d) along the same lines for r â‰¥ 2
seems to be difficult because of the many cases that have to be
considered. Even to determine P (d+2, d) will involve a large
number of cases. For example for the second permutation there
are 138 essentially different possibilities for the four positions
in the potency support of the first permutation. For each of
these there are many possible third permutations, etc.
D. Encoding/decoding of some PA constructed by the second
recursive construction
Suppose we start with the PA
Cd = {(1, 2, 3, . . . , d)}.
For Î½ = d, d+ 1, . . . , nâˆ’ 1 let
CÎ½+1 = CÎ½ [1, Î½ + 1].
Then Cn is an (n, d) PA of size 2nâˆ’d. For some applica-
tions, we may want to map a set of binary vectors to a
permutation array. One algorithm for mapping a binary vector
(x1, x2, . . . , xnâˆ’d) into Cn would be to use the recursive con-
struction of Cn by mapping (x1, x2, . . . , xi) into a permutation
pi in Cd+i. Recursively, we can then map (x1, x2, . . . , xi, 0)
to Ï•1(pi) and (x1, x2, . . . , xi, 1) to Ï•d+i+1(pi).
However, there is an alternative algorithm which requires
less work. Retracing the steps of the construction, we see
that given some initial part of length less than n âˆ’ d of a
permutation in Cn, there are exactly two possibilities for the
next element, one â€largerâ€ and one â€smallerâ€. More precisely,
induction shows that if the initial part of length iâˆ’ 1 contains
exactly t â€smallerâ€ elements, then element number i is either
t+1 (the â€smallerâ€) or nâˆ’ i+ t+1 (the â€largerâ€). This is the
basis for a simple mapping from Znâˆ’d2 to Cn. We give this
algorithm in Figure 1.
Input: (x1, . . . , xnâˆ’d) âˆˆ Znâˆ’d2
Output: (pi1, . . . , pin) âˆˆ Cn
for iâ† nâˆ’ d+ 1 to n do xi â† 0;
tâ† 0; //* t is the number of zeros seen so far.*//
for iâ† 1 to n do
if xi = 0
then {pii â† t+ 1; tâ† t+ 1;}
else {pii â† nâˆ’ i+ t+ 1;}
Fig. 1. Algorithm mapping Znâˆ’d2 to Cn
We see that the difference between the larger and the smaller
element in position i â‰¤ n âˆ’ d is n âˆ’ i. Hence we can
recover from any error of size less than (nâˆ’ i)/2 by choosing
the closest of the two possible values, and the corresponding
binary value. We give the decoding algorithm in Figure 2.
Input: (pi1, . . . , pin) âˆˆ [n]n
Output: (x1, . . . , xnâˆ’d)
tâ† 0; //* t is number of zeros determined. *//
for iâ† 1 to nâˆ’ d do
if pii < (nâˆ’ i)/2 + t+ 1
then {xi â† 0; tâ† t+ 1;}
else {xi â† 1;}
Fig. 2. Decoding algorithm recovering the binary preimage from a corrupted
permutation in Cn.
Without going into all details, we see that we can get a
similar mapping from q-ary vectors. Now we start with the
PA
C(qâˆ’1)d = {(1, 2, 3, . . . , (q âˆ’ 1)d)}.
For (qâˆ’ 1)d â‰¤ Î½ â‰¤ nâˆ’ 1 let sj = (jâˆ’ 1)bÎ½/(qâˆ’ 1)c+1 for
1 â‰¤ j â‰¤ q âˆ’ 1 and sq = Î½ + 1. Let
CÎ½+1 = CÎ½ [s1, s2, . . . , sq].
Then Cn is an (n, d) PA of size qnâˆ’(qâˆ’1)d. Encoding and
decoding correcting errors of size at most (dâˆ’1)/2, based on
the recursion, is again relatively simple.
IV. FURTHER BOUNDS ON P (n, d)
A. General bounds
Since dmax(pi, Ïƒ) â‰¤ nâˆ’1 for any two distinct permutations
in Sn, we have P (n, n) = 1. Therefore, we only consider
d < n.
Since the spheres of radius d in Sn all have size V (n, d),
we can get a Gilbert type lower bound on P (n, d).
Theorem 10: For n > d â‰¥ 2 we have
P (n, d) â‰¥ n!
V (n, dâˆ’ 1) .
Proof: It is clear that the following greedy algorithm pro-
duces a permutation array with cardinality at least n!/V (n, dâˆ’
1).
6Combining equations (33) and (34) in KlÃ¸ve [8] we get the
following lower bound on V (n, d):
V (n, d) â‰¥ n! (2d+ 1)
n
22d nn
. (5)
For d odd, (5) gives
V (n, b(dâˆ’ 1)/2c) = V (n, (dâˆ’ 1)/2) â‰¥ n! d
n
2dâˆ’1 nn
.
Combining this with Theorem 11 we get the following explicit
upper bound on P (n, d).
Corollary 2: For d odd and n > d â‰¥ 1, we have
P (n, d) â‰¤ 2
dâˆ’1nn
dn
.
Similarly, for d even, combining Theorem 11 and Theorem 12
with (5), we get the following.
Corollary 3: For d even and n > d â‰¥ 2, we have
P (n, d) â‰¤ min
{
2dâˆ’2nn
(dâˆ’ 1)n ,
2d(n+ 1)n+1
(d+ 1)n+1
}
.
The bounds on V (n, d), both the upper and the lower, are
in most cases quite weak and so the bounds on P (n, d) also
become quite weak.
B. Table of bounds on P (n, d)
We have used the following greedy algorithm to find an
(n, d) PA C: Let the identity permutation in Sn be the
first permutation in C. For any set of permutations chosen,
choose as the next permutation in C the lexicographically
next permutation in Sn with distance at least d to the chosen
permutations in C if such a permutation exists. The size of
the resulting PA is of course a lower bound on P (n, d).
The lower bounds in Table II were in most cases found by
this greedy algorithm. For n = 8, d = 5, the greedy algorithm
gave a PA of size 26. However,
P (8, 5) â‰¥ P (7, 4) â‰¥ 28
by Theorem 7. Similarly,
P (10, 7) â‰¥ P (9, 6) â‰¥ P (8, 5) â‰¥ 28.
Some other of the lower bounds are also determined using
Theorem 7. They are marked by âˆ—. The upper bound is the
Hamming type bound in Theorem 11 or itâ€™s modified bound in
Theorem 12. Since P (n, 1) = n! for all n, this is not included
in the table.
V. CONCLUSION
We give a number of constructions of permutations ar-
rays under the Chebyshev distance, some with efficient error
correction algorithms. We also consider an explicit mapping
of vectors to permutations with efficient encoding/decoding.
Finally, we give some bounds on the size of PAs under the
Chebyshev distance.
Tamo and Schwartz [15] independently considered this
problem and gave, among other results, a construction equiv-
alent to our first construction as well as some other construc-
tions.
TABLE II
BOUNDS ON P (n, d).
d = 2 d = 3 d = 4
n = d+ 1 3 3 3
n = d+ 2 6âˆ’ 24 9 9âˆ’ 12
n = d+ 3 29âˆ’ 120 20âˆ’ 34 28âˆ’ 43
n = d+ 4 90âˆ’ 720 84âˆ’ 148 68âˆ’ 166
n = d+ 5 582âˆ’ 5040 401âˆ’ 733 283âˆ’ 4077
d = 5 d = 6 d = 7
n = d+ 1 3 3 3
n = d+ 2 9âˆ’ 12 9âˆ’ 18 9âˆ’ 18
n = d+ 3 28âˆ— âˆ’ 43 28âˆ— âˆ’ 60 28âˆ— âˆ’ 60
n = d+ 4 95âˆ’ 166 95âˆ— âˆ’ 216 95âˆ— âˆ’ 216
n = d+ 5 236âˆ’ 714 236âˆ— âˆ’ 850 236âˆ— âˆ’ 850
REFERENCES
[1] P. Cappelletti, C. Golla, P. Olivo, and E. Zanoni, Flash memories.
Kluwer Academic Publishers, 1999.
[2] H. Chadwick, L. Kurz, â€œRank permutation group codes based on
Kendallâ€™s correlation statistic,â€ IEEE Trans. Inform. Th., vol. IT-15, pp.
306â€“315, Mar 1969.
[3] P. Diaconis, Group Representations in Probability and Statistics. Hay-
ward, CA: Institute of Mathematical Statistics, 1988.
[4] S. Haykin, Communication Systems, 4th Ed. John Wiley & Sons, 2001.
[5] A. Jiang, R. Mateescu, M. Schwartz and J. Bruck, â€œRank Modulation for
Flash Memories,â€ in Proc. IEEE Internat. Symp. on Inform. Th., 2008,
pp. 1731-1735.
[6] A. Jiang, M. Schwartz and J. Bruck, â€œError-Correcting Codes for Rank
Modulation,â€ in Proc. IEEE Internat. Symp. on Inform. Th., 2008, pp.
1736-1740.
[7] M. Kendall and J. D. Gibbons, Rank correlation methods. London, U.K.:
Edward Arnold, 1990.
[8] T. KlÃ¸ve, â€œSpheres of Permutations under the infinity norm - permu-
tations with limited displacement,â€ Reports in Informatics, Dept. of
Informatics, Univ. Bergen, Report no. 376, November 2008.
[9] T. KlÃ¸ve, â€œGenerating functions for the number of permutations with
limited displacement,â€ The Electronic Journal of Combinatorics, R104,
vol. 16(1), August 14, 2009.
[10] T. KlÃ¸ve, â€œLower bounds on the size of spheres of permutations under
the Chebychev distance,â€ Designs, Codes and Cryptography, to appear.
[11] D. H. Lehmer, â€œPermutations with strongly restricted displacements,â€ in
Combinatorial Theory and its Applications II, P. ErdoÂ¨s, A. RnÂ´yi and V.
T. SoÂ´s (eds.), Amsterdam: North Holland Publ., 1970.
[12] K. W. Shum, â€Permutation coding and MFSK modulation for frequency
selective channel,â€ IEEE Personal, Indoor and Mobile Radio Commu-
nications, vol. 13, pp. 2063â€“2066, Sept. 2002.
[13] R. P. Stanley, Enumerative Combinatorics, Vol. I. Cambridge, U.K.:
Cambridge Univ. Press, 1997.
[14] E. Stoll and L. Kurz, â€œSuboptimum Rank Detection Procedures Using
Rank Vector Codes,â€ IEEE Trans. Commun., vol. COM-16, pp. 402-
410, June 1968.
[15] I. Tamo and M. Schwartz, â€œCorrecting limited-magnitude errors in the
rank-modulation scheme,â€ arXiv:0907.3387, July 20, 2009.
[16] J.H. van Lint, R. M. Wilson, A Course in Combinatorics, 2nd ed.
Cambridge, U.K.: Cambridge Univ. Press, 2001.
Torleiv KlÃ¸ve (Mâ€™89â€“SMâ€™91â€“Fâ€™03) was born in Voss, Norway, 1943. He
received the Cand. Mag., Cand. Real., and Dr. Philos. degrees from the
University of Bergen, Norway, in 1966, 1967, and 1971, respectively.
He has been with the University of Bergen since 1971, first as Senior
Lecturer in Mathematics, and, since 1982, Professor of Informatics. During the
academic years 1975â€“1976, 1981â€“1982, and 1990â€“1991 he spent sabbaticals
at the University of Hawaii at Manoa. During the academic year 2001â€“
2002, he was a Visiting Professor at The Chinese University of Hong Kong,
and during the fall semester 2002, he was Visiting Professor at Hong Kong
University of Science and Technology. During the academic year 2008â€“2009
he spent a sabbatical at the University of California, Santa Cruz.
å‡ºå¸­ 2010 åœ‹éš›å¯†ç¢¼æœƒè­°(CRYPTO 2010)å ±å‘Š 
æ›¾æ–‡è²´ é™³æ¯…ç¿ 
ä¸€ã€æ™‚é–“èˆ‡åœ°é»ï¼š99/8/16~8/19ï¼ŒU. C. Santa Barbara 
äºŒã€è«–æ–‡ï¼š203ç¯‡æŠ•ç¨¿ï¼Œæ¥å— 39ç¯‡ 
ä¸‰ã€åƒåŠ æœƒè­°ç¶“éï¼š 
ç¬¬ 30å±†åœ‹éš›å¯†ç¢¼æœƒè­° (The 30th Annual Cryptology Conferenceï¼Œç°¡ç¨± CRYPTO 
2010) ç‚ºåœ‹éš›å¯†ç¢¼ç ”ç©¶æœƒ (International Association for Cryptologic 
Researchï¼Œç°¡ç¨± IACR) ä¸»è¾¦ï¼Œä»Šå¹´çš„æœƒè­°åœ¨ç¾åœ‹åŠ å·å¤§å­¸çš„è–å¡”èŠ­èŠ­æ‹‰åˆ†æ ¡èˆ‰è¡Œï¼Œ
èˆ‡æœƒäººæ•¸å…±ç´„ 350äººã€‚æœƒè­°ç‚ºæœŸäº”å¤© (8/16~8/19)ï¼Œé™¤äº†ç¬¬äºŒå¤©ä»¥åŠç¬¬äº”å¤©ä¸‹åˆ
å¤–ï¼Œå…¶é¤˜çš†ç‚ºè«–æ–‡ç™¼è¡¨æ™‚é–“ã€‚ç¬¬ä¸€å¤©çš„æ—©ä¸Šæœ‰å¤§å¸«ç´šçš„å­¸è€…å—é‚€æ¼”è¬›ï¼Œè¬›è€…åˆ†åˆ¥
æœ‰ Shafi Goldwasser (MIT and Weizmamnn) ä»¥åŠ Silvio Micali (MIT)ï¼Œè¬›é¡Œ
æ˜¯ Zero knowledge â€“ 25 Years ã€‚åœ¨æœƒè­°æœƒå ´å…§çš„è¨è«–æ°£æ°›éå¸¸ç†±çƒˆï¼Œä¼‘æ¯æ™‚
é–“éƒ½å¯çœ‹åˆ°è¨±å¤šå­¸è€…åœ¨ç›¸äº’äº¤æµèˆ‡è¨è«–ã€‚ 
 
å››ã€ç™¼è¡¨è«–æ–‡ä»‹ç´¹ï¼š 
ç„¡è«–æ–‡ç™¼è¡¨ã€‚ 
 
äº”ã€èˆ‡æœƒå¿ƒå¾—ï¼š 
æœ¬æ¬¡æœƒè­°å…±æœ‰ 39ç¯‡è«–æ–‡ç™¼è¡¨ï¼Œæ¯ç¯‡ç™¼è¡¨çš„æ™‚é–“ç‚º 25åˆ†é˜ï¼Œåˆ†ç‚º 12å€‹ sessions: 
    Day 1 (8/16) 
    Session 1: Leakage 
    Session 2: Lattice 
    Session 3: Invite Talk 
    Session 4: Homomorphic Encryption 
    Session 5: Theory and Applications 
    (c) Auxiliary-input security.åœ¨è­‰æ˜ä¸€å€‹ PKE schemeçš„å®‰å…¨æ€§ä¸­ï¼Œæ”»æ“Š 
è€…é™¤äº†å¯ä»¥å¾ç³»çµ±å…¬é–‹è¨Šæ¯ä¸­è©´è‘—å–å¾—ç³»çµ±ç§å¯†è³‡è¨Šä¹‹å¤–ï¼Œå¯ä»¥æ›´é€²ä¸€ 
æ­¥åœ°æ¨å»£æˆæ”»æ“Šè€…é‚„æœ‰è¾¦æ³•å¾—çŸ¥ f(secret key,public key)ï¼Œå…¶ä¸­ f 
æ˜¯æ”»æ“Šè€…ä»»æ„é¸å®šçš„ä¸€å€‹å‡½æ•¸ã€‚åœ¨é€™æ¨£å¢å¼·æ”»æ“Šè€…èƒ½åŠ›çš„ PKE scheme 
æ‰€è­‰æ˜çš„å®‰å…¨æ€§çš„å³æ˜¯ auxiliary-input securityã€‚ 
 
åœ¨é€™ç¯‡è«–æ–‡ä¸­ï¼Œä½œè€…æå‡ºäº†ä¸€å€‹ PKE schemeï¼Œé™¤äº†æ»¿è¶³ä¸€èˆ¬å¸¸è¦‹çš„ semantic 
security å¤–ï¼Œæ›´åŒæ™‚æ»¿è¶³äº†ä¸Šè¿°çš„ä¸‰ç¨®å®‰å…¨æ€§ã€‚è€Œé€™ç¯‡è«–æ–‡ä¸­æ‰€æå‡ºçš„ PKE 
schemeæ˜¯åŸºæ–¼ quadratic residuosity (QR) assumption (æˆ–æ˜¯ Paillierâ€™s 
decisional composite residuosity (DCR) assumption)ã€‚ 
 
 
(2) Ali Juma and Yevgeniy Vahlis, â€œProtecting Cryptographic Keys against  
Continual Lekageâ€. 
 
åœ¨ä¸€èˆ¬ç¾å¯¦ä¸­æ‡‰ç”¨çš„åŠ å¯†ç³»çµ±ä¸­ï¼Œside-channel attack æ˜¯æ”»æ“Šè€…å¸¸æœƒä½¿ç”¨
çš„ä¸€é¡æ”»æ“Šæ³•ï¼Œå…¶ä¸»è¦çš„ç²¾ç¥æ˜¯ç±ç”±è¨˜éŒ„ç³»çµ±é‹è¡Œæ™‚çš„å„ç¨®ç‹€æ…‹ä¾†é€²è¡Œç³»çµ±ç§å¯†
è³‡è¨Šçš„åˆ†æåŠå·å–ï¼Œåƒæ˜¯ cold boot attacksã€‚æ‰€ä»¥åœ¨è¨­è¨ˆåŠ å¯†æ¼”ç®—æ³•æ™‚ï¼Œéœ€è¦
å°‡é€™é¡æ”»æ“Šè€ƒæ…®åˆ°å®‰å…¨çš„ modelä¹‹ä¸­ï¼Œè€Œä»¥ä½çš„åŠ å¯†ç³»çµ±åœ¨è­‰æ˜å…¶å®‰å…¨æ€§æ™‚å¤§å¤š
éƒ½æ˜¯å‡è¨­ç³»çµ±åœ¨é‹è¡Œæ™‚ï¼Œç§å¯†çš„è³‡è¨Šæ˜¯ä¸æœƒæ´©éœ²çš„ï¼Œä½†åœ¨ç¾å¯¦ä¸­æ”»æ“Šè€…åœ¨ç³»çµ±é‹
è¡Œä¸­åˆ©ç”¨ side-channel attack ä¾†ç²å¾—ç³»çµ±ç§å¯†çš„è³‡è¨Šå»æ˜¯æœ‰å¯èƒ½çš„ã€‚è€Œä¸€å€‹èƒ½
è¢«è­‰æ˜æŠµæ“‹ side-channel attack çš„åŠ å¯†ç³»çµ±å¯ç¨±ç‚º leakage-resilient 
schemeã€‚ 
åœ¨é€™ç¯‡è«–æ–‡ç•¶ä¸­ï¼Œä½œè€…å€‘æå‡ºä¸€ç¨®åˆ©ç”¨â€fully homomorphic encryption 
with re-randomizable ciphertextsâ€ä¾†ä¿è­·ç³»çµ±ä¸­çš„ç§å¯†è³‡è¨Šå…æ–¼å—åˆ°
side-channel attack çš„æ–¹æ³•ã€‚å…¶ä¸­ä½œè€…å€‘åœ¨è­‰æ˜å®‰å…¨æ€§æ™‚æ˜¯å‡è¨­ç³»çµ±åªæœ‰åœ¨é€²
è¡Œé‹ç®—æ™‚ï¼Œæ‰æœ‰å¯èƒ½è®“æ”»æ“Šè€…åˆ©ç”¨ side-channel attack ä¾†å·å–ç§å¯†è³‡è¨Šï¼Œåƒæ˜¯
cold boot attackå°±æ˜¯è—‰ç”±ä½¿ç”¨è€…åœ¨è§£å¯†æ™‚ï¼Œæœƒå°‡è§£å¯†é‡‘é‘° loadåˆ°è¨˜æ†¶é«”ä¸­æ‰
æœƒè®“æ”»æ“Šè€…æœ‰æ©Ÿæœƒå°‡ç•¶æ™‚çš„è¨˜æ†¶é«”ç‹€æ…‹è¨˜éŒ„ä¸‹ä¾†ä¸¦é€²è¡Œåˆ†æï¼Œè€Œå…¶ä»–æ™‚å€™ä½¿ç”¨è€…
çš„ç§å¯†é‡‘é‘°éƒ½æ˜¯å‡è¨­åœ¨ç³»çµ±ä¸­è¢«å®‰å…¨åœ°ä¿è­·è‘—ã€‚ 
 
 
(3) Shafi Goldwasser and Guy N. Rothblum, â€œSecuring Computation against  
Continuous Leakageâ€. 
 
åœ¨ç¾å¯¦çš„å¯†ç¢¼ç³»çµ±ä¸­ï¼Œæ”»æ“Šè€…å¯åˆ©ç”¨ side-channel attackä¾†å·å–ç³»çµ±ç§å¯†
è³‡è¨Šã€‚è¿‘å¹¾å¹´ä¾†ï¼Œåœ¨è­‰æ˜ä¸€å€‹å¯†ç¢¼ç³»çµ±çš„å®‰å…¨æ€§æ™‚ï¼Œéƒ½æœƒå°‡é€™é¡çš„æ”»æ“Šæ”¾å…¥å®‰å…¨
æ€§ model ä¸­è€ƒé‡åˆ†æï¼Œè€Œæ»¿è¶³é€™ç¨®å®‰å…¨æ€§çš„é€™é¡çš„å¯†ç¢¼æ¼”ç®—æ³•å¯ç¨±ä¹‹ç‚º
leakage-resilient cryptographc algorithmsã€‚ 
æœƒå—åˆ°å¤§å®¶çš„é‡è¦–ã€‚å› æ­¤ï¼Œæˆ‘å€‘ä¹Ÿæ‡‰è©²ç›¡é‡ç™¼è¡¨åœ¨é‡è¦çš„åœ‹éš›æœƒè­°ä¸Šï¼Œæ‰å¯ä»¥çœŸ
æ­£æå‡æˆ‘åœ‹çš„å¯†ç¢¼å­¸ç ”ç©¶å±¤æ¬¡ã€‚å¦å¤–ï¼Œå„åœ‹å­¸è€…åœ¨æœƒè­°æœŸé–“ç©æ¥µçš„è¨è«–èˆ‡äº¤æµçš„
æ…‹åº¦ï¼Œæ˜¯æˆ‘å€‘æ‡‰è©²å­¸ç¿’çš„ã€‚è‹¥æœ‰è¶³å¤ çš„ç¶“è²»è£œåŠ©ï¼Œç„¡è«–æ˜¯å­¸ç”Ÿæˆ–æ˜¯æ•™æˆï¼Œéƒ½æ‡‰è©²
èƒ½å¤šå‡ºåœ‹å¸å–åœ‹å¤–å­¸è€…çš„ç ”ç©¶ç¶“é©—ã€‚ 
 
ä¸ƒã€æ”œå›è³‡æ–™åç¨±èˆ‡å…§å®¹ï¼š 
(1) CRYPTO 2010 æœƒè­°è³‡è¨Š: è¨˜è¼‰æœ¬æ¬¡ç ”è¨æœƒçš„æ™‚é–“ã€åœ°é»ã€æœƒè­°æµç¨‹ã€å ±å‘Šäººå“¡ã€
ä»¥åŠå ±å‘Šé¡Œç›®ç­‰èˆ‡ç ”è¨æœƒç›¸é—œçš„æœƒè­°è³‡è¨Šã€‚ 
(2) CRYPTO 2010æœƒè­°è«–æ–‡é›† (proceeding): æ”¶éŒ„æœ¬æ¬¡ç ”è¨æœƒæ‰€æ¥å—è«–æ–‡ä¹‹å…¨æ–‡è¨˜
éŒ„ã€‚ 
96ï¦ï¨å°ˆé¡Œç ”ç©¶è¨ˆç•«ç ”ç©¶æˆæœå½™æ•´è¡¨ 
è¨ˆç•«ä¸»æŒäººï¼šæ›¾æ–‡è²´ è¨ˆç•«ç·¨è™Ÿï¼š96-2628-E-009-011-MY3 
è¨ˆç•«åç¨±ï¼šå…·å¯†æ–‡èˆ‡ï¤Šé‘°æ•ˆï¥¡ä¹‹å…¬é–‹å¼å»£æ’­åŠ å¯†ç³»çµ±ä¹‹ç ”ç©¶ 
ï¥¾åŒ– 
æˆæœé …ç›® å¯¦éš›å·²é”æˆ
ï¥©ï¼ˆè¢«æ¥å—
æˆ–å·²ç™¼è¡¨ï¼‰
é æœŸç¸½é”æˆ
ï¥©(å«å¯¦éš›å·²
é”æˆï¥©) 
æœ¬è¨ˆç•«å¯¦
éš›è²¢ç»ç™¾
åˆ†æ¯” 
å–®ä½ 
å‚™ è¨» ï¼ˆ è³ª åŒ– ï¥¯
æ˜ï¼šå¦‚ï¥©å€‹è¨ˆç•«
å…±åŒæˆæœã€æˆæœ
ï¦œ ç‚º è©² æœŸ åˆŠ ä¹‹
å° é¢ æ•… äº‹ ...
ç­‰ï¼‰ 
æœŸåˆŠï¥æ–‡ 2 2 100% 
IEEE Trans. 
Wireless 
Communications 
åŠ  IEEE Trans. 
Information 
Theory 
ç ”ç©¶å ±å‘Š/æŠ€è¡“å ±å‘Š 0 0 100%  
ç ”è¨æœƒï¥æ–‡ 2 2 100% 
ç¯‡ 
PKC 2008, ICICS 
2009 åœ‹éš›æœƒè­°ï¥
æ–‡ 
ï¥æ–‡è‘—ä½œ 
å°ˆæ›¸ 0 0 100%   
ç”³è«‹ä¸­ä»¶ï¥© 0 0 100%  å°ˆï§ å·²ç²å¾—ä»¶ï¥© 0 0 100% ä»¶  
ä»¶ï¥© 0 0 100% ä»¶  
æŠ€è¡“ç§»è½‰ 
æ¬Šï§ï¤Š 0 0 100% åƒå…ƒ  
ç¢©å£«ç”Ÿ 0 0 100%  
åšå£«ç”Ÿ 0 0 100%  
åšå£«å¾Œç ”ç©¶å“¡ 0 0 100%  
åœ‹å…§ 
ï¥«èˆ‡è¨ˆç•«äººï¦Š 
ï¼ˆæœ¬åœ‹ç±ï¼‰ 
å°ˆä»»åŠ©ï§¤ 0 0 100% 
äººæ¬¡ 
 
æœŸåˆŠï¥æ–‡ 0 0 100%  
ç ”ç©¶å ±å‘Š/æŠ€è¡“å ±å‘Š 0 0 100%  
ç ”è¨æœƒï¥æ–‡ 0 0 100% 
ç¯‡ 
 
ï¥æ–‡è‘—ä½œ 
å°ˆæ›¸ 0 0 100% ç« /æœ¬  
ç”³è«‹ä¸­ä»¶ï¥© 0 0 100%  å°ˆï§ å·²ç²å¾—ä»¶ï¥© 0 0 100% ä»¶  
ä»¶ï¥© 0 0 100% ä»¶  
æŠ€è¡“ç§»è½‰ 
æ¬Šï§ï¤Š 0 0 100% åƒå…ƒ  
ç¢©å£«ç”Ÿ 0 0 100%  
åšå£«ç”Ÿ 0 0 100%  
åšå£«å¾Œç ”ç©¶å“¡ 0 0 100%  
åœ‹å¤– 
ï¥«èˆ‡è¨ˆç•«äººï¦Š 
ï¼ˆå¤–åœ‹ç±ï¼‰ 
å°ˆä»»åŠ©ï§¤ 0 0 100% 
äººæ¬¡ 
 
 
