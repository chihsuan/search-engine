node x âˆˆ V representing a processor in the system and each edge {x, y} âˆˆ E representing the link
connecting processors x and y. In any distributed system considered in this project, each processor
has a set of shared registers (registers for short). For each register rx in a processor x, only x can
write values into it and only x and its neighbors can read values of it. Each processor is equipped
with a local algorithm that consists of one or more rules of the form:
condition part â†’ action part.
The condition part (or guard) is a Boolean expression of registers of the processor and its neighbors,
and the action part is an assignment of values to some registers of the processor. If the condition
part of one or more rules in a processor is evaluated as true, we say that the processor is privileged
to execute the action part of any of these rules (or privileged to make a move). The local algorithms
of all the processors in a distributed system constitute a distributed algorithm. The local state of a
processor is specified by the values of all its shared registers. The local states of all the processors
in the system constitute a global configuration (configuration for short) of the system.
1.1 Three computational models
The central daemon model was first introduced by Dijkstra [1] in 1974. Under this computational
model, if the system starts with a configuration in which no node in the system is privileged, then
the system is deadlocked. Otherwise, the central daemon in the system will non-deterministically
select exactly one privileged processor and exactly one executable rule in the processorâ€™s local
algorithm, and let the selected processor execute the action part of the selected rule. The local state
of the selected processor thus changes, which in the meantime results in the change of the global
configuration of the system. The system will repeat the above process to change configurations
as long as it does not encounter any deadlock situation. Thus the behavior of the system under
the action of the algorithm can be described by executions defined as follows: an infinite sequence
of configurations Î“ = (Î³1, Î³2, . . .) of a distributed system is called an infinite execution (of the
algorithm in the system) under the central daemon model if for any i â‰¥ 1, Î³i+1 is obtained from Î³i
after exactly one processor in the system makes a move in the ith step Î³i â†’ Î³i+1; a finite sequence
of configurations Î“ = (Î³1, Î³2, . . . , Î³k) of a distributed system is called a finite execution (of the
algorithm in the system) under the central daemon model if (1) k = 1, or for any i = 1, 2, . . . , kâˆ’1,
Î³i+1 is obtained from Î³i after exactly one processor in the system makes a move in the i
th step
Î³i â†’ Î³i+1, and (2) no node is privileged in the last configuration Î³k.
The distributed daemon model was later considered by Burns [2] in 1987. The difference between
the central daemon model and the distributed daemon model is the number of processors that make
moves in a step of an execution of the algorithm. Under the central daemon model, exactly one
privileged processor in the system is non-deterministically selected by the central daemon to make
a move in a step of an execution of the algorithm. Under the distributed daemon model, however,
an arbitrary number of privileged processors are non-deterministically selected by the distributed
daemon to simultaneously make moves in a step. Thus, we can also define executions for the
distributed daemon model as follows: an infinite sequence of configurations Î“ = (Î³1, Î³2, . . .) of
a distributed system is called an infinite execution (of the algorithm in the system) under the
distributed daemon model if for any i â‰¥ 1, Î³i+1 is obtained from Î³i after a certain number of
2
the naturally-adapted version of the DFS algorithm in Collin and Dolev [5] can serve as a
counterexample to show it (see Appendix C of this report).
A self-stabilizing algorithm under a certain computational model is said to be silent if every
execution under that computational model ends up with a safe configuration in which no node is
privileged. Most of the existing self-stabilizing algorithms are silent [3], [6], [7], [8], [9], [10], [11],
[12].
1.3 Self-stabilizing bridge-finding algorithms
Three self-stabilizing bridge-finding algorithms have been proposed in the past: the SBF algorithm
in Karaata and Chaudhuri [3], Phase I of Algorithm A in Chaudhuri [8], and Algorithm UNNS in
Devismes [12]. In [3], under the assumption that a BFS tree has been constructed in a distributed
system, Theorem 13 shows that the SBF algorithm is a self-stabilizing bridge-finding algorithm
under the weakly fair daemon model. Under the assumption that a DFS tree has been constructed
in a distributed system, Lemma 4.17 in [8] and Lemma 2 in [12], respectively, show that the Phase
I part of Algorithm A and Algorithm UNNS are self-stabilizing bridge-finding algorithms under
the central daemon model.
In the Concluding Remarks in [3], it is mentioned that the SBF algorithm and the BFS tree
algorithm in Huang and Chen [6] can be combined to execute concurrently, to achieve the goal
of finding bridges in a self-stabilizing fashion. What this means is that the BFS tree assumption
for Theorem 13 in [3] can be dispensed with. Since the SBF algorithm is self-stabilizing under
the weakly fair daemon model and the BFS tree algorithm in [6] is self-stabilizing under the
distributed daemon model, the combining of the SBF algorithm with the BFS tree algorithm in [6]
indeed yields a self-stabilizing bridge-finding algorithm under the weakly fair daemon model (cf.
Concluding remarks of this report). Nevertheless, since the SBF algorithm is not self-stabilizing
under the central daemon model (see our disproof in Appendix B), the algorithm that results from
the combining of the SBF algorithm and the BFS tree algorithm in [6] cannot be self-stabilizing
under the central daemon model (and therefore not under the distributed daemon model).
Theorem 4.20 in [8] claims that the combining of Algorithm A with the DFS algorithm in Collin
and Dolev [5] produces a self-stabilizing algorithm under the central daemon model, which can find
all the bridge-connected components of the system. If the above claim is true, it implies that the
combining of Phase I of Algorithm A with the DFS algorithm in [5] produces a self-stabilizing
bridge-finding algorithm under the central daemon model. However, this last proposition cannot
be true because the naturally-adapted version of the DFS algorithm in [5] is not self-stabilizing
under the central daemon model (cf. Appendix C of this report).
Theorem 4 in [12] claims that the combining of Algorithm DFS with Algorithm UNNS produces
a self-stabilizing bridge-finding algorithm under the central daemon model, where Algorithm DFS
is any silent self-stabilizing DFS tree-finding algorithm under the central daemon model. However,
even if there may exist such a silent self-stabilizing DFS tree-finding algorithm under the central
daemon model, this claim is still incorrect (see our disproof of this claim in Appendix D).
The failures of all the above three combined algorithms to be self-stabilizing under the central
daemon model reaffirm our viewpoint (to be elaborated in Concluding remarks) that combining
4
meaning of legitimate configurations is clarified - explicitly, it is shown that in any legitimate
configuration, all the bridges in the system can be identified. In Section 4, an example illustrates
the execution of our proposed algorithm. In Section 5, a proof is given to show that the proposed
algorithm is self-stabilizing under the distributed daemon model. Moreover, assuming that a
shortest-path tree has been constructed, the worst-case stabilization time under the distributed
daemon model is computed. In Section 6, Concluding remarks, the issue concerning the combining
of two self-stabilizing algorithms, under different computational models, is discussed.
2 Preliminaries
In this section, some graph-theoretic concepts and properties needed in later discussion are listed.
Let G = (V,E) be a connected simple undirected graph. The removal of an edge {x, y} from G
results in the subgraph Gâˆ’{x, y} that consists of all the nodes of G and all the edges of G except
{x, y}. An edge {x, y} in G is called a bridge in G if Gâˆ’ {x, y} is disconnected.
Property 1 An edge Î± is a bridge in a connected simple undirected graph G if and only if Î± does
not lie on any cycle in G.
Proof. Cf. [14].
Property 2 Suppose Gâ€² = (V,E â€²) is a shortest-path spanning tree rooted at a node r for a con-
nected simple undirected graph G = (V,E). If {x, y} âˆˆ E âˆ’ E â€² (i.e., {x, y} is a non-tree edge),
then x is not a descendant of y and y is not a descendant of x in Gâ€².
Proof. See Appendix A.
Property 3 Suppose Gâ€² = (V,E â€²) is a rooted spanning tree for a connected simple undirected
graph G = (V,E) and {x, y} is an edge in E â€² (i.e., {x, y} is a tree edge) with x being the parent
of y. If {x, y} is not a bridge in G, then there exists an edge {u, v} in E âˆ’ E â€² (i.e., {u, v} is a
non-tree edge) such that u is a descendant of y and v is not a descendant of y in Gâ€².
Proof. See Appendix A.
3 The proposed algorithm and legitimate configurations
In this section, our self-stabilizing algorithm for solving the bridge-finding problem is presented.
The distributed system in consideration has a general underlying topology, and thus can be mod-
elled by a connected simple undirected graph G = (V,E), with each node x âˆˆ V representing a
processor in the system and each edge {x, y} âˆˆ E representing the bidirectional link connecting
processors x and y. It is assumed that
(1) each node in the system has a unique identifier and there is a special node r in the system,
(2) each node x in the system maintains three shared registers dx, px and bx,
(3) N(x) denotes the set of all neighbors of x,
6
Proof. Cf. [10, Theorem 1].
Let VÎ³ = {x âˆˆ V | SPTx is true in Î³}, EÎ³ = {{x, y} âˆˆ E | x, y âˆˆ VÎ³ and px = y in Î³} and
GÎ³ = (VÎ³, EÎ³), a subgraph of G.
Lemma 1 For any configuration Î³ and any edge {x, y} âˆˆ EÎ³, if px = y in Î³, then dx = dy + 1 in
Î³.
Proof. Since {x, y} âˆˆ EÎ³, we have that x âˆˆ VÎ³ and hence SPTx is true in Î³. This, combined
with px = y 6= âŠ¥ in Î³, implies that x 6= r, dx = min
zâˆˆN(x)
(dz + 1) and y = px = min{w âˆˆ N(x) |
dw = min
zâˆˆN(x)
dz} in Î³. Hence dy = min
zâˆˆN(x)
dz in Î³, and hence dx = dy + 1 in Î³.
Note that for any configuration Î³, if {x, y} âˆˆ EÎ³ , then either px = y or py = x in Î³, but not
both (for if px = y and py = x in Î³, it follows from Lemma 1 that dx = dy + 1 and dy = dx + 1 in
Î³, which is impossible). If we consider every edge {x, y} âˆˆ EÎ³ with px = y in Î³ as a directed edge
from x to y, then GÎ³ becomes a directed graph. As usual, the outdegree od(x) of a node x is the
number of all the directed edges of GÎ³ whose initial nodes are x. Since there exists at most one
node y âˆˆ N(x) such that px = y in Î³, we have that od(x) â‰¤ 1 in GÎ³.
Lemma 2 For any configuration Î³, GÎ³ = (VÎ³, EÎ³) is a forest (i.e., a graph with all its connected
components being trees) and each component of GÎ³ is a rooted tree.
Proof. First, we show that GÎ³ is a forest. Suppose GÎ³ is not a forest. Then GÎ³ contains a
cycle Ï„ = (x1, x2, . . . , xk, x1), with k â‰¥ 3. Since x1, x2, . . . , xk are all in VÎ³ , SPTxi is true in Î³ for
all 1 â‰¤ i â‰¤ k.
Case 1. The special node r lies on Ï„ . Without loss of generality, let x1 = r. Hence SPTx1 is true
and px1 = âŠ¥ in Î³. Since {x1, x2} âˆˆ EÎ³ and px1 = âŠ¥ 6= x2 in Î³, we have px2 = x1 in Î³. By the
same token, px3 = x2 in Î³. Arguing in this way, we eventually get that px2 = x1, px3 = x2, . . . ,
pxk = xkâˆ’1 and px1 = xk in Î³, which contradicts the above condition that px1 = âŠ¥ in Î³.
Case 2. The special node r does not lie on Ï„ . Since {x1, x2} âˆˆ EÎ³ , either px1 = x2 or px2 = x1
in Î³. Without loss of generality, let px2 = x1 in Î³. Since {x2, x3} âˆˆ EÎ³ , px3 = x2 in Î³. Arguing in
this way, we eventually get that px2 = x1, px3 = x2, . . . , pxk = xkâˆ’1 and px1 = xk in Î³. By Lemma
1, we have that dx2 = dx1 +1, dx3 = dx2 +1, . . . , dxk = dxkâˆ’1 +1, and dx1 = dxk +1 in Î³. It follows
that dx1 < dx2 < dx3 < Â· Â· Â· < dxk < dx1 in Î³, a contradiction.
Therefore, GÎ³ is a forest.
Next, we show that any component T of GÎ³ is a rooted tree. As remarked previously, GÎ³ can be
considered as a directed graph. Hence the component T of GÎ³ is a directed tree. Also as remarked,
od(x) â‰¤ 1 for any x in V . Hence, to show that T is a rooted tree amounts to showing that there
exists a unique node u in T such that od(u) = 0 in T . (1) We first show that there is a node u
in T such that od(u) = 0 in T . Suppose not. Then for any node x in T , od(x) = 1 in T . Let x1
be any node in T . Since od(x1) = 1 in T , there exists a node x2 in T such that px1 = x2 in Î³.
By the same token, there exist nodes x3, x4, . . . in T such that pxi = xi+1 in Î³ for i = 2, 3, . . ..
Hence, by Lemma 1, dx1 = dx2 + 1, dx2 = dx3 + 1, . . . in Î³, which implies that dx1 > dx2 > Â· Â· Â· in
Î³. Consequently, x1, x2, . . . must be all distinct, which causes a contradiction because T is a tree
with only a finite number of nodes. Therefore, there must be a node u in T such that od(u) = 0 in
8
common ancestor and the lowest common ancestor are as usual. Moreover, we shall call an edge
{x, y} in G a tree edge of G with respect to GÎ³ if {x, y} âˆˆ EÎ³ , and a non-tree edge of G with
respect to GÎ³ if otherwise. Note that for any two nodes x and y, the lowest common ancestor of x
and y exists and is unique, which we shall denote by lca(x, y). For any non-tree edge Î± = {u, v}
of G with respect to GÎ³, let Pu be the unique simple path in GÎ³ connecting u and lca(u, v) and
Pv be the unique simple path in GÎ³ connecting v and lca(u, v). Then the simple paths Pu and Pv
and the edge {u, v} form a cycle in G. Let Ï„u,v denote this cycle.
Lemma 4 Suppose the system is in a legitimate configuration Î³. Then, for any node x, if Î± âˆˆ bx
or Î± âˆˆ bx in Î³, then Î± is a non-tree edge of G with respect to GÎ³, i.e., Î± /âˆˆ EÎ³.
Proof. Suppose Î± is a tree edge of G with respect to GÎ³ . Then Î± /âˆˆ NT (x) in Î³.
Case 1. Î± âˆˆ bx in Î³. Since B3(x) = âˆ… in Î³, Î± /âˆˆ B3(x) in Î³. Then since Î± /âˆˆ NT (x) âˆ§ Î± âˆˆ bx
âˆ§ Î± /âˆˆ B3(x) in Î³, we have that Î± âˆˆ One(x) in Î³. Hence there exists a child x1 of x in GÎ³ such
that Î± âˆˆ bx1 in Î³. By the same token, there exists a child x2 of x1 in GÎ³ such that Î± âˆˆ bx2 in Î³.
Arguing in this way, we eventually get infinitely many nodes x1, x2, . . . in the system such that
xi+1 is a child of xi in GÎ³ for any i = 1, 2, . . .. However, this causes a contradiction because GÎ³ is
a rooted tree with only a finite number of nodes.
Case 2. Î± âˆˆ bx in Î³. Since B4(x) = âˆ… in Î³, Î± /âˆˆ B4(x) in Î³ and hence Î± âˆˆ Two(x) in Î³. Hence
there exist two children u and v of x in GÎ³ such that Î± âˆˆ bu and Î± âˆˆ bv in Î³. By the same argument
as in Case 1 above, we will get a contradiction from the condition that Î± âˆˆ bu.
Therefore, Î± must be a non-tree edge of G with respect to GÎ³ .
Lemma 5 Suppose the system is in a legitimate configuration Î³ and Î± = {u, v} is a non-tree edge
of G with respect to GÎ³. If x is not an ancestor of either u or v in the rooted tree GÎ³, then Î± /âˆˆ bx
in Î³.
Proof. Suppose Î± âˆˆ bx in Î³. Since x is not an ancestor of either u or v in GÎ³, x 6= u and x 6= v.
Thus, Î± /âˆˆ NT (x) in Î³. Since B3(x) = âˆ… in Î³, we have that Î± /âˆˆ B3(x). Since Î± /âˆˆ NT (x), Î± âˆˆ bx
and Î± /âˆˆ B3(x) in Î³, we have that Î± âˆˆ One(x) in Î³. Hence there exists a child x1 of x in GÎ³ such
that Î± âˆˆ bx1 in Î³. Since x is not an ancestor of either u or v in GÎ³ and x1 is a descendant of x,
we have that x1 is not an ancestor of either u or v in GÎ³ . By the same token, there exists a child
x2 of x1 in GÎ³ such that Î± âˆˆ bx2 in Î³, and x2 is not an ancestor of either u or v in GÎ³ . Arguing in
this way, we will eventually get infinitely many nodes x1, x2, . . . in the system such that xi+1 is a
child of xi in GÎ³ for any i = 1, 2, . . .. However, this causes a contradiction because GÎ³ is a rooted
tree with only a finite number of nodes. Therefore, Î± /âˆˆ bx in Î³.
Lemma 6 Suppose the system is in a legitimate configuration Î³. Then, for any node x âˆˆ V and
any edge Î± âˆˆ E, bx cannot contain both Î± and Î± in Î³.
Proof. Suppose both Î± âˆˆ bx and Î± âˆˆ bx in Î³. Since B4(x) = âˆ… in Î³, Î± /âˆˆ B4(x) in Î³. Since
Î± /âˆˆ B4(x) and Î± âˆˆ bx in Î³, Î± âˆˆ Two(x) in Î³ and thus Î± /âˆˆ One(x) in Î³. Then, from condition
[Î± âˆˆ bx âˆ§ Î± /âˆˆ One(x) âˆ§ B3(x) = âˆ… in Î³], it follows that Î± âˆˆ NT (x) in Î³. Let the non-tree edge
Î± be {x, y}. Since Î± âˆˆ Two(x) in Î³, there exists a child v of x in GÎ³ such that Î± âˆˆ bv in Î³. By
10
Lemma 9 Suppose the system is in a legitimate configuration Î³ and Î± = {u, v} is a non-tree edge
of G with respect to GÎ³. If node x lies on the unique simple path P in GÎ³ connecting lca(u, v) in
GÎ³ and the root r, then Î± /âˆˆ bx in Î³.
Proof. Let P = (x0, . . . , xt) with x0 = lca(u, v), xt = r and t â‰¥ 0. By Lemmas 6 and 8,
we have that Î± /âˆˆ bx0 in Î³. If t > 0, then x1 6= lca(u, v). Thus for any child y of x1 in GÎ³ such
that y 6= x0, y cannot be an ancestor of either u or v in GÎ³ . By Lemma 5, Î± /âˆˆ by in Î³. Hence
Î± /âˆˆ One(x1) in Î³. This together with the fact that Î± /âˆˆ E(x1) and B3(x1) = âˆ… in Î³ implies that
Î± /âˆˆ bx1 in Î³. By the same token, if t > 1 then Î± /âˆˆ bx2 in Î³. Arguing in this way, we will get that
Î± /âˆˆ bxi in Î³ for i = 0, . . . , t. Hence the lemma is proved.
Corollary 1 Suppose the system is in a legitimate configuration Î³ and Î± = {u, v} is a non-tree
edge of G with respect to GÎ³. Then, for any node x, Î± âˆˆ bx in Î³ if and only if x lies on the cycle
Ï„u,v in G and x 6= lca(u, v) in GÎ³.
Proof. The â€œifâ€ part is exactly Lemma 7, while the â€œonly ifâ€ part follows immediately from
Lemmas 5 and 9.
For presentationâ€™s sake, we use bâˆ—x to stand for the set {Î± âˆˆ E | Î± âˆˆ bx or Î± âˆˆ bx}.
Corollary 2 Suppose the system is in a legitimate configuration Î³ and Î± = {u, v} is a non-tree
edge of G with respect to GÎ³. Then, for any node x âˆˆ V , Î± âˆˆ b
âˆ—
x in Î³ if and only if x lies on the
cycle Ï„u,v in G.
Proof. This follows immediately from Lemma 8 and Corollary 1.
The following theorem claims that in any legitimate configuration, all the bridges in G can be
identified.
Theorem 1 Suppose the system is in a legitimate configuration Î³. Then
1) no non-tree edge of G with respect to GÎ³ can be a bridge in G, and
2) a tree edge {x, y} of G with respect to GÎ³ is a bridge in G if and only if b
âˆ—
x âˆ© b
âˆ—
y = âˆ… in Î³.
Proof. 1) For any non-tree edge {u, v} of G with respect to GÎ³, the simple paths Pu and Pv
and the edge {u, v} form a cycle Ï„u,v in G. Thus, the edge {u, v} lies on a cycle in G. By Property
1, {u, v} cannot be a bridge in G.
2)(â‡’) Suppose bâˆ—xâˆ©b
âˆ—
y 6= âˆ… in Î³. Then there exists an edge Î² = {u, v} in G such that Î² âˆˆ b
âˆ—
xâˆ©b
âˆ—
y
in Î³. By Lemma 4, Î² is a non-tree edge of G with respect to GÎ³ . By Corollary 2, both x and y
lie on the cycle Ï„u,v in G. Hence, x and y can be connected by a simple path in GÎ³ which lies on
Ï„u,v. This simple path must be exactly the edge {x, y} because {x, y} is the unique simple path
in GÎ³ connecting x and y. Hence the edge {x, y} must lie on the cycle Ï„u,v. By Property 1, {x, y}
cannot be a bridge in G.
(â‡) Suppose {x, y} âˆˆ EÎ³ is not a bridge of G. Without loss of generality, we assume that x
is the parent of y in GÎ³ . By Property 3, there exists a non-tree edge Î² = {u, v} such that u is a
descendant of y and v is not a descendant of y in GÎ³. Let Pu,y be the unique simple path in GÎ³
connecting u and y. For any node z lying on the path Pu,y, z 6= lca(u, v) (for if z = lca(u, v), then
v is a descendant of y, which causes a contradiction). Hence we have that lca(u, v) is an ancestor
of x in GÎ³. By Lemma 8 and Corollary 1, Î² âˆˆ bx or Î² âˆˆ bx in Î³, and Î² âˆˆ by in Î³. Hence b
âˆ—
xâˆ© b
âˆ—
y 6= âˆ…
in Î³.
12
Table 1: An execution of Algorithm 1 under the distributed daemon model for the system in Figure
1.
node 0 node 1 node 2 node 3 node 4 node 5 node 6
d  p   b   d p  b  d p  b  d p  b  d  p  b  d p  b  d p  b 
Î³ 1 2 {{0,1}} 3 3 {{1,3}} 0 4 {{5,6}} 1 2 {{5,6}} 3 5 {{4,6}} 2 4 {{4,5}} 2 âŠ¥ Ïˆ
Î³ 1 2 {{0,1}} 2 3 {{1,3}} 2 4 {{5,6}} 1 2 Ïˆ 1 5 {{4,6}} 2 4 {{4,5}} 2 âŠ¥ Ïˆ
Î³ 0 2 {{0,1}} 2 0 {{1,3}} 2 0 {{5,6}} 1 2 Ïˆ 3 5 {{4,6}} 2 4
{{4,6},
{5,6}}
2 âŠ¥ Ïˆ
Î³ 0 âŠ¥ {{0,1}} 1 0 {{1,3}} 1 0 {{5,6}} 3 2 Ïˆ 3 2 {{4,6}} 2 4
{{4,6},
{5,6}}
3 âŠ¥ Ïˆ
Î³ 0 âŠ¥ {{0,1}} 1 0 {{1,3}} 1 0 {{4,6}} 3 2 Ïˆ 3 2 {{4,6}} 4 4
{{4,6},
{5,6}}
3 5 Ïˆ
Î³ 0 âŠ¥
{{1,3},
{4,6}}
1 0 {{1,3}} 1 0 {{4,6}} 2 2 Ïˆ 2 2 {{4,6}} 4 4
{{4,6},
{5,6}}
3 5 Ïˆ
Î³ 0 âŠ¥
{{1,3},
{4,6}}
1 0 {{1,3}} 1 0 {{4,6}} 2 1 Ïˆ 2 2
{{4,6},
{5,6}}
3 4
{{4,6},
{5,6}}
3 4 Ïˆ
Î³ 0 âŠ¥
{{1,3},
{4,6}}
1 0 Ïˆ 1 0 {{4,6}} 2 1 {{2,3}} 2 2
{{4,6},
{5,6}}
3 4
{{4,6},
{5,6}}
3 4 {{5,6}}
Î³	 0 âŠ¥
{{1,3},
{4,6}}
1 0 Ïˆ 1 0 {{4,6}} 2 1 {{2,3}} 2 2
{{4,6},
{5,6}}
3 4
{{4,6},
{5,6}}
3 4 {{5,6}}
Î³  0 âŠ¥
{{1,3},
{4,6}}
1 0 {{2,3}} 1 0 {{4,6}} 2 1 {{2,3}} 2 2
{{4,6},
{5,6}}
3 4 {{5,6}} 3 4 {{5,6}}
Î³ 0 âŠ¥
{{2,3},
{4,6}}
1 0 {{2,3}} 1 0
{{2,3},
{4,6}}
2 1 {{2,3}} 2 2
{{4,6},
{5,6}}
3 4 {{5,6}} 3 4 {{5,6}}
Î³ 0 âŠ¥
{{2,3},
{4,6}}
1 0 {{2,3}} 1 0
{{2,3},
{4,6}}
2 1 {{2,3}} 2 2 {{5,6}} 3 4 {{5,6}} 3 4 {{5,6}}
Î³ 0 âŠ¥
{{2,3},
{4,6}}
1 0 {{2,3}} 1 0 {{2,3}} 2 1 {{2,3}} 2 2 {{5,6}} 3 4 {{5,6}} 3 4 {{5,6}}
Î³ 0 âŠ¥ {{2,3}} 1 0 {{2,3}} 1 0 {{2,3}} 2 1 {{2,3}} 2 2 {{5,6}} 3 4 {{5,6}} 3 4 {{5,6}}
(6) A step Î³ â†’ Î³â€² of Algorithm 1 is a b-step if it is neither a d-step nor a p-step. (Thus, any
node that makes a move in a b-step must make a b-move.)
Note that in all the rest of this section, we shall let â€œexecutionâ€ mean â€œexecution under the
distributed daemon modelâ€, for brevityâ€™s sake.
The following lemma is obvious in view of the definition of legitimate configuration, the defini-
tion of finite execution, and the definition that an algorithm is self-stabilizing under the distributed
daemon model.
Lemma 10 Algorithm 1 is self-stabilizing under the distributed daemon model if and only if any
execution of Algorithm 1 is a finite execution.
14
Proof of claim. Since the p-values of all the nodes in the system are fixed in Î“, the set
{y âˆˆ N(x) | py = x} does not change due to Î³ â†’ Î³
â€². For any node y in {y âˆˆ N(x) | py = x} that
is not in GËœ, y cannot make any move in any step in Î“ by Claim 1. Hence y cannot make any move
in Î³ â†’ Î³â€² and hence the b-set of y does not change due to Î³ â†’ Î³â€². For any node y in {y âˆˆ N(x)
| py = x} that is in GËœ, y is a child of x in GËœ. By the assumption of this claim, y does not make
any move in Î³ â†’ Î³â€². Hence the b-set of y does not change due to Î³ â†’ Î³â€² either. Consequently,
the b-sets of all the nodes in {y âˆˆ N(x) | py = x} do not change due to Î³ â†’ Î³
â€². This combined
with the fact that the set {y âˆˆ N(x) | py = x} does not change due to Î³ â†’ Î³
â€² implies that the
sets One(x) and Two(x) do not change due to Î³ â†’ Î³â€². Since the p-values of all the nodes in the
system do not change due to Î³ â†’ Î³â€², the set NT (x) does not change due to Î³ â†’ Î³â€².
Subclaim 1. B1(x) = âˆ… in Î³
â€².
Proof of subclaim. Let Î± be any edge.
Case 1. Î± does not satisfy [Î± âˆˆ NT (x) âˆ¨ (Î± âˆˆ One(x) âˆ§ Î± /âˆˆ E(x)) in Î³â€²]. Then Î± /âˆˆ B1(x) in Î³
â€².
Case 2. Î± satisfies [Î± âˆˆ NT (x) âˆ¨ (Î± âˆˆ One(x) âˆ§ Î± /âˆˆ E(x)) in Î³â€²]. Since as shown above the sets
NT (x), E(x) and One(x) do not change due to Î³ â†’ Î³â€², Î± âˆˆ NT (x) âˆ¨ (Î± âˆˆ One(x)âˆ§ Î± /âˆˆ E(x)) in
Î³. Thus, Î± /âˆˆ B2(x) âˆª B3(x) in Î³.
Subcase 2.1. Î± âˆˆ bx in Î³. Then, since Î± âˆˆ bx âˆ§Î± /âˆˆ B2(x)âˆªB3(x) in Î³, Î± âˆˆ bx âˆ’ (B2(x)âˆªB3(x))
in Î³. Hence Î± âˆˆ [bx âˆ’ (B1(x)âˆªB2(x)âˆªB3(x)âˆªB4(x))]âˆªB1(x)âˆªB2(x) in Î³. Since x executes R5
in Î³ â†’ Î³â€², Î± âˆˆ bx in Î³
â€². Hence Î± /âˆˆ B1(x) in Î³
â€².
Subcase 2.2. Î± /âˆˆ bx in Î³. Then, since Î± âˆˆ NT (x) âˆ¨ (Î± âˆˆ One(x) âˆ§ Î± /âˆˆ E(x)) in Î³ and Î± /âˆˆ bx in
Î³, Î± âˆˆ B1(x) in Î³. Hence Î± âˆˆ [bx âˆ’ (B1(x) âˆª B2(x) âˆª B3(x) âˆª B4(x))] âˆª B1(x) âˆª B2(x) in Î³. Since
x executes R5 in Î³ â†’ Î³â€², Î± âˆˆ bx in Î³
â€². Hence Î± /âˆˆ B1(x) in Î³
â€².
From all the above, we can conclude that B1(x) = âˆ… in Î³
â€².
Subclaim 2. B2(x) = âˆ… in Î³
â€².
Proof of subclaim. Let Î± be any edge.
Case 1. Î± does not satisfy [Î± âˆˆ Two(x) âˆ§ Î± /âˆˆ E(x) in Î³â€²]. Then Î± /âˆˆ B2(x) in Î³
â€².
Case 2. Î± satisfies [Î± âˆˆ Two(x) âˆ§ Î± /âˆˆ E(x) in Î³â€²]. Since the sets Two(x) and E(x) do not
change due to Î³ â†’ Î³â€², Î± âˆˆ Two(x) âˆ§ Î± /âˆˆ E(x) in Î³. Thus, Î± /âˆˆ B1(x) âˆª B4(x) in Î³ and hence
Î± /âˆˆ B1(x) âˆªB4(x) in Î³.
Subcase 2.1. Î± âˆˆ bx in Î³. Then, since Î± âˆˆ bx âˆ§ Î± /âˆˆ B1(x) âˆª B4(x) in Î³, Î± âˆˆ [bx âˆ’ (B1(x) âˆª
B2(x) âˆªB3(x) âˆªB4(x))] âˆªB1(x) âˆªB2(x) in Î³. Since x executes R5 in Î³ â†’ Î³
â€², Î± âˆˆ bx in Î³
â€². Hence
Î± /âˆˆ B2(x) in Î³
â€².
Subcase 2.2. Î± /âˆˆ bx in Î³. Then, since Î± âˆˆ Two(x) âˆ§ Î± /âˆˆ E(x) âˆ§ Î± /âˆˆ bx in Î³, Î± âˆˆ B2(x) in Î³
and hence Î± âˆˆ B2(x) in Î³. Thus, Î± âˆˆ [bx âˆ’ (B1(x)âˆªB2(x)âˆªB3(x)âˆªB4(x))]âˆªB1(x)âˆªB2(x) in Î³.
Since x executes R5 in Î³ â†’ Î³â€², Î± âˆˆ bx in Î³
â€². Hence Î± /âˆˆ B2(x) in Î³
â€².
From all the above, we can conclude that B2(x) = âˆ… in Î³
â€².
Subclaim 3. B3(x) = âˆ… in Î³
â€².
Proof of subclaim. Let Î± be any edge.
Case 1. Î± does not satisfy [Î± /âˆˆ NT (x) âˆ§ Î± /âˆˆ One(x) in Î³â€²]. Then Î± /âˆˆ B3(x) in Î³
â€².
Case 2. Î± satisfies [Î± /âˆˆ NT (x) âˆ§ Î± /âˆˆ One(x) in Î³â€²]. Since the sets NT (x) and One(x) do not
change due to Î³ â†’ Î³â€², Î± /âˆˆ NT (x) âˆ§ Î± /âˆˆ One(x) in Î³. Thus, Î± /âˆˆ B1(x) in Î³.
Subcase 2.1. Î± âˆˆ bx in Î³. Then, since Î± /âˆˆ NT (x) âˆ§ Î± /âˆˆ One(x) âˆ§ Î± âˆˆ bx in Î³, Î± âˆˆ B3(x) in
Î³. Hence Î± /âˆˆ (bx âˆ’ B3(x)) âˆª B1(x) in Î³ and hence Î± /âˆˆ [bx âˆ’ (B1(x) âˆª B2(x) âˆª B3(x) âˆª B4(x))] âˆª
16
(2) Inductive step. Assume that k â‰¥ 1 and the claim is true for 1 â‰¤ m â‰¤ k. Let x be any node in GËœ
that has k+1 descendants in GËœ. Let x1, x2, . . . , xj be all the children of x in GËœ andmx1 , mx2 , . . . , mxj
be the number of descendants of x1, x2, . . . , xj in GËœ, respectively. Then mx1 , mx2, . . . , mxj are all
less than or equal to k. By the induction hypothesis, x1, x2, . . . , xj can make a move in at most
mx1 , mx2 , . . . , mxj steps in Î“, respectively. Thus, the number of steps in Î“ in which at least one
child of x in GËœ makes a move is q â‰¤ mx1 +mx2 + Â· Â· Â·+mxj = k. By Claim 4, x can make a move
in q + 1 â‰¤ k + 1 steps in Î“.
By (1), (2) and the postulate of mathematical induction, the claim is proved.
For any node in GËœ, since it has at most n descendants in GËœ, by Claim 5 it can make a move in
at most n steps in Î“. For any node not in GËœ, it cannot make any move in Î“ by Claim 1. Hence,
the number of steps in Î“ is at most n2 and the lemma is proved.
Lemma 12 Any execution of Algorithm 1 which does not contain any d-step is finite.
Proof. Let Î“ be any execution of Algorithm 1 which does not contain any d-step. Then no
node can execute rule R1 or R2 in Î“. Thus, the d-value of each node is fixed in Î“. In view of the
rules R3 and R4, each node can make a p-move in at most one step in Î“. Thus, there exists a suffix
Î“â€² of Î“ such that Î“â€² does not contain any d-step or p-step. Hence Î“â€² is an execution containing
only b-steps. By Lemma 11, Î“â€² is a finite execution. Thus Î“ is a finite execution.
Lemma 13 Any execution of Algorithm 1 contains only a finite number of d-steps.
Proof. For any execution Î“ = (Î³1, Î³2, . . .) of Algorithm 1, let Î³i1, Î³i2, . . ., where i1 < i2 < Â· Â· Â· ,
be all the configurations in Î“ which result from the d-steps (i.e., for any k = 1, 2, ..., the step
Î³ikâˆ’1 â†’ Î³ik is a d-step). If we ignore all the p-values and b-values in these configurations, then
S = (Î³1 = Î³i0, Î³i1, Î³i2, . . .) becomes a segment of execution of the shortest path algorithm in [11]
under the distributed daemon model (i.e., for any k â‰¥ 0, Î³ik â†’ Î³ik+1 is a step of the shortest path
algorithm in [11] under the distributed daemon model). Since, by Theorem 1 in [11], any execution
of the shortest path algorithm under the distributed daemon model must be finite, we have that
S is a finite segment. Therefore, Î“ contains only a finite number of d-steps.
Theorem 2 Algorithm 1 is self-stabilizing under the distributed daemon model and solves the
bridge-finding problem.
Proof. This follows from Lemmas 10, 12, 13 and Theorem 1.
Corollary 3 Under the assumption that SPTx holds for all x in V (i.e., a shortest-path tree has
been constructed in the system), Algorithm 1 is a self-stabilizing bridge-finding algorithm under the
distributed daemon model and stabilizes in at most n2 steps, where n is the number of nodes in the
system.
Proof. Under the assumption that SPTx holds for all x in V , any execution of Algorithm 1
contains only b-steps. Thus the claim of this corollary follows immediately from Lemma 11 and
Theorem 2.
18
R2 : x 6= r âˆ§ dx 6= min
yâˆˆN(x)
(dy + 1)â†’ dx := min
yâˆˆN(x)
(dy + 1)
R3 : x = r âˆ§ dx = 0 âˆ§ px 6= âŠ¥ â†’ px := âŠ¥
R4 : x 6= r âˆ§ dx = min
yâˆˆN(x)
(dy + 1) âˆ§ px 6= min{z âˆˆ N(x) | dz = min
yâˆˆN(x)
dy}
â†’ px := min{z âˆˆ N(x) | dz = min
yâˆˆN(x)
dy}
With priorities properly set, the following combined algorithm was obtained:
Algorithm SP+02
{For any node x}
R1 : x = r âˆ§ dx 6= 0â†’ dx := 0
R2 : x 6= r âˆ§ dx 6= min
yâˆˆN(x)
(dy + 1)â†’ dx := min
yâˆˆN(x)
(dy + 1)
R3 : x = r âˆ§ dx = 0 âˆ§ px 6= âŠ¥ â†’ px := âŠ¥
R4 : x 6= r âˆ§ dx = min
yâˆˆN(x)
(dy + 1) âˆ§ px 6= min{z âˆˆ N(x) | dz = min
yâˆˆN(x)
dy}
â†’ px := min{z âˆˆ N(x) | dz = min
yâˆˆN(x)
dy}
R5 : SPTx âˆ§ [B1(x) 6= âˆ… âˆ¨B2(x) 6= âˆ… âˆ¨ B3(x) 6= âˆ… âˆ¨B4(x) 6= âˆ…]
â†’ bx := [bx âˆ’ (B1(x) âˆª B2(x) âˆªB3(x) âˆª B4(x))] âˆª B1(x) âˆªB2(x),
where
NT (x) = {{x, y} âˆˆ E | py 6= x âˆ§ px 6= y},
One(x) = {Î± âˆˆ E | there is exactly one node u âˆˆ N(x) s.t. pu = x âˆ§ Î± âˆˆ bu},
Two(x) = {Î± âˆˆ E | there are exactly two nodes u, v âˆˆ N(x) s.t. pu = xâˆ§pv = xâˆ§Î± âˆˆ buâˆ§Î± âˆˆ bv},
and
SPTx represents the following predicate:
(x = râˆ§ dx = 0âˆ§ px = âŠ¥)âˆ¨ [x 6= râˆ§ dx = min
yâˆˆN(x)
(dy+1)âˆ§ px = min{z âˆˆ N(x) | dz = min
yâˆˆN(x)
dy}].
Note that this combined Algorithm SP+02 is exactly Algorithm 1, the algorithm proposed in
this report. For this combined algorithm, the presence of a rooted spanning tree is not assumed.
Hence for this algorithm, the shared register px needs to be introduced, and the definitions of
NT (x), One(x) and Two(x) need to be modified, in order to accommodate situations where a
shortest-path tree has not been constructed yet. Moreover, the predicate SPTx is used in R5 to
set priorities. With these standard manipulations in the combining process, Algorithm SP+02
allows Algorithm SP and Algorithm 02 to work concurrently, but gives the Algorithm SP part a
higher priority to execute than the Algorithm 02 part. If the computational model is the weakly
fair daemon, it ensures that the Algorithm SP part will lead the system to the environment in
which a shortest-path tree is always present. Once this is achieved, the Algorithm SP part stops
operating, and the Algorithm 02 part will then lead the system to a legitimate configuration in
which all the bridges of the system can be identified.
The above argument shows that Algorithm SP+02 is a self-stabilizing bridge-finding algorithm
under the weakly fair daemon model, which can dispense with the rooted spanning tree assumption.
Note that this argument has a general nature. That is, an argument such as this can show that
under the weakly fair daemon model, combining two self-stabilizing algorithms using the standard
manipulations as above always yields a self-stabilizing algorithm. (For example, the two-center-
finding algorithm in Huang et al. [9] can also be viewed as obtained from combining two weakly-fair-
20
connecting x and y. Since y âˆˆ Vy and x âˆˆ V âˆ’Vy, there is an edge {u, v} on the path P connecting
Vy and V âˆ’ Vy (i.e., u âˆˆ Vy and v âˆˆ V âˆ’ Vy). Since {u, v} is on P and P is in G âˆ’ {x, y},
{u, v} 6= {x, y}. Since {x, y} is the only tree edge connecting Vy and V âˆ’ Vy, {u, v} must be a
non-tree edge. Thus, we have shown that there exists a non-tree edge {u, v} such that u is a
descendant of y (for u âˆˆ Vy) and v is not a descendant of y (for v âˆˆ V âˆ’ Vy) in G
â€².
B The SBF algorithm in [3]
In this appendix, we show that the SBF algorithm in [3] is not self-stabilizing under the central
daemon model.
First recall the SBF algorithm in [3] as follows:
{For any node x}
VARIABLE s(x) : a subset of elements of the form Î± and {Î±} where Î± is an edge in G
PARAMETER Î± : an edge in G
ACTIONS
G1 : ((incident.Î± âˆ§ Â¬one.Î±) âˆ¨ (Â¬incident.Î± âˆ§ one.Î±)) âˆ§ Î± /âˆˆ s(x)â†’ s(x) := (s(x)âˆ’ {{Î±}}) âˆª {Î±}
G2 : two.Î± âˆ§ {Î±} /âˆˆ s(x)â†’ s(x) := (s(x)âˆ’ {Î±}) âˆª {{Î±}}
G3 : Â¬incident.Î± âˆ§ Â¬one.Î± âˆ§ Î± âˆˆ s(x)â†’ s(x) := s(x)âˆ’ {Î±}
G4 : (Â¬incident.Î± âˆ¨ Â¬one.Î±) âˆ§ Â¬two.Î± âˆ§ {Î±} âˆˆ s(x)â†’ s(x) := s(x)âˆ’ {{Î±}}
where
incident.Î± : Î± is a non-tree edge incident on node x.
one.Î± : Î± is in the s-set of exactly one child of node x in the tree.
two.Î± : Î± is in the s-sets of exactly two children of node x in the tree.
The legal executions (of the SBF algorithm) under the weakly fair daemon model are designed to
be all those single-configuration executions (Î³)â€™s, where Î³ is any configuration in which no node is
privileged. Hence the safe configurations under the weakly fair daemon model are precisely those
configurations in which no node is privileged.
The above SBF algorithm is shown in [3] to be a silent self-stabilizing algorithm under the
weakly fair daemon model for solving the bridge-finding problem. However, if legal executions and
safe configurations (of the SBF algorithm) under the central daemon model are also specified to be
the same as those under the weakly fair daemon model, the SBF algorithm is not self-stabilizing
under the central daemon model, as shown in the following:
Consider now a distributed system G consisting of 5 nodes, as illustrated in Figure 3. Assume
that a BFS spanning tree rooted at node r is already constructed for this system. In Figure 3, the
tree edges indicating the BFS spanning tree of the system are represented by solid lines, while the
non-tree edges are represented by dashed lines. In Figure 3, we exhibit an infinite cyclic central-
daemon-model execution of the SBF algorithm. As one can see, only two configurations appear
alternately in this execution and both configurations are not safe configurations under the central
daemon model. Thus, the SBF algorithm is not self-stabilizing under the central daemon model.
22
C The naturally-adapted version of the DFS algorithm in
[5] to the central daemon model
In this appendix, we show that the naturally-adapted version of the DFS algorithm in [5] to the
central daemon model is not self-stabilizing. Let G = (V,E) be any general network in which there
is a unique special node r, called root. Each node x orders its edges by some arbitrary ordering
Î±x. For any edge e = {x, y}, Î±x(y) is the edge index of e according to Î±x. It is also assumed that
every node x knows the value Î±y(x) of any of its neighbors y. Each node x maintains a variable
pathx. The value of pathx is a sequence of at most N items, where N â‰¥ n (the number of nodes
in G) is a constant positive integer and each item in the sequence is either a positive integer or a
special symbol âŠ¥. The following is the naturally-adapted version of the DFS algorithm in Collin
and Dolev [5]:
Algorithm ADV
{For the root r}
R0 : pathr 6= âŠ¥ â†’ pathr := âŠ¥
{For any node x 6= r}
R1 : pathx 6= minâ‰ºlex{rightN(pathy â—¦ Î±y(x)) | y âˆˆ N(x)}
â†’ pathx := minâ‰ºlex{rightN(pathy â—¦ Î±y(x)) | y âˆˆ N(x)}
Note that in the algorithm,
(a) â‰ºlex is a lexicographical order over the set of all finite sequences of at most N items, and âŠ¥ is
the minimal character. For example, (âŠ¥, 1) â‰ºlex (âŠ¥, 1, 1) â‰ºlex (âŠ¥, 2) â‰ºlex (1);
(b) the notation rightN(w) refers to the sequence of the N least significant item of w. For example,
right6(âŠ¥, 3, 2, 1, 2, 1, 1) = (3, 2, 1, 2, 1, 1) and right6(2, 1, 2, 1, 1) = (2, 1, 2, 1, 1);
(c) pathy â—¦ Î±y(x) is the concatenation of pathy with Î±y(x). For example, if pathy = (1, 2, 1) and
Î±y(x) = 3, then pathy â—¦ Î±y(x) = (1, 2, 1, 3).
Since the DFS algorithm in [5] is self-stabilizing under the read/write atomicity model (cf.
Dolev et al. [15]), and since weakly fair executions have been checked for the self-stabilization
property of the DFS algorithm, it is not difficult to show that its adapted version, Algorithm ADV,
is self-stabilizing when it operates under the weakly fair daemon model. However, Algorithm ADV
is not self-stabilizing under the central daemon model, as we show now in the following:
According to [5], when pathx = pathy â—¦ Î±y(x), node x is a child of node y, and y is a parent
of x. Consider now a distributed system G consisting of 6 nodes as illustrated in Figure 4. The
number N in Algorithm ADV is now set to 6, which is the number of nodes in G. Table 2
exhibits a beginning portion of an infinite cyclic execution of Algorithm ADV in G, under the
central daemon model, with period 13 (note that Î³1 = Î³13). The shaded grid in each configuration
indicates the privileged node selected by the central daemon to make a move. In configuration Î³1,
since pathe â—¦ Î±e(r) = (3, 3) 6= (âŠ¥) = pathr, we have that node r is not a child of node e. On the
other hand, since pathr â—¦ Î±r(e) = (âŠ¥, 1) 6= (3) = pathe in Î³1, we have that r is not the parent
of e in Î³1. Thus, the edge {r, e} is not a tree edge in Î³1. Hence no spanning tree and thus no
DFS tree of G can be identified in Î³1. Consequently, the above algorithm is not a self-stabilizing
DFS-tree-finding algorithm under the central daemon model.
24
Table 2: A beginning portion of an infinite cyclic execution of Algorithm ADV under the central
daemon model for the system in Figure 4.
path 
 path  path  path  path  path 
Î³  âŠ¥ (3) (1,1,1,1,1,1) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,1,1)
Î³  âŠ¥ (3) (1,1,1,1,1,2) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,1,1)
Î³  âŠ¥ (3) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,2,2) (1,1,1,1,1,1)
Î³  âŠ¥ (3) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,1,1) (1,1,1,1,1,1)
Î³  âŠ¥ (3) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,1,1) (1,1,1,1,1,2)
Î³  âŠ¥ (3) (1,1,1,1,2,2) (1,1,1,1,2,2) (1,1,1,1,1,1) (1,1,1,1,1,2)
Î³  âŠ¥ (3) (1,1,1,1,2,2) (1,1,1,1,1,1) (1,1,1,1,1,1) (1,1,1,1,1,2)
Î³  âŠ¥ (3) (1,1,1,1,2,2) (1,1,1,1,1,1) (1,11,,1,1,2) (1,1,1,1,1,2)
Î³  âŠ¥ (3) (1,1,1,1,2,2) (1,1,1,1,1,1) (1,1,1,1,1,2) (1,1,1,1,2,2)
Î³  âŠ¥ (3) (1,1,1,1,1,1) (1,1,1,1,1,1) (1,1,1,1,1,2) (1,1,1,1,2,2)
Î³  âŠ¥ (3) (1,1,1,1,1,1) (1,1,1,1,1,2) (1,1,1,1,1,2) (1,1,1,1,2,2)
Î³  âŠ¥ (3) (1,1,1,1,1,1) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,2,2)
Î³  âŠ¥ (3) (1,1,1,1,1,1) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,1,1)
Î³  âŠ¥ (3) (1,1,1,1,1,2) (1,1,1,1,1,2) (1,1,1,1,2,2) (1,1,1,1,1,1)
â€¦ â€¦ â€¦ â€¦ â€¦ â€¦ â€¦
as Algorithm DFS+UNNS) is a silent self-stabilizing bridge-finding algorithm under the central
daemon model. However, this claim is incorrect, as we disprove it as follows:
Theorem 4 in [12] claims that the combined Algorithm DFS+UNNS stabilizes to PREDFS
and PREUNNS under the central daemon model, where PREUNNS denotes the predicate âˆ€x âˆˆ
V âˆ’{r}, Backx = u(x). This means that the legitimate configurations are all those configurations
in which PREDFS and PREUNNS hold. It is also mentioned in [12] that if Children backx,
Nontree heightx, and Heightx contain the expected values (which is the case under the condition
PREDFS), u(x) is equal to min(Children backx âˆª Nontree heightx âˆª {Heightx}). Hence the
legitimate configurations for Algorithm DFS+UNNS are all those configurations in which the
following conditions hold:
PREDFS and âˆ€x âˆˆ V âˆ’ {r}, Backx = min(Children backx âˆªNontree heightx âˆª {Heightx}.
In other words, the legitimate configurations are all those configurations in which no node in
the system is privileged with respect to Algorithm DFS+UNNS.
Consider now a distributed system G consisting of 4 nodes as illustrated in Figure 5. For this
system, we exhibit in Figure 6 an infinite cyclic execution of the combined Algorithm DFS+UNNS,
under the central daemon model, with period 6. Note that for each node x in the system, the
values of Parx, Cx and Heightx are all fixed in the whole execution, and the shaded nodes in each
configuration stand for the privileged nodes in that configuration. For brevityâ€™s sake, any arrow
from a node i to another node j in Figure 6 indicates Pari = j and Cj = {i}. The existence of
this infinite execution shows that the combined Algorithm DFS+UNNS may not lead the system
to a configuration in which no node is privileged (i.e., a legitimate configuration). Hence it shows
that Algorithm DFS+UNNS is not self-stabilizing under the central daemon model.
26
