2 
æœ¬ç ”ç©¶çš„æˆæœå·²æŠ•ç¨¿ ACM Transactions on Design Automation of 
Electronic Systems, ç›®å‰é€²è¡Œrevised ä¸­. 
â€œIn-place Depth-First Branch-and-Bound Search for the Resource 
Constrained Scheduling Problem during High Level Synthesisâ€ 
CHENG-JUEI YU, YI-HSIN WU, AND SHENG-DE WANG 
4 
å¯åˆ©ç”¨ä¹‹ç”¢æ¥­ 
åŠ 
å¯é–‹ç™¼ä¹‹ç”¢å“ 
 
å½±éŸ³è¨­å‚™ICè¨­è¨ˆ 
æŠ€è¡“ç‰¹é» 
æœ¬ç™¼æ˜ä¿‚æœ‰é—œæ–¼ä¸€ç¨®ç®¡ç·šåŒ–ç§»å‹•ä¼°æ¸¬å™¨åŠç®¡ç·šåŒ–ç§»å‹•ä¼°æ¸¬ç³»
çµ±ï¼Œå¯ä½¿æ¯å€‹è™•ç†å–®å…ƒå„è‡ªè™•ç†ä¸€å€‹ç›®å‰å€å¡ŠåŠå°æ‡‰ä¹‹ä¸€å€‹
åƒè€ƒå€å¡Šçš„è³‡æ–™ï¼Œå¦‚æ­¤ï¼Œè™•ç†å–®å…ƒä¹‹é–“ä¸éœ€é€²è¡Œæ¥ç·šï¼Œè€Œèƒ½
é™ä½é›»è·¯è¤‡é›œåº¦ã€ä¸¦æ¸›å°‘æ‰€éœ€é¢ç©ã€‚å†è€…ï¼Œé‚„èƒ½é¿å…æ–¼æ­¤äº›
è™•ç†å–®å…ƒä¹‹é–“å‚³éè¨ˆç®—çµæœï¼Œå¾è€Œé™ä½æ‰€éœ€çš„è¨ˆç®—æ™‚é–“ã€‚  
æ¨å»£åŠé‹ç”¨çš„åƒ¹å€¼ 
æœ¬ç™¼æ˜æ˜¯æœ‰é—œæ–¼ä¸€ç¨®ä¼°æ¸¬å™¨åŠä¼°æ¸¬ç³»çµ±ï¼Œä¸”ç‰¹åˆ¥æ˜¯æœ‰é—œæ–¼ä¸€
ç¨®ç®¡ç·šåŒ–ç§»å‹•ä¼°æ¸¬å™¨åŠç®¡ç·šåŒ–ç§»å‹•ä¼°æ¸¬ç³»çµ±ã€‚  
â€» 1.æ¯é …ç ”ç™¼æˆæœè«‹å¡«å¯«ä¸€å¼äºŒä»½ï¼Œä¸€ä»½éš¨æˆæœå ±å‘Šé€ç¹³æœ¬æœƒï¼Œä¸€ä»½é€ è²´å–®ä½ç ”ç™¼æˆæœæ¨å»£å–®ä½ï¼ˆå¦‚
æŠ€è¡“ç§»è½‰ä¸­å¿ƒï¼‰ã€‚ 
â€» 2.æœ¬é …ç ”ç™¼æˆæœè‹¥å°šæœªç”³è«‹å°ˆåˆ©ï¼Œè«‹å‹¿æ­éœ²å¯ç”³è«‹å°ˆåˆ©ä¹‹ä¸»è¦å…§å®¹ã€‚ 
â€» 3.æœ¬è¡¨è‹¥ä¸æ•·ä½¿ç”¨ï¼Œè«‹è‡ªè¡Œå½±å°ä½¿ç”¨ã€‚ 
 
[Sllame and Drabek 2002], and [Krishnan and Katkoori 2006] use various heuristics to 
find good designs.  
Besides heuristic algorithms, mathematical formulations are a kind of approaches to 
exactly solve the scheduling problem. Methodologies presented in [Hwang et al. 1991; 
Gebotys and Elmasry 1993; Chaudhuri et al. 1994] are such mathematical approaches 
that formulate the synthesis problem as an integer linear programming (ILP) problem, 
which is NP-complete in general and involves the optimization of a linear objective 
function, subject to linear equality and inequality constraints. These approaches give 
optimal solutions, but their computational complexity is exponential; as the number of 
variables in the formulations increases very rapidly with the size of the DFG, tight 
resource constraints can cause ILP models to take inordinately long to be solved 
[Narasimhan and Ramanujam 2001].  
Another approach for exactly solving this problem is using graph search algorithms, 
which are a general algorithmic method for finding optimal solutions of various 
optimization problems. Two such algorithms are BULB [Narasimhan and Ramanujam 
2001] and A* approach [Wu et al. 2009]. BULB uses a branch-and-bound search method 
which is basically an enumeration approach in a fashion that prunes inferior design points, 
and tries to decompose the scheduling problem into a number of smaller subproblems, 
many of which need not be solved because of the use of upper- and lower-bounding 
techniques. However, refer to the results provided by RECALS II [Rim and Jain 1994], 
the schedules produced by BULB can be further improved. The A* approach traverses 
the search space with the help of an admissible heuristic proposed by Langevin and 
Cenry [1996] to guide the path extraction. For a given consistent heuristic, the A* 
algorithm is guaranteed to find an optimal goal with the minimum number of nodes 
expanded among all algorithms [Zhang 1999]. However, compared to BULB, the run 
times of the A* approach are too long, and its space complexity is exponential [Russell  
and Norvig 2003], resulting in a chance of running out of space such that it cannot 
guarantee the solution optimality.  
In this paper, we present a search strategy using the depth-first branch-and-bound 
(DFBnB) method [Zhang 1999] for computing exact solutions to the RCS problem. 
Instead of using naÃ¯ve DFBnB whose space complexity is linear in the search depth, we 
propose a modified version of DFBnB, which is an in-place algorithm [Cormen et al. 
2001] that only needs a small, constant amount of extra storage space during the search 
process. Using a lexicographical ordering method described in [Knuth 2006] for 
generating combinations, the in-place algorithm visits search nodes in such a way that 
solution achieved so far, can be updated when a leaf is visited. The completion of the 
search process occurs when Î± reaches C(r), or all the search tree is traversed. 
 
 
Fig. 1  The search tree.  
 
DFBnB, best-first search (BFS), iterative-deepening (ID), and recursive best-first 
search (RBFS) are various search strategies that can traverse a search tree. However, as 
discussed in [Zhang and Korf 1995], the space complexity of BFS (as well as A*) is 
typically exponential, ID should be applied to problems that cannot be represented by 
bounded-depth trees, and RBFS should be adopted on a problem that can be solved in 
polynomial time. DFBnB is the best, however, on a problem that requires exponential 
computation, and whose search space can be represented by a bounded-depth tree. 
Therefore, for the RCS problem we choose DFBnB to be the search strategy. 
Fig. 2 shows the naÃ¯ve procedure of DFBnB (with a slight modification of discarding 
edge costs since each of them is identical in our approach) introduced by W. Zhang 
[1999], which is invoked with NaÃ¯veDFBnB( r, C(r), âˆ ). In the procedure, all k children 
n1, n2, â€¦, nk of search node n are generated and each of them is evaluated by C(ni) to 
check whether the search should be deepened or not. If some child ni is a goal node such 
that h(
in
U ) equals 0, the upper bound Î± is updated. In addition, if Î± reaches the lower 
bound of the DFG, an exception is reported to indicate the completion of the search 
process.  
Conceptually, the procedure of DFBnB starts from the root, and has the following 
three different actions at each search node: a) branches to its leftmost (first) child b) 
bounds to its right sibling, and 3) jumps (backtracks) to its uncle when all its siblings are 
visited. Since for a given DFG and some resource constraints there are typically many 
As introduced by Knuth [2006], instead of merely generating all combinations, we 
often prefer to visit them in such a way that each one is obtained by making only a small 
change to its predecessor. For instance, as shown in Fig. 3 which is a lexicographical 
order of ï£·ï£·
ï£¸
ï£¶
ï£¬ï£¬
ï£­
ï£«
5
10
 = 252 combinations, the ith combination can be obtained from the i-1th by 
applying Algorithm L specified in [Knuth 2006]. Thus, let the ith combination be exactly 
the ith child of search node n, we can orderly visit all Kn children appeared in (1) without 
keeping any parent nodes in memory. 
 
Fig. 3.  The lexicographical order of ï£·ï£·
ï£¸
ï£¶
ï£¬ï£¬
ï£­
ï£«
5
10
 = 252 combinations. Each column represents 
a combination with 5 light cells selected out of 10. 
 
Typically a DFG may have two or more resource classes, say multiplier Î² and adder 
Î³, such that we have to generate combinations for Î² and Î³ separately. Fig. 4 specifies 
the method of enumerating the next combination (or right sibling, equivalently) of search 
node n, consider resource classes Î² and Î³. When the enumeration of combinations for 
Î² is finished, we reinitialize the combination for  Î² and advance to the enumeration of 
combinations for Î³. 
______________________________________________________________ 
 
NextCombination( n ): 
if n has next combination for Î² 
apply Algorithm L for Î² 
/* enumeration of combinations for Î² is finished */ 
else if  n has next combination for Î³ 
reinitialize the combination for  Î² 
apply Algorithm L for Î³ 
/* both enumerations are finished */ 
else return null 
______________________________________________________________ 
 
Fig. 4.  Enumerate the next combination of n, consider resource classes Î² and Î³. 
 
 
Child( n ): 
assign the first Xm out of Ym operations at Rn to time-step d(n)+1 
d(n) â† d(n) + 1 
update Rn 
______________________________________________________________ 
 
Sibling( n ): 
n â† NextCombination( n ) 
if  n = null 
n â† Parent( n ) 
return Sibling( n ) 
else return  n  
______________________________________________________________ 
 
Parent( n ): 
if  d(n) = 1  
raise SearchCompleteException 
else  
d(n)â† d(n) - 1 
update Rn 
end 
______________________________________________________________ 
 
Fig. 6.  Tree traversal operations. 
 
Recall that the lower bound on the completion time of partial schedule Pn is 
determined by C(n) = d(n) + h(Un). Since the number of partial schedules is generally 
very high in the design space search, the estimate function h for partial schedules should 
be faster than that for the entire DFG. One method of computing h is proposed by 
Tiruvuri and Chung [1998], denoted Î¨, which has the computational complexity of O(n 
+ c2), where n is the number of nodes in the DFG and c is the critical path. Another 
method proposed by Langevin and Cenry [1996], denoted Î©, has a higher complexity, 
O(n2 + c2), which recursively applies the algorithm proposed by Rim and Jain [1994] by 
n times. Though Î© is slower, sometimes it can produce tighter bounds than Î¨. Therefore, 
since the lower bound for the entire DFG, C(r), needs to be accurate and is computed 
only once before the search, we use Max(Î¨, Î©) to determine the value of C(r). Besides, 
the faster one Î¨ is used for computing h(Un) during the search execution. 
 
4. EXTENSIONS 
 Our approach is basically designed for unit-cycle operations. For supporting pipelined 
and multicycle operations, we follow the same idea discussed in [Rim and Jain 1994; Wu 
2  2 
3  3 
18 
17 
<0.01 
<0.01 
18 
17 
 <0.01 
 <0.01 
18 
17 
0.09 
0.08 
18 
- 
18 
17 
ARF 1  1 
2  1 
2  2 
3  1 
4  1 
3  2 
3  3 
4  2 
34 
18 
18 
16 
16 
15 
15 
11 
11.22 
0.29 
2.34 
<0.01 
<0.01 
10.90 
11.35 
<0.01 
34 
18 
18 
16 
16 
15 
15 
11 
2.1 
2.7 
5.5 
3.4 
3.4 
33.9 
32.7 
3.2 
34 
18 
18 
16 
16 
15 
15 
11 
0.07 
0.87 
0.19 
2.36 
0.45 
2.12 
1.92 
0.22 
34 
18 
- 
16 
- 
15 
15 
- 
34 
18 
- 
16 
- 
15 
- 
11 
FDCT 1  1 
2  1 
2  2 
2  3 
3  2 
3  3 
3  4 
4  2 
4  3 
4  4 
4  5 
5  4 
5  5 
8  4 
34 
26 
18 
18 
14 
14 
14 
13 
11 
11 
11 
10 
10 
08 
0.01 
<0.01 
â€ â€  
<0.01 
213.25 
1.03 
â€ â€  
<0.01 
107.03 
<0.01 
<0.01 
<0.01 
<0.01 
<0.01 
34 
26 
18 
18 
14 
14 
14 
13 
11 
11 
11 
10 
10 
08 
1.1 
1.0 
1.3 
1.6 
1.4 
1.5 
85.3 
15.9 
2.2 
250.9 
308.7 
1.6 
1.2 
1.5 
34 
26 
18 
18 
14 
14 
14 
13 
11 
11 
11 
10 
10 
08 
0.38 
0.05 
0.23  
0.11 
0.23 
0.11 
0.06 
  4.91 
101.08 
100.46 
119.89 
0.04 
0.04 
0.03 
34 
- 
18 
- 
14 
14 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
2 
times 
unfolded 
EWF 
1  1 
2  1 
1  2 
2  2 
1  3 
2  3 
3  3 
56 
56 
41 
35 
41 
35 
33 
<0.01 
<0.01 
0.04 
0.02 
0.04 
0.01 
<0.01 
56 
56 
40 
35 
40 
34 
33 
43.3 
44.1 
12.1 
8.8 
12.1 
3.8 
3.4 
 
 
â€  
 
â€  
â€  
56 
56 
40 
35 
40 
34 
33 
2.09 
2.06 
2.05 
2.10 
2.06 
2.01 
1.98 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
3 
times 
unfolded 
EWF 
1  1 
2  1 
1  2 
2  2 
1  3 
2  3 
3  3 
84 
84 
61 
52 
61 
52 
49 
<0.01 
<0.01 
0.08 
0.04 
0.08 
2460 
<0.01 
84 
84 
59 
52 
59 
50 
49 
451.4 
460.0 
136.3 
111.3 
136.6 
66.4 
61.6 
 
 
â€  
 
â€  
â€  
84 
84 
59 
52 
59 
50 
49 
12.12 
12.19 
12.91 
15.73 
13.02 
12.05 
11.67 
84 
- 
- 
52 
- 
50 
49 
84 
- 
- 
52 
- 
50 
49 
Bench- 
mark 
# of 
*p, a 
BULB 
#steps 
BULB 
sec. 
A* 
#steps 
A* 
sec. 
DFBnB 
#steps  
DFBnB 
sec. 
DPS 
#steps 
RECALS 
II  #steps 
EWF 1  1 
1  2 
28 
19 
<0.01 
0.04 
28 
19 
0.7 
0.1 
28 
19 
0.13 
0.13 
- 
- 
28 
19 
exponential in the search depth. We demonstrated the effectiveness of our approach by 
comparing the run times and the produced schedule lengths to the BULB [Narasimhan 
and Ramanujam 2001] and A* approach [Wu et al. 2009]. The experimental results show 
that in most cases, our algorithm is much faster than A* approach, and in some larger-
sized problems, our approach can produce superior schedules than BULB. Therefore, our 
work eliminates the need of replacing exact techniques with heuristic-based approaches 
in an effort to obtain good solutions within acceptable runtimes, and can solve the 
scheduling problems by using a simple platform running a search algorithm. 
 
REFERENCES 
SLLAME, A.M. AND DRABEK, V. 2002. An efficient list-based scheduling algorithm for high-level synthesis. 
In Digital System Design, 2002. Proceedings. Euromicro Symposium on, 316-323. 
 
HWANG, C.T., LEE, J.H. AND HSU, Y.C. 1991. A formal approach to the scheduling problem in high level 
synthesis. Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on 10, 464-475. 
 
GEBOTYS, C.H. AND ELMASRY, M.I. 1993. Global optimization approach for architectural synthesis. 
Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on 12, 1266-1278. 
 
GAJSKI, D.D. AND RAMACHANDRAN, L. 1994. Introduction to high-level synthesis. Design & Test of 
Computers, IEEE 11, 44-54. 
 
TIRUVURI, G. AND CHUNG, M. 1998. Estimation of lower bounds in scheduling algorithms for high-level 
synthesis. ACM Trans. Des. Autom. Electron. Syst. 3, 162-180. 
 
PARK, I.C. AND KYUNG, C.M. 1993. FAMOS: an efficient scheduling algorithm for high-level synthesis. 
Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on 12, 1437-1448. 
 
NESTOR, J.A. AND KRISHNAMOORTHY, G. 1993. SALSA: a new approach to scheduling with timing 
constraints. Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on 12, 1107-1122. 
 
KRISHNAN, V. AND KATKOORI, S. 2006. A genetic algorithm for the design space exploration of datapaths 
during high-level synthesis. Evolutionary Computation, IEEE Transactions on 10, 213-229. 
 
LANGEVIN, M. AND CERNY, E. 1996. A recursive technique for computing lower-bound performance of 
schedules. ACM Trans. Des. Autom. Electron. Syst. 1, 443-455. 
 
NARASIMHAN, M. AND RAMANUJAM, J. 2001. A fast approach to computing exact solutions to the 
resource-constrained scheduling problem. ACM Trans. Des. Autom. Electron. Syst. 6, 490-500. 
 
RIM, M. AND JAIN, R. 1994. Lower-bound performance estimation for the high-level synthesis scheduling 
problem. Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on 13, 451-458. 
 
PARK, N. AND PARKER, A.C. 1988. Sehwa: a software package for synthesis of pipelines from behavioral 
specifications. Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on 7, 356-370. 
 
CHAUDHURI, S., WALKER, R.A. AND MITCHELL, J.E. 1994. Analyzing and exploiting the structure of the 
constraints in the ILP approach to the scheduling problem. Very Large Scale Integration (VLSI) Systems, IEEE 
Transactions on 2, 456-471. 
 
WU, Y.H., YU, C.J. AND WANG, S.D. 2009. Heuristic algorithm for the resource constrained scheduling 
problem during high-level synthesis. Computers & Digital Techniques, IET 3, 43-51. 
 
W. Zhang. State Space Search: Algorithms, Complexity and Applications. New York: Springer-Verlag, 1999. p. 
145. 
 
A System-level Power Estimation Approach based 
on RTL Macro-Modeling and Using SystemC 
æ‘˜è¦ 
å› ç‚ºç³»çµ±å–®æ™¶ç‰‡(SoC)çš„å¿«é€Ÿç™¼å±•å°¤å…¶å°å¯æ”œå¼çš„é›»å­ç”¢å“çš„é«˜åº¦éœ€æ±‚é‡ï¼Œç‚º
äº†è®“ä½¿ç”¨è€…èƒ½åœ¨æœ‰é™çš„é›»æ± èƒ½é‡ä¸‹ï¼Œæœ‰æ›´é•·çš„ä½¿ç”¨æ™‚é–“ï¼Œå› æ­¤åŠŸç‡æ¶ˆè€—æˆç‚ºå¦ä¸€
å€‹è¨­è¨ˆé™åˆ¶å› ç´ ã€‚å†åŠ ä¸Šå¿«é€Ÿå°å…¥å¸‚å ´æ™‚ç¨‹çš„å£“åŠ›ï¼Œç³»è¨­è¨ˆè€…éœ€è¦èƒ½åœ¨æ›´æ—©è¨­è¨ˆ
éšæ®µå³å°åŠŸç‡æ¶ˆè€—ä½œè©•ä¼°åˆ†æä¸¦åŠ é€Ÿç³»çµ±è¨­è¨ˆçš„æ™‚ç¨‹ã€‚å› æ­¤åœ¨æœ¬ç ”ç©¶ä¸­ï¼Œä¸»è¦æ¢
è¨çš„ä¸»é¡Œå³ç‚ºç³»çµ±å±¤ç´šçš„åŠŸç‡æ¶ˆè€—è©•ä¼°æ–¹æ³•ï¼ŒåŸºæ–¼ç¾ä»Šä¸»è¦çš„è¨­è¨ˆæ–¹æ³•ï¼çŸ½æ™ºç”¢
(Intellectual Propertyï¼ŒIP)é‡è¦†ä½¿ç”¨çš„æ¦‚å¿µä¸‹ï¼Œæˆ‘å€‘æ‡‰è©²äº¦èƒ½å¤ åŠ å…¥ IP è³‡è¨Šå†æ¬¡åˆ©
ç”¨çš„è€ƒé‡é»ã€‚å› æ­¤åœ¨æœ¬ç ”ç©¶ä¸­åŸºæ–¼é€™å€‹åŸºæœ¬æ¦‚å¿µï¼Œå»¶ä¼¸å‡ºä¸€äº›æ–°çš„çœ‹æ³•ã€‚åŒæ™‚å°
æ–¼é‡è¦†ä½¿ç”¨è³‡è¨Šçš„æ–¹å¼ï¼Œæˆ‘å€‘æ¡ç”¨ Macro-Modeling æ–¹å¼ä¾†é‡å»ºåŠŸç‡æ¶ˆè€—è¨Šæ¯çš„ç›¸
é—œè³‡è¨Šåº«ï¼Œå³ç‚ºé‡æ¸¬è¼ƒä½éšç´šçš„æœ€å°æ“ä½œè¡Œç‚ºæ¨¡å‹çš„åŠŸç‡æ¶ˆè€—è³‡è¨Šï¼Œä¸¦ä¸”æ–¼ç³»çµ±
å±¤ç´šé‡æ–°ä½¿ç”¨ä¹‹ï¼Œå› æ­¤æˆ‘å€‘å¯åŸºæ–¼é€™æ¨£çš„æ“ä½œè¡Œç‚ºæ¨¡å‹å»å»ºæ§‹å‡ºç³»çµ±å±¤ç´šçš„æ¶æ§‹ï¼Œ
é€²è€Œå®Œæˆç³»çµ±å±¤ç´šçš„åŠŸç‡æ¶ˆè€—è©•ä¼°æ¨¡å‹ã€‚ç”±å¯¦é©—æ¨¡æ“¬åˆ†æçš„çµæœå¯å¾—çŸ¥ï¼Œæˆ‘å€‘å¯
è—‰ç”±ç³»çµ±å±¤ç´šçš„æŠ½è±¡åŒ–é€²è€Œæä¾›æ›´ç‚ºå¿«é€Ÿçš„æ¨¡æ“¬é©—è­‰ç’°å¢ƒä¸¦æä¾›æŸç¨‹åº¦ä¸Šçš„æº–ç¢º
æ€§ï¼›ç›¸è¼ƒæš«å­˜å™¨å‚³è¼¸å±¤ç´š(RTL)çš„æ–¹æ³•ï¼Œæˆ‘å€‘çš„æ–¹æ³•æ‰€è©•ä¼°å‡ºçš„åŠŸç‡æ¶ˆè€—åˆ†ææ•¸æ“š
åŒæ¨£å¯é”ç›¸ç•¶æ¥è¿‘çš„æº–ç¢ºæ€§ï¼›è€Œé©—è­‰æ‰€éœ€çš„æ™‚é–“ï¼Œä¾æ‰€æ¶æ§‹çš„ç’°å¢ƒè¤‡é›œåº¦ï¼Œæœ‰åŠ 
é€Ÿæ•¸åå€åˆ°æ•¸ç™¾å€ä¹‹å·®ã€‚ 
 
é—œéµå­—ï¼šç³»çµ±å±¤ç´šï¼ŒåŠŸç‡æ¶ˆè€—è©•ä¼°ï¼ŒSystemC 
1. ç·’ï¥ 
1.1 ç°¡ä»‹ 
ç”±æ–¼å¯æ”œå¸¶å¼ç³»çµ±çš„é«˜åº¦å¸‚å ´éœ€æ±‚ä»¥åŠå„ç¨®é›»å­ç”¢å“æ•´åˆåº¦è¶Šä¾†è¶Šé«˜ï¼Œå°¤å…¶
æ˜¯åœ¨å¯æ”œå¸¶å¼é›»å­æ¶ˆè²»ç”¢å“ï¼Œä¾‹å¦‚å€‹äººè¡Œå‹•é›»è©±ã€å€‹äººæ•¸ä½åŠ©ç†(PDA)èˆ‡ç­†è¨˜å‹é›»
è…¦ç­‰ç”¢å“çš„é«”ç©è¶Šä¾†è¶Šéˆå·§ï¼Œä½†æ˜¯åŠŸèƒ½çš„éœ€æ±‚ä¹Ÿè¶Šä¾†è¶Šä¾†å¤šï¼Œå› æ­¤å…§éƒ¨æ™¶ç‰‡é›»è·¯
è¶Šè¨­è¨ˆè¶Šè¤‡é›œï¼Œé›»è·¯é¢ç©ä¹Ÿè¶Šä¾†è¶Šå¤§ã€‚ 
éš¨è‘—è£½ç¨‹æŠ€è¡“çš„é€²æ­¥ï¼Œé›»å­ç”¢å“ä¸­çš„æ™¶ç‰‡è¨­è¨ˆèµ°å‘SoCå·²ç¶“æ˜¯å¤§å‹¢æ‰€è¶¨äº†ã€‚å°¤
å…¶ç¾ä»Šé›»è·¯è¨­è¨ˆä¸­ï¼Œè¦æ±‚é«˜è¼¸å‡ºç‡èˆ‡ä½ç¸½æ™‚é–“å»¶é²ä¹‹æƒ…æ³ä¸‹ï¼Œæ“ä½œé€Ÿåº¦æœå‘æ¥µé™
é‚é€²ï¼Œå°è‡´åŠŸç‡æ¶ˆè€—å¤§å¤§çš„å¢åŠ ï¼Œä¸¦ä¸”ç”¢ç”Ÿäº†å†·å»æ•£ç†±çš„æˆæœ¬ä»¥åŠç”¢å“å¯é åº¦çš„
å•é¡Œã€‚ 
é«˜æ•ˆèƒ½æ™¶ç‰‡çš„å…±åŒç‰¹é»æ˜¯é«˜æ•´åˆå¯†åº¦å’Œé«˜æ™‚è„ˆé »ç‡ï¼Œå¦‚æ­¤åŠŸç‡æ¶ˆè€—ä»¥åŠæº«åº¦
éƒ½å°‡å› æ“ä½œæ™‚è„ˆé »ç‡å¢åŠ è€Œå¢åŠ ã€‚ç”±æ–¼æ¶ˆè€—çš„ç†±èƒ½å¿…é ˆæœ‰æ•ˆçš„ç§»å‡ºä»¥ä½¿å¾—æ™¶ç‰‡çš„
æº«åº¦èƒ½ä¿æŒåœ¨å¯æ¥å—çš„ç¯„åœï¼Œæ™¶ç‰‡å°è£ã€å†·å»ä»¥åŠæ•£ç†±çš„æˆæœ¬å‡è®Šæˆé€™äº›é›»è·¯çš„
é‡è¦é™åˆ¶å› ç´ ã€‚å°¤å…¶æ”œå¸¶å¼ç³»çµ±æ˜¯ä»¥é›»æ± ç‚ºä¸»è¦èƒ½é‡ä¾†æºï¼Œç‚ºä¸€å€‹æœ‰é™èƒ½é‡çš„ç³»
çµ±ï¼Œéœ€è¦çš„æ˜¯ä½åŠŸç‡æ¶ˆè€—å’Œé«˜ååé‡é€™äºŒå¤§ç‰¹æ€§ï¼Œæ›è¨€ä¹‹ï¼ŒåŠŸç‡æ¶ˆè€—æˆç‚ºåœ¨ç³»çµ±
æ•ˆç‡ä¹‹å¤–çš„ä¸€å€‹è¨­è¨ˆé™åˆ¶å› ç´ ã€‚å› æ­¤åœ¨ç¾ä»£åŒ–çš„æ•¸ä½ç³»çµ±è¨­è¨ˆä¸­ï¼Œå¦‚ä½•åœ¨åŠŸç‡æ¶ˆ
è€—å’Œç³»çµ±æ•ˆèƒ½çš„å–æ¨ï¼Œå–å¾—ä¸€å€‹å¸„è¡¡é»æˆç‚ºä¸€å€‹æ–°çš„ç³»çµ±è¨­è¨ˆè­°é¡Œã€‚ 
  åŠŸç‡æ¶ˆè€—çš„å•é¡Œè€ƒæ…®å·²æ¼¸æ¼¸è¢«æå‰åˆ°ç³»çµ±è¨­è¨ˆéšæ®µã€‚éš¨è‘— SoC ä½åŠŸç‡æ¶ˆè€—çš„
è¨­è¨ˆé™åˆ¶æ¼¸ç‚ºé‡è¦ï¼Œå·²é€æ¼¸æ¨å¾€è¼ƒé«˜å±¤æ¬¡çš„è¨­è¨ˆéšæ®µã€‚å†åŠ ä¸Šå¿«é€Ÿå°å…¥å¸‚å ´æ™‚ç¨‹
çš„å£“åŠ›ï¼Œå‚³çµ±çš„è¨­è¨ˆæµç¨‹å¾€å¾€æ˜¯æœ€å¾Œçš„è¨­è¨ˆéšæ®µæ‰èƒ½å¾—çŸ¥åŠŸç‡æ¶ˆè€—æ˜¯å¦ç¬¦åˆè¨­è¨ˆ
é™åˆ¶ï¼Œå€˜è‹¥ä¸åˆä¹è¨­è¨ˆé™åˆ¶å°±å¾—é‡æ–°è¨­è¨ˆï¼Œç›´åˆ°ç¬¦åˆè¨­è¨ˆè¦æ ¼ã€‚ä½†æ˜¯é€™å€‹æ–¹æ³•æœ‰
è‘—è€—æ™‚è¨­è¨ˆå•é¡Œä»¥åŠè¨­è¨ˆæˆæœ¬éé«˜çš„å•é¡Œã€‚å› æ­¤ç³»çµ±è¨­è¨ˆè€…è‹¥èƒ½åœ¨è¼ƒæ—©çš„è¨­è¨ˆéš
æ®µä¸­ï¼Œæ­£è¦–åŠŸç‡æ¶ˆè€—çš„å•é¡Œï¼Œå°æ–¼å‚³çµ±è¨­è¨ˆæ–¹å¼çš„ç¼ºé»å°±èƒ½å…‹æœä¸¦ä¸”é¿å…æ‰ã€‚ 
  ç³»çµ±å–®æ™¶ç‰‡è¦æˆåŠŸå¯¦ç¾ï¼Œè¨­è¨ˆè€…å°‡è¦é¢è‡¨é¾å¤§ç³»çµ±è¦æ ¼çš„è¨­è¨ˆèˆ‡ç¡¬é«”é©—è­‰çš„
è«¸å¤šæŒ‘æˆ°ã€‚éå»è¨­è¨ˆæµç¨‹ä¸­ä½¿ç”¨ C/C++ ä¾†ä½œç‚ºç³»çµ±æ¼”ç®—æ³•å±¤æ¬¡çš„åŠŸèƒ½é©—è­‰ï¼Œç”¨ç¡¬
2. ç›¸é—œç ”ç©¶èˆ‡èƒŒæ™¯çŸ¥è­˜ 
 
åœ¨é€™ç« ç¯€åˆ†ç‚ºäºŒå€‹éƒ¨åˆ†ä½œè¨ï¥ï¼Œç¬¬ä¸€éƒ¨åˆ†é‡å°SystemCç›¸é—œèƒŒæ™¯çŸ¥è­˜ä½œä»‹ç´¹ï¼Œ
ç¬¬äºŒéƒ¨åˆ†å°å…ˆå‰æœ‰é—œç³»çµ±å±¤ç´šåŠŸç‡æ¶ˆè€—åˆ†æçš„ç›¸é—œç ”ç©¶å·¥ä½œåšæ¦‚è¦æ€§ä»‹ç´¹ã€‚ 
 
2.1 SystemC ç¨‹å¼èªè¨€ 
SystemC[27]æ˜¯ 1999 å¹´ 9 æœˆæ™‚ç”± EDA å» å•†èˆ‡ ARMã€STã€NECã€Motorola ç­‰
çµ„æˆçš„ OSCI (Open SystemC Initiative)çµ„ç¹”æ‰€è¨‚å®šçš„ç³»çµ±èˆ‡ç¡¬é«”æ¨¡å‹å»ºæ§‹èªè¨€ï¼Œå®ƒ
æ–°å¢è¨±å¤šæ”¯æ´ç¡¬é«”è§€å¿µçš„ C++é¡åˆ¥ï¼Œé‚„æœ‰å„ç¨®ç¡¬é«”æè¿°çš„è³‡æ–™å‹åˆ¥ã€‚ 
åˆ¶è¨‚ SystemC çš„ä¸»è¦ç›®çš„æ˜¯æƒ³è®“ç³»çµ±ã€è»Ÿé«”å’Œç¡¬é«”å·¥ç¨‹å¸«ä½¿ç”¨ç›¸åŒçš„ç¨‹å¼èª
è¨€ä¾†åšé–‹ç™¼ç”¢å“ï¼Œé¿å…æºé€šä¸è‰¯çš„æƒ…æ³ä¸¦èƒ½å¤ åˆ©ç”¨ SystemC æ¨¡å‹å»ºç«‹ç³»çµ±å¸„å°é€²
è¡Œç¡¬é«”/è»Ÿé«”çš„å…±åŒè¨­è¨ˆï¼Œé€™æ¨£å°‡èƒ½å¤ ç¢ºå®šç¡¬é«”å¯¦ç¾æ–¹æ³•å’Œè»Ÿé«”å¯¦ç¾æ–¹æ³•ä¹‹é–“çš„æŠ˜
è¡·ä¸¦ç°¡åŒ–è¨­è¨ˆæµç¨‹ï¼Œææ—©ç”¢å“ä¸Šå¸‚æ™‚é–“ã€‚ 
 
2.1.1 ä»€éº¼æ˜¯ SystemC 
SystemC å»ºç«‹åœ¨ C++ç¨‹å¼èªè¨€åŸºç¤ä¹‹ä¸Šã€‚C++æ˜¯ä¸€ç¨®å¯å»¶å±•çš„ç‰©ä»¶å°å‘å»ºæ§‹èª
è¨€ã€‚SystemC æ“´å±•äº† C++èªè¨€çš„åŠŸèƒ½ï¼Œä½¿å…¶èƒ½å°ç¡¬é«”æ¶æ§‹é€²è¡Œå»ºæ§‹æè¿°ã€‚SystemC
å¼•å…¥äº†ä¸€äº›é‡è¦çš„æ¦‚å¿µé€²å…¥ C++ï¼Œä¾‹å¦‚å¤šç¨‹åºçš„ä¸¦è¡Œæ€§ã€å…·æ™‚é–“æ€§çš„äº‹ä»¶å’Œå„å¼
å„æ¨£çš„è³‡æ–™å‹åˆ¥ã€‚SystemC å¢åŠ ä¸€å€‹é¡åˆ¥(Class)å‡½å¼åº«è€Œå»¶å±•äº† C++èªè¨€çš„åŠŸèƒ½ã€‚
æ­¤é¡åˆ¥å‡½å¼åº«ä¸æ˜¯å° C++ä½œä¿®æ”¹ï¼Œè€Œæ˜¯ä¸€å€‹æ¡ç”¨æ¨™æº–åˆæ³• C++ç¨‹å¼ç¢¼ï¼Œæ‰€ç·¨åˆ¶è€Œ
æˆçš„å„ç¨®å‡½å¼ï¼Œè³‡æ–™å‹åˆ¥ä»¥åŠå…¶ä»–èªè¨€çµæ§‹çš„å‡½å¼åº«ã€‚ç°¡è€Œè¨€ä¹‹ï¼ŒSystemC çš„æœ¬è³ª
ä¸Šå°±æ˜¯ C++ã€‚ 
é¡åˆ¥å‡½å¼åº«æä¾›åŠŸèƒ½å¼·å¤§çš„æ©Ÿåˆ¶å»æ¶æ§‹å‡ºå…·æœ‰ç¡¬é«”æ™‚é–“ã€åŒæ™‚é€²è¡Œã€æœ‰äº’å‹•
è¡Œç‚ºçš„ç³»çµ±æ¶æ§‹ã€‚é€™äº›æ©Ÿåˆ¶å®Œå…¨å»ºç«‹åœ¨ç”¨æ–¼ C++èªè¨€çš„é¡åˆ¥çµæ§‹ä¹‹ä¸Šã€‚å› æ­¤ï¼Œ
2.1.2 SystemC èˆ‡å…¶ä»–èªè¨€çš„æ¯”è¼ƒ 
åš´æ ¼åœ°èªªï¼ŒSystemC ä¸¦éæ˜¯ç¨‹å¼èªè¨€ï¼Œè€Œæ˜¯ä¸€å€‹åŸºæ–¼ C++èªè¨€ä¸¦å»ºå¥½çš„é¡åˆ¥å‡½
å¼åº«ã€‚ä½†ç›¸è¼ƒå…¶ä»–èªè¨€ï¼ŒSystemC æœ‰è‘—ç›¸å°å®¹æ˜“çš„å»ºæ§‹çš„ç‰¹æ€§ä»¥åŠå½ˆæ€§ã€‚æ­£å› ç‚ºåŸº
æ–¼ C++çš„æ¨™æº–ï¼Œå…¶æä¾›äº†ç¡¬é«”å’Œè»Ÿé«”ä¹‹é–“æä¾›äº†ä¸€å€‹å…±é€šçš„èªè¨€ã€‚ 
æœ‰å¹¾å€‹èªè¨€ä¹Ÿæ˜¯ç”¨ä¾†è™•ç†å„å¼å„æ¨£çš„ç³»çµ±è¨­è¨ˆçš„å•é¡Œï¼Œé›–ç„¶ Ada å’Œ Java å·²è¢«
è­‰æ˜ä»–å€‘çš„åƒ¹å€¼ï¼Œä½†åœ¨ç¾ä»ŠåµŒå…¥å¼ç³»çµ±è¨­è¨ˆçš„é ˜åŸŸä¸­ï¼ŒC/C++æ—©å·²å»£æ³›ä½¿ç”¨ï¼Œå…·æœ‰
å…¶æ¬Šå¨æ€§çš„å½±éŸ¿åŠ›ã€‚ç¡¬é«”æè¿°èªè¨€ VHDL å’Œ Verilog æ˜¯ç”¨ä¾†æ¨¡æ“¬åŠåˆæˆæ•¸ä½é›»è·¯ä¹‹
ç”¨ã€‚Vera å’Œ e æ˜¯è¤‡é›œçš„ ASIC2åŠŸèƒ½é©—è­‰çš„ä¸€å€‹é¸æ“‡èªè¨€ã€‚SystemVerilog ç‚ºä¸€å€‹æ–°
çš„èªè¨€å¼•å…¥ç”¨ä¾†è™•ç†ç¡¬é«”å°å‘çš„ç³»çµ±è¨­è¨ˆå•é¡Œã€‚Matlab å’Œå…¶ä»–å·¥å…·è»Ÿé«”å¦‚ SPW å’Œ
System Studio å»£æ³›åœ°è¢«ç”¨ä¾†æ•æ‰ç³»çµ±çš„éœ€æ±‚è¦æ ¼ä»¥åŠç”¨ä¾†ç™¼å±•æ•¸ä½è¨Šè™Ÿè™•ç†çš„æ¼”
ç®—æ³•ã€‚ 
åœ–è¡¨ 2.2 æ¨™ç¤ºå‡ºä¸Šè¿°æ‰€è«‡åŠå„å€‹èªè¨€ä¹‹æ‰€è¦è™•ç†çš„æ‡‰ç”¨å•é¡Œï¼Œå°æ™‚å¯ä»¥ç™¼ç¾é™¤
äº†å„å€‹ç¨‹å¼èªè¨€éƒ½æœ‰ä¸»è¦è™•ç†çš„é ˜åŸŸä¹‹å¤–ï¼Œä¹Ÿå¯ç™¼ç¾æœ‰ä¸€äº›é‡ç–Šçš„åœ°æ–¹ã€‚ 
 
åœ–è¡¨ 2.2 SystemC èˆ‡å…¶ä»–èªè¨€çš„æ¯”è¼ƒ (source [25]) 
                                                     
2
 ASICï¼ˆApplication Specific Integrated Circuitï¼‰æ˜¯ä¾ç‰¹å®šç”¨é€”è€Œè¨­è¨ˆçš„ç‰¹æ®Šè¦æ ¼é‚è¼¯
ICã€‚ASIC ä¸€èˆ¬ä¸¦æ²’æœ‰æ¨™æº–è¦æ ¼ï¼Œä½†ä¾è¨­è¨ˆæ–¹å¼çš„ä¸åŒï¼Œåˆå¯åˆ†ç‚º PLDã€é–˜æ’åˆ—ã€é›»è·¯
å…ƒè¨­è¨ˆåŠå…¨å®¢æˆ¶è¨­è¨ˆç­‰ã€‚  
2.2.1 è»Ÿé«”çš„ç³»çµ±å±¤ç´šåŠŸç‡æ¶ˆè€—åˆ†æ 
  Dalal, V. and Ravikumar, C. P[10]æ¡ç”¨åŸºæ–¼è¿½è¹¤(trace)æ–¹å¼çš„åŠŸç‡æ¶ˆè€—è©•ä¼°æ–¹æ³•ï¼Œ
åŠŸç‡æ¶ˆè€—ç‚ºåŸºæ–¼CMOSçš„å‡è¨­ï¼Œå› æ­¤åœ¨è»Ÿé«”ç«¯çš„è€ƒæ…®å³ç‚ºè™•ç†å™¨ã€è¨˜æ†¶é«”é›»è·¯ã€ä»¥
åŠç³»çµ±åŒ¯æµæ’çš„é›»å­é›»è·¯é–‹é—œæ´»å‹•çš„åŠŸç‡æ¶ˆè€—æ¨¡å‹ï¼Œé›»å®¹çš„å……æ”¾é›»æ ¹æ“šå‰å¾Œçš„ç‹€
æ³è€Œå®šï¼Œä¾‹å¦‚ä¸€å€‹8ä½å…ƒ(bit)çš„åŒ¯æµæ’ï¼Œå‡è¨­è³‡æ–™ç”±â€™001000101â€™è®Šç‚ºâ€™100100010â€™å³
æœ‰å…­æ¬¡çš„è½‰æ›æˆ–åˆ‡æ›ã€‚è—‰ç”±ARM[22]è»Ÿé«”é–‹ç™¼å·¥å…·å¥—ä»¶æ‰€åŒ…å«çš„ARMè™•ç†å™¨çš„æŒ‡
ä»¤é›†æ¨¡æ“¬å™¨ISS(Instruct Set Simulator)ï¼Œç¨±ä¹‹ç‚ºARMulator[22]ï¼Œèƒ½åœ¨æ²’æœ‰çœŸå¯¦åœ°å»
å­˜å–ç¡¬é«”çš„æƒ…å½¢ä¸‹æ¨¡æ“¬ä¸¦åŸ·è¡ŒARMæ‡‰ç”¨ç¨‹å¼ï¼ŒARMulatoræä¾›äº†ä¸€å€‹è¿½è¹¤çš„å·¥å…·ï¼Œ
ä½¿å¾—è¨­è¨ˆè€…å¯ä»¥ç¶“ç”±è¿½è¹¤çš„æ–¹å¼è€Œå–å¾—åŸ·è¡Œçš„æŒ‡ä»¤ã€è¨˜æ†¶é«”çš„å­˜å–å‹åˆ¥ï¼Œä»¥åŠä»»
ä½•åœ¨åŸ·è¡Œä¸­é–“æ‰€ç™¼ç”Ÿçš„äº‹ä»¶ã€‚ä¾‹å¦‚é€™å€‹è¿½è¹¤å·¥å…·å¯æä¾›æˆ‘å€‘åƒS-cycles(Sequential 
Access Cycle)ï¼ŒN-cycles(Non-Sequential Access Cycle)ï¼Œå’ŒI-cycles(Internal Access 
Cycle)çš„è³‡è¨Šçµ¦ä½¿ç”¨è€…ã€‚æœ€å¾Œæ ¹æ“šè¿½è¹¤æ‰€æä¾›çš„å‘¨æœŸæ•¸(Cycle)ä»¥åŠçµ±è¨ˆé‡åŒ–è¨ˆç®—è€Œ
å–å¾—çš„ç›¸å°åŠŸç‡æ¶ˆè€—æ¶ˆè€—æ•¸å€¼ã€‚ä½†æ­¤æ–¹æ³•çš„é©ç”¨æ€§åªé©ç”¨æ–¼ç‰¹å®šçš„æ¶æ§‹ï¼ARM7 
ç³»åˆ—è™•ç†å™¨ï¼Œå…¶é©ç”¨ç¯„åœæ€§å°±å¤§å¤§æŠ˜æ‰£ã€‚ 
åŒæ¨£ä¹Ÿæœ‰ä¸€äº›ç ”ç©¶æ˜¯åŸºæ–¼æŒ‡ä»¤é›†æ¨¡æ“¬å™¨æ‰€æœ‰æ“æœ‰çš„ç‰¹æ€§æˆ–æ•´åˆæœ‰åŠŸç‡æ¶ˆè€—è©•
ä¼° æŒ‡ ä»¤ é›† æ¨¡ æ“¬ å™¨ çš„ ç›¸ é—œ ç ” ç©¶ [17][18][19] ï¼Œ ä¾‹ å¦‚ ä½¿ ç”¨ SimpleScalar[14] ã€
SimplePower[15]ã€Sim-Panalyzer[16]è—‰ç”±æ¨¡æ“¬å™¨æœ¬èº«æ‰€æ“æœ‰çš„åŠŸç‡æ¶ˆè€—è©•ä¼°èƒ½åŠ›é€²
è€Œå»¶ä¼¸çš„ç›¸é—œç ”ç©¶å·¥ä½œã€‚è—‰ç”±ARMulatoræŒ‡ä»¤é›†æ¨¡æ“¬å™¨çš„åŠŸç‡æ¶ˆè€—åˆ†æç›¸é—œç ”ç©¶
[20][21]ï¼ŒARMulatoræœ¬èº«ä¸¦æ²’æœ‰æä¾›ARMè™•ç†å™¨ç›¸é—œæŒ‡ä»¤é›†çš„åŠŸç‡æ¶ˆè€—è³‡è¨Šï¼Œæ‰€
æä¾›èƒ½è™•ç†ä»¥åŠåƒè€ƒçš„åªæœ‰ç¨‹å¼åŸ·è¡Œçš„å‘¨æœŸæ•¸åŠé‹ç®—è™•ç†æ™‚é–“çš„è³‡è¨Šï¼Œç‚ºäº†é”åˆ°
åŠŸç‡æ¶ˆè€—è©•ä¼°çš„èƒ½åŠ›ï¼Œè—‰ç”±å¼•å…¥DC-DCèƒ½é‡è½‰æ›æ¨¡å‹çš„æ•´åˆï¼Œå½¢æˆåŸºæ–¼å‘¨æœŸç²¾ç¢º
çš„åŠŸç‡æ¶ˆè€—æ¨¡æ“¬åˆ†æï¼Œå…¶ä¸­DC-DCèƒ½é‡è½‰æ›æ¨¡å‹æœƒå°å€‹åˆ¥å…ƒä»¶åŠ ç¸½è¨ˆç®—å€‹åˆ¥çš„æ¯
ä¸€å€‹å‘¨æœŸçš„é›»æµå€¼ï¼Œæœ€å¾Œå³èƒ½å¾—åˆ°ç³»çµ±å…ƒä»¶çš„ç¸½æ¶ˆè€—èƒ½é‡ã€‚ 
 
2.2.3 AMBA åŒ¯æµæ’çš„ç³»çµ±å±¤ç´šåŠŸç‡æ¶ˆè€—åˆ†æ 
é—œæ–¼å°æ–¼AMBAåŒ¯æµæ’åŠŸè€—æ¨¡å‹çš„è¨ï¥[11]ï¼Œè¡¨æ ¼2.1å‘ˆç¾äº†å…¶æ‰€é¸å–ä¸”åˆ†æçš„
å€‹åˆ¥æŒ‡ä»¤é›†æ‰€è€—è²»ä¹‹å¸„å‡èƒ½é‡ï¼Œä½¿å¾—èƒ½ç¶“ç”±é€™äº›åŠŸç‡æ¶ˆè€—è³‡è¨Šä¾†å¯¦è¡ŒåŠŸç‡æ¶ˆè€—åˆ†
æåŠæœ€ä½³åŒ–çš„å¯èƒ½æ€§ï¼ŒåŒæ™‚è¡¨æ ¼2.1å…§ä¹Ÿå‘ˆç¾äº†ï¼Œç•¶å…¶æ“ä½œæ–¼100MHzçš„æ™‚è„ˆé »ç‡ä»¥
åŠç¸½æ“ä½œæ™‚é–“ç‚º50Î¼sçš„æ¨¡æ“¬éç¨‹ä¸­çš„ç¸½æ¶ˆè€—èƒ½é‡å€¼ã€‚åŒæ™‚ä¹Ÿå¯ä»¥å¾è¡¨æ ¼2.1çš„å¯¦é©—
æ•¸æ“šä¸­äº†è§£åˆ°ä¸€å€‹é‡è¦çš„ç‰¹æ€§ï¼Œæ•´å€‹èƒ½é‡æ¶ˆè€—å°æ–¼å–®ç¨åŒ¯æµæ’ä»²è£æ©Ÿåˆ¶(Arbitration)
æ‰€ä½”çš„æ¯”ä¾‹åªæœ‰12.69%ï¼Œè€Œä½”ç¸½èƒ½é‡æ¶ˆè€—çš„87.31%å…¶ä¸»è¦è™•ç†çš„å…§å®¹ç‚ºè³‡æ–™å‚³è¼¸
ä¸­é–“ä¸¦è€Œæ²’æœ‰åŒ¯æµæ’çš„äº¤æ¡ï¼ŒåŸºæ–¼æ­¤ç¯„ä¾‹çš„æ¶æ§‹ä¹Ÿå‘ŠçŸ¥äº†ä¸€å€‹æ¸›å°‘åŠŸç‡æ¶ˆè€—æœ€ä½³
åŒ–çš„æ–¹æ³•åŠçµï¥ï¼Œå³å°ˆæ³¨æ–¼AHBè³‡æ–™è·¯å¾‘çš„éƒ¨åˆ†ï¼Œå¯é”åˆ°æœ€æœ‰å¯èƒ½æ¸›å°‘åŠŸç‡æ¶ˆè€—
æ©Ÿæœƒã€‚ 
 
è¡¨æ ¼ 2.1 AMBA AHB åŒ¯æµæ’æŒ‡ä»¤èƒ½é‡æ¶ˆè€—åˆ†æ(source [11]) 
Instruction 
Average 
energy 
Total energy 
per instruction 
IDLE_HO_IDLE_HO 14.7 pJ 96.5 Î¼J 11.49% 
IDLE_HO_WRITE 16.7 pJ 0.5 Î¼J 0.06% 
READ_WRITE 19.8 pJ 417.7 Î¼J 49.75% 
READ_IDLE_HO 22.4 pJ 9.6 Î¼J 1.14% 
WRITE_READ 14.7 pJ 315.3 Î¼J 37.56% 
Total simulation energy 839.6 Î¼J 100 % 
 
  
èƒ½å®Œæˆã€‚åœ¨å¯¦é©—ä¸­[9]ä¹ŸæŒ‡å‡ºäº†åœ¨é¡å¤–å¤šäº†æ•¸å€‹åŠŸç‡æ¶ˆè€—åˆ†æç›£è¦–æ¨¡çµ„å…ƒä»¶åŠ å…¥æ¨¡
æ“¬é©—è­‰ï¼Œå‹¢å¿…å½¢æˆæ¨¡æ“¬é©—è­‰ä¸Šçš„è² æ“”ã€‚ 
 
 
 
åœ–è¡¨ 2.4 åŸºæ–¼ç•°è³ªç›£è¦–æ¨¡çµ„çš„ç³»çµ±å±¤ç´šåŠŸç‡æ¶ˆè€—åˆ†ææ¶æ§‹ 
 
2.3 æ‘˜è¦ 
åœ¨å®Œæˆç›¸é—œç ”ç©¶ä»¥åŠèƒŒæ™¯çŸ¥è­˜çš„èªªæ˜ï¼Œåœ¨ä¸‹ä¸€ç« ç¯€å°ˆé–€å°æ–¼ç¾æœ‰çš„æš«å­˜å™¨å‚³
è¼¸å±¤ç´šçš„åŠŸç‡æ¶ˆè€—åˆ†ææ–¹æ³•ä½œç›¸é—œçš„è§£æï¼Œä¸¦å°ä¸€äº›å¯¦ä½œç¼ºé»åŠä¸ä¾¿ä¹‹è™•çµ¦äºˆé»
å‡ºä¸¦èªªæ˜ï¼Œæœ€å¾Œæ‘˜è¦äºŒå€‹è§£æ±ºçš„æ–¹å¼ï¼Œä¸¦æå‡ºæˆ‘å€‘çš„æƒ³æ³•ã€‚ 
  
ä¿¡è™Ÿåˆ‡æ›é »ç‡ã€‚ 
XPower æŠŠå€‹å„å…ƒä»¶çš„åŠŸç‡æ¶ˆè€—æ±‚å’ŒåŠ ç¸½å¾Œä½œç‚º FPGA/CPLD çš„æ•´é«”åŠŸç‡æ¶ˆè€—ï¼Œ
æ¯å€‹å…ƒä»¶çš„åŠŸç‡æ¶ˆè€—å¯ä»¥è¡¨ç¤ºç‚ºï¼š 
 
                          ğ‘ƒ = ğ›¼ Ã— ğ¶ Ã— ğ‘‰2 Ã— ğ¹                            (1) 
 
å…¶ä¸­çš„ P ç‚ºåŠŸç‡æ¶ˆè€—ï¼Œå–®ä½ç‚ºç“¦(W)ï¼›C ç‚ºé›»å®¹ï¼Œå–®ä½ç‚ºæ³•æ‹‰(F)ï¼›Î± ç‚ºå…ƒä»¶åœ¨
ç³»çµ±ä¸­çš„åˆ‡æ›ç¿»è½‰é »ç‡(å³å–®ä½æ™‚è„ˆå‘¨æœŸçš„å¸„å‡åˆ‡æ›è®Šå‹•æ¬¡æ•¸)ï¼›F ç‚ºå…¶æ“ä½œé »ç‡
(Hz)ï¼›V ç‚ºæ“ä½œå·¥ä½œé›»å£“ï¼Œå–®ä½ç‚ºä¼ç‰¹(V)ã€‚ 
é›»å®¹å€¼å–æ±ºæ–¼ä½¿ç”¨è€…çš„è¨­è¨ˆï¼Œå› æ­¤åœ¨é¸å®šè£ç½®å…ƒä»¶ï¼Œå®Œæˆå¸ƒå±€å’Œç¹ç·š(Place and 
Route)ä¹‹å¾Œï¼Œé›»å®¹å€¼ä¹Ÿéš¨ä¹‹ç¢ºå®šï¼Œæ“ä½œå·¥ä½œé›»å£“å¯ä»¥åœ¨ XPower è»Ÿé«”ç•Œé¢ä¸­è¨­ç½®ã€‚
Î±Ã—F ç‚ºå–®ä½æ™‚é–“ä¸­ä¿¡è™Ÿçš„åˆ‡æ›ç¿»è½‰æ¬¡æ•¸ï¼Œå…¶ä¸­ F(å³å…ƒä»¶çš„åˆ‡æ›ç¿»è½‰é »ç‡)æ˜¯æœ€é›£ä»¥
ç¢ºå®šçš„åƒæ•¸ï¼Œè¨­è¨ˆè€…å¯ç¶“ç”±è¨­å®šé è¨­çš„åˆ‡æ›ç¿»è½‰æ´»å‹•é »ç‡ï¼Œåœ¨ XPower çš„ä½¿ç”¨è€…ç•Œ
é¢ä¸­å°ç‰¹å®šä¿¡è™ŸæŒ‡å®šå€‹åˆ¥çš„åˆ‡æ›ç¿»è½‰æ´»å‹•é »ç‡ï¼Œæˆ–è€…è®€å– HDL æ¨¡æ“¬å™¨æ‰€è½‰å„²ç”Ÿæˆ
çš„ VCD æ–‡ä»¶ç­‰æ–¹å¼ç‚º XPower æä¾›é€™å€‹åƒæ•¸ã€‚åœ¨æœ¬ç ”ç©¶ä¸­é¸ç”¨è®€å– HDL æ¨¡æ“¬å™¨
æ‰€è½‰å„²ç”Ÿæˆçš„ VCD æ–‡ä»¶æ–¹å¼ä¾†ç¢ºä¿åƒæ•¸å–å¾—çš„æº–ç¢ºæ€§ã€‚ 
 
3.3 ä½¿ç”¨ XPower åˆ†æåŠŸç‡æ¶ˆè€— 
ç•¶è¨­è¨ˆå®Œæˆå¸ƒå±€ç¹ç·šä¹‹å¾Œï¼Œåœ¨Xilinx ISEå°ˆæ¡ˆç€è¦½å™¨ä¸­å³å¯ç›´æ¥å•Ÿå‹•XPowerï¼Œ
é€™æ™‚ XPower æœƒè‡ªå‹•è®€å…¥ç³»çµ±è¨­è¨ˆæª”æ¡ˆ(.NCD)ã€å¯¦é«”é™åˆ¶è¨­å®šæª”æ¡ˆ(.PCF)ã€æ•´é«”ç³»
çµ±ç’°å¢ƒçš„è¨­å®šæª”(.XML)ï¼Œå¦‚ä¸‹åœ–è¡¨ 3.1 é¡¯ç¤ºçš„è¨Šæ¯è¦–çª—ï¼Œè¨­è¨ˆè€…æ ¹æ“šéœ€æ±‚å†è¼‰å…¥ä¿¡
è™Ÿæ¨¡æ“¬è½‰å„²æª”æ¡ˆ(.VCD/.XAD)ä¸¦è¨­ç½®ç›¸é—œåƒæ•¸ä¹‹å¾Œï¼Œå³å¯ç”¢ç”Ÿ XPower çš„åŠŸç‡æ¶ˆè€—
åˆ†æå ±å‘Šã€‚ 
å°æ–¼ VHDL èªè¨€ï¼Œä½¿ç”¨ ModelSim SE æ™‚å¦‚åœ–è¡¨ 3.3ï¼Œå¯ä»¥åœ¨ do æ–‡ä»¶ä¸­åŠ å…¥ä»¥
ä¸‹çš„èªæ³•ä»¥ä¾¿ç”¢ç”Ÿ VCD æª”æ¡ˆã€‚ 
 
 
 
 
å› æ­¤ä½¿ç”¨ VCD æª”æ¡ˆæœ‰å…¶æ–¹ä¾¿æ€§ã€ä¼°è¨ˆæº–ç¢ºçš„ç‰¹æ€§ï¼Œå› æ­¤åœ¨æœ¬ç ”ç©¶å¯¦é©—ä¸­æ¡ç”¨
ä¹‹ã€‚ 
ç„¶è€Œï¼Œç•¶é›»è·¯è¨­è¨ˆè¼ƒå¤§æ™‚æˆ–è€…æ¨¡æ“¬æ™‚é–“è¼ƒé•·æ™‚ï¼ŒVCD æª”æ¡ˆä¹Ÿå°‡éš¨ä¹‹å¢å¤§ï¼Œ
XPower åŠŸç‡æ¶ˆè€—åˆ†ææ¨¡æ“¬å™¨è¼‰å…¥ VCD æª”çš„æ™‚é–“ä¹ŸåŒæ™‚ç”±é•·é”æ•¸åˆ†é˜è®Šè‡³é•·é”æ•¸
å°æ™‚ä¹‹ä¹…ï¼Œå› æ­¤å®¹æ˜“è®“ä½¿ç”¨è€…æœƒæœ‰ XPower ç¨‹å¼ç•¶æ‰çš„éŒ¯è¦ºã€‚å°¤å…¶ VCD æª”å¾ˆå®¹æ˜“
ç”¢ç”Ÿè¶…é 1GB ä»¥ä¸Šçš„ä¿¡è™Ÿè³‡æ–™ï¼Œéƒ½æ˜¯å¾ˆå¸¸è¦‹çš„æƒ…å½¢ï¼Œå› æ­¤ Xilinx å…¬å¸æä¾›äº†ä¸€äº›
è§£æ±ºæ–¹æ¡ˆ[21]ï¼Œä»¥è§£æ±º VCD æª”æ¡ˆéå¤§çš„å•é¡Œï¼›å»ºè­°è¨­è¨ˆè€…å°‡æ•´å€‹è¨­è¨ˆå€åˆ†ç‚ºæ•¸å€‹
ç¨ç«‹æ¨¡çµ„ä½œåŠŸç‡æ¶ˆè€—åˆ†æï¼Œç„¶å¾Œæœ€å¾Œå†åŠ ç¸½å…¨éƒ¨æ¨¡çµ„æ‰€å¾—åˆ°çš„åŠŸç‡æ¶ˆè€—è©•ä¼°çµæœï¼Œ
ä½†æ˜¯æ­¤ç¨®æ–¹æ³•åªé©ç”¨æ–¼å°å‹•æ…‹(dynamic)åŠŸç‡æ¶ˆè€—åˆ†æçµæœï¼Œå°æ–¼éœæ…‹(quiescent)åŠŸ
ç‡æ¶ˆè€—åˆ†æçµæœä½œåŠ ç¸½çš„æ–¹å¼ä¸¦ä¸é©ç”¨ä¹‹ã€‚ 
å¦ä¸€å€‹æ›¿ä»£æ–¹å¼ç‚ºä½¿ç”¨ Xilinx ISE æä¾›ä¸€å€‹å…§å»ºçš„ Perl script-vcd2xad.pl 
[28,29]ï¼Œå¦‚åœ–è¡¨ 3.4 æ‰€é¡¯ç¤ºï¼Œvcd2xad.pl æä¾›çµ¦è¨­è¨ˆè€…å»é å…ˆè½‰æ›æˆè¼ƒå°çš„æ ¼å¼ï¼
XAD æª”æ¡ˆï¼Œæ­¤ XAD æª”æ¡ˆåŒæ¨£å¯ä»¥æä¾› XPower åŠ è¼‰ä¸¦åˆ†æåŠŸç‡æ¶ˆè€—è™•ç†ç”¨ã€‚åŒæ¨£
åœ°ï¼Œåœ¨æª”æ¡ˆæ ¼å¼è½‰æ›çš„éç¨‹ä¸­ï¼ŒVCD æª”æ¡ˆæ‰€ä½”ç©ºé–“æ„ˆå¤§æ™‚ï¼Œæ‰€éœ€æ¶ˆè€—çš„è½‰æª”æ™‚é–“
ç›¸å°åœ°å¢åŠ ã€‚æ›è¨€ä¹‹ï¼Œå…ˆå‰ VCD åŠ è¼‰è™•ç†æ™‚é–“éé•·çš„å•é¡Œå·²è½‰å«æ–¼è‡³æ­¤ï¼Œä½†æ­¤æ–¹
æ³•å¯ä»¥é¿å… XPower åŠ è¼‰æ™‚è®“ä½¿ç”¨è€…æœ‰ XPower ç¨‹å¼ç•¶æ‰çš„éŒ¯è¦ºã€‚ 
  
vcd file my_design.vcd 
vcd add testbench/uut/* 
åœ–è¡¨ 3.3 ä½¿ç”¨ VHDL ç¨‹å¼èªè¨€ç”¢ç”Ÿ VCD æª”æ¡ˆä¹‹èªæ³• 
  
 
åœ–è¡¨ 3.5 XPower åŠŸç‡æ¶ˆè€—åˆ†ææµç¨‹ 
 
4. ç³»çµ±å±¤ç´šçš„åŠŸç‡æ¶ˆè€—åˆ†æ 
 
4.1 åŸºæœ¬æ§‹æƒ³ 
éš¨è‘—æ¬¡å¾®ç±³æŠ€è¡“çš„é€²æ­¥ï¼Œè¤‡é›œçš„ç³»çµ±å¯ä»¥è¢«æ•´åˆåœ¨åŒä¸€å€‹æ™¶ç‰‡ä¸Šï¼Œç‚ºäº†ç¯€çœ
è¨­è¨ˆæˆæœ¬èˆ‡ç¸®çŸ­è¨­è¨ˆæ™‚é–“ï¼Œç™¼å±•çŸ½æ™ºç”¢å…ƒä»¶(IP)èˆ‡å†åˆ©ç”¨(Reuse)çš„è¨­è¨ˆæ–¹æ³•å·²æˆç‚º
æœ€ä½³çš„è§£æ±ºæ–¹æ¡ˆã€‚ 
ç‚ºäº†åŠ é€Ÿç”¢å“ä¸Šå¸‚ï¼Œè¨­è¨ˆè€…å¿…éœ€è—‰ç”±å†æ¬¡åˆ©ç”¨é‡è¦çš„ IP å…ƒä»¶ä¾†é¿å…é‡è¦†å·²è¨­
è¨ˆçš„å·¥ä½œã€‚å› æ­¤è¦èƒ½æˆåŠŸæ•´åˆ IPï¼Œå¾—å¾é¸æ“‡ä¸€å€‹å¯ä¿¡è³´çš„ IP æä¾›å» å•†é–‹å§‹ï¼Œå¥½çš„
IP æä¾›å» å•†å¿…é ˆèƒ½å¤ è§£æ±ºä¸€é€£ä¸²çš„å•é¡Œï¼Œæ‰€ä»¥ä¸åƒ…åƒ…æ˜¯æä¾› IP çš„å“è³ªï¼Œé‚„å¿…é ˆå°
æ–¼æ•´é«”æœ‰ç›¸é—œæ”¯æ´ï¼Œé€™åŒ…æ‹¬è©³ç´°çš„æ–‡ä»¶èªªæ˜ã€ç¨±è·çš„ç”¢å“æ‡‰ç”¨å·¥ç¨‹å¸«ä»¥åŠé©æ™‚åœ¨
å·¥ç¨‹ä¸Šçš„æ”¯æ´ç­‰ã€‚ä¸€å¥—å®Œæ•´çš„æœå‹™æ‡‰è©²åŒ…æ‹¬æš«å­˜å™¨å‚³è¼¸å±¤ç´šçš„ç¨‹å¼ç¢¼ã€é©—è­‰çš„ç’°
å¢ƒã€åˆæˆã€å¸ƒå±€å’Œç¹ç·šå°å¼•æ‘˜è¦ï¼Œä»¥åŠç›¸é—œåŠŸèƒ½çš„æ–‡ä»¶èªªæ˜ã€‚å°±å¾®è™•ç†å™¨æˆ–æ˜¯å¯
ç·¨ç¨‹åºçš„æ•¸ä½è¨Šè™Ÿè™•ç†å™¨çš„å» å•†è€Œè¨€ï¼Œå³é ˆæä¾›ä¸€äº›å·¥å…·è³‡æºä¾†æ”¯æ´æ˜¯å¾ˆé‡è¦çš„ï¼Œ
ä¸¦ä¸”æ‡‰è©²è¦æœ‰ç·¨è­¯å™¨ã€ä½œæ¥­ç³»çµ±ã€é–‹ç™¼å‡½å¼åº«ä»¥åŠç›¸é—œæ‡‰ç”¨è»Ÿé«”ã€‚ 
å› æ­¤åœ¨æå€¡çŸ½æ™ºç”¢å…ƒä»¶å†åˆ©ç”¨çš„è¨­è¨ˆæ¦‚å¿µçš„åŒæ™‚ï¼Œå¦‚æœèƒ½å°å¸¶æœ‰çš„ç›¸é—œè¦æ ¼
è³‡è¨Šå†æ¬¡åˆ©ç”¨ï¼Œä¾‹å¦‚è©³ç´°çš„åŠŸç‡æ¶ˆè€—è¨Šæ¯ï¼›è—‰ç”±å†åˆ©ç”¨çš„å‹•æ©Ÿè€Œå½¢æˆ IP åŠŸç‡æ¶ˆè€—
è³‡æ–™åº«ï¼Œä½†æ˜¯å¾€å¾€å…¶åŠŸç‡æ¶ˆè€—è³‡è¨Šæ‰€æä¾›çš„è©³ç´°ç¨‹åº¦ä¸¦ä¸è¶³å¤ ã€‚ 
å› æ­¤æˆ‘å€‘æ‰€æå‡ºçš„ç³»çµ±å±¤ç´š åŠŸç‡æ¶ˆè€—è©•ä¼°æ–¹æ³•ï¼Œä¸»è¦æ˜¯å†åˆ©ç”¨åŠŸç‡æ¶ˆè€—è³‡è¨Š
çš„è§€å¿µï¼Œä½†æ˜¯åœ¨ç³»çµ±å±¤ç´šä½œåˆ†ææ™‚ï¼Œæ‰€éœ€è¦çš„åŠŸç‡æ¶ˆè€—è³‡è¨Šä¸¦ä¸å­˜åœ¨ï¼Œå› æ­¤åœ¨æ­¤
æˆ‘å€‘éœ€è¦å‡è¨­æ­¤åŠŸç‡æ¶ˆè€—è³‡è¨Šæ˜¯å­˜åœ¨çš„ï¼Œä¸¦è£œè¶³é€™äº›åŠŸç‡æ¶ˆè€—è³‡è¨Šä»¥ä¾¿å†åˆ©ç”¨ã€‚
å› æ­¤æˆ‘å€‘ä½œäº†ä¸€å€‹å‡è¨­ï¼šé€™å€‹åŠŸç‡æ¶ˆè€—è³‡è¨Šå¯èƒ½æ˜¯ IP æä¾›è€…å·²æä¾›çš„è³‡è¨Šæˆ–æ˜¯å¾
å…¶ä»–ç¬¬ä¸‰æ–¹å–å¾—çš„è³‡è¨Šã€‚ 
ç‚ºäº†æ»¿è¶³é€™å€‹å‡è¨­ï¼Œæˆ‘å€‘åœ¨æ­¤æå‡ºä¸€å€‹åœ¨æš«å­˜å™¨å‚³è¼¸å±¤ç´šåŠŸç‡æ¶ˆè€—è³‡è¨Šå–å¾—
çš„æ–¹æ³•ï¼šé‡æ–°å°æš«å­˜å™¨å‚³è¼¸å±¤ç´šçš„ç¨‹å¼ç¢¼é€²è¡Œæ™‚åºåœ–ç´°éƒ¨è§£ææˆ–ç‰¹å®šè¡Œç‚ºä½œç´°éƒ¨
æ¨¡æ“¬ï¼Œä¸¦å°å„å€‹å€æ®µä½œæ™‚åºåœ–æˆªå–ã€‚ç„¶å¾Œå°å„å€‹æ‹†è§£çš„è¡Œç‚ºæ¨¡å¼ä½œ XPower çš„è©•ä¼°
 Etotal = Etotal ,op 1 + Etotal ,op 2 + Etotal ,op 3 + Etotal ,op 4 + Etotal ,op 5 +  â€¦     (2) 
 
 
 
 
 
 
Etotal ,op 1 =  Eop 1 Ã— Top 1 
Etotal ,op 2 =  Eop 2 Ã— Top 2 
Etotal ,op 3 =  Eop 3 Ã— Top 3 
Etotal ,op 4 =  Eop 4 Ã— Top 4 
Etotal ,op 5 =  Eop 5 Ã— Top 5 
â€¦â€¦
                       (3) 
 
å…¶ä¸­Etotal ç‚ºæ•´é«”çš„ç¸½èƒ½é‡æ¶ˆè€—ã€‚Etotal ,op 1ã€Etotal ,op 2ã€Etotal ,op 3ã€Etotal ,op 4ã€
Etotal ,op 5ç­‰è¡¨ç¤ºç‚ºæ“ä½œå€‹åˆ¥æ“ä½œè¡Œç‚ºæ‰€å çš„ç¸½èƒ½é‡æ¶ˆè€—ã€‚Eop 1ã€Eop 2ã€Eop 3ã€Eop 4ã€
Eop 5ç­‰è¡¨ç¤ºç‚ºå–®ä¸€æ“ä½œä¸€æ¬¡æ“ä½œè¡Œç‚ºçš„èƒ½é‡æ¶ˆè€—ã€‚Top 1ã€Top 2ã€Top 3ã€Top 4ã€Top 5è¡¨
ç¤ºç‚ºå€‹åˆ¥æ“ä½œè¡Œç‚ºçš„æ“ä½œç¸½æ¬¡æ•¸ã€‚ 
æ¯æ¬¡æ“ä½œè¡Œç‚ºçš„èƒ½é‡æ¶ˆè€—å€¼è¨ˆç®—ï¼Œæˆ‘å€‘æ¡ç”¨ Macro-Modeling å³ç‚ºä¸€å€‹åŸºæ–¼ä¸€
å€‹å·²æœ‰çš„æŠ€è¡“æˆ–å…·æœ‰å¯¦ä½œå¯èƒ½æ€§çš„æŠ€è¡“å»å®Œæˆé‡æ¸¬åŠŸç‡æ¶ˆè€—ç‰¹å¾µæ–¹æ³•ï¼Œç°¡è€Œè¨€ä¹‹ï¼Œ
é€™äº›åŠŸç‡æ¶ˆè€—æ•¸å€¼å¯ç”±è¼ƒä½å±¤ç´šå·²æœ‰çš„åŠŸç‡æ¶ˆè€—è©•ä¼°æ–¹æ³•é€²è¡Œé‡æ¸¬ã€‚åŸºæ–¼é€™æ¨£çš„
è§€å¿µå†åˆ©ç”¨è¼ƒä½å±¤ç´šçš„åŠŸç‡æ¶ˆè€—è³‡è¨Šæ­£å¥½èˆ‡æˆ‘å€‘å…ˆå‰å‡è¨­çš„ IP è¦æ ¼è³‡è¨Šå†åˆ©ç”¨è§€
å¿µä¸è¬€è€Œåˆã€‚å› æ­¤æ¡ç”¨ Macro-Modeling çš„æ–¹å¼ï¼Œå³æœ‰æ©Ÿæœƒæ–¼è¼ƒé«˜è¨­è¨ˆéšæ®µä¸”æ²’æœ‰
å¯¦éš›åŠŸç‡æ¶ˆè€—è³‡è¨Šå¯é©—è­‰çš„ç¡¬é«”ç³»çµ±æ¶æ§‹ä¸‹ï¼Œä¾†é€²è¡Œè©•ä¼°åŠŸç‡æ¶ˆè€—ã€‚åœ¨ä¸‹ä¸€å°ç¯€ï¼Œ
æˆ‘å€‘å°‡èªªæ˜å¦‚ä½•é‡æ¸¬æ“ä½œè¡Œç‚ºçš„åŠŸç‡/èƒ½é‡æ¶ˆè€—å€¼ã€‚ 
 
 
 
 
4.3 åŠŸç‡æ¶ˆè€—è³‡è¨Šçš„å–å¾— 
åŸºæ–¼ Macro-Modeling çš„æ–¹å¼ï¼Œæˆ‘å€‘é‡æ–°æ–¼è¼ƒä½å±¤ç´šé‡æ¸¬å€‹åˆ¥å–®ä¸€æ“ä½œè¡Œç‚ºçš„
åŠŸç‡æ¶ˆè€—å€¼ã€‚åœ¨å‰ä¸€ç« ç¯€å·²èªªæ˜äº†å¦‚ä½•åœ¨ XPower ä½œåŠŸç‡æ¶ˆè€—è©•ä¼°çš„æ¨¡æ“¬ï¼Œå°æ–¼è¼ƒ
å®Œæˆæ”¶é›†å€‹åˆ¥æ“ä½œè¡Œç‚ºçš„æ™‚åºåœ–æ™‚ï¼Œå†ç¶“ç”± XPower ä½œåŠŸç‡æ¶ˆè€—åˆ†æè©•ä¼°ã€‚å› 
æ­¤å–®æ¬¡æ“ä½œè¡Œç‚ºå³å¯ç”¨ä»¥ä¸‹çš„æ–¹ç¨‹å¼é‹ç®—å‡ºã€‚ 
Eoperation =  Poperation Ã— toperation                      (4) 
å…¶ä¸­ Eoperation   ç‚ºæ¯æ¬¡æ“ä½œè¡Œç‚ºçš„æ¶ˆè€—èƒ½é‡ï¼› 
             Poperation  ç‚ºæ¯æ¬¡æ“ä½œè¡Œç‚ºçš„å¸„å‡æ¶ˆè€—åŠŸç‡å€¼ï¼› 
            toperation  ç‚ºæ¯æ¬¡æ“ä½œè¡Œç‚ºçš„åŸ·è¡Œæ™‚é–“ã€‚ 
  ç¸½çµä½¿ç”¨ Macro-Modeling çš„è¨­è¨ˆæ­¥é©Ÿï¼š 
(1) è§£æå…¶æ¨¡çµ„ä¸å¯åˆ†å‰²çš„å‡½å¼/æ“ä½œè¡Œç‚º/ç¨‹åºç­‰ç¡¬é«”çš„æ“ä½œç‰¹æ€§ã€‚ 
(2) æ’°å¯«ç¡¬é«”æ“ä½œç‰¹æ€§çš„å€‹åˆ¥æ¸¬è©´ç¨‹å¼ã€‚ 
(3) æ¨¡æ“¬å€‹åˆ¥çš„ç¡¬é«”æ“ä½œç‰¹æ€§ï¼Œä¸¦æ”¶é›†å…¶æ™‚åºåœ– VCD æª”ã€‚ 
(4) ä½¿ç”¨XPoweråŠ è¼‰VCDæª”ä¾†åˆ†æåŠŸç‡æ¶ˆè€—ï¼Œå»ºç«‹å…¶åŠŸç‡æ¶ˆè€—è³‡è¨Šè³‡æ–™åº«ã€‚ 
(5) åŸºæ–¼æ¨¡çµ„çš„ç¡¬é«”æ“ä½œç‰¹æ€§å»æ’°å¯«æˆ SystemCæ¨¡çµ„ï¼Œä¸¦åŠ å…¥åŠŸç‡æ¶ˆè€—è³‡è¨Šã€‚ 
(6) ä½¿ç”¨ç³»çµ±å±¤ç´šçš„ç¡¬é«”æ¨¡çµ„ä½œæ¨¡æ“¬ä¸¦åˆ†æå…¶åŠŸç‡æ¶ˆè€—ã€‚ 
 
 
åœ–è¡¨ 4.2 å…·æœ‰åŠŸç‡æ¶ˆè€—è³‡è¨Šçš„ IP æ¨¡çµ„å»ºæ§‹ç¤ºæ„åœ– 
  
RGB ä¸‰é¡è‰²çš„è³‡æ–™ã€‚ 
(2) æºé€š(Communication)ã€æ§åˆ¶ä¿¡è™Ÿ(Control Signal)ï¼š 
æ¯å€‹ç¡¬é«”å€å¡Šåœ¨æ“ä½œæ™‚å¿…å®šæ˜¯è¼¸å…¥ç›¸é—œä¿¡è™Ÿï¼Œè€Œç”¢ç”Ÿç›¸å°æ˜ çš„æ“ä½œæ¨¡å¼åŠ
è¡Œç‚ºã€‚è€Œåœ¨æ“ä½œç¡¬é«”ä½œç‰¹å®šçš„è¨ˆç®—åŠŸèƒ½æ™‚ï¼Œä¹Ÿå¿…éœ€è¼¸å…¥ç›¸é—œå¾…è¨ˆç®—çš„æ•¸æ“š
è³‡æ–™ï¼Œæ‰æ˜¯ä¸€å€‹æœ‰æ„ç¾©çš„è¨ˆç®—æ“ä½œï¼ŒåŒæ™‚ä¹Ÿæœƒç”¢ç”Ÿä¸¦è¼¸å‡ºç›¸é—œå·²è¨ˆç®—çš„æ•¸
æ“šè³‡æ–™ã€‚å› æ­¤é€™éƒ¨åˆ†å¯æ ¹æ“šå…¶ç¡¬é«”çš„æ§åˆ¶ä¿¡è™Ÿç‹€æ…‹ä½œç‚ºåŠƒåˆ†ä¾æ“šï¼Œä¾‹å¦‚å¸¸
è¦‹çš„ç¡¬é«”ç‹€æ…‹æœ‰è¼¸å…¥ã€è¼¸å‡ºã€ç¡¬é«”é‡ç½®ç­‰ç‹€æ…‹ã€‚å› æ­¤åŠƒåˆ†æ“ä½œè¡Œç‚ºçš„ä¾æ“š
é»å³å¯ç‚ºç¡¬é«”çš„æ“ä½œç‰¹æ€§å’Œæºé€šè¡Œç‚ºä½œç‚ºåŠƒåˆ†ä¾æ“šé»ã€‚ 
 
æ ¹æ“šä»¥ä¸Šçš„æ“ä½œè¡Œç‚ºåˆ†é¡è¦é»ï¼Œæœ€å¾Œå†åˆ†åˆ¥æ–¼æ“ä½œè¡Œç‚ºåŠ ä¸Šç¶“ç”±è¼ƒä½å±¤ç´šé‡
æ¸¬åˆ°çš„åŠŸç‡æ¶ˆè€—è³‡è¨Šï¼Œå³å¯æ§‹æˆæ“æœ‰åŠŸç‡æ¶ˆè€—è³‡è¨Šçš„æ¨¡çµ„ï¼Œä¸¦æ–¼æ¨¡æ“¬åˆ†ææ™‚æä¾›
è¨­è¨ˆè€…ç›¸é—œçš„åŠŸç‡æ¶ˆè€—è³‡è¨Šã€‚å½¢æˆå¯æ–¼ç³»çµ±å±¤ç´šä½œåŠŸç‡è€—åˆ†æçš„å¯èƒ½æ€§ã€‚ 
 
4.5 æ¨¡çµ„åŠŸç‡æ¶ˆè€—è³‡è¨Šçš„ç¶­è­·æ€§â€“ä½¿ç”¨ C/C++å·¨é›†å®šç¾© 
  å°±ç³»çµ±æ•´é«”è¨­è¨ˆè€ƒé‡é»è€Œè¨€ï¼Œå·²å¤§é‡æ¡ç”¨æ¨¡çµ„åŒ–çš„æ–¹å¼ä¾†è¨­è¨ˆæ•´å€‹ç³»çµ±ã€‚å…¶
ä¸»è¦ç›®çš„å°±æ˜¯ç‚ºäº†å¯ä»¥å¢åŠ å„æ¨¡çµ„ä¹‹é–“æ›¿æ›çš„ä¾¿åˆ©æ€§ã€‚å› æ­¤åœ¨åŠŸç‡æ¶ˆè€—è³‡è¨ŠåŠ å…¥
çš„åŒæ™‚ï¼Œæˆ‘å€‘ç†æ‡‰åŒæ™‚å»è€ƒé‡å…¶ç¶­è­·çš„ä¾¿åˆ©æ€§ã€‚åœ¨ç®¡ç†åŠŸç‡æ¶ˆè€—è³‡è¨Šçš„æ–¹å¼ï¼Œæ¡
ç”¨äº† C/C++å¸¸è¦‹çš„é å…ˆè™•ç†ä½¿ç”¨å·¨é›†å®šç¾©çš„æ©Ÿåˆ¶ä¾†ç®¡ç†ä¹‹ï¼Œç”±æ–¼ä½¿ç”¨ C/C++å·¨é›†
å®šç¾©çš„æ–¹å¼ï¼Œå¯ä½¿å¾—åœ¨ç¡¬é«”çš„ç¨‹å¼ç¢¼ç¶­è­·æ–¹å¼ä¾¿æ·è¨±å¤šä¸¦ä¸éœ€è¦æ·±å…¥ä¿®æ”¹ï¼Œä¸æœƒ
å› ç‚ºæ›¿æ›æ¡ç”¨ä¸åŒçš„ç¡¬é«”æŠ€è¡“æ™‚ï¼Œç”¢ç”ŸåŠŸç‡æ¶ˆè€—çš„ä¸åŒï¼Œè€Œéœ€è¦æ·±å…¥ä¿®æ”¹ç¡¬é«”å€
å¡Šçš„ç¨‹å¼ç¢¼ï¼Œå¦‚æ­¤å¯ä»¥é¿å…ä¸€äº›ä¸å¯é æ¸¬çš„äººç‚ºå•é¡Œã€‚ç•¶ä½¿ç”¨ä¸åŒçš„ç¡¬é«”æŠ€è¡“ï¼Œ
ä¾‹å¦‚ç•¶è¨­è¨ˆçš„ç¡¬é«”æ¡ç”¨çš„å…ƒä»¶è£ç½®å…¶æŠ€è¡“ç”± Virtex-II ç³»åˆ—è½‰æ›ä½¿ç”¨ Spartan-II ç³»åˆ—
çš„æŠ€è¡“æ™‚ï¼Œå…¶åŠŸç‡æ¶ˆè€—å€¼å‹¢å¿…ä¸åŒã€‚æ­¤æ™‚åªéœ€å°å·¨é›†å®šç¾©æª”æ¡ˆä½œä¿®æ”¹å³å¯ï¼Œä¸éœ€
è¦æ·±å…¥ä¿®æ”¹å…¶ä»–ç¨‹å¼ç¢¼ï¼Œä»¥é”åˆ°æ–¹ä¾¿ç¶­è­·ç®¡ç†ä¹‹ç”¨é€”ã€‚ 
5. æ¨¡æ“¬å¯¦é©—èˆ‡çµæœ 
 
åœ¨æœ¬ç« ç¯€ï¼Œæˆ‘å€‘å°‡åˆ†åˆ¥ä»¥ä¸‰å€‹ä¸åŒçš„ç‰¹å®šæ‡‰ç”¨ IP ä¾†é©—è­‰å‰äºŒç« ç¯€æ‰€è¨ï¥çš„ç³»
çµ±å±¤ç´šå’Œæš«å­˜å™¨å‚³è¼¸å±¤ç´šäºŒè€…ä¹‹é–“çš„åŠŸç‡æ¶ˆè€—åˆ†æè©•ä¼°çš„æ–¹æ³•ã€‚ 
 
é¦–å…ˆç°¡è¿°å¯¦é©—ä¸­æ‰€æ¡ç”¨çš„ç’°å¢ƒä»¥åŠç›¸é—œè¨­å®šæ¢ä»¶çš„å…§å®¹ã€‚ 
1. å¯¦é©—ç¡¬é«”å¸„å°ï¼š 
Intel Pentium4 550 CPUï¼Œ2G RAM çš„ç¡¬é«”å¸„å°ä¸‹å®Œæˆæ¨¡æ“¬é©—è­‰ç­‰å·¥ä½œã€‚ 
2. å·¥å…·è»Ÿé«”æ–¹é¢ï¼š 
åœ¨æš«å­˜å™¨å‚³è¼¸å±¤ç´šå…¨éƒ¨æ¡ç”¨ Xilinx ISE 9.1 ç‚ºé–‹ç™¼ç’°å¢ƒï¼ŒåŒæ™‚ä¸¦ä½¿ç”¨
ModelSim SE ä½œç‚º HDL æ¨¡æ“¬å™¨å»æ”¶é›†åŸ·è¡Œéç¨‹çš„æ™‚åºåœ– VCD æª”æ¡ˆï¼Œæœ€å¾Œ
å†ç¶“ç”± Xilinx çš„ XPower ä½œåŠŸç‡æ¶ˆè€—æ¨¡æ“¬åˆ†æã€‚è€Œåœ¨ç³»çµ±å±¤ç´šæœƒæ¡ç”¨ä¸‰ç¨®
ä¸åŒçš„é–‹ç™¼ç’°å¢ƒ(CoWare Platform Architect[37]ã€OSIC SystemC[39]ã€ARM 
SoC Designer[38])ä¾†å»ºæ§‹ç‰¹å®šæ‡‰ç”¨ IPï¼Œé€²è€Œèªªæ˜æ–¹æ³•çš„é©ç”¨æ€§ã€‚ 
3. ç¨‹å¼å¯¦ä½œæ–¹é¢ï¼š 
åœ¨æš«å­˜å™¨å‚³è¼¸å±¤ç´šçµ±ä¸€æ¡ç”¨ Virtex ç³»åˆ—çš„ FPGA æŠ€è¡“ï¼Œå…¶ä¸­æ¡ç”¨çš„ç›®æ¨™ç¡¬
é«”è£ç½®ç‚º xc2v250-6fg456 (Device:XC2V250ã€Package:FG456ã€Speed:-6)ä¸¦
æ“ä½œåœ¨ 100MHzï¼Œå…¶é¤˜çš„è£ç½®è³‡è¨Šæˆ‘å€‘å…¨æ¡ç”¨é è¨­çš„è¨­å®šå€¼(ä¾‹å¦‚æ“ä½œé›»å£“ã€
ç™¼ç†±é‡çš„è³‡è¨Š)ã€‚åœ¨ç³»çµ±å±¤ç´šå¯¦ä½œç›¸å°æ˜ åŠŸèƒ½çš„ SystemC ç¡¬é«”å€å¡Šæ¨¡çµ„ï¼Œ
æœ€å¾Œæ¨¡æ“¬é©—è­‰å…¶ä¸­äºŒè€…ä¹‹é–“çš„å·®ç•°æ€§ã€‚ 
 
ä»¥ä¸‹æˆ‘å€‘å°‡åˆ†ç‚ºä¸‰å€‹ä¸åŒçš„æ‡‰ç”¨ç¨‹å¼ä¾†å¯¦é©—ä¸¦æ–¼ 5.1ï¼Œ5.2ï¼Œ5.3 ç¯€åˆ†åˆ¥è¨ï¥ï¼Œ
æœ€å¾Œæ–¼ 5.4 ç¯€ç¸½çµæ‘˜è¦ä¹‹ã€‚ 
5.1 å¯¦é©—ä¸€ï¼šJPEG ç·¨ç¢¼å™¨ 
JPEG æ˜¯éœæ­¢å½±åƒç·¨ç¢¼æ–¹å¼çš„åœ‹éš›æ¨™æº–ã€‚ç¾ä»Šå¦‚å½©è‰²å‚³çœŸå’Œç°¡æ˜“é›»è¦–é›»è©±çš„å½±
5.1.1 DCT HDL ç¨‹å¼å¯¦ä½œéƒ¨åˆ† 
è€Œ HDL çš„éƒ¨åˆ†æˆ‘å€‘åŒæ¨£éœ€è¦å¯¦ä½œ DCT çš„ç¡¬é«”è¨­è¨ˆï¼Œä¸¦ä¸”åœ¨ Xilinx ISE ä¸­ä½œå®Œ
åˆæˆã€è½‰è­¯ã€å°æ˜ ã€å¸ƒå±€å’Œç¹ç·šã€‚åœ¨å®Œæˆå¸ƒå±€å’Œç¹ç·šä¹‹æ™‚ï¼Œæˆ‘å€‘å·²å¯ä»¥ç¶“ç”± XPower
å–å¾—éœæ…‹çš„åŠŸç‡æ¶ˆè€—è³‡è¨Šï¼Œéœæ…‹åŠŸç‡æ¶ˆè€—å€¼çš„æ±ºå®šæ˜¯å–æ±ºæ–¼è£ç½®å…ƒä»¶çš„é¸æ“‡ï¼Œæ‰€
ä»¥æ­¤æ™‚çš„è£ç½®å…ƒä»¶æ˜¯æ²’æœ‰ä»»ä½•çš„è¼¸å‡ºå…¥è¨Šè™Ÿã€‚ç„¶è€Œæˆ‘å€‘å°šéœ€è¦è—‰ç”± ModelSim SE - 
HDL æ¨¡æ“¬å™¨å’Œæ¸¬è©´ç¨‹å¼ä½œæ›´è©³ç´°ä¸”å®Œæ•´çš„æ¨¡æ“¬ä¸¦æ”¶é›†æ™‚åºåœ– VCD æª”ï¼Œå†ç¶“ç”±
XPower åŠŸç‡æ¶ˆè€—åˆ†ææ¨¡æ“¬å™¨çš„åˆ†ææ¨¡æ“¬æ‰èƒ½å¾—åˆ°æ•´é«”å…ƒä»¶çš„å¸„å‡åŠŸç‡æ¶ˆè€—ã€‚æ­¤æ™‚
æ‰€å¾—çš„å¸„å‡åŠŸç‡æ¶ˆè€—å€¼å³ç‚ºå·²åŒ…å«äº†éœæ…‹åŠŸç‡æ¶ˆè€—å€¼å’Œå‹•æ…‹åŠŸç‡æ¶ˆè€—å€¼ã€‚æœ€å¾Œå†
ç¶“ç”±æ“ä½œåŸ·è¡Œæ™‚é–“åˆ©ç”¨ä¸‹æ–¹çš„æ–¹ç¨‹å¼è¨ˆç®—ï¼Œå³å¯é”åˆ°æ•´é«”çš„èƒ½é‡æ¶ˆè€—ã€‚ä½†æ˜¯æ„ˆè©³
ç›¡çš„æ¨¡æ“¬ï¼Œå…¶æ¨¡æ“¬çš„æ™‚é–“æœƒæ„ˆé•·ï¼›åŒæ™‚æ‰€ç´€éŒ„ä¸‹çš„ VCD æª”å…¶æª”æ¡ˆå¤§å°ä¹Ÿæœƒå› æ­¤é
å¢ã€‚å½¢æˆ XPower åœ¨è™•ç† VCD æª”æ¡ˆæ™‚æ‰€é€ æˆçš„è€—æ™‚è©•ä¼°ä¸»è¦å› ç´ ã€‚ 
 
Ptotal = PQuiescent + PDynamic                              (5) 
 
Etotal = EQuiescent + EDynamic  ,                           (6) 
=  PQuiescent + PDynamic  Ã— Ttotal  , 
                                               =  Ptotal Ã— Ttotal  
 
å…¶ä¸­   Ptotal   ç‚ºæ•´é«”çš„å¸„å‡åŠŸç‡æ¶ˆè€— 
     PQuiescent  ç‚ºæ•´é«”çš„å¸„å‡éœæ…‹åŠŸç‡æ¶ˆè€— 
     PDynamic  ç‚ºæ•´é«”çš„å¸„å‡å‹•æ…‹åŠŸç‡æ¶ˆè€— 
       Etotal   ç‚ºæ•´é«”çš„ç¸½èƒ½é‡æ¶ˆè€— 
     EQuiescent  ç‚ºæ•´é«”çš„éœæ…‹èƒ½é‡æ¶ˆè€— 
       EDynamic  ç‚ºæ•´é«”çš„å‹•æ…‹èƒ½é‡æ¶ˆè€— 
       Ttotal   ç‚ºæ•´é«”çš„æ“ä½œåŸ·è¡Œæ™‚é–“ 
æ“ä½œè¡Œç‚ºæ™‚åºåœ– VCD æª”ä¾†è¨ˆç®—åŠŸç‡æ¶ˆè€—å€¼ï¼Œå°± DCT IP çš„å¯¦é©—ä¸­æˆ‘å€‘å°‡å…¶åŠƒåˆ†ç‚º
äº”ç¨®æ“ä½œè¡Œç‚ºå‡½å¼(initial/resetã€inputã€outputã€do_dctã€idle)ï¼Œå› æ­¤æˆ‘å€‘éœ€è¦åˆ†åˆ¥
æ’°å¯«æ¸¬è©´ç¨‹å¼ä¸¦å–å¾—äº”ç¨®ä¸åŒçš„æ™‚åºåœ– VCD æª”ï¼Œç„¶å¾Œåœ¨ XPower ä¸­å¾—åˆ°å€‹åˆ¥æ“ä½œ
è¡Œç‚ºçš„ç¸½åŠŸç‡æ¶ˆè€—å€¼åŒæ™‚é–“ç´€éŒ„å…¶åŸ·è¡Œæ™‚é–“ã€‚åœ¨å®Œæˆäº”ç¨®ä¸åŒçš„æ“ä½œè¡Œç‚ºèƒ½é‡æ¶ˆ
è€—è©•ä¼°å¾Œï¼Œæˆ‘å€‘å³å¯å°‡é€™äº›åŠŸç‡æ¶ˆè€—å€¼è³‡è¨ŠåŠ å…¥ SystemC çš„ DCT æ¨¡çµ„ï¼Œå½¢æˆä¸€å€‹
å¯æä¾›å³æ™‚åŠŸç‡æ¶ˆè€—å€¼è³‡è¨Šçš„æ¨¡çµ„ï¼Œå› æ­¤å°‡å…¶æ‡‰ç”¨åˆ°ç³»çµ±æ¶æ§‹æ¨¡æ“¬çš„åŒæ™‚ï¼Œæ­¤æ¨¡
çµ„å³èƒ½æä¾›çµ¦ç³»çµ±è¨­è¨ˆè€…å…¶åŠŸç‡/èƒ½é‡æ¶ˆè€—å€¼ã€‚ 
 
 
 
 
5.1.3 DCT SystemC ç¨‹å¼å¯¦ä½œéƒ¨åˆ† 
åœ¨ SystemC çš„éƒ¨åˆ†ï¼Œå°‡ä»¥ JPEG ç·¨ç¢¼å™¨ç¨‹å¼ç‚ºä¾‹ï¼Œåœ–è¡¨ 5.3 é¡¯ç¤ºæ­¤ JPEG ç·¨ç¢¼
å™¨ç¨‹å¼è¼¸å‡ºå…¥æµç¨‹ï¼Œç‚ºä»¥ PPM(Portable Pix Map)å‹å¼çš„å½±åƒè¼¸å…¥ï¼Œä¸”ä»¥åŸºæœ¬æ–¹å¼è½‰
æ›æˆ JPEG å‹å¼ã€‚å…¶ä¸­ DCT å€å¡Šå³ç‚ºæˆ‘å€‘ä½œç‚ºé©—è­‰çš„éƒ¨åˆ†ï¼ŒDCT_one_block ç¶“ç”±
è»Ÿç¡¬é«”åˆ‡å‰²çš„ç¨‹åº(Hardware/Software Partitioning)ï¼Œå°‡ DCT_one_block è½‰æ›æˆ
SystemC ç¡¬é«”æ¨¡çµ„ï¼Œä¸¦æ¶æ§‹è‡³ CoWare Platform Architect å¸„å°ä¸Šï¼Œå¦‚åœ–è¡¨ 5.5 ç³»çµ±
æ•´é«”ç¡¬é«”æ¶æ§‹ï¼Œåœ–è¡¨ 5.6 è»Ÿé«”æ¨¡æ“¬çµæœï¼Œå½¢æˆä¸€å€‹å¯åŸ·è¡Œè»Ÿç¡¬é«”å…±åŒæ¨¡æ“¬çš„ç’°å¢ƒï¼Œ
ç‚ºä¸€å€‹ JPEG ç·¨ç¢¼ç³»çµ±ä¸¦ä¸”æœ‰ä¸€ç¡¬é«” DCT æ¨¡çµ„ï¼Œæ­¤ DCT å€å¡Šå³ç‚ºåœ¨å¯¦é©—ä¸€ä¸­çš„ä¸»
è¦è§’è‰²ã€‚ 
 
// Power information from XPOWER Analysis 
// Xilinx Device Part: 2v250fg456-6 
// Power Unit : uJ 
// filename : DCT_POWER.h 
 
#define  IDEL_POWER      6906000 
#define  DO_DCT_POWER  108638320 
#define  INPUT_POWER   249337600 
#define  OUTPUT_POWER  380379520 
#define  RESET_POWER    21853250 
åœ–è¡¨ 5.2 DCT_POWER.h â€“åŠŸç‡æ¶ˆè€—è³‡è¨Šçš„å·¨é›†å®šç¾© 
åœ–è¡¨ 5.2 å‘ˆç¾ C/C++å·¨é›†å®šç¾©çš„æ–¹å¼ï¼Œå¯ä»¥å¾ˆæ˜é¡¯çœ‹çš„å‡ºå…¶æ–¹ä¾¿æ€§åŠç¶­è­·ä¾¿åˆ©æ€§ï¼Œ
åœ¨åŠŸç‡æ¶ˆè€—è³‡è¨Šå€¼éœ€è¦è®Šå‹•æ™‚ï¼Œæˆ‘å€‘åªéœ€è¦ä¿®æ”¹é å…ˆå®šç¾©çš„å·¨é›†æª”ï¼Œä¸¦ä¸éœ€æ·±å…¥
ä¿®æ”¹ DCT æ¨¡çµ„çš„ç¨‹å¼ç¢¼å…§å®¹ã€‚ 
 
 
åœ–è¡¨ 5.4 å…·æœ‰åŠŸç‡æ¶ˆè€—è³‡è¨Šçš„ DCT IP æ¨¡çµ„å»ºæ§‹ç¤ºæ„åœ– 
 
 
  
5.1.4 DCT å¯¦é©—çµæœåŠæ¨¡æ“¬ 
ä¸‹åœ–è¡¨ 5.7 æ‰€å‘ˆç¾æ˜¯ DCT çš„é‹ç®—æ¬¡æ•¸æ¯æ¬¡éå¢ 10 å€ä¸¦é‡æ¸¬å…¶èƒ½é‡æ¶ˆè€—ã€‚åœ–è¡¨
æ©«è»¸è¡¨ DCT çš„é‹ç®—æ¬¡æ•¸ï¼Œç¸±è»¸è¡¨æ¶ˆè€—çš„èƒ½é‡ã€‚åœ–è¡¨ 5.7 ä¸­çš„ç™¾åˆ†æ¯”æ•¸å€¼è¡¨ç¤ºæš«å­˜
å™¨å‚³è¼¸å±¤ç´š(RTL)èˆ‡ SystemC å…©è€…ä¹‹é–“çš„åŠŸç‡æ¶ˆè€—ç›¸å°èª¤å·®å€¼ï¼Œå¯æ˜é¡¯çœ‹åˆ°äºŒè€…ä¹‹
é–“æ˜¯å‘ˆç¾å°æ–¼ 0.2%çš„èª¤å·®å€¼ï¼Œä¹Ÿå°±æ˜¯èªªä½¿ç”¨ç³»çµ±å±¤ç´šçš„æ–¹å¼ä¹Ÿæ˜¯æœ‰ä¸€å®šçš„ç²¾ç¢º
åº¦ã€‚ 
 
 
åœ–è¡¨ 5.7 DCT IP æ¨¡çµ„ä¹‹åŠŸç‡æ¶ˆè€—åˆ†ææ¯”è¼ƒ 
  
5.2 å¯¦é©—äºŒï¼šCRC32 
CRC çš„è‹±æ–‡å…¨ç¨±ç‚º Cyclic Redundancy Check(Code)ï¼Œä¸­æ–‡åç¨±ç‚ºå¾ªç’°å†—é¤˜æ ¡
é©—(ç¢¼)ï¼Œç‚ºä¸€ç¨®ç·šæ€§åˆ†çµ„ç¢¼ï¼Œç·¨ç¢¼å’Œè§£ç¢¼æ–¹æ³•ç°¡å–®ï¼Œæª¢éŒ¯å’Œç³¾éŒ¯èƒ½åŠ›å¼·ï¼Œåœ¨é€šä¿¡ç³»
çµ±åŠå…¶ä»–åºåˆ—è³‡æ–™çš„å‚³è¼¸å·²å»£æ³›é‹ç”¨ä¹‹ã€‚ 
 
5.2.1 CRC32 HDL ç¨‹å¼å¯¦ä½œéƒ¨åˆ† 
HDL ç¨‹å¼ç¢¼çš„éƒ¨åˆ†æ˜¯æºè‡ªæ–¼[33]ï¼Œä¸€å€‹ä½¿ç”¨ Virtex è£ç½®ä¸¦å¯¦ä½œå‡º IEEE 802.3 
CRC çš„ IP åƒè€ƒè¨­è¨ˆç¯„ä¾‹ï¼Œæä¾›äº† CRC-8ï¼ŒCRC-12ï¼ŒCRC-16 å’Œ CRC-32ã€‚åœ¨æ­¤å¯¦
é©—ä¸­æˆ‘å€‘åƒ…æ¡ç”¨ CRC-32 ä¾†é©—è­‰ã€‚ 
 
5.2.2 CRC32 ç³»çµ±å±¤ç´šæ¨¡çµ„ä¹‹åŠŸç‡æ¶ˆè€—è³‡è¨Šçš„å–å¾— 
åœ¨å»ºæ§‹éç¨‹ä¸­ï¼Œå¦‚åœ–è¡¨ 5.10 æ‰€ç¤ºï¼Œæ­¤ CRC32 çš„å¯¦é©—ä¸­æˆ‘å€‘å°‡å…¶åŠƒåˆ†ç‚ºäº”ç¨®æ“
ä½œè¡Œç‚ºå‡½å¼(initializeã€shiftã€calculateã€result_outputã€idle)ï¼Œå› æ­¤æˆ‘å€‘éœ€è¦åˆ†åˆ¥æ’°
å¯«æ¸¬å¼ç¨‹å¼ä¸¦å–å¾—äº”ç¨®ä¸åŒçš„æ™‚åºåœ– VCD æª”ï¼Œç„¶å¾Œåœ¨ XPower ä¸­å¾—åˆ°å€‹åˆ¥æ“ä½œè¡Œ
ç‚ºçš„ç¸½åŠŸç‡æ¶ˆè€—å€¼åŒæ™‚ç´€éŒ„å…¶åŸ·è¡Œæ™‚é–“ã€‚åœ¨å®Œæˆèƒ½é‡æ¶ˆè€—è©•ä¼°å¾Œï¼Œæˆ‘å€‘å³å¯å°‡é€™
äº›åŠŸç‡æ¶ˆè€—è³‡è¨ŠåŠ å…¥ SystemC çš„ CRC32 æ¨¡çµ„ï¼Œå½¢æˆä¸€å€‹å¯æä¾›å³æ™‚åŠŸç‡æ¶ˆè€—è³‡è¨Š
çš„æ¨¡çµ„ï¼Œå› æ­¤å°‡å…¶æ‡‰ç”¨åˆ°ç³»çµ±æ¶æ§‹æ¨¡æ“¬çš„åŒæ™‚ï¼Œæ­¤æ¨¡çµ„å³èƒ½æä¾›çµ¦ç³»çµ±è¨­è¨ˆè€…å…¶
åŠŸç‡/èƒ½é‡æ¶ˆè€—å€¼ã€‚ 
  åŒæ¨£åœ°ï¼Œå¦‚åœ–è¡¨ 5.9 æ‰€ç¤ºï¼Œä½¿ç”¨ VCD æª”çš„æ–¹å¼æ”¶é›†åŠŸç‡æ¶ˆè€—è©•ä¼°æ‰€éœ€çš„å…§éƒ¨
è¨Šè™Ÿè³‡è¨Šï¼Œå¯é¿å…ä½¿ç”¨è€…è‡ªè¡Œå®šç¾©çš„è¼¸å…¥æ‰€é€ æˆçš„èª¤å·®ï¼ŒåŒæ™‚ä¹Ÿå¯ä»¥å…é™¤ç¹è¤‡çš„
è¼¸å…¥è³‡æ–™éç¨‹ã€‚åœ–è¡¨ 5.9 å¯æ˜é¡¯çœ‹å‡º VCD æª”å…§ Signals æ¬„æ‰€ç´€éŒ„çš„è¨Šè™Ÿè³‡è¨Šé …ç›®ï¼Œ
å…¶ä¸­å·²è©³ç´°åœ°è¨˜è¼‰è‘—è¼¸å‡ºå…¥çš„è¨Šè™Ÿè³‡æ–™ä»¥åŠå…§éƒ¨é‹ç®—çš„è¨Šè™Ÿè³‡æ–™ã€‚ 
5.2.3 CRC32 SystemC ç¨‹å¼å¯¦ä½œéƒ¨åˆ† 
åœ¨æ­¤å¯¦é©—ï¼Œæˆ‘å€‘æ¡ç”¨ä¸åŒçš„ SystemC é–‹ç™¼ç’°å¢ƒï¼Œæ¡ç”¨çš„ç‚º OSCI å·¥ä½œçµ„ç¹”æ‰€ç™¼
è¡¨çš„ SystemC 2.1 ç¨‹å¼èªè¨€ï¼Œç›®å‰ä¹Ÿå·²æˆç‚º IEEE 1666 SystemC æ¨™æº–ã€‚æˆ‘å€‘å°‡
SystemC çš„æ¨¡çµ„ä»¥åŠ OSCI SystemC æ¨¡æ“¬ç’°å¢ƒæ¶è¨­è‡³ Linux å·¥ä½œç«™ä¸Šï¼ŒåŒæ¨£æ¡ç”¨
C/C++é å…ˆè™•ç†å™¨å·¨é›†å®šç¾©çš„æ–¹å¼ä¾†ç®¡ç†ç¶­è­·ã€‚ 
é—œæ–¼ SystemC çš„åŸå§‹ç¨‹å¼ç¢¼ï¼Œæ­¤å¯¦ä½œå…§å®¹ç‚ºä¸€å€‹è¨ˆç®—æŸæª”æ¡ˆçš„ CRC32 å€¼ï¼›å› 
æ­¤è¼¸å…¥ç‚ºä¸€å€‹æª”æ¡ˆåç¨±ï¼Œä¸¦è¨ˆç®—å…¶æª”æ¡ˆçš„ CRC32 å€¼ã€‚åœ–è¡¨ 5.11 å‘ˆäº†æ¶æ§‹æ–¼ OSCI
ä¸Šçš„æª”æ¡ˆéšå±¤é—œé€£æ€§ï¼Œåœ¨ CRC_POWER.h æª”æ¡ˆä¸­ï¼Œå³ç‚ºå‰è¿°ä½¿ç”¨ C/C++å·¨é›†çš„æ–¹
å¼ä¾†ç®¡ç†ç¶­è­·ç”¨ï¼Œæ‰€è¨˜è¼‰çš„åªæœ‰åŠŸç‡æ¶ˆè€—çš„è³‡è¨Šï¼›åœ–è¡¨ 5.12 å‘ˆç¾å‡ºæ¶æ§‹çš„æ¨¡æ“¬ç¤º
æ„åœ–ï¼ŒCRC32 æ¨¡çµ„ç”¨æ–¼è¨ˆç®—å¾…æ¸¬æª”æ¡ˆçš„ CRC32 æ•¸å€¼ï¼Œæ¸¬è©´å¸„å°(Testbench)æ¨¡çµ„è² 
è²¬å¾…æ¸¬æª”æ¡ˆçš„é å…ˆè™•ç†ï¼Œå…©è€…ä¹‹é–“ç¶“ç”± FIFO çš„é€šé“ä½œæºé€šï¼Œä¾†å®Œæˆè³‡æ–™å‚³è¼¸åŠæ§
åˆ¶ä¹‹ç”¨é€”ã€‚å…¶ä¸­ç”±æ–¼å¯¦ä½œå¿…é ˆå°ç…§ HDL çš„ç¨‹å¼ç¢¼å…¶ç‰¹æ€§ï¼Œæ‰€ä»¥æˆ‘å€‘å¯ä»¥å®¹æ˜“åœ°è§€
å¯Ÿå‡º(å¦‚åœ–è¡¨ 5.13)ï¼Œå…¶è¨ˆç®—é‡å°‡æœƒæ˜¯ç­‰åŒæª”æ¡ˆå¤§å°çš„ä½å…ƒçµ„(byte)å€¼ã€‚ 
æ¶æ§‹æ–¼ OSCI ç’°å¢ƒä¸‹çš„ CRC32 å¯¦ä½œç¤ºæ„åœ–ï¼š 
 
åœ–è¡¨ 5.11 CRC-32 SystemC å¯¦ä½œçš„æª”æ¡ˆéšæ®µé—œä¿‚ 
 
5.2.4 CRC32 å¯¦é©—çµæœåŠæ¨¡æ“¬ 
ä¸‹åœ–è¡¨ 5.14 æ‰€å‘ˆç¾æ˜¯ CRC32 ç¯„ä¾‹ï¼Œå…¶å°æ–¼ä¸åŒæª”æ¡ˆå¤§å°åˆ†åˆ¥è¨ˆç®— CRC32 å€¼ï¼Œ
ä¸¦ä»¥ä½å…ƒçµ„(byte)ç‚ºå–®ä½çš„é‹ç®—é‡ä½œæ¯æ¬¡éå¢ 10 å€é‡æ¸¬å…¶èƒ½é‡æ¶ˆè€—ã€‚åœ–è¡¨ 5.14 æ©«
è»¸è¡¨è©´é©—æª”æ¡ˆå…¶å¤§å°ä»¥ä½å…ƒçµ„(byte)ç‚ºå–®ä½(K ç‚º 1000 å€)ï¼Œç¸±è»¸è¡¨æ¶ˆè€—çš„èƒ½é‡ã€‚åœ–
è¡¨5.14ä¸­çš„ç™¾åˆ†æ¯”æ•¸å€¼è¡¨ç¤ºæš«å­˜å™¨å‚³è¼¸å±¤ç´š(RTL)èˆ‡SystemCå…©è€…ä¹‹é–“çš„åŠŸç‡æ¶ˆè€—
ç›¸å°èª¤å·®å€¼ï¼Œå¯æ˜é¡¯çœ‹åˆ°äºŒè€…ä¹‹é–“æ˜¯å‘ˆç¾å°æ–¼ 0.4%çš„èª¤å·®å€¼ï¼Œä¹Ÿå°±æ˜¯èªªä½¿ç”¨ç³»çµ±
å±¤ç´šçš„æ–¹å¼åŒæ¨£ä¹Ÿæ˜¯ä¸€å®šçš„ç²¾ç¢ºåº¦ã€‚ 
 
 
åœ–è¡¨ 5.14 CRC-32 IP æ¨¡çµ„ä¹‹åŠŸç‡æ¶ˆè€—åˆ†ææ¯”è¼ƒ 
 
  
5.3 å¯¦é©—ä¸‰ï¼šè‰²å½©ç©ºé–“è½‰æ› - RGB è½‰ YCbCr 
é¡è‰²æœ‰å¹¾å€‹ä»¥æ•¸ä½è¡¨ç¾çš„æ–¹æ³•ï¼Œå¦‚åœ–è¡¨ 5.16 æ‰€ç¤ºï¼Œå…¶ä¸­ä»£è¡¨æ€§ä¹‹ä¸€çš„æ–¹æ³•å¦‚
RGB å’Œ YCbCrã€‚RGB æ˜¯é¡è‰²ä¸‰åŸè‰²ï¼ŒR(ç´…è‰²)ï¼ŒG(ç¶ è‰²)ï¼ŒB(è—è‰²)ä»¥æ•´æ•¸å€¼(0~255)
è¡¨ç¤ºã€‚YCbCr ç‚º Y(äº®åº¦æˆä»½)ï¼ŒCb(è‰²å·®æˆä»½ï¼Œç¶ è‰²äº®åº¦æˆä»½)ï¼ŒCr(è‰²å·®æˆä»½ï¼Œç´…
è‰²äº®åº¦æˆä»½)ã€‚è‰²å½©ç©ºé–“è½‰æ›ç›®å‰å·²å¤§é‡åœ°æ‡‰ç”¨æ–¼å½±éŸ³å½±åƒç·¨ç¢¼çš„è¨­è¨ˆã€‚ä¸»è¦åŸå› 
æ˜¯äººé¡çš„çœ¼ç›å°é¡è‰²çš„è®ŠåŒ–(Cr å’Œ Cb æˆä»½)æ¯”äº®åº¦çš„è®ŠåŒ–æ›´æ•æ„Ÿï¼Œä¿æŒ Y æˆä»½è€Œå–
å¾— Crï¼ŒCb æˆä»½ï¼Œå¯ä»¥æŠ‘åˆ¶ç•«è³ªè®Šå·®åŠæ¸›å°‘è³‡æ–™é‡çš„è™•ç†ã€‚ 
 
 
åœ–è¡¨ 5.16 é¡è‰²è½‰æ›é›»è·¯æ¦‚è¦ 
 
 
5.3.1 RGBtoYCbCr HDL ç¨‹å¼å¯¦ä½œéƒ¨åˆ† 
HDLç¨‹å¼ç¢¼çš„éƒ¨åˆ†æ˜¯æºè‡ªæ–¼[34]ï¼Œç‚ºä¸€å€‹ä½¿ç”¨ Spartan-IIE è£ç½®(2S50E-6TQ144)
çš„ IP åƒè€ƒè¨­è¨ˆå¯¦ä½œã€‚åœ¨æ­¤å¯¦é©—ä¸­æˆ‘å€‘é‡æ–°ä¿®æ”¹ä¸¦æ“ä½œåˆæˆã€è½‰è­¯ã€ä½ˆå±€å’Œç¹ç·šæ–¼
Virtex-2 è£ç½®ä½œå†æ¬¡çš„é©—è­‰ã€‚ 
 
  
 
åœ–è¡¨ 5.18 RGBtoYCbCr æ™‚åºåœ– 
 
5.3.3 RGBtoYCbCr SystemC ç¨‹å¼å¯¦ä½œéƒ¨åˆ† 
åœ¨ SystemCçš„å¯¦ä½œéƒ¨åˆ†ï¼Œæ­¤RGBè½‰YCbCræ¨¡çµ„æˆ‘å€‘æ¶è¨­æ–¼ARM SoC Designer 
(MaxSim)é–‹ç™¼ç’°å¢ƒå¦‚ä¸‹åœ–è¡¨5.19æ‰€ç¤ºï¼Œæ¡ç”¨å¦ä¸€å€‹æ¸¬è©´å¸„å°æ¨¡çµ„ä¾†å®Œæˆé©—è­‰æ¨¡æ“¬ï¼Œ
åœ¨ Console è¦–çª—å°è©±æ¡†çš„ç•«é¢ä¸­æ–¼åŸ·è¡Œéç¨‹å³å¯å¾—çŸ¥å…¶åŠŸç‡æ¶ˆè€—çš„è³‡è¨Šã€‚ 
 
 
åœ–è¡¨ 5.19 RGBtoYCbCr æ–¼ ARM RealView SoC Designer çš„æ¨¡æ“¬åŸ·è¡Œçµæœ 
åŒæ¨£åœ°æˆ‘å€‘å°æ–¼é‹ç®—é‡é”åˆ° 107 æ¬¡æ™‚ï¼Œå°äºŒè€…ä¹‹é–“æ‰€éœ€çš„åŠŸç‡æ¶ˆè€—æ¨¡æ“¬ä¹‹æ“ä½œ
æ™‚é–“ä½œåˆ†ææ¯”è¼ƒã€‚åœ–è¡¨ç¸±è»¸è¡¨æ‰€éœ€çš„åŠŸç‡æ¶ˆè€—åˆ†ææ“ä½œæˆæœ¬æ¯”ä¾‹å€¼ã€‚å¦‚ä¸‹åœ–è¡¨ 5.21
æ‰€å‘ˆç¾å‡ºçš„ç‚ºæ–¼äºŒå€‹ä¸åŒå±¤ç´šä¹‹é–“æ‰€éœ€åŠŸç‡æ¶ˆè€—åˆ†ææˆæœ¬çš„æ¯”è¼ƒåœ–è¡¨ï¼Œå³ç‚ºæš«å­˜
å™¨å‚³è¼¸å±¤ç´š(RTL)å’Œ SystemC ä¹‹é–“åŸ·è¡Œæ“ä½œæ¨¡æ“¬ã€åˆ†æåŠŸç‡æ¶ˆè€—æ‰€éœ€çš„åŸ·è¡Œç¸½æ™‚é–“
çš„æ¯”ä¾‹ã€‚å¾åœ–è¡¨ 5.21 ä¸Šæ‰€ç¤ºæš«å­˜å™¨å‚³è¼¸å±¤ç´š(RTL)æ‰€éœ€èŠ±è²»çš„æ™‚é–“æ˜¯ SystemC çš„
607 å€ä¹‹ä¹…ã€‚ 
 
 
åœ–è¡¨ 5.21 RGBtoYCbCr IP æ¨¡çµ„ä¹‹åŠŸç‡æ¶ˆè€—åˆ†ææ“ä½œæˆæœ¬æ¯”è¼ƒ 
  
6. çµï¥èˆ‡æœªä¾†å·¥ä½œ 
6.1 çµï¥ 
åœ¨æœ¬ç ”ç©¶ä¸­ï¼Œæˆ‘å€‘ä¸»è¦å°ˆæ³¨æ–¼å°å”åŠ›è™•ç†æ©Ÿ (Coprocessor)æˆ–æ˜¯ç‰¹å®šæ‡‰ç”¨
IC(ASIC)æå‡ºä¸€å€‹å¯æ–¼ç³»çµ±å±¤ç´šåŸ·è¡ŒåŠŸç‡æ¶ˆè€—è©•ä¼°çš„æ–¹æ³•ã€‚ç„¶è€Œï¼Œåœ¨ç³»çµ±å±¤ç´šä¸¦
æ²’æœ‰çœŸå¯¦çš„ç¡¬é«”æ¶æ§‹ç’°å¢ƒï¼Œæ›´æ²’æœ‰åŠŸç‡æ¶ˆè€—çš„è³‡è¨Šå­˜åœ¨ã€‚å› æ­¤æ¡ç”¨äº†
Macro-Modelingçš„æ–¹å¼å¾è¼ƒä½å±¤ç´šå»é‡æ¸¬ä¸¦è£œè¶³åœ¨ç³»çµ±å±¤ç´šæ‰€æ²’æœ‰æä¾›çš„åŠŸç‡æ¶ˆ
è€—è³‡è¨Šï¼›å› æ­¤æ¡ç”¨Macro-Modelingæ–¹å¼æ‰€å»ºæ§‹çš„SystemCæ¨¡çµ„ï¼Œèƒ½åœ¨æ²’æœ‰çœŸå¯¦ç¡¬é«”
æ¶æ§‹ä¸‹çš„ç³»çµ±å±¤ç´šä½œå®Œæ•´çš„æ¨¡æ“¬é©—è­‰ä¸¦æä¾›åŠŸç‡æ¶ˆè€—è³‡è¨Šã€‚ 
åœ¨IPæ¨¡çµ„å»ºæ§‹çš„æ–¹é¢ï¼Œæˆ‘å€‘ä¹Ÿæä¾›äº†ä¸€äº›åˆ†æè¦é»åŠå»ºæ§‹æ‘˜è¦åŠæŒ‡å¼•ï¼Œæ¡ç”¨ä¸
å¯åˆ†å‰²çš„æ“ä½œè¡Œç‚ºç‰¹æ€§å»å‰µå»ºSystemCç¡¬é«”æ¨¡çµ„ã€‚ 
åœ¨æ¨¡çµ„è¨­è¨ˆçš„åŒæ™‚ï¼Œæˆ‘å€‘ä¸¦ä¸éœ€è¦å»å¢åŠ ä»»ä½•çš„å‡½å¼åº«æˆ–æ¨¡çµ„ï¼Œæ›´ä¸éœ€å»å°
SystemCçš„å‡½å¼åº«ä½œä»»ä½•çš„ä¿®æ”¹ï¼Œå› æ­¤ç¨‹å¼ç¢¼çš„é©ç”¨ç¯„åœä¸¦ä¸å—æ–¼ä»»ä½•ç’°å¢ƒæˆ–ç¨‹å¼
èªè¨€ï¼Œå…¶ç‚ºæ˜é¡¯å¯è¦‹çš„ã€‚åŒæ™‚ä¹Ÿå¼•å…¥ç¶­è­·ä¾¿åˆ©æ€§çš„è¨­è¨ˆè€ƒé‡è§€é»ï¼Œæ¡ç”¨C/C++å¸¸è¦‹
çš„å¯«ä½œæŠ€å·§ä¾†é”åˆ°ç¨‹å¼ç¢¼æ–¹ä¾¿ç¶­è­·ä¹‹ç”¨é€”ã€‚ 
åœ¨å¯¦é©—ä¸­ï¼Œè¨¼æ˜äº†æˆ‘å€‘çš„æ–¹æ³•å°±ç³»çµ±å±¤ç´šå’Œæš«å­˜å™¨å‚³è¼¸å±¤ç´šç›¸æ¯”è¼ƒï¼Œåœ¨ç³»çµ±
å±¤ç´šåŒæ¨£èƒ½æä¾›è¨­è¨ˆè€…æœ‰ä¸€å®šå“è³ªçš„åŠŸç‡æ¶ˆè€—è³‡è¨Šï¼Œä¸”äºŒè€…ä¹‹é–“åªæœ‰æ¥µå°çš„èª¤å·®
å€¼ï¼›åŒæ™‚æ¡ç”¨ç³»çµ±å±¤ç´šä½œåŠŸç‡æ¶ˆè€—æ¨¡æ“¬åˆ†æèƒ½è—‰ç”±æŠ½è±¡åŒ–çš„å½±éŸ¿è€ŒåŠ é€Ÿåˆ†æçµæœ
çš„å–å¾—ï¼Œè§£æ±ºä½¿ç”¨æš«å­˜å™¨å‚³è¼¸å±¤ç´šçš„æ–¹æ³•ç•¶è¨­è¨ˆéå¤§æˆ–è€…éœ€é•·æ™‚é–“çš„æ¨¡æ“¬åˆ†ææ™‚
å€™ï¼Œæ‰€é€ æˆçš„è€—æ™‚åˆ†æçš„å•é¡Œï¼ŒäºŒè€…ä¹‹é–“çš„æ¨¡æ“¬æ“ä½œæ™‚é–“å‘ˆç¾äº†æœ‰æ•¸åå€çš„æ™‚é–“
å·®è‡³æ•¸ç™¾å€ä¹‹å¤šã€‚æ›è¨€ä¹‹ï¼Œå°±çœŸå¯¦æ™‚é–“å’Œå–®ä½è€Œè¨€ï¼ŒäºŒè€…ä¹‹é–“æ˜¯æ•¸åˆ†é˜èˆ‡æ•¸å°æ™‚
ä¹‹æ¯”ã€‚å¦å¤–ï¼Œå¯¦é©—çš„æ¨¡æ“¬å¸„å°æ¡ç”¨äº†ä¸‰ç¨®ä¸åŒçš„ SystemC é–‹ç™¼é©—è­‰ç’°å¢ƒï¼Œä¸¦æ–¼é€™
ä¸‰å€‹ä¸åŒçš„é–‹ç™¼ç’°å¢ƒä¸ŠæˆåŠŸå¯¦ä½œå‡ºï¼Œä¸¦åŸ·è¡Œå®Œæ•´çš„æ¨¡æ“¬ï¼Œåœ¨åœ¨åœ°èªªæ˜æˆ‘å€‘çš„æ–¹æ³•
å…¶é©ç”¨æ€§ä¸æœƒå› ç‚ºç’°å¢ƒçš„ä¸åŒè€Œæ”¹è®Šã€‚ 
åƒè€ƒæ–‡ç» 
[1] S. Swan, â€œAn Introduction to System Level Modeling in SystemC 2.0,â€ White 
paper, http://www.systemc.org, May 2001. 
[2] SystemVerilog, http://www.systemverilog.org/. 
[3] T. K. Tan, A. Raghunathan, G. Lakshminarayana, and N. K. Jha, "High level 
software energy macro-modeling," in Proc. Design Automation Conf., 2001, pp. 
605--610. 
[4] Tan, T. K., Raghunathan, A., and Jha, N. K. "Energy macro modeling of embedded 
operating systems," Trans. on Embedded Computing Sys. pp. 231--254, Feb. 2005. 
[5] Nitesh Goyal, "Macro-modeling and energy efficiency studies of file management 
in embedded systems with flash memory," MASTER Thesis, in Texas A&M 
University, May 2005. 
[6] S. Xanthos, A. Chatzigeorgiou, and G. Stephanides. "Energy Estimation with 
SystemC: A Programmer's Perspective," in Proc. of the 7th Int. Conf. on Systems, 
Computational Methods in Circuits and Systems Applications, July 7, 2003. 
[7] Robertas Damasevicius, "Estimation of Design Characteristics at RTL Modeling 
Level Using SystemC," Information Technology And Control, 2006, vol.35, no.2, 
pp. 117--123. 
[8] Jinwen Xi, Zhaohui Huang, Peixin Zhong, "Energy macro-modeling of embedded 
microprocessor using SystemC," Electro Information Technology IEEE 
International Conference, May 2005. 
[9] Bansal, N., Lahiri, K., Raghunathan, A., and Chakradhar, S. T. 2005. â€œPower 
Monitors: A Framework for System-Level Power Estimation Using Heterogeneous 
Power Models,â€ In Proceedings of the 18th international Conference on VLSI 
Design Held Jointly with 4th international Conference on Embedded Systems 
pp. 867--872. 
[21] Benini, L. Ferrero, M. Macii, A. Macii, E. Poncino, M., "Power analysis of 
software-implemented digital filters: a case study", Electrotechnical Conference, 
2000, vol.2, pp. 595--598. 
[22] ARM Software Development Toolkit, http://www.arm.com/ 
[23] Givargis, T. D., Vahid, F., and Henkel, J. â€œInstruction-based System-Level power 
evaluation of system-on-a-chip peripheral cores,â€ In Proceedings of the 13th 
international Symposium on System Synthesis, September 20, 2000, pp. 163--169. 
[24] Claudio Talarico , Jerzy W. Rozenblit , Vinod Malhotra , Albert Stritter, "A New 
Framework for Power Estimation of Embedded Systems", Computer, vol.38 no.2, 
p.71--78, February 2005. 
[25] David C. Black and Jack Donovan, "SYSTEMC: FROM THE GROUND UP," 
Kluwer Academic Publishers, 2004. 
[26] IEEE1666TM Standard SystemC Language Reference Manual, http://www.ieee.org/ 
[27] OSCI SystemC 2.1/2.0 Language Reference Manual, http://www.systemc.org 
[28] XPower Analyzer FAQ, http://www.xilinx.com/ 
[29] Xilinx Solution 15492ï¼General tips on reducing VCD file size using ModelSim, 
http://www.xilinx.com/ 
[30] å¤§æ‘æ­£ä¹‹ã€æ·±å±±æ­£å¹¸ åŸè‘—ï¼Œæº«æ¦®å¼˜ ç·¨è­¯ï¼Œâ€C/C++ VLSI è¨­è¨ˆâ€ï¼Œå…¨è¯ç§‘æŠ€åœ–
æ›¸è‚¡ä»½æœ‰é™å…¬å¸ï¼Œ2005 
[31] Latha Pillai, "Xilinx Reference Design XAPP610 (v1.3) - Video Compression 
Using DCT", March 3, 2005. 
[32] Latha Pillai, "Xilinx Reference Design XAPP611 (v1.2) - Video Compression 
Using IDCT", June 3, 2005. 
[33] Chris Borrelli, "Xilinx Reference Design XAPP209 (v1.0) - IEEE 802.3 Cyclic 
Redundancy Check", March 23, 2001. 
 2009 å¹´ IEEE Symposium on Field-
Programmable Custom Computing 
Machines 
 åƒåŠ åœ‹éš›æœƒè­°å ±å‘Š 
 
 
 
 
ç‹å‹å¾· æ•™æˆ 
åœ‹ç«‹å°ç£å¤§å­¸é›»æ©Ÿå·¥ç¨‹å­¸ç³»æ•™æˆ 
 
 
 
 
 
 
 
  
 
(and vice versa) 
Languages and Compilers 
ï‚· New languages and development environments to describe spatial or hybrid 
applications 
ï‚· Tools to make run-time reconfiguration more accessible to application 
designers 
ï‚· Compilation and CAD techniques for reconfigurable computing systems and 
other spatial computers Run-Time Systems and Run-Time Reconfiguration 
ï‚· Operating system techniques to manage run-time reconfiguration of 
resources in reconfigurable computing or spatial computing systems 
ï‚· Run-time CAD algorithms to support the above techniques or improve fault 
tolerance/avoidance 
ï‚· Use of reconfigurability to build evolvable or adaptable computing systems 
ï‚· Novel uses of run-time reconfiguration in application-specific systems 
Applications 
ï‚· Novel applications that use reconfigurability to customize hardware for 
scientific computation, mobile communications, medical image processing, 
data and communication security, network infrastructure and other 
embedded systems 
ï‚· Comparison of application implementations on different spatial hardware, 
such as GPGPUs, multi-core processors, and FPGAs. 
 
æœƒè­°å¿ƒå¾— 
æœ¬æ¬¡æœƒè­°æˆ‘ç™¼è¡¨çš„è«–æ–‡å®‰æ’åœ¨ poster section 3: 
Context Sharing for Area Efficiency of Regular Expression Pattern Matching on 
FPGA, Yuan-Chin Wen, Henry Yu and Sheng-De Wang 
 1 
ï€  
Abstractâ€”Network Intrusion Detection System (NIDS) utilizes 
complex strings to perform inspection over the raw traffic from 
networks. The goal is to identify whether this traffic is intrusive or 
not. Complex strings, also known as signatures, are on behalf of 
various behaviors of attacks. Most of signatures are composed of 
normal characters and regular expressions which are provided by 
illustrious network security software such as SNORT and Bro. 
With rapid growing of Perl compatible regular expressions 
(PCREs) used in SNORT, more and more resources are required 
to store these increasing rules. Therefore, the trend is towards 
minimizing designs of logic block and architecture on 
field-programmable gate array (FPGA). In this paper, we propose 
a novel method, named context sharing (CS), to minimize the size 
of NFAs. We also create a circuit generator, called Rx2V, to gen-
erate pattern matching engines corresponding to given PCREs. 
Finally we conduct experiments and obtain results showing that 
CS can achieve 41.7% reduced usage of logic cells (LCs) on 
FPGA. 
 
 Index Termsâ€”Intrusion detection, pattern matching, regular 
expression, field programmable gate array 
 
I. INTRODUCTION 
ITH common uses of web services and Internet applica-
tions, network security systems have attracted more and 
more attention. In case some malicious network traffic contains 
particularly designated strings, said signatures, these packets in 
the traffic are probably trying to break in intrusively or attempt 
to launch attacks that cause services unavailable from victim 
systems or web sites. These attacks are also known as denial of 
service (DOS). Signature-based NIDS generally utilizes com-
plex signatures to look through network traffic to identify 
whether the traffic is hostile to the system. As soon as any 
malicious packet is detected by a matched pattern, the NIDS 
will execute a corresponding emergent process or issue an alert 
for analysis or forensics. 
 Most end-users, even system administrators, rely on plenty 
of anti-virus software and network monitoring tools. Due to 
sequential pattern-matching, these software-based tools have 
 
 
This work is supported by iCAST, The International Collaboration for 
Advancing Security Technology, was established in the 1
st
 quarter of 2006 to 
start a three year international collaboration project of research and develop-
ment in the area of Information Security. This mission-oriented project was 
granted by the National Science Council (NSC) of Taiwan to strengthen in-
formation and communication security within all Taiwanâ€™s academic, gov-
ernment, industry and service sectors 
Y.C. Wen, Henry Yu and S. â€“D. Wang are with Division of Computer 
Science, Department of Electrical Engineering, National Taiwan University, 
Taipei, TAIWAN  
(email: {puff, henry}@hpc.ee.ntu.edu.tw; sdwang@ntu.edu.tw) 
shortcomings that are incapable of catching up high throughput 
interfaces such as 10 Gbps Ethernet or Infiniband. On the other 
hand, the number of vulnerabilities is rapidly on the increase; 
meanwhile, security communities need to provide more com-
plicated patterns to describe these malicious signatures. Fig. 1 
shows that more and more various intrusions have been dis-
covered. In other words, the signatures corresponding to these 
intrusions are also rapidly increasing. For example, in SNORT 
2.1 and 2.8, there are 3108 and 9854 rules respectively. The 
growing ratio for the two verisons is 317%. On the other hand, 
non-duplicate PCREs in SNORT 2.1 and 2.8 are 324 and 1941 
respectively. The growing ratio is 599%. Moreover, with such 
high rapid increase of rules, it is difficult to update large 
amount of rules for NIDS within a short interval of time. For 
the rules in SNORT, the analysis in [1] points out that the pat-
tern-matching procedure consumes about 80% of processing 
time. On the whole, an accelerative, scalable, and flexible 
method is demanded to solve above problems. 
 
 
Fig. 1. SNORT rules statistics 
 
Before minimizing the size of NFA, here comes one example 
to present the problem of applying sharing methods in 
NFA-based pattern matching on FPGA. Traditionally, we im-
plement one NFA corresponding to one rule in Fig. 2. These 
NFAs are independent with each other. However, in our anal-
ysis, many similar rules possess very little difference even only 
one character. For example, in Fig. 2, considering rules net-
bios2467, netbios2470, and netbios2473 under the netbios rule 
set in SNORT 2.8, we will waste many logic cells (LCs) on 
FPGA to build identical circuit blocks. If we could provide 
methods to group common substrings between those indepen-
dent NFAs, we may save lots of LCs to achieve area efficiency. 
0
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
2.1 2.2 2.4 2.6 2.8
SNORT statistics
Rules
PCREs
Context Sharing for Area Efficiency of Regular 
Expression Pattern Matching on FPGA 
Yuan-Chin Wen, Henry Yu, and Sheng-De Wang 
         
W 
 3 
Fig. 5. Using delay logic to keep signal from prior state Fig. 6. CS architecture 
       
In general, most memory accessing relies on the given ad-
dress of data location. However, it is infeasible address by 
address to find the location of specific data. Therefore, a type of 
memory uses a mechanism looking for the content by using the 
address that depends on a part of data content. The memory 
adopting this mechanism is called CAM.  
Bu et al. [8] presented a CAM-based solution to NIDS at line 
speed over 2 Gbps and pointed out that improving technologies 
of VLSI can further enable CAM-based approaches to meet 10 
Gbps. Sourdis et al. applied character pre-decoding, shift reg-
ister based lookup table with 16 bits (SRL16) of Xilinx FPGA 
and pipelining technologies to catch up throughput almost 10 
Gbps. Yu et al. [10] utilized TCAM to process complex pat-
terns such as correlated patterns and patterns with negations 
and wildcards. In their design, it is able to work 2Gbps with 240 
KB TCAM. 
 
III. CONTEXT SHARING FOR AREA EFFICIENCY 
In Section I, we have addressed the false-positive problem 
that we would encounter if we apply common prefix sharing 
method for common infix/postfix sharing. In this section, we 
are going to discuss and provide a novel method to solve the 
context sharing problem. Part A discusses the architecture of 
CS and proves the feasibility of the design. Part B points out the 
advantages and features of our method. Part C provides the 
constraint in this method. 
A. Context Sharing 
To solve above problem, we need a new mechanism to keep 
track of positive signals triggered by which prior state of each 
NFA[7]. Besides keeping track of the positive signal, we can 
also â€œdelayâ€ the signal from the prior state of each NFA before 
completing the match of the common context sharing module. 
Hence, we modify the erroneous design in Fig. 4 to the CS 
approach in Fig. 5. In this way, our design is able to achieve 
common infix and postfix sharing. Moreover, this mechanism 
supports not only simple strings composed of printable and hex 
characters pattern matching but also complicated PCREs 
composed of printable, meta-characters, modifiers, etc. 
To prove our method, consider m regular expressions, said 
Rx1, Rx2, Rx3, â€¦, Rxm. Assume these m regular expressions 
contain a common infix as a sub regular expression which is 
Rxcomm.. Then we can rewrite the regular expressions into Rxj = 
{Rxpre_jRxcommRxpost_j| âˆ€ j âˆˆ Z
+
, 1 â‰¤ j â‰¤ m, (Rxpre_j, Rxcomm, 
Rxpost_j) âˆˆ regular expression}. In Fig. 6, if âˆƒ i âˆˆ Z
+
, 1 â‰¤ i â‰¤ m: 
Rxpre_iRxcommRxpost_i is embedded in the incoming traffic, then 
in the beginning, Rxpre_i will be matched and fan-out the posi-
tive signals to Rxcomm and the delay blocks. The delay clock 
cycles depend on the length of Rxcomm. For example, if the 
length of Rxcomm is n, then one signal will spend n clock cycles 
passing through the states of Rxcomm in NFAi. On the other hand, 
the other signal will take n clock cycles to pass through the 
delay block. After an â€œandâ€ operation, the signals will converge 
and pass through Rxpost_i to complete this pattern matching and 
issue a correct alert. 
B. Features 
There are three features in our CS approach. First, for m 
regular expressions, Rxj = {Rxpre_jRxcommRxpost_j| âˆ€ j âˆˆ Z
+
: 1 â‰¤ j 
â‰¤ m , (Rxpre_j, Rxcomm, Rxpost_j) âˆˆ regular expression, Rxpre_j can 
be null}. For example, consider two NFAs said 
Rxpre_1RxcommRxpost_1 and Rxpre_2RxcommRxpost_2. Assume Rxpre_2 
is null. If the incoming traffic contains the pattern 
Rxpre_1RxcommRxpost_1, then after match of Rxpre_1Rxcomm, the 
signal will go through Rxpost_1 and does not go through Rxpost_2 
because there is no signal from the delayed circuit in NFA2. It is 
the same way to prove if the incoming traffic contains the pat-
tern RxcommRxpost_2.  
Second, for m regular expressions, Rxj = 
{Rxpre_jRxcommRxpost_j| âˆ€ j âˆˆ Z
+
: 1 â‰¤ j â‰¤ m , (Rxpre_j, Rxcomm, 
Rxpost_j) âˆˆ regular expression, Rxcomm can be shared if 
Rxpre_jâŠ‚Rxpre_kRxcomm âˆ€ j, k âˆˆ Z
+
, jâ‰ k, 1 â‰¤ j, k â‰¤ m }. The proof 
method is similar to the first feature. 
Third, for m regular expressions, Rxj = {Rxpre_jRxin_jRxpost_j| 
âˆ€ j âˆˆ Z+: 1 â‰¤ j â‰¤ m , (Rxpre_j, Rxin_j, Rxpost_j) âˆˆ regular expression, 
Rxin_j âŠ‚ Rxin_k âˆ€ j, k âˆˆ Z
+
, jâ‰ k, 1 â‰¤ j, k â‰¤ m }. In the feature, it  
 5 
 
 
Fig. 8. Basic components Fig. 9. PCRE:â€/((a?b)+c)*[^0-9]{3}/â€ to NFA
After implementing these basics components, we regard 
these components as a separated module and refer to given 
PCREs to integrate these modules to the corresponding NFA. 
For example, pattern PCRE:â€/((a?b)+c)*[^0-9]{3}/â€ is a com-
plicated regular expression. Required components are listed in 
Fig. 8. First, we need an at-most-once module in Fig. 8(c) to be 
appended after â€œaâ€. Then we append an at-least-once module in 
Fig. 8(b) after â€œ(a?b)â€. Third, we use a kleen-star which means 
the assigned PCRE can appear any times in Fig. 8(a) after 
â€œ((a?b)+c)â€. Fourth, we append a repetition module in Fig. 8(d) 
and specify the repeated times after the class range â€œ[^0-9]â€. 
The result is depicted in Fig. 9. 
B. Rx2V 
In Fig. 1, we can see that the number of rules in the latest 
SNORT 2.8 is 9854. And there are 91776 characters in the 
content. As for PCRE, it appears to have 12778 instances dis-
tributed in all rules. After removing duplications, we find 1941 
various PCREs in SNORT 2.8. With these enormous patterns, it 
costs an arm and a leg to implement circuit blocks manually for 
NFA-based NIDS. For example, a PCRE like 
/^Host\x3A[^\r\n]*www\.hithopper\.com/smi, may cost about 
20 minutes. For 1941 PCREs in SNORT 2.8, it takes 647 hours. 
In other words, we would spend 27 days accomplishing PCRE 
in SNORT 2.8. Therefore, a fast and complete circuit generator 
that can automatically generate NFA for FPGA form SNORT 
rules is indeed required. 
In Fig. 10, there are five steps during execution of Rx2V 
described as follows: 
step 1. Change to the specified directory then retrieve all pat-
terns followed by â€œPCRE:â€. Then Remove duplicated 
patterns. 
step 2. In implementing the CS method, we shall find common 
prefix first because it costs nothing for sharing. Then find 
common infix and postfix. We apply a greedy algorithm 
to find the longest common sub-pattern. For example, in 
Fig. 7, we chose â€œcdefâ€ to be sub-NFA and specify dif-
ferent length for each delay block of shared rules. Before 
selecting common infix and postfix, we must refer to the 
constraints listed in TABLE 2. 
step 3. Parse modifiers such as multiple lines match(/m), case 
insensitive match(/i), dot matches newlines(/s). 
step 4. Parse operations such as the asserting start and end of 
string(/^Rx$/), wildcard(.), character class([Rx]), sub 
pattern, at most once(?), at least once(+), kleen-star(*), 
repetition(Rx{M}, Rx{M, }, Rx{M, N}), and other me-
ta-characters. 
step 5. Generate Verilog hardware description language codes 
for synthesis. 
 
Retrieve PCRE from 
SNORT rules
Context Sharing
Parse modifiers(/m, /i, /s)
Basic(^, 
$, |, \)
Generate Verilog 
Classes([ab], 
[^ab], [A-Z])
Advanced(*, +, ?, 
{m}, {M,}, {M, N})
Hex and meta-
char(\xFF, \char)
 
 
Fig. 10. Flow of Rx2V 
 
V. EXPERIMENTS 
In our system, we apply the latest version, 2.8, of Snort to 
build NFA-based NIDS on FPGA. We have implemented 
Rx2V to generate the given PCREs to corresponding NFA. We 
also adopt our proposed method, CS, to minimize slices used on 
FPGA. In this section, we will discuss our experimental results. 
Our experimental device is Xilinx Virtex-II Pro 50 FPGA 
which consists of 47232 slices [12]. We synthesize these gen-
erated NFA by the commercial tool Xilinx ISE 9.2.04i. 
 
 
