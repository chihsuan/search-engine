1 
 
 
ä¸€ã€ ä¸­è‹±æ–‡æ‘˜è¦ 
æ‘˜è¦ 
ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯æ˜¯ç›®å‰æ­£è“¬å‹ƒç™¼å±•çš„ä¸€é …æ–°èˆˆæŠ€è¡“ã€‚è—‰ç”±æä¾›ç„¡æ‰€ä¸åœ¨çš„æ„Ÿæ‡‰èƒ½åŠ›ã€è¨ˆ
ç®—èƒ½åŠ›ä»¥åŠé€šè¨Šèƒ½åŠ›ï¼Œç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯å¤§å¤§ä¾¿åˆ©äº†äººé¡çš„ç”Ÿæ´»ã€‚æ­¤é¡çš„ç’°å¢ƒå¯èƒ½åŒ…å«è¨±å¤šåƒ¹
å»‰çš„ç„¡ç·šç¯€é»ï¼Œå…¶ä¸­æ¯å€‹ç¯€é»éƒ½èƒ½å¤ æä¾›æ”¶é›†ã€è™•ç†åŠå„²å­˜ç’°å¢ƒè³‡è¨Šçš„èƒ½åŠ›ï¼Œä¸¦èƒ½èˆ‡ç›¸é„°
çš„ç¯€é»æºé€šã€‚é€éé€™ç¨®æ–°èˆˆçš„æŠ€è¡“ï¼Œä¸ç®¡æˆ‘å€‘åˆ°ä»€éº¼åœ°æ–¹ï¼Œéƒ½èƒ½å¤ æ›´å¯†åˆ‡åœ°èˆ‡ç’°å¢ƒé€²è¡Œäº’
å‹•ã€‚ç„¶è€Œï¼Œåœ¨ä¸€å€‹èˆ‡å¤–ç•Œéš”çµ•è€Œè¢«å­¤ç«‹çš„ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯ç’°å¢ƒä¸­ï¼Œè³‡æ–™è¢«èšé›†åˆ°åŒ¯èšç¯€é»ä¹‹
å¾Œä»ç„¡æ³•å‚³éåˆ°å…¶ä»–åœ°æ–¹ã€‚ 
æœ¬è¨ˆåŠƒæå‡ºä¸€æ–°çš„éšå±¤å¼ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯æ¶æ§‹ä¾†è§£æ±ºä¸Šè¿°çš„å•é¡Œï¼Œæˆ‘å€‘å»ºè­°åœ¨ç¾æœ‰çš„ç„¡
ç·šæ„Ÿæ¸¬ç¶²è·¯æ¶æ§‹ä¸­ï¼Œå†åŠ å…¥ä¸€å€‹è¡Œå‹•æ”¶é›†å™¨(mobile mule)ã€‚è¡Œå‹•æ”¶é›†å™¨æœƒå›ºå®šåœ°(å¦‚ï¼šé 
å…ˆæ±ºå®šå¥½è¡Œèµ°è·¯å¾‘çš„å…¬è»Š)æˆ–å¶çˆ¾åœ°(å¦‚ï¼šç„¡å…ˆæ±ºå®šè¡Œèµ°è·¯å¾‘çš„è¨ˆç¨‹è»Š)å»è¨ªå•è¢«å­¤ç«‹çš„ç„¡
ç·šæ„Ÿæ¸¬ç¶²è·¯ä¸­çš„åŒ¯èšç¯€é»ï¼Œä¸¦ä¸”å‡è¨­ç¯€é»å¿…é ˆæš«æ™‚å­˜æ”¾æ”¶é›†åˆ°çš„è³‡æ–™ç›´åˆ°è¡Œå‹•æ”¶é›†å™¨è¨ªå•
åŒ¯èšç¯€é»ç‚ºæ­¢ï¼Œä¸¦è®“åŒ¯èšç¯€é»å°‡æ”¶é›†åˆ°çš„è³‡æ–™å‚³é€çµ¦è¡Œå‹•æ”¶é›†å™¨ï¼Œä½¿è¡Œå‹•æ”¶é›†å™¨èƒ½æŠŠè³‡æ–™
å¸¶åˆ°å¤–ç•Œã€‚ 
ç”±æ–¼ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯çš„ä¸€äº›å¤©ç”Ÿé™åˆ¶ï¼Œä¾‹å¦‚ç¯€é»çš„è¨˜æ†¶é«”å­˜æ”¾ç©ºé–“æ˜¯æœ‰é™çš„ç­‰ç­‰ï¼Œæˆ‘å€‘
å®šç¾©äº†ä¸‰å€‹å•é¡Œï¼š(1) åœ¨ç¯€é»çš„è¨˜æ†¶é«”å­˜æ”¾ç©ºé–“æœ‰é™çš„æƒ…æ³ä¸‹ï¼Œå¦‚ä½•åœ¨ç›¡å¯èƒ½æ¸›å°‘è³‡æ–™æµ
å¤±çš„æƒ…æ³ä¸‹æš«å­˜æ„Ÿæ¸¬åˆ°çš„è³‡æ–™ï¼Œ(2) å‡å¦‚ç„¡æ³•é¿å…è³‡æ–™ä¸Ÿå¤±ï¼Œå¦‚ä½•é¿å…å…·æœ‰é«˜åº¦å„ªå…ˆæ¬Šçš„
è³‡æ–™è¢«ä¸Ÿå¤±ï¼Œ(3) å¦‚ä½•ä¿æŒå…·æœ‰é«˜åº¦å„ªå…ˆæ¬Šçš„è³‡æ–™èƒ½è¼ƒé è¿‘åŒ¯èšç¯€é»ï¼Œä½¿å¾—è¡Œå‹•æ”¶é›†å™¨é 
è¿‘å­¤ç«‹ç¶²è·¯ï¼Œä½†æ”¶é›†è³‡æ–™çš„æ™‚é–“æœ‰é™æ™‚ï¼Œèƒ½å„ªå…ˆæ”¶é›†åˆ°è¼ƒé‡è¦çš„è³‡æ–™ã€‚å¦å¤–ï¼Œæˆ‘å€‘èªç‚ºï¼Œ
å¦‚ä½•æ±ºå®šè¦å°‡ç¶²è·¯ä¸­çš„å“ªå€‹ç¯€é»ç•¶æˆåŒ¯èšç¯€é»ä¹Ÿæ˜¯ä¸€é …éå¸¸é‡è¦çš„ç ”ç©¶è­°é¡Œã€‚å› ç‚ºï¼ŒåŒ¯èš
ç¯€é»çš„ä½ç½®å°‡æœƒé—œä¿‚åˆ°å„ç¯€é»é–“çš„é›»é‡æ¶ˆè€—å·®ç•°æ˜¯å¦å¹³è¡¡ï¼Œæ›´é€²ä¸€æ­¥åœ°æœƒå½±éŸ¿åˆ°æ•´å€‹ç¶²è·¯
çš„å­˜æ´»æ™‚é–“ã€‚å› æ­¤ï¼Œæˆ‘å€‘é‡å°é€™å€‹éƒ¨ä»½å®šç¾©äº†ä»¥ä¸‹å•é¡Œï¼šå¦‚ä½•æ±ºå®šåŒ¯èšç¯€é»çš„ä½ç½®ï¼Œä»¥è®“
æ•´å€‹ç¶²è·¯çš„è² è¼‰å¹³è¡¡ã€‚ 
åœ¨é€™ä¸€æ–°çš„ç¶²è·¯æ¶æ§‹ä¹‹ä¸‹ï¼Œç¾æœ‰ç‚ºåŸæœ¬æ„Ÿæ¸¬ç¶²è·¯æ‰€è¨­è¨ˆçš„æ–¹æ³•åŠå”å®šï¼Œä¸¦ä¸èƒ½å®Œå…¨é©
ç”¨ï¼Œæœ¬è¨ˆç•«å°‡ä»¥æ­¤ä¸€éšå±¤å¼ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯ç‚ºåŸºç¤ï¼Œé€²ä¸€æ­¥ç ”ç©¶ç›¸é—œçš„è³‡æ–™å­˜æ”¾å•é¡ŒåŠé€šè¨Š
å”å®šï¼Œä¸»è¦åŒ…å«å…©å€‹æ–¹å‘ï¼š1. éšå±¤å¼æ„Ÿæ¸¬ç¶²è·¯è³‡æ–™å­˜æ”¾å•é¡Œä¹‹ç ”ç©¶ 2. éšå±¤å¼æ„Ÿæ¸¬ç¶²è·¯
å¹³å°å”å®šè¨­è¨ˆèˆ‡å¯¦ä½œã€‚ 
æœ¬è¨ˆç•«æå‡ºä¸€åŒæ™‚å…¼é¡§è¯çµæ€§ã€è³‡æ–™å®Œæ•´åº¦ã€é«˜å„ªå…ˆæ¬Šè³‡æ–™å„ªå…ˆä¿ç•™ç­‰è¦æ±‚çš„è³‡æ–™å­˜
æ”¾èˆ‡äº¤æ›ç­–ç•¥ï¼Œä¸¦ä»¥é›»è…¦æ¨¡æ“¬å’Œç†è«–åˆ†æå…©ç¨®æ–¹å¼ï¼Œä¾†é©—è¨¼æ‰€æå‡ºæ¼”ç®—æ³•çš„å¯è¡Œæ€§åŠæ•ˆèƒ½ã€‚
é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘å€‘ä¹Ÿå°‡è¨­è¨ˆèˆ‡å¯¦ä½œæ­¤ä¸€éšå±¤å¼æ„Ÿæ¸¬ç¶²è·¯å¹³å°ï¼Œå®Œæˆç¡¬é«”å¹³å°çš„å»ºæ§‹ï¼Œè¨­è¨ˆåŠ
ä¿®æ”¹ç›¸é—œçš„é€šè¨Šå”å®šï¼Œä¸¦ç ”ç©¶é€™å€‹å¹³å°çš„ç›¸é—œè­°é¡Œã€‚ 
 
é—œéµå­—ï¼šç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯ã€è¡Œå‹•æ”¶é›†å™¨ã€è² è¼‰å¹³è¡¡ã€é€šè¨Šå”å®š 
3 
 
ç›®ï¤¿ 
ä¸€ã€ ä¸­è‹±æ–‡æ‘˜è¦ 
äºŒã€ å ±å‘Šå…§å®¹ ................................................................................................. 1 
2-1å‰è¨€ .................................................................................................... 1 
2-2ç ”ç©¶ç›®çš„ ............................................................................................. 3 
2-3ç ”ç©¶æ–¹æ³• ............................................................................................. 4 
2-4çµæœèˆ‡è¨ï¥ ........................................................................................12 
2-5ï¥«è€ƒæ–‡ç» ............................................................................................15 
ä¸‰ã€ è¨ˆç•«æˆæœè‡ªè©• ..........................................................................................16 
é™„ï¤¿ä¸€è¨ˆç•«åŸ·ï¨ˆæœŸé–“ï¥æ–‡ç™¼è¡¨ 
  
2 
 
 
ç›¸è¼ƒæ–¼å‚³çµ±æœ‰ç·šæ„Ÿæ¸¬å™¨ï¼Œç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯æœ‰ä¸‹åˆ—å„ªé»ï¼š 
I. å¤§å¹…ï¨‰ä½å»ºç½®æˆæœ¬ï¼šå‚³çµ±åœ¨ä½ˆç½®æ„Ÿæ¸¬å™¨ç¶²è·¯æ™‚ï¼Œç´„æœ‰ 50%~90%çš„æˆæœ¬æ˜¯è€—è²»åœ¨ä½ˆç·šçš„
æˆæœ¬ä¸Šï¼Œå› æ­¤ç•¶ä½¿ç”¨ç„¡ç·šéš¨æ„ç¶²è·¯ä½œç‚ºæ„Ÿæ¸¬å™¨æºé€šçš„æ–¹å¼å¾Œï¼Œå°±å¯ä»¥å¤§å¹…åº¦ï¨‰ä½æ•´é«”
çš„æˆæœ¬ã€‚ 
II. å¢åŠ æ„Ÿæ¸¬å™¨æ“ºæ”¾ä½ç½®çš„å½ˆæ€§ï¼šç”±æ–¼æ“ºè„«äº†æœ‰ç·šçš„æŸç¸›ï¼Œå› æ­¤æ„Ÿæ¸¬å™¨çš„æ“ºæ”¾ä½ç½®å¯ä»¥æ ¹
æ“šéœ€æ±‚ä»¥åŠç’°å¢ƒçš„é™åˆ¶ï¼Œèª¿æ•´æ“ºæ”¾åœ¨ä¸åŒçš„ä½ç½®ï¼Œé€™å€‹ç‰¹æ€§è®“ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯çš„æ‰€èƒ½æ‡‰
ç”¨çš„å ´æ™¯æ›´åŠ å»£æ³›ã€‚å‚³çµ±ä¸Šï¼Œç”±æ–¼æ„Ÿæ¸¬å™¨æ‰€è¦ä½ˆå»ºçš„ç’°å¢ƒå¯èƒ½æœƒé­é‡åˆ°è¨±å¤šçš„éšœç¤™ç‰©
(ä¾‹å¦‚é“è·¯ã€æ¹–æ³Šã€æ¨“å±¤ã€ç‰†é¢ç­‰)ï¼Œåœ¨é€™æ¨£å­çš„ç’°å¢ƒä¸­ï¼Œä½ˆç½®æ„Ÿæ¸¬å™¨å¾€å¾€è€—æ™‚è²»åŠ›ã€‚ç¾
åœ¨ï¼Œç”±æ–¼ç„¡ç·šæ„Ÿæ¸¬å™¨æ˜¯ä»¥ç„¡ç·šæ–¹å¼é€šè¨Šï¼Œæˆ‘å€‘åªéœ€è¦é©ç•¶åœ°é»å®‰ç½®æ„Ÿæ¸¬å™¨ï¼Œé€éæ„Ÿæ¸¬
å™¨çš„è‡ªæˆ‘çµ„æ…‹èƒ½åŠ›ï¼Œå³å¯ä»¥å½¢æˆä¸€å€‹å¯è¯é€šçš„ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯äº† 
III. æ„Ÿæ¸¬å™¨ä½ç½®å…·æœ‰å¯èª¿æ€§ï¼šåœ¨æ„Ÿæ¸¬ç¶²è·¯å»ºç½®å®Œæˆä¹‹å¾Œï¼Œå› ç‚ºæ‡‰ç”¨éœ€æ±‚æˆ–ç’°å¢ƒç­‰å› ç´ çš„è®Š
å‹•ï¼Œè€Œéœ€è¦æ”¹è®Šæ„Ÿæ¸¬å™¨çš„ä½ç½®æ™‚ï¼Œæˆ‘å€‘å¯ä»¥å¾ˆå®¹æ˜“åœ°å‹•æ…‹èª¿æ•´æ„Ÿæ¸¬å™¨çš„ä½ç½®ï¼Œç„¡ç·šæ„Ÿ
æ¸¬å™¨ä¹‹é–“å¯ä»¥å¾ˆå¿«åœ°é‡æ–°çµ„æ…‹ï¼Œæ•´å€‹ç¶²è·¯å³å¯ç¬¦åˆæ–°çš„éœ€æ±‚/é™åˆ¶ã€‚åœ¨å‚³çµ±çš„æœ‰ç·šæ„Ÿæ¸¬
å™¨çš„ç’°å¢ƒä¸­ï¼Œç”±æ–¼å›ºå®šå¼ä½ˆç·šåŠæ¶æ§‹çš„é™åˆ¶ï¼Œä»»ä½•çš„è®Šæ›´éƒ½æ˜¯è€—åŠ›è²»æ™‚çš„å·¥ä½œã€‚ 
äº‹å¯¦ä¸Šï¼Œé€éç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯é€™ç¨®æ–°èˆˆçš„æŠ€è¡“ï¼Œå¯ä»¥è®“äººå€‘èˆ‡å…¶é€±é­ç’°å¢ƒä¹‹é–“çš„äº’å‹•æ›´
åŠ ç·Šå¯†ã€‚èˆ‰ä¾‹ä¾†èªªï¼Œæˆ‘å€‘å¦‚åœ¨æ£®ï§´ä¸­è¨­ç½®ç«ç½åµæ¸¬å™¨(å³å¯ä»¥åµæ¸¬æº«åº¦åŠç…™éœ§çš„æ„Ÿæ¸¬å™¨)ï¼Œ
ç•¶ï§´é–“æº«åº¦å‡é«˜æ™‚ï¼Œæ„Ÿæ¸¬å™¨ä¾¿å¯æ„Ÿæ¸¬åˆ°æº«åº¦è®ŠåŒ–ä¸¦ç™¼å‡ºè­¦å‘Šï¼Œäººå€‘å³å¯æ¡å–è¡Œå‹•ï¼Œé¿å…å€
åŸŸæ€§çš„å°ç«ç½é‡€æˆåš´é‡çš„æ£®ï§´å¤§ç«ï¼Œä»¥ä¿éšœæ°‘çœ¾çš„ç”Ÿå‘½è²¡ç”¢å®‰å…¨ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œåœ¨ä¸€èˆ¬çš„è¾¦
å…¬å¤§æ¨“å…§ï¼Œæˆ‘å€‘å¯ä»¥åˆ©ç”¨æ„Ÿæ¸¬å™¨å°‡æ„Ÿæ¸¬åˆ°çš„æº«æº¼åº¦åŠäººæ•¸ç­‰è³‡æ–™è™•ç†å¾Œï¼Œå‚³å›ä¸­å¤®ç©ºèª¿æ§
åˆ¶å™¨åšèª¿æ•´ï¼Œè—‰æ­¤åŒæ™‚é”åˆ°ç’°å¢ƒèˆ’é©åŠç¯€èƒ½çœé›»çš„ç›®çš„ï¼›ï¥´å°‡æ„Ÿæ¸¬å™¨å®‰è£åœ¨äº¤é€šå·¥å…·ä¸Šæˆ–
4 
 
(2) å‡å¦‚ç„¡æ³•é¿å…è³‡æ–™ä¸Ÿå¤±ï¼Œå¦‚ä½•é¿å…å…·æœ‰é«˜åº¦å„ªå…ˆæ¬Šçš„è³‡æ–™è¢«ä¸Ÿå¤±ï¼Œ(3) å¦‚ä½•ä¿æŒå…·æœ‰é«˜åº¦
å„ªå…ˆæ¬Šçš„è³‡æ–™èƒ½è¼ƒé è¿‘åŒ¯èšç¯€é»ï¼Œä½¿å¾—è¡Œå‹•æ”¶é›†å™¨é è¿‘å­¤ç«‹ç¶²è·¯ï¼Œä½†æ”¶é›†è³‡æ–™çš„æ™‚é–“æœ‰é™æ™‚ï¼Œ
èƒ½å„ªå…ˆæ”¶é›†åˆ°è¼ƒé‡è¦çš„è³‡æ–™ã€‚å¦å¤–ï¼Œæˆ‘å€‘èªç‚ºï¼Œå¦‚ä½•æ±ºå®šè¦å°‡ç¶²è·¯ä¸­çš„å“ªå€‹ç¯€é»ç•¶æˆåŒ¯èšç¯€é»
ä¹Ÿæ˜¯ä¸€é …éå¸¸é‡è¦çš„ç ”ç©¶è­°é¡Œã€‚å› ç‚ºï¼ŒåŒ¯èšç¯€é»çš„ä½ç½®å°‡æœƒé—œä¿‚åˆ°å„ç¯€é»é–“çš„é›»é‡æ¶ˆè€—å·®ç•°æ˜¯
å¦å¹³è¡¡ï¼Œæ›´é€²ä¸€æ­¥åœ°æœƒå½±éŸ¿åˆ°æ•´å€‹ç¶²è·¯çš„å­˜æ´»æ™‚é–“ã€‚å› æ­¤ï¼Œæˆ‘å€‘é‡å°é€™å€‹éƒ¨ä»½å®šç¾©äº†ä»¥ä¸‹å•é¡Œï¼š
(1)å¦‚ä½•æ±ºå®šåŒ¯èšç¯€é»çš„ä½ç½®ï¼Œä»¥è®“æ•´å€‹ç¶²è·¯çš„è² è¼‰å¹³è¡¡ã€‚åœ¨ä¸‹ä¸€ç« ï¼Œæˆ‘å€‘å°‡é€™å…©é …è­°é¡Œåˆ†é–‹
è¨è«–ã€‚ 
 
2-3 ç ”ç©¶æ–¹æ³• 
 æœ¬è¨ˆç•«ä¹‹ç ”ç©¶æ–¹æ³•ä¸»è¦åˆ†ç‚ºä»¥ä¸‹ä¸‰å€‹æ–¹å‘ï¼šA.éšå±¤å¼æ„Ÿæ¸¬ç¶²è·¯ç¯€é»è³‡æ–™å­˜æ”¾å•é¡Œä¹‹ç ”ç©¶ 
B.åŒ¯èšç¯€é»ä½ç½®ä¹‹ç ”ç©¶ C.éšå±¤å¼æ„Ÿæ¸¬ç¶²è·¯å¹³å°å”å®šè¨­è¨ˆèˆ‡å¯¦ä½œ 
 
A. éšå±¤å¼æ„Ÿæ¸¬ç¶²è·¯ç¯€é»è³‡æ–™å­˜æ”¾å•é¡Œä¹‹ç ”ç©¶ 
æˆ‘å€‘å®šç¾©ä¸€å€‹ç‰¹æ®Šçš„WSNï¼Œå…¶åŒ…å«ä¸€äº›éœæ­¢çš„ç¯€é»ä»¥åŠè¡Œå‹•æ”¶é›†å™¨ã€‚éœæ­¢ç¯€é»å¯ä»¥ä¸æ–·
åœ°æ„Ÿæ¸¬å‘¨é­ç’°å¢ƒä¸¦é€±æœŸæ€§åœ°ç”¢ç”Ÿå›å ±å°åŒ…ï¼Œæ¯å€‹ç¯€é»éƒ½æœ‰åŒæ¨£çš„å„²å­˜ç©ºé–“Ssn(å–®ä½æ˜¯å°åŒ…)åŠå‚³
è¼¸ç¯„åœRsnã€‚é€™äº›éœæ­¢ç¯€é»çµåˆæˆä¸€å€‹ï¦šé€šæ€§çš„WSNï¼Œä¸¦ä¸”é€™äº›WSNéƒ½æ”¯æ´å¤šé»è·³èºç¹å¾‘
(Multi-hop routing)ã€‚ä½†æ˜¯ï¼Œé€™äº›WSNéƒ½è¢«ä½ˆç½®åœ¨åé çš„å€åŸŸä¸¦ä¸”èˆ‡å¤–ç•Œéš”çµ•ï¼Œä»–å€‘å¿…é ˆä¾é 
è¡Œå‹•æ”¶é›†å™¨ç¶“éæ‹œè¨ªä»–å€‘ä¸¦ä¸”æŠŠä»–å€‘æ„Ÿæ¸¬åˆ°çš„è³‡æ–™å¸¶åˆ°å¤–ç•Œã€‚è¡Œå‹•æ”¶é›†å™¨æœƒåœåœ¨ä¸€å€‹ç‰¹å®šçš„ç¯€
é»ä¸Šä¸€æ®µæ™‚é–“ä¾†æ”¶é›†æ„Ÿæ¸¬åˆ°çš„è³‡æ–™ï¼Œé€™å€‹ç‰¹å®šç¯€é»æˆ‘å€‘å«åšåŒ¯èšç¯€é»(sink)ã€‚åœ¨é€™æ®µæ™‚é–“å…§ï¼Œ
åŒ¯èšç¯€é»å¯ä»¥æŠŠè‡ªå·±è·Ÿå…¶ä»–ç¯€é»çš„å°åŒ…å‚³é€çµ¦è¡Œå‹•æ”¶é›†å™¨ã€‚è¡Œå‹•æ”¶é›†å™¨åœä¸‹çš„é€™æ®µæ™‚é–“é•·åº¦å¯
èƒ½æ˜¯å›ºå®šæˆ–æ˜¯éš¨æ©Ÿçš„ã€‚è¡Œå‹•æ”¶é›†å™¨çš„ç§»å‹•æ–¹å¼å¯èƒ½æ˜¯å›ºå®šçš„(å¦‚ï¼šé å…ˆæ±ºå®šå¥½è¡Œèµ°è·¯å¾‘çš„å…¬è»Š)
æˆ–éš¨æ©Ÿçš„(å¦‚ï¼šç„¡å…ˆæ±ºå®šè¡Œèµ°è·¯å¾‘çš„è¨ˆç¨‹è»Š)ã€‚è¡Œå‹•æ”¶é›†å™¨ä¹‹å¾Œå¯ä»¥å°‡æ”¶é›†åˆ°çš„å°åŒ…è½‰é€çµ¦åœ¨å¤–
ç•Œçš„ä¸­å¤®æ”¶é›†å™¨ã€‚åœ–ä¸‰æ˜¯ä¸€å€‹æˆ‘å€‘çš„ç¶²è·¯æ¨¡å‹åŠè³‡æ–™æ”¶é›†ç­–ç•¥çš„ç¯„ä¾‹ã€‚ 
 
6 
 
          min {ğ¹(ğ‘ƒ(ğœ”))|ğœ” âˆˆ ğ‘(ğ‘¢),ğ·(ğœ”) < ğ·(ğ‘¢)}ã€‚ 
 
 P1(åéä¾†èªªï¼ŒP2)ä»£è¡¨æ¯” ué é›¢(åéä¾†èªªï¼Œé è¿‘)åŒ¯èšç¯€é»çš„ç¯€é»æ‡‰è©²æ“æœ‰æ¯” ué‚„ä½çš„å„ª
å…ˆæ¬Š(åéä¾†èªªï¼Œæ¯” ué‚„é«˜çš„å„ªå…ˆæ¬Š)ã€‚P3å‰‡å¼·åˆ¶è®“åˆ°åŒ¯èšç¯€é»çš„è·é›¢èˆ‡ uç›¸åŒçš„ç¯€é»æ‡‰è©²æ“æœ‰
èˆ‡uç›¸åŒçš„å„ªå…ˆæ¬Šã€‚ç•¶ä¸€å€‹ç¯€é»åŒæ™‚æ“æœ‰ä»¥ä¸Šä¸‰æ¨£ç‰¹æ€§ï¼Œæˆ‘å€‘ç¨±é€™å€‹ç¯€é»ç‚ºæ’åºå®Œæˆ(in-order)ã€‚
åœ¨åœ–å››ä¸­ï¼Œé™¤äº†ç¯€é» måŠ jä»¥å¤–ï¼Œå…¶ä»–ç¯€é»çš†å·²æ’åºå®Œæˆã€‚
 
 å°æ–¼æ¯å€‹ç¯€é» uï¼Œæˆ‘å€‘å®šç¾© maxPost(u)è¡¨ç¤ºåœ¨ uçš„é„°å±…ä¸­ï¼Œæ»¿è¶³ğ·(ğœˆ) > ğ·(ğ‘¢)çš„ç¯€é»ğœˆä¸­ï¼Œ
å…·æœ‰æœ€é«˜å„ªå…ˆæ¬Šçš„å°åŒ…ï¼›ğ‘šğ‘–ğ‘›ğ‘ƒğ‘Ÿğ‘’(ğ‘¢)è¡¨ç¤ºåœ¨ uçš„é„°å±…ä¸­ï¼Œæ»¿è¶³ğ·(ğœˆ) < ğ·(ğ‘¢)çš„ç¯€é»ğœˆä¸­ï¼Œå…·æœ‰æœ€
ä½å„ªå…ˆæ¬Šçš„å°åŒ…ï¼›maxEqual(u)è¡¨ç¤ºåœ¨ uçš„é„°å±…ä¸­ï¼Œæ»¿è¶³ğ·(ğœˆ) = ğ·(ğ‘¢)çš„ç¯€é»ğœˆä¸­ï¼Œå…·æœ‰æœ€é«˜å„ª
å…ˆæ¬Šçš„å°åŒ…ï¼›ä»¥åŠğ‘šğ‘–ğ‘›ğ¸ğ‘ğ‘¢ğ‘ğ‘™(ğ‘¢)è¡¨ç¤ºåœ¨ğ‘¢çš„é„°å±…ä¸­ï¼Œæ»¿è¶³ğ·(ğœˆ) = ğ·(ğ‘¢)çš„ç¯€é»ğœˆä¸­ï¼Œå…·æœ‰æœ€ä½å„ª
å…ˆæ¬Šçš„å°åŒ…ã€‚æ ¹æ“šä»¥ä¸Šçš„ç‰¹æ€§ï¼Œæˆ‘å€‘è¨­è¨ˆæˆ‘å€‘ç”¨æ–¼ç¯€é»ğ‘¢ âˆˆ ğµğ´çš„å°åŒ…äº¤æ›è¦å‰‡å¦‚ä¸‹ï¼š 
E1ï¼šç•¶ğ¹ï¿½ğ‘šğ‘ğ‘¥ğ‘ƒğ‘œğ‘ ğ‘¡(ğ‘¢)ï¿½ > ğ¹(ğ‘ƒ(ğ‘¢))æ™‚ï¼Œç¯€é» uæœƒå˜—è©¦èˆ‡ğ‘šğ‘ğ‘¥ğ‘ƒğ‘œğ‘ ğ‘¡(ğ‘¢)äº¤æ›å…¶æ‰€å„²å­˜çš„å°åŒ…ã€‚ 
E2ï¼šç•¶ğ¹(ğ‘ƒ(ğ‘¢)) > ğ¹ï¿½ğ‘šğ‘–ğ‘›ğ‘ƒğ‘Ÿğ‘’(ğ‘¢)ï¿½æ™‚ï¼Œç¯€é» uæœƒå˜—è©¦èˆ‡ğ‘šğ‘–ğ‘›ğ‘ƒğ‘Ÿğ‘’(ğ‘¢)äº¤æ›å…¶æ‰€å„²å­˜çš„å°åŒ…ã€‚ 
8 
 
ç‹€æ…‹ã€‚ä½†æ˜¯æ¯«ç„¡ç–‘å•çš„ï¼Œå°ä¸€å€‹å°åŒ…ä¾†èªªï¼Œæ¯ç•¶æ¯”å®ƒé«˜å„ªå…ˆæ¬Šçš„å°åŒ…è®Šæˆç©©å®šç‹€æ…‹æ™‚ï¼Œå®ƒå°‡æœƒ
è®Šæˆç©©å®šç‹€æ…‹ã€‚ç•¶ BAçš„å¤§å°æ˜¯æœ‰é™æ™‚ï¼Œå°åŒ…äº¤æ›çš„å‹•ä½œå°‡æœƒåœ¨æœ‰é™æ­¥é©Ÿå…§çµæŸã€‚ 
 
å®šç†äºŒ. ç•¶æ‰€æœ‰åœ¨ BAå…§çš„ç¯€é»çµæŸå°åŒ…äº¤æ›å¾Œï¼Œå®ƒå€‘æœƒæ˜¯æ’åºå®Œæˆçš„ç‹€æ…‹ã€‚ 
è­‰æ˜ï¼šæˆ‘å€‘åˆ©ç”¨åè­‰æ³•ä¾†è­‰æ˜é€™å€‹å®šç†ã€‚å‡å¦‚ç¯€é»ğ‘¢ä¸åœ¨ç©©å®šç‹€æ…‹ï¼Œé‚£éº¼å…¶åªæœƒæœ‰ä»¥ä¸‹ä¸‰
ç¨®å¯èƒ½çš„æƒ…æ³ï¼š 
æƒ…æ³ä¸€ï¼šç¯€é»ğ‘¢é•åP1ã€‚ä¹Ÿå°±æ˜¯èªªå­˜åœ¨ä¸€å€‹é„°å±…ğœˆ âˆˆ ğ‘(ğ‘¢)ï¼Œä¸”ğ·(ğœˆ) > ğ·(ğ‘¢)ï¼Œğ¹ï¿½ğ‘ƒ(ğœˆ)ï¿½ > ğ¹ï¿½ğ‘ƒ(ğ‘¢)ï¿½ã€‚
å› ç‚ºğ¹ï¿½ğ‘šğ‘ğ‘¥ğ‘ƒğ‘œğ‘ ğ‘¡(ğ‘¢)ï¿½ â‰¥ ğ¹ï¿½ğ‘ƒ(ğœˆ)ï¿½ > ğ¹(P(ğ‘¢)ï¼‰ã€‚æ ¹æ“š E1ï¼Œå®ƒå°‡ä¸æœƒåœæ­¢äº¤æ›å°åŒ…ã€‚ 
æƒ…æ³äºŒï¼šç¯€é»ğ‘¢é•å P2ä½†éµå®ˆ P1ã€‚ä¹Ÿå°±æ˜¯èªªå­˜åœ¨ä¸€å€‹é„°å±…ğœˆ âˆˆ ğ‘(ğ‘¢)ï¼Œä¸”ğ·(ğœˆ) < ğ·(ğ‘¢)ï¼Œ
ğ¹ï¿½ğ‘ƒ(ğœˆ)ï¿½ < ğ¹ï¿½ğ‘ƒ(ğ‘¢)ï¿½ã€‚å› ç‚ºğ¹ï¿½ğ‘šğ‘–ğ‘›ğ‘ƒğ‘Ÿğ‘’(ğ‘¢)ï¿½ â‰¤ ğ¹ï¿½ğ‘ƒ(ğœˆ)ï¿½ < ğ¹(P(ğ‘¢)ï¼‰ã€‚æ ¹æ“š E2ï¼Œå®ƒå°‡ä¸æœƒåœæ­¢äº¤
æ›å°åŒ…ã€‚ 
æƒ…æ³ä¸‰ï¼šç¯€é»ğ‘¢é•å P3ä½†éµå®ˆ P1è·Ÿ P2ã€‚ä¹Ÿå°±æ˜¯èªªå­˜åœ¨ä¸€å€‹é„°å±…ğœˆ âˆˆ ğ‘(ğ‘¢)ï¼Œä¸”ğ·(ğœˆ) = ğ·(ğ‘¢)ï¼Œ
ğ¹ï¿½ğ‘ƒ(ğœˆ)ï¿½ä¸åœ¨ ğ¹ï¿½ğ‘šğ‘ğ‘¥ğ‘ƒğ‘œğ‘ ğ‘¡(ğ‘¢)ï¿½è·Ÿğ¹ï¿½ğ‘šğ‘–ğ‘›ğ‘ƒğ‘Ÿğ‘’(ğ‘¢)ï¿½ä¹‹é–“ã€‚å› ç‚ºç¯€é»ğ‘¢éµå®ˆ P1è·Ÿ P2ï¼Œæ‰€ä»¥æˆ‘å€‘å¯ä»¥
å¾—åˆ°ğ¹ï¿½ğ‘šğ‘–ğ‘›ğ‘ƒğ‘Ÿğ‘’(ğ‘¢)ï¿½ â‰¥ ğ¹ï¿½ğ‘šğ‘ğ‘¥ğ‘ƒğ‘œğ‘ ğ‘¡(ğ‘¢)ï¿½ã€‚ğ¹ï¿½ğ‘ƒ(ğœˆ)ï¿½æœƒæ¯”ğ¹ï¿½ğ‘šğ‘–ğ‘›ğ‘ƒğ‘Ÿğ‘’(ğ‘¢)ï¿½å¤§æˆ–æ˜¯æ¯”ğ¹ï¿½ğ‘šğ‘ğ‘¥ğ‘ƒğ‘œğ‘ ğ‘¡(ğ‘¢)ï¿½
å°ã€‚ 
(1) ğ¹ï¿½ğ‘ƒ(ğœˆ)ï¿½ > ğ¹ï¿½ğ‘šğ‘–ğ‘›ğ‘ƒğ‘Ÿğ‘’(ğ‘¢)ï¿½ã€‚ 
å› ç‚ºğ¹ï¿½ğ‘šğ‘ğ‘¥ğ¸ğ‘ğ‘¢ğ‘ğ‘™(ğ‘¢)ï¿½ â‰¥ ğ¹ï¿½ğ‘ƒ(ğœˆ)ï¿½ > ğ¹ï¿½ğ‘šğ‘–ğ‘›ğ‘ƒğ‘Ÿğ‘’(ğ‘¢)ï¿½ã€‚æ ¹æ“š E3.1ï¼Œå®ƒå°‡ä¸æœƒåœæ­¢äº¤æ›å°
åŒ…ã€‚ 
(2) ğ¹ï¿½ğ‘ƒ(ğœˆ)ï¿½ < ğ¹ï¿½ğ‘šğ‘ğ‘¥ğ‘ƒğ‘œğ‘ ğ‘¡(ğ‘¢)ï¿½ã€‚ 
å› ç‚ºğ¹ï¿½ğ‘šğ‘–ğ‘›ğ¸ğ‘ğ‘¢ğ‘ğ‘™(ğ‘¢)ï¿½ â‰¤ ğ¹ï¿½ğ‘ƒ(ğœˆ)ï¿½ <  ğ¹ï¿½ğ‘šğ‘ğ‘¥ğ‘ƒğ‘œğ‘ ğ‘¡(ğ‘¢)ï¿½ã€‚æ ¹æ“š E3.2ï¼Œå®ƒå°‡ä¸æœƒåœæ­¢äº¤æ›
å°åŒ…ã€‚ 
æƒ…æ³ä¸€ã€äºŒä»¥åŠä¸‰çš†ç‰´è§¸æˆ‘å€‘ç¯€é»æœƒçµæŸå°åŒ…äº¤æ›å‹•ä½œçš„å‡è¨­ï¼Œæ‰€ä»¥å®šç†å¾—è­‰ã€‚ 
 
ç¸½çµä¾†èªªï¼Œç”±æ–¼æˆ‘å€‘çš„è³‡æ–™äº¤æ›ç­–ç•¥åˆ©ç”¨è¼ƒæœ‰åŠ›çš„ç¶²ç‹€(mesh)ï¦šçµä¾†äº¤æ›å°åŒ…ï¼Œæ‰€ä»¥æ ¹æ“š
E3.1è·Ÿ E3.2ï¼Œå…·æœ‰è¼ƒé«˜å„ªå…ˆæ¬Šçš„å°åŒ…æœƒæœ‰æ›´å¤šçš„æ©Ÿæœƒå¯ä»¥è¢«å„²å­˜æ–¼è¼ƒé è¿‘åŒ¯èšç¯€é»çš„ä½ç½®ã€‚ 
 å¦å¤–ï¼Œä»¥ä¸‹æˆ‘å€‘è¨è«–å…©å€‹èƒ½æ“´å±•çš„è­°é¡Œã€‚ 
 é¦–å…ˆï¼Œå°‡æˆ‘å€‘çš„ç­–ç•¥æ“´å±•åˆ°ğ‘†ğ‘ ğ‘› > 1çš„æƒ…æ³ã€‚æˆ‘å€‘å®šç¾©ğ‘šğ‘ğ‘¥ğ‘€ğ‘–ğ‘›ğ‘’(ğ‘¢) (åéä¾†èªªï¼Œ
ğ‘šinğ‘€ğ‘–ğ‘›ğ‘’(ğ‘¢) )ä»£è¡¨èƒ½å„²å­˜å¤šå€‹å°åŒ…çš„ç¯€é»ğ‘¢ä¸­æ“æœ‰æœ€é«˜(åéä¾†èªªï¼Œæœ€ä½)å„ªå…ˆæ¬Šçš„å°åŒ…ã€‚ç•¶ä¸€
å€‹ç¯€é»æ“æœ‰å¤šå€‹å°åŒ…æ™‚ï¼Œå°åŒ…äº¤æ›çš„è¦å‰‡æ‡‰ä¿®æ”¹æˆä»¥ä¸‹çš„æ¨£å­ï¼š 
E1â€™ï¼šç•¶ğ¹ï¿½ğ‘šğ‘ğ‘¥ğ‘ƒğ‘œğ‘ ğ‘¡(ğ‘¢)ï¿½ > ğ¹ï¿½ğ‘šğ‘–ğ‘›ğ‘€ğ‘–ğ‘›ğ‘’(ğ‘¢)ï¿½ï¼Œç¯€é»ğ‘¢æœƒå˜—è©¦å°‡å°åŒ…ğ‘šğ‘ğ‘¥ğ‘ƒğ‘œğ‘ ğ‘¡(ğ‘¢)èˆ‡ğ‘šğ‘–ğ‘›ğ‘€ğ‘–ğ‘›ğ‘’(ğ‘¢)äº¤
æ›ã€‚ 
E2â€™ï¼š ç•¶ğ¹ï¿½ğ‘šğ‘ğ‘¥ğ‘€ğ‘–ğ‘›ğ‘’(ğ‘¢)ï¿½ > ğ¹ï¿½ğ‘šğ‘–ğ‘›ğ‘ƒğ‘Ÿğ‘’(ğ‘¢)ï¿½ï¼Œç¯€é»ğ‘¢æœƒå˜—è©¦å°‡å°åŒ…ğ‘šğ‘ğ‘¥ğ‘€ğ‘–ğ‘›ğ‘’(ğ‘¢)èˆ‡ğ‘šğ‘–ğ‘›ğ‘ƒğ‘Ÿğ‘’(ğ‘¢)äº¤
10 
 
æ ¹æ“šç¾æœ‰çš„è³‡è¨Šï¼Œå°±å¯ä»¥åšï¨ç¢ºçš„è©•ä¼°äº†ã€‚ 
é€™å€‹å‹•ä½œæŒçºŒè¶Šå¤šæ¬¡æœƒè®“å­æ¨¹é–“è¶Šæ¥è¿‘è² è¼‰å¹³è¡¡ï¼Œä½†æ˜¯ï¼Œåšè¶Šå¤šæ¬¡ä¹‹å¾Œæ•ˆæœè¶Šä¸æ˜é¡¯ã€‚æˆ‘å€‘åš
äº†å¯¦é©—ç™¼ç¾ï¼Œå¤§ç´„é‡è¤‡ 10æ¬¡ä¹‹å¾Œè½‰ç§»å°ç¶²è·¯ç”¢ç”Ÿçš„å½±éŸ¿æœƒéå¸¸å°ï¼Œå› æ­¤ï¼Œæˆ‘å€‘èªç‚ºé‡è¤‡ 10
æ¬¡æ˜¯æ¯”è¼ƒå¥½çš„ã€‚ 
é€éä¸Šè¿°è½‰ç§»ç­–ç•¥ï¼Œå°‡å¯é”åˆ°åŒ¯èšç¯€é»å„å­æ¨¹ä¹‹é–“çš„è² è¼‰å¹³è¡¡ã€‚å¦‚æ­¤ä¸€ä¾†ï¼ŒåŒ¯èšç¯€é»å°‡æœƒ
ä¸€æ­¥ä¸€æ­¥åœ°è½‰ç§»å…¶ä½ç½®ï¼Œæˆ‘å€‘å¯ä»¥æƒ³åƒï¼Œåœ¨ç¶²è·¯ä¹‹ä¸­ï¼ŒåŒ¯èšç¯€é»æœƒå¾€ç¶²è·¯ä¸­ç¯€é»æœ€å¯†é›†çš„åœ°æ–¹
è½‰ç§»ï¼Œæ¥è‘—ï¼Œåœ¨æ¥ä¸‹ä¾†çš„æ¯å€‹å›åˆéƒ½æœƒå¾€å°ç›®å‰ä½ç½®ä¾†èªªç¯€é»æœ€å¯†é›†çš„åœ°æ–¹è½‰ç§»ï¼Œæœ€å¾Œå°‡è½‰ç§»
åˆ°æ•´å€‹ç¶²è·¯çš„ä¸­å¿ƒä¸¦é”åˆ°ä¸€å€‹å¹³è¡¡çš„ç‹€æ…‹ã€‚ 
 
C.éšå±¤å¼æ„Ÿæ¸¬ç¶²è·¯å¹³å°å”å®šè¨­è¨ˆèˆ‡å¯¦ä½œ 
 æ¥ä¸‹ä¾†ï¼Œæœ¬è¨ˆç•«ä¹Ÿå¯¦ä½œäº†éšå±¤å¼æ„Ÿæ¸¬ç¶²è·¯å¹³å°åŠå…¶ç›¸é—œå”å®šã€‚ä¸»è¦é”æˆçš„å·¥ä½œé …ç›®æœ‰
ä¸‹åˆ—å…©é …ï¼š(1) ç¡¬é«”å¹³å°å»ºæ§‹ (2)ç¶²è·¯é€šè¨Šå”å®šè¨­è¨ˆä¿®æ”¹ 
ï¬ ç¡¬é«”å¹³å°å»ºæ§‹ 
åœ¨ç¡¬é«”å¹³å°çš„éƒ¨åˆ†ï¼Œä¸»è¦å¯åˆ†ç‚ºç„¡ç·šæ„Ÿæ¸¬å™¨ã€è¡Œå‹•æ”¶é›†å™¨ã€ä¸­å¤®æ”¶é›†ç­‰ä¸‰å€‹éƒ¨åˆ†ï¼Œä»¥ä¸‹åˆ†åˆ¥è¨
è«–ä¹‹ã€‚ 
 
 
åœ–äº”ã€Jennic JN5139ç‚ºåŸºç¤çš„ç„¡ç·šæ„Ÿæ¸¬å™¨å¹³å°  
ï‚² ç„¡ç·šæ„Ÿæ¸¬å™¨çš„éƒ¨åˆ†ï¼Œå…¶ç„¡ç·šå‚³è¼¸æ¨¡çµ„å°‡æˆ‘å€‘ä½¿ç”¨ Jennic JN5139 æ™¶ç‰‡æ¨¡çµ„(å¦‚åœ–äº”
æ‰€ç¤º)ï¼Œå…¶ç‚ºä¸€ç¬¦åˆ IEEE 802.15.4 è¦ç¯„ä¹‹å‚³è¼¸æ¨¡çµ„ï¼Œé¸æ“‡ Jennicçš„åŸå› ï¼Œä¸»è¦æ˜¯
å› ç‚ºå…¶å° ZigBee/IEEE 802.15.4æ¨™æº–çš„æ”¯æ´æ€§ï¼Œä»¥åŠå…¶ç›¸é—œé–‹ç™¼æ”¯æ´è¼ƒç‚ºè±å¯Œï¼Œå±¤
åº•ä¹‹ç„¡ç·šå‚³è¼¸æ¨¡çµ„æ”¶åˆ°è³‡æ–™å¾Œï¼Œä¸Šå±¤å‡ä»¥ Javaèªè¨€ä¾†å¯¦ä½œï¼Œè€Œæˆ‘å€‘æ¡ç”¨å…¶æä¾›ä¹‹
802.15.4 Stack API ä¾†åšç‚ºé–‹ç™¼ç„¡ç·šå‚³è¼¸ä¹‹å·¥å…·ï¼Œä¿®æ”¹/è¨­è¨ˆç›¸é—œçš„é€šè¨Šå”å®šã€‚ 
ï‚² è¡Œå‹•æ”¶é›†å™¨çš„ç¡¬é«”å¹³å°ï¼Œæˆ‘å€‘åˆ©ç”¨ç¾å­˜çš„å°å‹å¯ç§»å‹•å¼è£ç½®ä½œç‚ºè¡Œå‹•è¼‰å…·ï¼Œä¸Šé¢
è¼‰æœ‰ Jennic è£ç½®ä½œç‚ºç³»çµ±é‹ç®—æ§åˆ¶ä¸­å¿ƒï¼Œä¾†å»ºæ§‹ç§»å‹•å¼æ„Ÿæ¸¬å™¨ã€‚åœ¨è¡Œå‹•è¼‰å…·ç¡¬é«”
çš„é¸ç”¨ä¸Šï¼Œè¼‰å…·çš„éƒ¨ä»½æˆ‘å€‘é¸ç”¨å¸‚å”®çš„è»Œé“æ¨¡å‹ç«è»Šï¼Œå¦‚åœ–å…­æ‰€ç¤ºï¼Œé€™æ˜¯ä¸€å¥—ç”±
12 
 
å€‹ç¶²è·¯æ‹“æ¨¸ï¼Œç”¨ä¾†é”æˆå¤šç¯€é»è·³èºå¼å‚³è¼¸(multi-hop transmission)ï¼Œå°‡è³‡æ–™å‚³é€åˆ°åŒ¯èš
ç¯€é»ã€‚ä¸‹å±¤çš„æ¯ä¸€å€‹æ„Ÿæ¸¬å™¨éƒ½çŸ¥é“å…¶é„°å±…ï¼Œå½¢æˆä¸€å€‹ç¶²ç‹€(mesh)çš„çµæ§‹ã€‚åœ¨ç¶²è·¯ä¸€å•Ÿ
å‹•æ™‚ï¼Œæ¯ä¸€å€‹ä¸‹å±¤ç¶²è·¯çš„æ„Ÿæ¸¬å™¨æœƒå»åµæ¸¬å…¶åˆ°åŒ¯èšç¯€é»çš„è·é›¢ï¼Œæ­¤éç¨‹å¯ä»¥ç”±ç¯€é»å»£
æ’­Beaconå°åŒ…æ™‚ï¼Œå¢åŠ è¨˜éŒ„è·é›¢çš„æ¬„ä½ä¾†é”æˆï¼›ç•¶ç¶²è·¯åˆå§‹æ™‚ï¼ŒåŒ¯èšç¯€é»æœƒæ“”ä»» Zigbee
å”èª¿è€…çš„è§’è‰²ï¼Œç¯€é»æœƒå„è‡ªé¸æ“‡åˆé©çš„é »é“ï¼Œä¸¦é–‹å§‹ä»¥çŸ­è·çš„å¤©ç·šå»£æ’­ Beacon å°åŒ…
çµ¦é„°è¿‘çš„æ„Ÿæ¸¬å™¨ï¼ŒBeaconå°åŒ…ä¸­åŒ…å«æ­¤åŒ¯èšç¯€é»çš„ IDï¼Œç›®çš„æ˜¯ç”¨ä¾†åˆ†è¾¨ä¸åŒçš„ç¶²è·¯ï¼Œ
æ­¤å¤–ï¼Œé‚„æœ‰ä¸€æ¬„ä½è¨˜éŒ„å’ŒåŒ¯èšç¯€é»ä¹‹é–“çš„ç¯€é»è·é›¢ï¼Œä¸€é–‹å§‹è¨­ç‚ºé›¶ï¼›ç•¶ç¯€é»æ¥æ”¶åˆ°
Beacon å°åŒ…æ™‚åŠ å…¥æ­¤ç¶²è·¯ï¼Œä¸¦é–‹å§‹å»£æ’­ Beacon å°åŒ…ï¼Œå…¶ä¸­ ID æ¬„ä½ä¸è®Šï¼Œè¨˜éŒ„è·é›¢
çš„æ¬„ä½æœƒåŠ ä¸€ï¼›ï¥´ä¸€å€‹æ„Ÿæ¸¬å™¨æ”¶åˆ°ä¸åŒç¶²è·¯ IDçš„ Beaconï¼Œç¶“æ¯”è¼ƒè·é›¢æ¬„ä½ä¹‹å¾Œï¼Œå°±
å¯ä»¥é¸æ“‡åˆé©çš„è¡Œå‹•æ”¶é›†å™¨çš„ç¶²è·¯åŠ å…¥ã€‚ 
ï‚² ä¸Šå±¤æ”¶é›†å™¨ç¶²è·¯ 
åœ¨ä¸Šå±¤æ”¶é›†å™¨ç¶²è·¯ä¸­åŒ…å«è¡Œå‹•æ”¶é›†å™¨åŠä¸­å¤®æ”¶é›†å™¨ï¼Œç”±æ–¼è¡Œå‹•æ”¶é›†å™¨æœƒç¶“éä¸­å¤®
æ”¶é›†å™¨é™„è¿‘ä¸¦ç›´æ¥å°‡è³‡æ–™è½‰é€çµ¦ä¸­å¤®æ”¶é›†å™¨ï¼Œæˆ‘å€‘è®“ä¸Šå±¤ç¶²è·¯ç›´æ¥å¥—ç”¨ Zigbeeå”å®šæ¶
æ§‹ã€‚ä¸­å¤®æ”¶é›†å™¨ä½œç‚º Zigbee å”èª¿è€…(Coordinator)è€Œè¡Œå‹•æ”¶é›†å™¨ä½œç‚ºæœ«ç«¯è¨­å‚™(End 
device)ï¼Œç”¨ä¾†é”æˆå–®ç¯€é»ç›´æ¥å‚³è¼¸(1-hop transmission)ï¼Œå°‡è³‡æ–™å‚³é€åˆ°ä¸­å¤®æ”¶é›†å™¨ã€‚ 
 
2-4 çµæœèˆ‡è¨è«– 
 ä»¥ä¸‹æˆ‘å€‘åˆ†æˆä¸‰å€‹éƒ¨ä»½ä¾†å‘ˆç¾æˆ‘å€‘çš„æˆæœ A.éšå±¤å¼æ„Ÿæ¸¬ç¶²è·¯ç¯€é»å­˜æ”¾è³‡æ–™äº¤æ›ç­–ç•¥ä¹‹æ¨¡
æ“¬æˆæœ B.éšå±¤å¼æ„Ÿæ¸¬ç¶²è·¯å¹³å°å”å®šå¯¦ä½œ C.ç¸½çµ 
A. éšå±¤å¼æ„Ÿæ¸¬ç¶²è·¯ç¯€é»å­˜æ”¾è³‡æ–™äº¤æ›ç­–ç•¥ä¹‹æ¨¡æ“¬æˆæœ 
æˆ‘å€‘æ¨¡æ“¬çš„ç’°å¢ƒç‚º 400 å€‹æ„Ÿæ¸¬ç¯€é»éš¨æ©Ÿå¸ƒå»ºåœ¨200 Ã— 200çš„å€åŸŸå…§ï¼Œæ¯å€‹ç¯€é»çš„å‚³æ›¸
ç¯„åœæ˜¯ 25ï¼Œå„å€‹ç¯€é»çš„å°åŒ…åˆ°é”ç‡(packet arrive rate)ç‚º1 âˆ• 50ã€‚ä¸¦ä¸”æ¯å€‹å°åŒ…éš¨æ©Ÿçµ¦å®šä¸€
å€‹0 âˆ¼ 1000ä¹‹é–“çš„å„ªå…ˆæ¬Šå€¼ã€‚BAå®šç¾©ç‚ºè·é›¢åŒ¯èšç¯€é» 10å€‹ç¯€é»è·é›¢(hop)å…§çš„ç¯€é»é›†åˆã€‚
æ¯å€‹çµæœéƒ½å„åˆ¥åŸ·è¡Œ 50æ¬¡ä¸¦å–å¹³å‡å€¼ã€‚ 
é¦–å…ˆæˆ‘å€‘åœ¨åœ–ä¸ƒ(a)åŠåœ–ä¸ƒ(b)ä¸­åˆ†åˆ¥æ¯”è¼ƒå°‡è¡Œå‹•æ”¶é›†å™¨è¨ªå• WSN çš„æ™‚é–“é–“éš”ç•¶è®Šæ•¸æ™‚ï¼›
ä»¥åŠåœ¨ä¸­æ¯”è¼ƒå°‡è¡Œå‹•æ”¶é›†å™¨æ”¶é›†çš„æ™‚é–“é•·çŸ­ç•¶è®Šæ•¸æ™‚ï¼Œæ”¶é›†åˆ°çš„å°åŒ…çš„å¹³å‡å„ªå…ˆæ¬Šå€¼ã€‚æˆ‘
å€‘å°‡æˆ‘å€‘çš„æ–¹æ³•(Distributed Storage Management Strategy, DSMS)èˆ‡ Greedy Forwarding(GF)
ä»¥åŠæœ€ä½³è§£(OPT)åšæ¯”è¼ƒã€‚GF ä»£è¡¨ç¯€é»æ°¸é ç›¡é‡è®“å…¶å°åŒ…å¾€åŒ¯èšç¯€é»é è¿‘ç›´åˆ°å‰æ–¹æ²’æœ‰
å„²å­˜ç©ºé–“ç‚ºæ­¢ï¼ŒOPTä»£è¡¨é”åˆ°å…¨é¢æœ€ä½³åŒ–å¾Œçš„ç†æƒ³æƒ…æ³ã€‚åœ–ä¸ƒ(a)ä¸­é¡¯ç¤ºç•¶åƒè¨ªé–“éš”å¢åŠ 
æ™‚ï¼Œæ”¶é›†åˆ°çš„å„ªå…ˆæ¬Šå€¼å¹³å‡ä¹Ÿæœƒä¸Šå‡ã€‚å…¶ä¸­ï¼Œä¸€å€‹æ§½(slot)çš„æ™‚é–“é–“éš”ä»£è¡¨å°åŒ…ç§»å‹•ä¸€å€‹
ç¯€é»è·é›¢(hop)çš„æ™‚é–“ã€‚åœ–ä¸ƒ(b)ä¸­é¡¯ç¤ºç•¶æ”¶é›†æ™‚é–“æ‹‰é•·æ™‚ï¼Œæ”¶é›†åˆ°çš„è³‡æ–™å„ªå…ˆæ¬Šå€¼å¹³å‡æœƒ
ï¨‰ä½ï¼Œä¸éé€™å€‹å½±éŸ¿éå¸¸å°ã€‚ 
14 
 
 
ç‚ºäº†æ–¹ä¾¿å°åŒ…äº¤æ›ï¼Œæˆ‘å€‘è¨­è¨ˆäº†ä¸€å€‹ç”±è¡Œå‹•æ”¶é›†å™¨ç”¢ç”Ÿä¸¦å‚³çµ¦åŒ¯èšç¯€é»çš„
COLLECT_DATAè¨Šæ¯ã€‚æ¯ç•¶æ¥æ”¶ä¸€æ®µè³‡æ–™ï¼Œè¡Œå‹•æ”¶é›†å™¨æœƒå‚³é€ ACKè¨Šæ¯çµ¦åŒ¯èšç¯€é»ã€‚
æˆ‘å€‘çš„å¯¦ä½œé¡¯ç¤ºå‡ºæˆ‘å€‘çš„è³‡æ–™å­˜æ”¾èˆ‡äº¤æ›ç­–ç•¥å¯ä»¥å¾ˆç°¡å–®åœ°åœ¨å¯¦éš›å¹³å°ä¸Šå¯¦ä½œå‡ºä¾†ã€‚ 
C. ç¸½çµ 
æˆ‘å€‘çš„è¨ˆç•«é‡å°è³‡æ–™å¿…é ˆæš«å­˜åœ¨ä¸€å€‹è¢«å¤–ç•Œéš”é›¢çš„ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯çš„æƒ…æ³ï¼Œæå‡ºäº†ä¸€å€‹
åˆ†æ•£å¼çš„è³‡æ–™å­˜æ”¾åŠäº¤æ›ç­–ç•¥ï¼Œèƒ½ä¿æŒå…·æœ‰è¼ƒé«˜å„ªå…ˆæ¬Šçš„è³‡æ–™å­˜æ”¾ä½ç½®è¶Šé è¿‘åŒ¯èšç¯€
é»ï¼Œä¸¦ä¸”æ¸›å°‘è³‡æ–™ä¸Ÿå¤±ã€‚æˆ‘å€‘è­‰æ˜äº†æˆ‘å€‘æå‡ºçš„ç­–ç•¥çš„ç‰¹æ€§ï¼Œä¸¦ä¸”åœ¨å¯¦éš›çš„å¹³å°ä¸Šå¯¦
ä½œäº†æˆ‘å€‘çš„ç­–ç•¥ï¼Œè­‰æ˜å…¶ç‚ºå¯è¡Œçš„ã€‚ 
 
  
16 
 
å››ã€è¨ˆç•«æˆæœè‡ªè©•éƒ¨ä»½ 
 
æœ¬çµæ¡ˆå ±å‘Šç ”ç©¶å…§å®¹èˆ‡åŸè¨ˆç•«æˆæœç›¸ç¬¦ï¼Œå…¶æˆæœæ•ˆç›Šæè¿°å¦‚ä¸‹ï¼š 
 
(ä¸€) å­¸è¡“æŠ€è¡“é¢ 
æœ¬è¨ˆç•«åœ¨å­¸è¡“æ–¹é¢ï¼Œç™¼è¡¨äº†å…©ç¯‡æœƒè­°è«–æ–‡[12][13]ã€‚åœ¨æŠ€è¡“æ–¹é¢ï¼Œæœ¬è¨ˆç•«åœ¨è¢«å­¤ç«‹çš„ç„¡ç·š
æ„Ÿæ¸¬ç¶²è·¯ä¸­ï¼ŒåŠ å…¥ä¸€è¡Œå‹•æ”¶é›†å™¨å½¢æˆæ–°çš„éšå±¤å¼ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯æ¶æ§‹ï¼Œä¸¦é‡å°é€™å€‹æ¶æ§‹è¨­è¨ˆäº†ä¸€
å¥—è³‡æ–™å­˜æ”¾èˆ‡äº¤æ›ç­–ç•¥(Distributed Storage Management Strategy, DSMS)ä¾†è§£æ±ºå­¤ç«‹ç„¡ç·šç¶²è·¯
ä¸­å°åŒ…ä¸Ÿå¤±çš„å•é¡Œï¼Œä¸¦ä¸”åœ¨å¯¦éš›å¹³å°ä¸Šå¯¦ä½œäº†æˆ‘å€‘æå‡ºçš„ç³»çµ±ï¼Œè­‰æ˜é€™å¥—ç³»çµ±æ˜¯å¯è¡Œä¸¦ä¸”èƒ½ç¢º
å¯¦æ‡‰ç”¨åœ¨å¯¦éš›ç’°å¢ƒä¸­ï¼Œä¸¦å¯ä¾›åœ‹å…§æ¥­è€…ç›´æ¥å¥—ç”¨æ–¼å…¶ç”¢å“ä¸Šã€‚ 
 
(äºŒ) ç¶“æ¿Ÿé¢æ•ˆç›Š 
æœ¬è¨ˆç•«æ‰€æå‡ºä¹‹ç³»çµ±ï¼Œéå¸¸é©ç”¨åœ¨å±±ä¸Šæˆ–æ·±æµ·ç­‰ç„¡æ³•éš¨æ™‚å°‡è³‡æ–™å›å‚³åˆ°å¤–ç•Œè€Œè¢«å­¤ç«‹çš„ç„¡
ç·šæ„Ÿæ¸¬ç¶²è·¯ç’°å¢ƒã€‚ç”±æ–¼è¿‘å¹¾å¹´ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯çš„æ‡‰ç”¨è¶Šä¾†è¶Šå¤šï¼Œå°¤å…¶ç”¨ä¾†åµæ¸¬å¤©ç½ç™¼ç”Ÿçš„æ‡‰ç”¨å°
äººé¡æœ‰éå¸¸å¤§çš„å¹«åŠ©ï¼Œå¦‚åœ¨é«˜å±±åµæ¸¬åœŸçŸ³æµæµå‘ï¼›åœ¨æµ·åº•åµæ¸¬æµ·åº•æ²¹ç”°ç­‰ã€‚ä½†æ˜¯æ­¤é¡ç³»çµ±å‹¢å¿…
æœƒé‡åˆ°è³‡æ–™ç„¡æ³•å›å‚³è‡³å¤–ç•Œçš„å•é¡Œã€‚å› æ­¤ï¼Œæˆ‘å€‘çš„è¨ˆç•«å°‡å¯å”åŠ©æœ‰é¡ä¼¼ç”¢å“çš„åœ‹å…§æ¥­è€…é–‹ç™¼ç”¢
å“ï¼Œï¨‰ä½å…¶ç ”ç™¼æˆæœ¬ã€‚ä¸¦ä¸”ï¼Œåƒèˆ‡æœ¬è¨ˆç•«ä¹‹å­¸ç”ŸåŠæ•™å¸«å·²è—‰ç”±å¯¦é©—ç†Ÿæ‚‰ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯ç›¸é—œå¥—ä»¶
ä¹‹é–‹ç™¼ç¨‹åºï¼Œä¸¦æœ‰å…©åç¢©å£«ç”Ÿå·²é †åˆ©å®Œæˆç¢©å£«è«–æ–‡ä¸”å–å¾—ç¢©å£«å­¸ä½ï¼Œå¯å³åˆ»æŠ•å…¥åœ‹å…§ä¹‹äººåŠ›å¸‚
å ´ä¸¦ï¨‰ä½åœ‹å…§æ¥­ç•Œä¹‹äººæ‰åŸ¹è¨“æˆæœ¬ã€‚ 
 
(ä¸‰) ç¤¾æœƒé¢æ•ˆç›Š 
æœ¬ç³»çµ±ä¹‹æ‡‰ç”¨èƒ½ä½¿äººé¡èƒ½æ›´å³æ™‚çš„åµæ¸¬åˆ°å¤©ç½çš„ç™¼ç”Ÿä»¥æ‡‰å°ï¼Œä»¥æ­¤æ¸›å°‘ç¤¾æœƒå°æ–¼å¤©ç½çš„ä¸
ç¢ºå®šæ€§ç”¢ç”Ÿçš„ä¸å®‰ï¼Œä¸¦ä»¥æ­¤ä¿ƒé€²ç¤¾æœƒç™¼å±•ã€‚ 
above mud flood example, the node that is most frequently
visited by rangers can be the sink.
There have been many works related to mules. Data collec-
tion using mules is addressed in [7][12][13]. Using mules to
connect sparse sensor networks at the cost of higher latencies
is explored in [7]. Reference [12] analyzes the upper bound
of the optimal data transfer with mules. In [13], it shows
that using mules with predictable mobility can significantly
reduce communication power in WSNs. Using mobile ferries
to conduct routing in a highly disconnected ad hoc network is
discussed in [14][15][16]. A comprehensive survey of mobile
sensor networks can be found in [17]. However, how to buffer
packets generated by an isolated WSN remains an obscure
problem. To the best of our knowledge, our work is the first
one addressing distributed prioritized storing strategies for
isolated WSNs using mobile mules.
The rest of the paper is organized as follows. Section II
presents our system model. DSMS is given in Section III.
Some extensions of DSMS are in Section IV. Section V
contains our simulation results. Our implementation results are
shown in Section VI. Section VII concludes this paper.
II. SYSTEM MODEL
We consider a heterogeneous WSN consisting of some static
sensors and mobile mules. Static sensor nodes, or simply
nodes, can continuously monitor the environment and peri-
odically generate reporting packets, or simply packets. Each
node has the same storage space of Ssn (in unit of packet) and
communication range of Rsn. Two nodes u and v can com-
municate with each other if their distance dist(u, v) â‰¤ Rsn.
These static sensor nodes form a connected WSN. Multi-hop
routing is supported in each WSN. However, since these WSNs
are deployed in a remote field and are isolated from the outside
world, they rely on mobile mules to visit them and carry their
sensory data out. Mobile mules will stop by a specific node,
called sink, for a period of time to collect sensory data. During
this period, the sink can relay its own and othersâ€™ packets to the
mule. The stopping period can be a fixed or a random length.
The movement of mules can be by intention (pre-arranged,
such as a bus) or by opportunity (not pre-arranged, such as a
taxi). These mules can later deliver the collected packets to an
external base station. Fig. 2 shows an example of our network
model and data collection mechanism.
Whenever a mule arrives at the sink, the sink can commu-
nicate with the mule. However, we assume that the connection
time and the available storage space of the mule are both
unpredictable. Therefore, packets generated by nodes should
be prioritized to reflect their importance. This can be done by
a pre-agreed function, by an aging process, or by importance
of readings. Higher priority means more importance. We also
assume that there is a predefined region nearby the sink called
Buffer Area (BA). The set of sensor nodes in BA are designated
to store sensing data of the WSN. Therefore, all static sensor
nodes will try to forward their data to BA. As an example,
in Fig. 2, the BA of network C contains nodes within 3 hops
from the sink. (In an extreme case, one may designated all
Priority: 19
Priority: 21
Priority: 18
Priority: 6
Priority: 8
Priority: 17
Sink
Buffer Area
Base Station
Internet
Isolated Network A
Isolated Network B
Isolated Network C
mule route
Fig. 2. System model of the DSMS system.
WSN as the BA.) We regard the storage spaces of nodes in
BA as a distributed storage system. Our goal is to design a
distributed protocol to achieve three goals.
G1 : Dropping of packets in BA should be minimized.
G2 : If dropping of packets is unavoidable, the lower-priority
ones should be dropped first.
G3 : To facilitate mobile mules to collect data, higher priority
packets should be stored closer to the sink.
Definition 1. Given a WSN modeled as a graph G = (V,E),
a sink âˆˆ V , a BA âŠ† V , and a priority function F for
packets, the Distributed Storage Management (DSM) problem
is to develop a packet exchange protocol to maintain packets
being generated by the WSN within BA such that G1-G3 are
met and Î©(BA) =
âˆ‘
vâˆˆBA,pâ†’v F (p) is maximized, where
pâ†’ v means that a packet p is stored at the storage of v.
III. PROPERTIES AND PROTOCOLS OF DSMS
The objective function Î©(BA) reflects our goal of accumu-
lating packets of higher priorities inside BA. We propose a
Distributed Storage Management Strategy (DSMS) based on
a shuffling mechanism. DSMS is a distributed solution. Nodes
not in BA will forward their packets to nodes in BA, while
nodes in BA will observe their neighborsâ€™ states and exchange
packets with each other as necessary. We assume that each
node u knows its distance D(u) to the sink and its neighbor
set N(u). Without loss of generality, we assume that each
node u has only one buffer space (i.e., Ssn = 1). So the (only)
packet in u is written as P (u) and its priority is F (P (u)) (if
u has no packet, F (P (u)) = âˆ’1). Our scheme can be easily
extended to Ssn > 1.
DSMS tries to maintain the following properties for each
node u âˆˆ BA
P1 : For each node v âˆˆ N(u) such that D(v) > D(u),
F (P (v)) â‰¤ F (P (u)).
P2 : For each node v âˆˆ N(u) such that D(v) < D(u),
F (P (v)) â‰¥ F (P (u)).
P3 : For each node v âˆˆ N(u) such that D(v) =
D(u), max{F (P (w))|w âˆˆ N(u),D(w) > D(u)} â‰¤
F (P (v)) â‰¤ min{F (P (w))|w âˆˆ N(u),D(w) < D(u)}.
674
F (P (v)) < F (P (u)). Since F (minPre(u)) â‰¤ F (P (v)) <
F (P (u)). It will not stop exchanging packets according to
E2.
Case 3 : Node u violates P3 but it follows P1 and P2.
That is there is a node v âˆˆ N(u) such that D(v) =
D(u) and F (P (v)) is not between F (maxPost(u)) and
F (minPre(u)). Since node u follows P1 and P2, we
can get F (minPre(u)) â‰¥ F (maxPost(u)). The value of
F (P (v)) is either larger than F (minPre(u)) or smaller than
F (maxPost(u)).
(1) F (P (v)) > F (minPre(u)). Since
F (maxEqual(u)) â‰¥ F (P (v)) > F (minPre(u)). It
will not stop exchanging packets according to E3.1.
or
(2) F (P (v)) < F (maxPost(u)). Since
F (minEqual(u)) â‰¤ F (P (v)) < F (maxPost(u)). It
will not stop exchanging packets according to E3.2.
Cases 1, 2 and 3 all contradict our assumption that nodes
have stopped exchanging packets, so this theorem is proved.
To summarize, because DSMS utilizes the richer mesh links
to exchange packets, higher-priority packets have chance to
stay closer to the sink by rules E3.1 and E3.1. One question
is: how many packet exchanges may be incurred when a
new packet is generated. We will investigate this issue via
simulations.
IV. SOME EXTENSIONS
We discuss two extensions below. We first extend DSMS
to Ssn > 1. We define maxMine(u) (resp., minMine(u))
to be the packet of u with the highest (resp., lowest) priority.
Since a node may have multiple packets, the exchange rules
for node u are modified as follows:
E1â€™ : When F (maxPost(u)) > F (minMine(u)), node u
tries to exchange its packet minMine(u) with packet
maxPost(u).
E2â€™ : When F (maxMine(u)) > F (minPre(u)), node u
tries to exchange its packet maxMine(u) with packet
minPre(u).
E3.1â€™, E3.2â€™ are the same as previous as E3.1 and E3.2.
The definition of â€œin-orderâ€ can be directly extended to
Ssn > 1. Note that nodes only need to broadcast the highest
and the lowest priorities of its packets. It is not hard to prove
that previous properties still hold when Ssn > 1.
The second extension is to add a new transmission buffer
to each node to handle packet overflow. A packet waiting
to be transmitted should be put in the transmission buffer.
When a node u âˆˆ BA whose storage space is full generates
a new packet, it will keep packets with higher priorities and
move the lowest-priority one to its transmission buffer. We
assume that BA is more crowded, so such packets will be
forwarded to node v, where v âˆˆ N(u),D(v) > D(u) and
F (minMine(v)) is minimum. However, this decision will not
affect the correctness of our protocol.
x coordinate
y 
co
or
di
na
te
819.6318
640.4303
461.2287
282.0272
102.82
57
0 50 100 150 200
0
20
40
60
80
100
120
140
160
180
200
âˆ’200
âˆ’100
0
100
200
300
400
500
600
700
800
Fig. 4. A snapshot of priority distribution.
 550
 600
 650
 700
 750
 800
 850
 900
 950
 1000
 0  50  100  150  200  250  300  350  400
A
v
e
r
a
g
e
 
p
r
io
ri
ty
Numer of collecting nodes
Communication graph
Tree structure
Fig. 5. DSMS with a mesh-like communication graph and with a tree
structure.
V. SIMULATION RESULTS
We have conducted some simulations to verify our results.
Unless otherwise indicated, the simulation environment con-
tains 400 sensor nodes randomly deployed in 200Ã— 200 field,
each with a transmission range of 25. The packet arrival rate is
1/50 per node, and each packet has a random priority between
0 and 1000. BA is set as the set of sensor nodes within 10
hops from the sink. All results are from the average of 50
test runs. Fig. 4 shows a snapshot of priority distribution in a
network with the sink at (0, 0) after applying DSMS.
We first compare DSMS when the richer mesh links are
adopted against when a tree is adopted. The shortest path
tree rooted at the sink is adopted for comparison, where each
node only is allowed to exchange its packets with its parent or
children. In this experiment, we vary the collecting duration
when a mule visits a sink node (i.e., how long a mule collects
the data from a fixed number of nodes). The results are shown
in Fig. 5. More higher-priority packets are collected when a
mesh-like communication graph is adopted.
Fig. 6 compares the average priorities of the packets col-
676
(a)
g
c
hf
k l
db
j
a
e
i
m
n p qo
(b)
Fig. 9. (a) Snapshot of our DSMS implementation. (b) A grid WSN.
lected by mobile mules when we vary the visited interval of
a sink or collecting duration of a mule. We compare DSMS
against Greedy Forward (GF), where a node always tries to
send its packets to any node closer to the sink until the latter
has no storage space. OPT represents an ideal situation when
the global optimization is achieved. Fig. 6(a) shows that as the
visited interval increases, the average priority also increases.
Here, the duration of one slot is how long a packet moves
one hop. Fig. 6(b) shows that the average priority decreases
slightly as the collecting duration is prolonged. However, the
impact is insignificant.
Fig. 7 shows the effect of BAâ€™s size. In Fig. 7(a), we vary
the size of BA (in terms of hop count) but fix the visiting
period of a mule by enforcing that the 1/3 of data in the
network must be collected. In terms of the average priority of
collected packets, DSMS outperforms GF and is close to OPT
when the hop count is larger than 5. Fig. 7(b) shows that the
amount of dropped data will decrease when BAâ€™s size becomes
larger. This is because much storage space could be used. On
the other hand, transmission overheads will decrease first and
then increase when the BAâ€™s size is getting larger, where the
transmission overheads are increased by one if there is a packet
exchange. This is because packets with the smaller priorities
have to travel long to reach BA when BAâ€™s size is relative
small (4âˆ¼7 hops). However, as the hop count is larger than
7, more packets will be exchanged toward BA. So, this will
cause the transmission overheads increasing.
Fig. 8 shows the transmission overheads of DSMS under the
different number of nodes and a new packet arrival. Fig. 8(a)
compares the transmission overheads by varying the number of
nodes and the packet arrival rate. As can be seen, DSMS costs
more packet exchanges than GF. The transmission overheads
caused by DSMS is about a constant higher than that by
GF. Fig. 8(b) shows that the packet transmissions will be
incurred when a new packet with a random priority is inserted
into a stabilized network. The number of packet transmissions
increases while the number of nodes increases, but the effect
is insignificant.
VI. IMPLEMENTATION
We have implemented DSMS in a simplified hardware
platform. A toy train is designed to repeatedly circle around a
toy rail. The train serves as a mule, and we deploy a wireless
node on it. A number of isolated grid WSNs are deployed
around the rail. Whenever the train has a connection with a
sink, it will pull as much data from the sink (and thus its BA)
as possible. Fig. 9(a) shows our implementation structure. Our
sensor hardware platform is a low-power and low-cost wireless
microcontroller, JN5139 [18], with ZigBee-compliant wireless
interface. The WSN in Fig. 9(b) is a 4Ã—4 grid plus a sink. We
implement our DSMS on these Jennic microcontroller boards.
We use a light sensor to generate sensory packets with priority
ranging from 0 to 9, where a higher light intensity means
a higher priority. To view the priority of a piece of sensing
data, we display the value on an on-board 7-segment display.
To facilitate data exchange, we design a COLLECT DATA
message that can be initiated by the mule to the sink. After
collecting a piece of data, the mule will transmit an ACK
message to the sink.
Our implementation shows that the DSMS can be easily
implemented in a real sensor platform with a very small image
in each microcontroller. Fig. 10 shows a snapshot where after
applying our exchange rules, data in all nodes are in-order.
The implementation verifies that our DSMS protocol is quite
simple and only needs local information. So, it is suitable for
a distributed WSN.
678
Non-Location-Based Mobile Sensor Relocation in a Hybrid Static-Mobile Wireless
Sensor Network
Fang-Jing Wu, Hsiu-Chi Hsu, and Yu-Chee Tseng
Department of Computer Science
National Chiao-Tung University
Hsin-Chu, Taiwan
{fangjing, hchsu, yctseng}@cs.nctu.edu.tw
Chi-Fu Huang
Department of Computer Science and
Information Engineering
National Chung Cheng University
Chia-Yi, Taiwan
cfhuang@csie.nctu.edu.tw
Abstract
An inherent concern for a wireless sensor network (WSN)
is the unbalanced energy consumption problem, where sen-
sors closer to the sink are more likely to exhaust their
energy faster than other nodes. To mitigate this problem,
this paper considers including some resource-rich mobile
nodes, called mobile data-pumps, to conduct data relaying
from static sensors to the sink. The network thus becomes
a two-tier network, with the original static sensors at the
low tier and data-pumps at both low and high tiers. We
propose a novel distributed navigation protocol that does
not rely on any location information of sensor nodes to
relocate data-pumps to meet both goals of connectivity and
load balance. The main idea is a concept called virtual
Voronoi cells, which can help data-pumps to locally balance
their loads using the underlaying low-tier topology and
thus significantly balance energy consumption of sensors.
Simulation results are presented to verify the effectiveness
of our result.
Keywords: load balance, mobile computing, mobile sensor,
pervasive computing, wireless sensor network.
1. Introduction
The progress of embedded micro-sensing MEMS and
wireless technologies has made the success of wireless
sensor networks (WSNs). A WSN is usually composed of
a sink and a large number of sensors, each capable of
collecting environmental information. Research issues for
WSNs, such as deployment [15], [21], energy-efficient MAC
[7], [11], and data aggregation [3], have been intensively
studied.
Sensor deployment is a critical issue for WSNs. A suc-
cessful deployment must guarantee both connectivity and
coverage. The former is to ensure that sensory data can be
delivered to the sink, and the latter is to ensure that the whole
sensing field is fully monitored. Another big challenge is the
energy unbalanced problem, where it is known that sensors
closer to the sink are likely to consume their energy much
faster than other nodes; a lot of works have tried to address
this issue [1]â€“[4].
Recently, researchers have proposed to add resource-
richer mobile nodes to help relieve the energy unbalanced
problem. In [8], [9], [12], [13], [17], [18], [20], a set of
mobile collectors are used to move along pre-planned paths
to collect data from static sensors. The collection process
can be single-hop [9], [13], [20] or multi-hop [8], [12],
[17], [18]. While such approaches can balance the energy
consumption of sensors, moving these collectors may cause
long delays, thus harming real-time applications. To relieve
this limitation, [19] proposes a two-tier architecture, where
the low tier consists of typical sensor nodes and the high tier
consists of mobile data-pumps, called syphons, each with a
long-range and a short-range wireless interfaces. The short-
range ones can communicate with the low-tier network. The
goal is to design a range-free protocol to help these syphons
to move around to form a connected syphon tree rooted at
the sink by those long-range interfaces. The low-tier nodes
can first relay their data to the nearest syphons and then the
syphon tree can quickly relay these data to the sink. In this
way, the energy requirement of low-tier nodes is relaxed.
In this work, we adopt the same two-tier architecture as
in [19]. However, we observe that the design of [19] does
not try to balance the loads of syphons (i.e., the numbers of
sensors served by syphons). Note that unbalanced loads of
syphons will also affect the energy consumption, and thus
the lifetime, of both high- and low-tier nodes. To resolve this
problem, we propose a novel range-free relocation protocol
based on a virtual Voronoi cell concept. We assume no loca-
tion information for syphons, and nor for low-tier sensors.
The only assumption is that the initial deployment of low-
tier sensors should be dense enough to form a connected
network with the sink. Initially, syphons may or may not
be connected with the sink. Figure 1(a) gives an example,
where the data of sensor s1 is relayed by m1 and m2, and
that of sensor s2 needs to go long way to m3 and then to
the sink. If we can properly relocate syphons as shown in
Figure 1(b), then s2 can quickly relay its data via syphons.
Relocating syphons needs to address both connectivity and
55
70
42
s1
68
data-pump
sensor
moving direction
1349,   D|)(| 1mC
7044
s2 m0
m1
m2
m3
m0
m1
m2
m3
(a) (b)
wireless link
114
Figure 2. An example of relocating data-pumps.
3.1. Balancing Mode for Attached Data-Pumps
The main idea is to enforce each attached data-pump mi
to move, based on local information, toward the â€˜centerâ€™
of its current virtual Voronoi cell while keep attached.
By so doing, load balance can be achieved eventually.
Geometrically, F can be partitioned into multiple Voronoi
cells based on attached data-pumpsâ€™ locations. However,
since no location information is assumed, we will use the
connectivity information among S as a clue to navigate data-
pumps. For example, in Figure 2(a), m1 can detect that it is
not at the center of its current virtual Voronoi cell by forming
an intra-cell tree rooted at itself. Our scheme will force m1
to move toward the child with the largest subtree, i.e., s1.
After repeating this movement process several times, m1â€™s
subtrees will reach certain equilibrium. Concurrently, m2
and m3 will conduct the same process. More importantly,
this will repartition the virtual Voronoi cells. Figure 2(b)
shows an ideal situation after several rounds.
Our protocol is designed as an iterative process with
multiple rounds. Each round has four phases, during which
a data-pump may make a movement. Phase 1 is to partition
F into virtual Voronoi cells in a distributed manner. Phase
2 will decide each data-pumpâ€™s moving direction. Phase
3 will choose each data-pumpâ€™s parent to maintain the
connectivity in the high-tier network. The actual movement
and termination conditions are decided in phase 4. Phases
among data-pumps need to be synchronized (refer to Sec
3.3).
Phase 1: Virtual cell construction. In this phase, each
data-pump mi will compute its cell C(mi) by forming a
tree Ti rooted at itself. Each sensor sj will maintain two
variables: Ï‡(sj) and h(sj) (hop count from mi to sj in Ti).
Initially, Ï‡(sj) = NULL and h(sj) =âˆ. To start with, mi
will broadcast a Cell(mi, h) message using its short-range
antenna with h = 1 (standing for hop count). When any sj
receives a Cell(mi, h) message, it will check the following
conditions: (i) Ï‡(sj) = NULL and (ii) h < h(sj). If any
of the above conditions is true, sj will set Ï‡(sj) = mi, set
h(sj) = h, and broadcast a Cell(mi, h+1) message. At the
end of Phase 1, each sensor will know its master data-pump.
Phase 2: Cell center estimation. In this phase, each
mi will try to identify the center sensor cn(mi) of its
cell C(mi). Initially, mi will assume itself as the center,
i.e., cn(mi) = mi, and broadcast a CENTER(cn(mi))
message around sensors in C(mi) to form a spanning tree
rooted at itself. Each sensor sj will calculate the depth and
the number of sensors of the subtree rooted at itself, denoted
by dj and nj , respectively. Then, each sensor sj can compute
a load index as follows:
Îµj = Î± Â· nj + (1âˆ’ Î±) Â· dj ,
where 0 â‰¤ Î± â‰¤ 1 is a weight to reflect the importance of
our two metrics (i.e, the deviation among |C(mi)| and the
deviation among R(mi)). Then, mi will run the following
iterative process to update the center sensor cn(mi). The
main idea can be imagined that mi throws an agent which
is like a ball and will roll toward the center of C(mi) along
the sensors with higher load index. Specifically, in each
iteration, mi will try to update the center sensor cn(mi)
by the child of cn(mi) with the highest load index, denoted
by sc, if the following condition is satisfied: ÎµcÎµâ€²c â‰¥ 1, where
Îµâ€²c = Î± Â· (|C(mi)|âˆ’nc)degree(cn(mi))âˆ’1 + (1âˆ’ Î±) Â· (dmax + h(sc,mi)) is
the estimation of the average load index for the remaining
subtrees rooted at cn(mi)â€™s children excluding the subtree
rooted at sc. Here, degree(cn(mi)) is the low-tier degree of
cn(mi) (in terms of short-range antenna degree), dmax is the
maximum depth of subtrees rooted at miâ€™s children in the
spanning tree except the subtree rooted at scâ€™s ancestor, and
h(sc,mi) is the short-range antenna hop count from sc to
mi along the spanning tree. Note that instead of reforming
the spanning tree, we use ÎµcÎµâ€²c to estimate if the loads between
the side of the subtree rooted at sc and the remaining side
in C(mi) is balancing after mi move to scâ€™s position. Once
mi updates cn(mi) = sc, it must memorize the history of
cn(mi) to help relocate itself along the sequence of sensors
in the history when moving. This completes one iteration.
This process is repeated until there is no descent of cn(mi)
can satisfy the above condition. Note that, this phase can be
repeated more times for refining the center sensor cn(mi) of
this cell. Figure 2 gives an example, where |C(m1)| = 349,
and Î± = 1. Initially, m1 finds the subtree rooted at s1 with
highest load index Îµ1 = 114 and updates cn(mi) = s1,
because Îµ1Îµâ€²1 =
114
58.75 â‰¥ 1, where Îµâ€²1 = 349âˆ’1144 = 58.75.
Then, m1 repeatedly run this process until it finds Îµ2Îµâ€²2 < 1,
where Îµ2 = 70, and Îµâ€²2 =
349âˆ’70
2 = 139.5. Finally, m1 can
identify the center sensor cn(m1) is s1.
Phases 3: Connectivity maintenance between mobile
data-pumps. In this phase, each data-pump mi must choose
an attached data-pump to be its parent, denoted by P (mi)
for keeping attached. Specifically, mi must make sure
that it can always hear the periodical Attachment message
from P (mi) when moving. To achieve this goal, each
3.3. Synchronization Between Phases
We suggest two possible approaches to synchronize the
phases between data-pumps. The first one is that the phases
switching is coordinated by the sink, while the second one
is that each data-pump will set a timer for each pases to
control the switching timing between phases.
For the first type synchronization, upon the network is re-
quested to perform our protocol, the sink must first broadcast
a Phase1-2 Start message via the high-tier network to in-
form attached data-pumps to construct cells and estimate the
centers of cells. When an attached data-pump mi receives
the Phase1-2 Start message, it will rebroadcast this message
via the high-tier network and then execute the phase 1 and
phase 2. After mi has finished phase1 and phase 2, it will
send a Phase1-2 End message to inform the sink. The sink
must collect Phase1-2 End messages from all attached data-
pumps and then broadcast a Phase3 Start message to inform
data-pumps to execute phase 3. It is similar to the above
procedures, the sink must wait until it knows that all data-
pumps have finished the current phase and then triggers the
next phase by broadcasting message in the high-tier network.
Also, when an unattached data-pump has became an attached
one, it must listen the synchronization messages from the
sink to conduct the balancing mode.
For the second type synchronization, each data-pump will
set a specified a timer for each phase. Upon the network is
requested to execute our protocol, each attached data-pump
mi will enter the phase 1 and start a timer Phases1 Timer.
After the Phases1 Timer expired, mi will enter the phase 2
and also wait a timer for the current phases until the timer
has expired. This process will be repeatedly phase by phase
until the protocol is terminated. On the other hand, when an
unattached data-pump mi becomes an attached one, it will
immediately send Synchronization Request message to the
neighboring data-pumps to query how long it should wait
for entering the balancing mode to start a new round. When
an attached data-pump receives a Synchronization Request
message, it will reply a Synchronization Reply message with
a time duration, based on the timers of the four phases
in the balancing mode. After mi receives reply message
from neighboring data-pumps, it will switch to the balancing
mode until the maximum execution rounds has been reached.
4. Simulation Results
We randomly deploy 20000 sensors and 75 data-pumps
in a disk-sharp field with a radius of Rf . The short-range
antenna and the long-range antenna have transmission
distances rc = 60 m and Rc = 240 m, respectively (we
use WiFi and ZigBee as the reference here; the former
has a transmission range of five times the latter [10]). We
set the parameters both Î± (in phase 2) and Î² (in phase 3)
as 0.5. Our simulation results are all from the average of
100 runs. We compare our protocol against the SODaR
protocol proposed in [19] by the following two ways.
The first one (denoted by â€˜ours-only connecting modeâ€™) is
that data-pumps only can perform the connecting mode to
achieve the same goal of the connectivity in the SODaR.
The second one (denoted by â€˜oursâ€™) is that data-pumps can
run two modes in our protocol to achieve the both goals of
connectivity and load balance. In SODaR, each unattached
data-pump mi must move along the circle composed of
sensors with the same sensor hop counts from the sink as
miâ€™s (in terms of short-range antenna hop count) to connect
an attached data-pump. In our simulations, we use three
metrics to evaluate the performance of ours and the SODaR
as follows.
1. The quantification of the balance: we use the
fairness index [6] to measure the deviation of data-
pumpsâ€™ loads. Here, the fairness index is calculated by
f(|C(m1)|, |C(m2)|, . . . , |C(me)|) = (Î£
e
i=1|C(mi)|)2
eÂ·Î£ei=1(|C(mi)|)2 ,
where 0 â‰¤ f(|C(m1)|, |C(m2)|, . . . , |C(me)|) â‰¤ 1. Note
that a protocol with the larger fairness index implies the less
deviation of data-pumpsâ€™ loads (i.e., it is more balancing).
2. The movement overhead: we calculate the average
moving distance of data-pumps in a protocol.
3. The communication overhead: we calculate the total
number of messages exchanged in a protocol.
First, we find an adequate maximum execution round by
observing the improvement in balance under different num-
ber of execution rounds. Figure 3(a) shows the simulation
result, where the fairness index only is slightly improvement
after 10 rounds. Thus, we take the maximum execution
round of our protocol by 30 rounds in the following simula-
tions. Then, we investigate the impact of relocation protocols
on balance under different radius of deployment. Figure 3(b)
shows the result, where the fairness index is decreasing with
the increasing of Rf . This is because the number of data-
pumps is too less to span a large-scale high-tier network to
balance the loads of data-pumps when Rf is larger. Note
that our relocation protocol has prominent balance results
even if only the connecting mode is conducted. Then, we
focus on the goal of connectivity to compare the overheads
of relocation protocols under different Rf . Figure 3(c) shows
an interesting result on the movement overhead, where
SODaR only can successfully work under some deployment
cases (Rf is between 1000 and 2000) and results in higher
movement overhead. This is because it may fail that an
unattached data-pump in SODaR searches an attached data-
pumps within a limited area. Note that the SODaR results
in less movement overhead when Rf > 2000, because most
data-pumps can not relocate themselves due to the SODaR
fail. However, our connecting mode can always work out
fine, and unattached data-pumps can quickly connect to the
sink with less moving distance. Finally, in Figure 3(d) shows
[2] R. Cristescu, B. Beferull-lozano, and M. Vetterli. On network
correlated data gathering. In Proc. IEEE INFOCOM, pages
2571â€“2582, 2004.
[3] K.-W. Fan, S. Liu, and P. Sinha. Structure-free data aggre-
gation in sensor networks. IEEE Trans. Mobile Computing,
6(8):929â€“942, 2007.
[4] K.-W. Fan, S. Liu, and P. Sinha. Dynamic forwarding over
tree-on-DAG for scalable data aggregation in sensor networks.
IEEE Trans. Mobile Computing, 6(10):1271â€“1284, 2008.
[5] N. Heo and P.K. Varshney. Energy-efficient deployment of
intelligent mobile sensor networks. IEEE Trans. Systems,
Man, and Cyberneticsâ€“Part A, 35(1):78â€“92, 2005.
[6] R. K. Jain. The Art of Computer Systems Performance
Analysis: Techniques for Experimental Design, Measurement,
Simulation, and Modeling. John Wiley and Sons, New York,
1991.
[7] G. Lu, B. Krishnamachari, and C. S. Raghavendra. An adap-
tive energy-efficient and low-latency MAC for data gathering
in wireless sensor networks. In Proc. IEEE Intâ€™l Parallel and
Distributed Processing Symp., 2004.
[8] M. Ma and Y. Yang. SenCar: an energy-efficient data gath-
ering mechanism for large-scale multihop sensor networks.
IEEE Trans. Parallel and Distributed Systems, 18(10):1476â€“
1488, 2007.
[9] M. Ma and Y. Yang. Data gathering in wireless sensor
networks with mobile collectors. Proc. IEEE Intâ€™l Parallel
and Distributed Processing Symp., pages 1â€“9, 2008.
[10] T. Nolte, H. Hansson, and L. L. Bello. Wireless automotive
communications. In Euromicro Conference on Real-Time
Systems, pages 35â€“38, 2005.
[11] M.-S. Pan and Y.-C. Tseng. Quick Convergecast in Zig-
Bee Beacon-Enabled Tree-Based Wireless Sensor Networks.
Computer Comm., 31(5):999â€“1011, 2008.
[12] J. Rao and S. Biswas. Joint routing and navigation protocols
for data harvesting in sensor networks. In Proc. IEEE Intâ€™l
Conf. Mobile Ad Hoc and Sensor Systems, pages 143â€“152,
2008.
[13] J. Rao, T. Wu, and S. Biswas. Network-assisted sink navi-
gation protocols for data harvesting in sensor networks. In
Proc. IEEE Wireless Comm. and Networking Conf., pages
2887â€“2892, 2008.
[14] G. Wang, G. Cao, and T.F.L. Porta. Movement-assisted sensor
deployment. IEEE Trans. Mobile Computing, 5(6):640â€“652,
2006.
[15] Y.-C. Wang, C.-C. Hu, and Y.-C. Tseng. Efficient placement
and dispatch of sensors in a wireless sensor network. IEEE
Trans. Mobile Computing, 7(2):262â€“274, 2008.
[16] Y.-C. Wang and Y.-C. Tseng. Distributed deployment schemes
for mobile wireless sensor networks to ensure multilevel
coverage. IEEE Trans. Parallel and Distributed Systems,
19(9):1280â€“1294, 2008.
[17] G. Xing, T. Wang, W. Jia, and M. Li. Rendezvous design
algorithms for wireless sensor networks with a mobile base
station. Proc. ACM Intâ€™l Symp. Mobile Ad Hoc Networking
and Computing., pages 231â€“240, 2008.
[18] G. Xing, T. Wang, Z. Xie, and W. Jia. Rendezvous planning in
wireless sensor networks with mobile elements. IEEE Trans.
Mobile Computing, 7(12):1430â€“1443, 2008.
[19] G. Yang, B. T. amd Daji Qiao, and W. Zhang. Sensor-
aided overlay deployment and relocation for vast-scale sensor
networks. In Proc. IEEE INFOCOM, pages 2216â€“2224, 2008.
[20] M. Zhao, M. Ma, and Y. Yang. Mobile data gathering with
space-division multiple access in wireless sensor networks.
Proc. IEEE INFOCOM, pages 1283â€“1291, 2008.
[21] Y. Zou and K. Chakrabarty. Sensor deployment and target lo-
calization based on virtual forces. In Proc. IEEE INFOCOM,
pages 1293â€“ 1303, 2003.
[22] Y. Zou and K. Chakrabarty. Sensor deployment and target
localization in distributed sensor networks. ACM Trans.
Embedded Computing Systems, 3(1):61â€“91, 2004.
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•«è¡ç”Ÿç ”ç™¼æˆæœæ¨å»£è³‡æ–™è¡¨
æ—¥æœŸ:2011/08/18
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•«
è¨ˆç•«åç¨±: éšå±¤å¼ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯è¨­è¨ˆèˆ‡å¯¦ä½œ
è¨ˆç•«ä¸»æŒäºº: é»ƒå•Ÿå¯Œ
è¨ˆç•«ç·¨è™Ÿ: 98-2218-E-194-010-MY2 å­¸é–€é ˜åŸŸ: è¨ˆç®—æ©Ÿç¶²è·¯èˆ‡ç¶²éš›ç¶²è·¯
ç„¡ç ”ç™¼æˆæœæ¨å»£è³‡æ–™
å…¶ä»–æˆæœ 
(ç„¡æ³•ä»¥é‡åŒ–è¡¨é”ä¹‹æˆ
æœå¦‚è¾¦ç†å­¸è¡“æ´»å‹•ã€ç²
å¾—çé …ã€é‡è¦åœ‹éš›åˆ
ä½œã€ç ”ç©¶æˆæœåœ‹éš›å½±éŸ¿
åŠ›åŠå…¶ä»–å”åŠ©ç”¢æ¥­æŠ€
è¡“ç™¼å±•ä¹‹å…·é«”æ•ˆç›Šäº‹
é …ç­‰ï¼Œè«‹ä»¥æ–‡å­—æ•˜è¿°å¡«
åˆ—ã€‚) 
ç„¡ 
 æˆæœé …ç›® é‡åŒ– åç¨±æˆ–å…§å®¹æ€§è³ªç°¡è¿° 
æ¸¬é©—å·¥å…·(å«è³ªæ€§èˆ‡é‡æ€§) 0  
èª²ç¨‹/æ¨¡çµ„ 0  
é›»è…¦åŠç¶²è·¯ç³»çµ±æˆ–å·¥å…· 0  
æ•™æ 0  
èˆ‰è¾¦ä¹‹æ´»å‹•/ç«¶è³½ 0  
ç ”è¨æœƒ/å·¥ä½œåŠ 0  
é›»å­å ±ã€ç¶²ç«™ 0  
ç§‘ 
æ•™ 
è™• 
è¨ˆ 
ç•« 
åŠ  
å¡« 
é … 
ç›® è¨ˆç•«æˆæœæ¨å»£ä¹‹åƒèˆ‡ï¼ˆé–±è½ï¼‰äººæ•¸ 0  
 
