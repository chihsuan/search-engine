è¡Œæ”¿é™¢åœ‹å®¶ç§‘å­¸å§”å“¡æœƒè£œåŠ©å°ˆé¡Œç ”ç©¶è¨ˆç•« 
â– æˆæœå ±å‘Š   
â–¡æœŸä¸­é€²åº¦å ±å‘Š 
 
åœ¨ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯ä¸€ç¨®åˆ©ç”¨è™›æ“¬åº§æ¨™å®¹éŒ¯å¯é åŠä¿è­‰å°åŒ…é€é”çš„ç¹å¾‘
æ–¹æ³•ï¼ˆ3/3ï¼‰ 
 
 
è¨ˆç•«é¡åˆ¥ï¼šâ– å€‹åˆ¥å‹è¨ˆç•«   â–¡æ•´åˆå‹è¨ˆç•« 
è¨ˆç•«ç·¨è™Ÿï¼šNSC 97ï¼2221ï¼Eï¼007ï¼042ï¼MY3 
åŸ·è¡ŒæœŸé–“ï¼š97å¹´ 08æœˆ 01æ—¥è‡³ 100å¹´ 07æœˆ 31æ—¥ 
 
åŸ·è¡Œæ©Ÿæ§‹åŠç³»æ‰€ï¼šåœ‹ç«‹æ¸…è¯å¤§å­¸è³‡è¨Šå·¥ç¨‹å­¸ç³»ï¼ˆæ‰€ï¼‰ 
 
è¨ˆç•«ä¸»æŒäººï¼šè”¡æ˜å“² 
è¨ˆç•«åƒèˆ‡äººå“¡ï¼šåšç­ç ”ç©¶ç”Ÿ-å…¼ä»»åŠ©ï§¤ï¼šæ—ä½³å®ã€æŸ¯å´´å‚‘ã€è‘£è‚²èã€é„­å…ƒåš 
éƒ­å»ºå¿—ã€æ¹¯æ›œä»»ã€é™³ä»¥é›· 
ç¢©ç­ç ”ç©¶ç”Ÿ-å…¼ä»»åŠ©ï§¤ï¼šè¨±æ›¸è±ªã€éƒ­æ¡æƒŸã€æ¸¸æŒ¯å¨ã€è¨±å€æº 
å¤§å­¸ç•¢æ¥­ç”Ÿ-å°ˆä»»åŠ©ï§¤ï¼šåŠ‰æ™‰æ¦® 
 
æˆæœå ±å‘Šé¡å‹(ä¾ç¶“è²»æ ¸å®šæ¸…å–®è¦å®šç¹³äº¤)ï¼šâ–¡ç²¾ç°¡å ±å‘Š  â– å®Œæ•´å ±å‘Š 
 
æœ¬è¨ˆç•«é™¤ç¹³äº¤æˆæœå ±å‘Šå¤–ï¼Œå¦é ˆç¹³äº¤ä»¥ä¸‹å‡ºåœ‹å¿ƒå¾—å ±å‘Šï¼š 
â–¡èµ´åœ‹å¤–å‡ºå·®æˆ–ç ”ç¿’å¿ƒå¾—å ±å‘Š 
â–¡èµ´å¤§é™¸åœ°å€å‡ºå·®æˆ–ç ”ç¿’å¿ƒå¾—å ±å‘Š 
â– å‡ºå¸­åœ‹éš›å­¸è¡“æœƒè­°å¿ƒå¾—å ±å‘Š 
â–¡åœ‹éš›åˆä½œç ”ç©¶è¨ˆç•«åœ‹å¤–ç ”ç©¶å ±å‘Š 
 
 
è™•ï§¤æ–¹å¼ï¼šé™¤åˆ—ç®¡è¨ˆç•«åŠä¸‹åˆ—æƒ…å½¢è€…å¤–ï¼Œå¾—ç«‹å³å…¬é–‹æŸ¥è©¢ 
            â–¡æ¶‰åŠå°ˆåˆ©æˆ–å…¶ä»–æ™ºæ…§è²¡ç”¢æ¬Šï¼Œâ–¡ä¸€å¹´â– äºŒå¹´å¾Œå¯å…¬é–‹æŸ¥è©¢ 
 
ä¸­   è¯   æ°‘   åœ‹  100å¹´ 10æœˆ 19æ—¥ 
II 
 
Abstract 
A wireless sensor network is composed of multiple wireless sensors. Each sensor is able to collect, 
process, and store environmental information as well as communicate with others via inter-sensor 
communication. Routing is an important issue that affects wireless sensor networks. Many routing protocols 
based on virtual coordinates are proposed in wireless sensor networks without GPS assistance. In these 
works, some cannot guarantee packet delivery in discrete domain and some need to memorize a graph 
having the global topological features, consuming, in the process, a great deal of message broadcast 
overhead. We have proposed ABVCap and ABVCap_Uni which are the first routing protocols, in the 
literature, able to guarantee packet delivery in discrete domain without computation and storage of the 
global topological features in wireless sensor networks with bidirectional and unidirectional links, 
respectively. However, both of ABVCap and ABVCap_Uni assume that no node switches off or runs out of 
batteries (no faulty node) and there is no packet loss due to the link quality and interference, which is 
impractical in real environment. In this project, we develop an approach, ABVCap maintenance, to 
reconstruct an ABVCap virtual coordinate system in a network with node failures. In addition, we develop a 
method capable of augmenting virtual-coordinate-based routing protocols to guarantee packet delivery. The 
virtual face construction and naming protocols are developed to construct and name virtual faces, 
respectively. To route a packet from a dead-end node to a progress node, the VirtualFace algorithm is 
presented by traversing the boundaries of the virtual faces from face to face. 
 
Keywords: wireless sensor networks, routing protocol, fault tolerant, guaranteed delivery 
 
 
 
  
1 
 
å ±å‘Šå…§å®¹ 
ä¸€ã€å‰è¨€ 
A wireless sensor network is composed of multiple wireless sensors. Each sensor is able to collect, 
process, and store environmental information as well as communicate with others via inter-sensor 
communication. The rapid development of wireless communications and embedded micro-sensing 
technologies facilitate the use of wireless sensor networks in our daily lives; a wide range of applications 
exist for wireless sensor networks, including environmental monitoring, battle-field surveillance, health care, 
nuclear, biological, and chemical (NBC) attack detection, intruder detection, etc. Recently, studies of 
wireless sensor networks have received considerable attention 0, [2], [3]. In wireless sensor networks, 
routing is an important issue that has a significant impact on the network performance. In this project, we 
undertake the development of routing protocols in wireless sensor networks. 
 
äºŒã€ç ”ç©¶ç›®çš„ 
In geographic routing, the physical location is used as the node address. The source node determines 
the destination address by looking it up from the location server [4], or by computing it using a hash 
function in a data-centric storage scheme [5]. The node usually forwards the packet to a neighbor closer to 
the destination. This, however, may bring the packet to a dead-end node, a node with no neighbor closer to 
the destination. GPSR [6] and GFG [7] routing use the FACE algorithm on a planar graph to deal with the 
dead-end node problem. In addition, GSR routing [8] and a combination of the FACE algorithm and the 
shortcut-based procedure [9] are proposed to improve routing efficiency. GSR routing builds a planar 
routing subgraph RDG (Restricted Delaunay Graph) so that there exists a path whose distance, in terms of 
Euclidean distance or hop distance, in RDG is only the constant times to the minimum distance between any 
pair of nodes. In Fang et al. [10] and Kuhn et al. [11], methods for mapping holes and routing around holes 
are proposed. In geographic routing, nodes are required to have accurate geographic information that is 
difficult to obtain because GPS devices are expensive, do not work indoors, and has measurement error.  
Routing protocols based on virtual coordinates are proposed in wireless sensor networks without GPS 
assistance. Through an iterative procedure, a relaxation algorithm [12] assigns virtual coordinates to nodes 
that are close to their physical locations, consuming, in the process, a great deal of message broadcast 
overhead. This method does not guarantee packet delivery because the FACE algorithm cannot be used to 
solve the dead-end node problem due to the local error of the virtual coordinate assignment [13]. A survey of 
methods for assigning virtual coordinates to nodes similar to the real ones can be found in [14]. GLIDER 
[15] is a landmark-based routing scheme, in which all nodes are divided into cells by the landmark Voronoi 
complex. The connections between neighboring cells are represented as combinatorial Delaunay 
3 
 
maximum hop distance from W, Y is the node with the maximum hop distance from X, and Z is the node 
with the maximum hop distance from W among all nodes whose x and y coordinates each satisfy the 
relationship, ğ‘¥ =  ğ‘¦ Â± 1. In case of a tie, the node with the maximum ID is selected. 
VCap proceeds in a four-phase process. In the first phase, each node is assigned a w coordinate that 
denotes the hop distance from W by the following method. Once the network is deployed, W assigns its w 
coordinate to 0 and generates a W_SET message containing a hop counter that is initially set to 1 and 
advanced in increments by the forwarding nodes. The other node broadcasts the W_SET message and 
assigns its w coordinate to the hop counter contained in the W_SET message received. If a node receives 
more than one W_SET message, the node assigns the w coordinate to the smallest hop counter and 
broadcasts the message containing the smallest hop counter. The second phase initiates after the w 
coordinates have been assigned to all nodes. Each node first broadcasts the ID and the w coordinate of the 
node with the maximum w coordinate in the 1-hop neighborhood, or, in case of a tie, the node with the 
maximum ID, which is obtained in the first phase. Subsequently, each node with the maximum w coordinate 
in the 2-hop neighborhood, or, in case of a tie, the node with the maximum ID, assigns its x coordinate to 0 
and generates an X_SET message containing its ID, its w coordinate, and a hop counter that is initially set to 
1 and advanced in increments by the forwarding nodes. The node broadcasts the X_SET message and 
assigns its x coordinate to the hop counter contained in the X_SET message received that was generated by 
the node with the maximum w coordinate, or, in case of a tie, the node with the maximum ID. If a node 
receives more than one X_SET message generated by a node, the node assigns the x coordinate to the 
smallest hop counter and broadcasts the message containing the smallest hop counter. The y and z 
coordinates are assigned in a manner analogous to that for the x coordinate in the third and fourth phases, 
which initiates after all nodes have been assigned the x and y coordinates, respectively.  
In VCap routing, each node forwards the packet to a neighbor with closer and the minimal distance 
from the destination. The distance between two nodes with the virtual coordinates (x1, y1, z1)  and 
(x2, y2, z2) is defined as a âˆš(x2 âˆ’ x1)2 + (y2 âˆ’ y1)2 + (z2 âˆ’ z1)2. When the packet is routed to a node in 
the zone of the destination, the packet is forwarded to the destination using proactive routing, in which a 
zone denotes a set of nodes with the same virtual coordinate. Because many zones are disconnected, 
proactive routing cannot always route a packet to the destination even if the packet reaches the zone of the 
destination. In addition, the state in which each node has at least one neighbor with a closer distance from 
the destination of any packet is difficult to achieve; therefore, VCap routing may convey the packet to a 
dead-end node. Consequently, packet delivery is not guaranteed. 
å››ã€ç ”ç©¶æ–¹æ³• 
In this project, we first develop an approach, ABVCap maintenance, to reconstruct an ABVCap virtual 
coordinate system, and then develop an algorithm, VirtualFace, to route a packet from a dead-end node to a 
progress node by traversing the boundaries of the virtual faces from face to face. The approaches of 
ABVCap maintenance and VirtualFace are described in subsections A and B, respectively. In subsection C, 
we analyze the message overhead encountered using proposed protocols, the route stretch of ABVCap 
5 
 
the shortest path to the longitude head that has the smallest longitude distance from ğ¿ğ»(ğ‘˜) among all 
longitude heads generating the Equator_REP messages and having a smaller longitude coordinate than 
ğ¿ğ»(ğ‘˜). In addition, if new anchor X is not in the 1-hop neighborhood of ğ¿ğ»(1), the shortest path is 
established between new anchor X and ğ¿ğ»(1). 
Once the shortest path between ğ¿ğ»(ğ‘—) and ğ¿ğ»(ğ‘˜) is established, nodes on the path create virtual 
nodes that are assigned the longitude coordinates in an increasing order, as implemented in the following. 
The Equator_RESET message generated by ğ¿ğ»(ğ‘˜) contains the ratio of the longitude distance between 
LH(j) and ğ¿ğ»(ğ‘˜) to the hop distance between ğ¿ğ»(ğ‘—) and ğ¿ğ»(ğ‘˜) (the longitude distance per hop). Each 
node that receives the Equator_RESET message creates a new virtual node with the latitude coordinate equal 
to 0 and the longitude coordinate equal to the longitude coordinate of ğ¿ğ»(ğ‘—) plus the multiplication of the 
longitude distance per hop and the hop distance from ğ¿ğ»(ğ‘—). The ripple, up, and down coordinates of the 
new virtual nodes are initially set to âˆ. Note that if the longitude distance per hop is larger than 1, a 
longitude head is not assigned to every longitude region. In this case, the longitude distance per hop 
contained in the Equator_RESET message is set to 1, and ğ¿ğ»(ğ‘˜) creates i virtual nodes to be longitude 
heads ğ¿ğ»(ğ‘˜ âˆ’ ğ‘–), â€¦ , ğ¿ğ»(ğ‘˜ âˆ’ 1), where i denotes the longitude distance between ğ¿ğ»(ğ‘—) and ğ¿ğ»(ğ‘˜) minus 
the hop distance between ğ¿ğ»(ğ‘—) and ğ¿ğ»(ğ‘˜). 
After the reconstruction of the equator, the longitude coordinate of a virtual node on the equator could 
be a non-integer. In this project, the virtual node with the longitude coordinate equal to i is said to be in 
longitude region âŒŠğ‘–âŒ‹. A virtual node on the equator is the longitude head ğ¿ğ»(ğ‘–) and the cell head ğ¶ğ»(ğ‘–, 0), 
if it has the smallest longitude coordinate among all virtual nodes on the equator in longitude region i. A 
virtual node resets the ripple coordinate to 0 if it is a longitude head.  
Furthermore, if ğ¿ğ»(ğ‘–) fails, a new ğ¿ğ»(ğ‘–) is first generated in the reconstruction of the equator. 
Subsequently, each of the i-th meridians from ğ¿ğ»(ğ‘–) to anchor Z and the i-th meridian from ğ¿ğ»(ğ‘–) to 
anchor Zâ€™ are reconstructed in a manner analogous to that for the reconstruction of the equator from anchor 
X to anchor Y. Each virtual node with the latitude coordinate equal to j on the i-th meridian is the cell head 
ğ¶ğ»(ğ‘–, ğ‘—), where j could be a non-integer. The ripple coordinate of each cell head is set to 0, and the up and 
down coordinates are initially set to âˆ. 
 
A.3 Update of Ripple, Up, and Down Coordinates  
If a virtual node that is not a cell head has no neighbor with a smaller ripple coordinate in the same cell 
region, it updates the ripple coordinate to âˆ. Once a virtual node updates the ripple coordinate, it 
broadcasts a RP_CHANGE message containing its longitude, latitude, and updated ripple coordinates. A 
virtual node that is not a cell head checks if it has a neighbor with a smaller ripple coordinate in the same 
cell region as it detects the failure of any neighbor or receives a RP_CHANGE message. For each period of 
time, the virtual node with the ripple coordinate equal to âˆ resets the ripple coordinate to one plus the 
smallest ripple coordinate of the neighbors, if exists, having the ripple coordinates not equal to âˆ in the 
same cell region. In addition, if a virtual node has the ripple coordinate equal to âˆ for t periods of time 
because the cell region of the virtual node is not connected, it resets the longitude and latitude coordinates to 
join another cell region. If a virtual node joins another cell region, it broadcasts a CELL_CHANGE message 
containing its updated and original longitude, updated and original latitude, and updated ripple coordinates. 
7 
 
B.1.1 Generation of a Triangle-Free Subnetwork 
There are two steps in this phase. The connected dominating set is first generated by the pruning 
algorithm. Subsequently, the triangle-free subnetwork is constructed by removing each edge between two 
nodes with the largest two IDs in a triangle in the subnetwork induced by the connected dominating set. 
 
B.1.2 Evaluation of Hop Distances 
Let S be the pre-programmed node or the node with the largest ID dominating the pre-programmed 
node. Each node, u, evaluates ğ‘¢. â„ğ‘(ğ‘†), as implemented in the following. Firstly, S broadcasts an S_SET 
message containing a hop counter initially set to 1. Once a node, u, receives an S_SET message, u sets 
ğ‘¢. â„ğ‘(ğ‘†) to the hop counter contained in the message and broadcasts the message containing the hop 
counter increased by 1. If u receives more than one S_SET message, u broadcasts the S_SET message 
containing the smallest hop counter and sets ğ‘¢. â„ğ‘(ğ‘†) according to the message. 
 
B.1.3 Computation of Shortest Down-Up Cycle Lengths 
A tail node, u, evaluates the lengths of shortest down-up cycle, as implemented in the following. Each 
neighbor, v, of u with ğ‘£. â„ğ‘(ğ‘†)  =  ğ‘¢. hğ‘(ğ‘†) âˆ’ 1 generates a DUCYCLE_SET message containing the ID 
of v, a hop counter initially set to 1, and a state status initially set to down; subsequently, the message is 
forwarded to all neighbors y with ğ‘¦. â„ğ‘(ğ‘†)  â‰¤  ğ‘£. â„ğ‘(ğ‘†). Once a node, x, receives a DUCYCLE_SET 
message generated by v, x sets ğ‘¥. â„ğ‘(ğ‘£) to the hop counter contained in the message, and forwards the 
message containing the ID of v, the hop counter increased by 1, and a state status equal to up to all neighbors 
y with ğ‘¦. â„ğ‘(ğ‘†) â‰¥ ğ‘¥. â„ğ‘(ğ‘†). In addition, if the state status contained in the received DUCYCLE_SET 
message equals down, x also forwards the message containing the ID of v, the hop counter increased by 1, 
and a state status equal to down to all neighbors y with ğ‘¦. â„ğ‘(ğ‘†) â‰¤ ğ‘¥. â„ğ‘(ğ‘†). If x receives more than one 
DUCYCLE_SET message generated by v, x forwards the DUCYCLE_SET message containing the smallest 
hop counter, and sets ğ‘¥. â„ğ‘(ğ‘£) according to the message. After u receives the DUCYCLE_SET message 
generated by v from w with ğ‘¤. â„ğ‘(ğ‘†) â‰¤ ğ‘¢. â„ğ‘(ğ‘†), the length of the shortest down-up cycle containing u, v, 
and w is evaluated as 2 + ğ‘¤. â„ğ‘(ğ‘£). 
 
B.1.4 Construction of Virtual Faces 
A tail node, u, constructs a virtual face, ğ‘£ğ‘“, with a boundary containing u, v, and w, where v and w are 
two neighbors of u, with ğ‘£. â„ğ‘(ğ‘†)  =  ğ‘¢. â„ğ‘(ğ‘†) âˆ’ 1 and ğ‘¤. â„ğ‘(ğ‘†) â‰¤ ğ‘¢. â„ğ‘(ğ‘†), as implemented in the 
following. u sets ğ‘£ğ‘“. ğ‘ ğ‘–ğ‘§ğ‘’ as its sequence number in ğ‘£ğ‘“ (ğ‘¢. ğ‘ ğ‘’ğ‘(ğ‘£ğ‘“)), generates a FACE_SET message 
containing the ID of v, the ID of ğ‘£ğ‘“ (ğ‘£ğ‘“. ğ‘–ğ‘‘) which is a random number chosen in a large enough interval to 
break a tie, and the size of ğ‘£ğ‘“ (ğ‘£ğ‘“. ğ‘ ğ‘–ğ‘§ğ‘’) equal to 2 + ğ‘¤. â„ğ‘(ğ‘£), and forwards the message to w. If a node, 
x, receives a FACE_SET message, x stores ğ‘£ğ‘“. ğ‘ ğ‘–ğ‘§ğ‘’ and ğ‘£ğ‘“. ğ‘–ğ‘‘, sets ğ‘¥. ğ‘ ğ‘’ğ‘(ğ‘£ğ‘“) to ğ‘¥. â„ğ‘(ğ‘£) + 1, and 
forwards the message by backtracking the shortest down-up cycle containing u, v, and w. If a node, x, is not 
contained in the boundary of a virtual face, a virtual face with a boundary containing x is constructed. 
 
B.2 Virtual Face Naming Protocol (VFNP) 
9 
 
VFNP is implemented as follows. Let u be a node in the boundary of virtual face ğ‘£ğ‘“. If ğ‘¢ğ‘£ğ‘“ has a 
smaller ID than any ğ‘¢-neighbor in ğºğ‘£ğ‘“, u assigns ğ‘£ğ‘“ğ‘ . ğ‘–ğ‘‘, ğ‘£ğ‘“. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™, and ğ‘£ğ‘“. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ to ğ‘£ğ‘“. ğ‘–ğ‘‘, 0, and 
[0, 2Ï€), respectively, and then generates and broadcasts to neighbors a NAME_SET message containing 
ğ‘£ğ‘“ğ‘. ğ‘–ğ‘‘, ğ‘£ğ‘“. ğ‘ ğ‘–ğ‘§ğ‘’, ğ‘£ğ‘“. ğ‘–ğ‘‘, ğ‘£ğ‘“. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™, ğ‘£ğ‘“. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ, ğ‘¢. ğ‘ ğ‘’ğ‘(ğ‘£ğ‘“), and the IDs of u-neighbors of ğ‘¢ğ‘£ğ‘“. If u 
receives a NAME_SET message containing ğ‘£ğ‘“. ğ‘–ğ‘‘ and ğ‘£ğ‘“. ğ‘ ğ‘–ğ‘§ğ‘’, u broadcasts the message to the neighbors 
in the boundary of ğ‘£ğ‘“, and assigns ğ‘£ğ‘“ğ‘. ğ‘–ğ‘‘, ğ‘£ğ‘“. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™, and ğ‘£ğ‘“. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ to ğ‘£ğ‘“ğ‘ . ğ‘–ğ‘‘, ğ‘£ğ‘“. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™, and 
ğ‘£ğ‘“. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ contained in the message, respectively. If u receives from a node, v, a NAME_SET message 
containing ğ‘£ğ‘“1. ğ‘–ğ‘‘ and ğ‘£ğ‘“1. ğ‘ ğ‘–ğ‘§ğ‘’ (ğ‘£ğ‘“1 â‰  ğ‘£ğ‘“), u broadcasts the message to the neighbors in the boundary of 
ğ‘£ğ‘“ , assigns ğ‘£ğ‘“ğ‘ . ğ‘–ğ‘‘  to ğ‘£ğ‘“ğ‘ . ğ‘–ğ‘‘  contained in the message, assigns ğ‘£ğ‘“. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™  to ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ + 1 , and 
assigns ğ‘£ğ‘“. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ  to [a + (i âˆ’ 1)(b âˆ’ a)/c + (j âˆ’ 1)(b âˆ’ a)/(c âˆ™ n), a + (i âˆ’ 1)(b âˆ’ a)/c + j âˆ™ (b âˆ’
a)/(c âˆ™ n)), in which interval [a, b) is the angular coordinate of ğ‘£ğ‘“1 , i equals ğ‘¢. ğ‘ ğ‘’ğ‘(ğ‘£ğ‘“1), c equals 
ğ‘£ğ‘“1. ğ‘ ğ‘–ğ‘§ğ‘’, n is the number of v-neighbors of ğ‘¢ğ‘£ğ‘“1 in ğºğ‘£ğ‘“, and j is the number of v-neighbors of ğ‘¢ğ‘£ğ‘“1 with a 
smaller or an equal ID than ğ‘¢ğ‘£ğ‘“ in ğºğ‘£ğ‘“. In addition, if at least one u-neighbor of ğ‘¢ğ‘£ğ‘“ exists, u also 
generates and broadcasts to neighbors a NAME_SET message containing ğ‘£ğ‘“ğ‘. ğ‘–ğ‘‘ , ğ‘£ğ‘“. ğ‘ ğ‘–ğ‘§ğ‘’ , ğ‘£ğ‘“. ğ‘–ğ‘‘ , 
ğ‘£ğ‘“. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™, ğ‘£ğ‘“. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ, ğ‘¢. ğ‘ ğ‘’ğ‘(ğ‘£ğ‘“), and the IDs of u-neighbors of ğ‘¢ğ‘£ğ‘“ after u receives a NAME SET 
message. If u receives more than one NAME_SET message, u assigns (ğ‘£ğ‘“. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™, ğ‘£ğ‘“. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ) to the 
smallest pair of numbers (ğ‘£ğ‘“. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™, ğ‘£ğ‘“. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ) according to the message containing the smallest 
ğ‘£ğ‘“ğ‘. ğ‘–ğ‘‘. 
 
B.3 VirtualFace Algorithm 
We assume that the routed packet carries the name of the virtual face, ğ‘£ğ‘“ğ‘‘, with a boundary containing 
the destination or the dominating node of the destination. Once a message encounters a dead-end node, the 
VirtualFace algorithm routes the message toward ğ‘£ğ‘“ğ‘‘ until a progress node is reached. The following 
notations are necessary for the description of the VirtualFace algorithm. 
 
Definition 9. Let [ğ‘, ğ‘) and [ğ‘, ğ‘‘) be the angular coordinates of virtual faces ğ‘£ğ‘“1 and ğ‘£ğ‘“2, respectively. 
The angular distance from ğ‘£ğ‘“1 to ğ‘£ğ‘“2 denoted by ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘ğ‘›ğ‘”(ğ‘£ğ‘“1, ğ‘£ğ‘“2), equals ğ‘ âˆ’ ğ‘ + 1 if [ğ‘, ğ‘)  <  [ğ‘, ğ‘‘), 
equals ğ‘ âˆ’ ğ‘‘ + 1 if [ğ‘, ğ‘‘) < [ğ‘, ğ‘), and equals 0 otherwise. The radial distance from ğ‘£ğ‘“1 to ğ‘£ğ‘“2, denoted 
by ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘Ÿğ‘ğ‘‘(ğ‘£ğ‘“1, ğ‘£ğ‘“2), equals |ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ âˆ’ ğ‘£ğ‘“2. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™| if ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘ğ‘›ğ‘”(ğ‘£ğ‘“1, ğ‘£ğ‘“2) = 0, and equals ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ 
otherwise. 
 
Definition 10. The distance between virtual faces ğ‘£ğ‘“1 and ğ‘£ğ‘“2, denoted by ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘£ğ‘“1, ğ‘£ğ‘“2), is a pair of 
numbers (ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘ğ‘›ğ‘”(ğ‘£ğ‘“1, ğ‘£ğ‘“2), ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘Ÿğ‘ğ‘‘(ğ‘£ğ‘“1, ğ‘£ğ‘“2)). ğ‘£ğ‘“1 is said to be closer to virtual face ğ‘£ğ‘“3 than ğ‘£ğ‘“2 if 
ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘£ğ‘“1, ğ‘£ğ‘“3) < ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘£ğ‘“2, ğ‘£ğ‘“3). 
 
If a packet with the destination, d, encounters a dead-end node, the VirtualFace algorithm routes the 
packet to a progress node, as described in the following. If the forwarding node, u, is not in ğºğ·, u forwards 
the packet to the dominating node of u. Otherwise, if one neighbor, v, of u in ğº is a progress node, the 
packet is forwarded to v. Otherwise, if u is contained in the boundary of ğ‘£ğ‘“ğ‘ğ‘™ğ‘œğ‘ ğ‘’ğ‘ ğ‘¡, the packet is forwarded to 
the successive node of u in the boundary of ğ‘£ğ‘“ğ‘ğ‘™ğ‘œğ‘ ğ‘’ğ‘ ğ‘¡, where ğ‘£ğ‘“ğ‘ğ‘™ğ‘œğ‘ ğ‘’ğ‘ ğ‘¡ denotes the virtual face closest to 
11 
 
C.1.2 Expected Routing Path Length 
Theorem 1 shows the route stretch of ABVCap routing in a boundless 2D space in a continuous domain, 
where nodes are assumed to be infinitely dense in a boundless 2D space.  
 
 
Fig. 1 Locations of the source s, the intermediate node i, and the destination d. 
 
Theorem 1: Given the source s and the destination d, the expected ratio of the ABVCap routing path length 
to the shortest path length is 4
Ï€
 in a boundless 2D space in a continuous domain. 
Proof: Assume that s and d are located on (0, 0) and (ğ‘Ÿcosğœƒ, ğ‘Ÿsinğœƒ), respectively. Using ABVCap 
routing, the packet is first routed to an intermediate node i, located on (ğ‘Ÿcosğœƒ, 0), in longitude routing, and 
then routed to d in latitude routing, as shown in Fig. 1. Since the probability density function of ğœƒ is 1
2ğœ‹
, the 
expected ratio of the ABVCap routing path length to the shortest path length equals 
âˆ« (|ğ‘Ÿ cos ğœƒ|+|ğ‘Ÿ sin ğœƒ|
ğ‘Ÿ
)( 1
2ğœ‹
)ğ‘‘ğœƒ = 4
ğœ‹
2ğœ‹
0
.  
 
C.2 Analysis of the VirtualFace Algorithm 
We show the VirtualFace algorithm can always route a packet from a dead-end node to a progress node. 
 
Lemma 1: For any virtual face ğ‘£ğ‘“1 â‰  ğ‘£ğ‘“ğ‘ , there exists a virtual face, ğ‘£ğ‘“2 , such that ğ‘£ğ‘“2. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ =
ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ âˆ’ 1 and ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ âŠ† ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ. 
Proof: Assume that ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ and ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ are assigned when a node, u, contained in the 
boundary of ğ‘£ğ‘“1 receives a NAME_SET message from a node, v, contained in the boundary of ğ‘£ğ‘“2. By 
VFNP, ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ equals ğ‘£ğ‘“2. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ + 1, and ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ equals the j-th smallest equal sub-interval 
of the i-th smallest equal sub-interval of ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ if the sequence number of v in ğ‘£ğ‘“2 is i and the 
number of v-neighbors of ğ‘¢ğ‘£ğ‘“2 with a smaller or an equal ID than ğ‘¢ğ‘£ğ‘“1 in ğºğ‘£ğ‘“ is j. 
 
Lemma 2: Let ğ‘£ğ‘“
1
 and ğ‘£ğ‘“2  be two virtual faces. If ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ = ğ‘£ğ‘“2. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ , then ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ <
ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ or ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ < ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ. 
Proof: It suffices to show the statement S, there exists no virtual faces, ğ‘£ğ‘“1 and ğ‘£ğ‘“2, with radial 
coordinate k such that neither of ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ < ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ  and ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ < ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ  is 
satisfied, holds for all ğ‘˜ â‰¥ 0. S holds for ğ‘˜ = 0 because there is only one virtual face with radial 
coordinate 0; therefore, a basis for the proof exists. We prove S holds for ğ‘˜ â‰¥ 1 by induction on k. As an 
induction assumption, we take S holds for ğ‘˜ â‰¤ ğ‘š âˆ’ 1. If ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ = ğ‘£ğ‘“2. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ = ğ‘š, according to 
13 
 
ğ‘£ğ‘“5. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ , and there exists virtual faces, ğ‘£ğ‘“4  and ğ‘£ğ‘“6 , such that ğ‘£ğ‘“4. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ = ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ + 1 , 
ğ‘£ğ‘“6. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ = ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ , and ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ âŠ† ğ‘£ğ‘“4. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ âŠ† ğ‘£ğ‘“6. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ . It suffices to show 
ğ‘£ğ‘“1 = ğ‘£ğ‘“5 = ğ‘£ğ‘“6  to complete the proof. Assume that ğ‘£ğ‘“1 â‰  ğ‘£ğ‘“5 . Because ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ = ğ‘£ğ‘“5. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ , 
ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ < ğ‘£ğ‘“5. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ or ğ‘£ğ‘“5. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ < ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ according to Lemma 2, resulting in the 
impossibility that ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ âŠ† ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ  and ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ âŠ† ğ‘£ğ‘“5. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ . In addition, 
ğ‘£ğ‘“1 = ğ‘£ğ‘“6 can be proved in a manner analogous for that of ğ‘£ğ‘“1 = ğ‘£ğ‘“5. 
 
Theorem 3: If G is connected, then for any virtual face ğ‘£ğ‘“1 â‰  ğ‘£ğ‘“ğ‘‘ , there exists a neighboring virtual face, 
ğ‘£ğ‘“2, such that ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘£ğ‘“2, ğ‘£ğ‘“ğ‘‘) < ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘£ğ‘“1, ğ‘£ğ‘“ğ‘‘). 
Proof: According to Theorem 2, we have to discuss five cases: c1) ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ < ğ‘£ğ‘“ğ‘‘ . ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ; c2) 
ğ‘£ğ‘“ğ‘‘ . ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ < ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ; c3) ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ âŠ‚ ğ‘£ğ‘“ğ‘‘ . ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ; c4) ğ‘£ğ‘“ğ‘‘ . ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ âŠ‚ ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ; c5) 
ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ = ğ‘£ğ‘“ğ‘‘ . ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ. We adhere to the proofs of c1 and c3 and omit the proofs of the other cases 
due to the similarities. For c1, because ğ‘£ğ‘“1 = ğ‘£ğ‘“ğ‘ is impossible to hold, there exists a virtual face, ğ‘£ğ‘“2, 
such that ğ‘£ğ‘“2. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ = ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ âˆ’ 1, and c1.1) ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ âŠ‚ ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ or c1.2) ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ =
ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ  according to Lemma 1. For c1.1, neither of ğ‘£ğ‘“ğ‘‘ . ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ < ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ  and 
ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ âŠ† ğ‘£ğ‘“ğ‘‘ . ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ holds because ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ < ğ‘£ğ‘“ğ‘‘ . ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ. Therefore, two cases need to 
be discussed: c1.1.1) ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ < ğ‘£ğ‘“ğ‘‘ . ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ; c1.1.2) ğ‘£ğ‘“ğ‘‘ . ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ âŠ‚ ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ. For c1.1.1, 
according to Definition 9, 0 < ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘ğ‘›ğ‘”(ğ‘£ğ‘“2, ğ‘£ğ‘“ğ‘‘) â‰¤ ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘ğ‘›ğ‘”(ğ‘£ğ‘“1, ğ‘£ğ‘“ğ‘‘) , and ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘Ÿğ‘ğ‘‘(ğ‘£ğ‘“2, ğ‘£ğ‘“ğ‘‘) <
 ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘Ÿğ‘ğ‘‘(ğ‘£ğ‘“1, ğ‘£ğ‘“ğ‘‘) because ğ‘£ğ‘“2. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ < ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ . This implies ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘£ğ‘“2, ğ‘£ğ‘“ğ‘‘) < ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘£ğ‘“1, ğ‘£ğ‘“ğ‘‘) 
according to Definition 10. For c1.1.2, ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘ğ‘›ğ‘”(ğ‘£ğ‘“2, ğ‘£ğ‘“ğ‘‘) = 0 < ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘ğ‘›ğ‘”(ğ‘£ğ‘“1, ğ‘£ğ‘“ğ‘‘) , implying 
ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘£ğ‘“2, ğ‘£ğ‘“ğ‘‘) < ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘£ğ‘“1, ğ‘£ğ‘“ğ‘‘). c1.2 can be proved in a manner analogous for that of c1.1.1, completing 
the proof of c1. For c3, ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ > ğ‘£ğ‘“ğ‘‘ . ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ according to Lemma 3. Therefore, there exists a virtual 
face, ğ‘£ğ‘“2 , such that ğ‘£ğ‘“2. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ = ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ âˆ’ 1  and ğ‘£ğ‘“1. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ âŠ† ğ‘£ğ‘“2. ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ âŠ† ğ‘£ğ‘“ğ‘‘ . ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ 
according to Lemma 4. Clearly, ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘ğ‘›ğ‘”(ğ‘£ğ‘“2, ğ‘£ğ‘“ğ‘‘) = 0 = ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘ğ‘›ğ‘”(ğ‘£ğ‘“1, ğ‘£ğ‘“ğ‘‘). In addition, ğ‘£ğ‘“1. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ >
ğ‘£ğ‘“2. ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™ â‰¥ ğ‘£ğ‘“ğ‘‘ . ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘ğ‘™. Therefore, ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘Ÿğ‘ğ‘‘(ğ‘£ğ‘“2, ğ‘£ğ‘“ğ‘‘) <  ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘Ÿğ‘ğ‘‘(ğ‘£ğ‘“1, ğ‘£ğ‘“ğ‘‘), and thus ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘£ğ‘“2, ğ‘£ğ‘“ğ‘‘) <
ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘£ğ‘“1, ğ‘£ğ‘“ğ‘‘), completing the proof of c3. 
 
Theorem 4: If G is connected, the VirtualFace algorithm can always route a packet to a progress node. 
Proof: Let u be a forwarding node in the boundary of a virtual face, ğ‘£ğ‘“. Using the VirtualFace algorithm, 
u forwards a packet to the successive node in the boundary of ğ‘£ğ‘“, if no neighbor is in the boundary of a 
virtual face closer to ğ‘£ğ‘“ğ‘‘; otherwise, u forwards a packet to a neighbor in the boundary of the virtual face 
closest to ğ‘£ğ‘“ğ‘‘. It implies the packet traverses the boundaries of virtual faces in a decreasing order of the 
distance to ğ‘£ğ‘“ğ‘‘. Because any virtual face except for ğ‘£ğ‘“ğ‘‘ has a neighboring virtual face closer to ğ‘£ğ‘“ğ‘‘ 
according to Theorem 3, the packet can be always routed to ğ‘£ğ‘“ğ‘‘, and thus to the destination if no progress 
node is encountered during the routing process. Because the destination is a progress node, the proof is 
completed. 
 
D. Performance Evaluation 
We evaluate, by simulation, our proposed protocols ABVCap maintenance and the VirtualFace algorithm in 
subsections D.1 and D.2, respectively.  
15 
 
 
Fig. 2 Packet delivery rate of GLIDER, Hop ID, GLDR, VCap, and ABVCap routing on the packet level simulator. The side 
length of the square region is 50 in (a) and (b), and 10 in (c); the number of voids in the square region is 0 in (a) and (c), and 10 in 
(b). 
 
Fig. 3 Routing path length of GLIDER, Hop ID, GLDR, VCap, and ABVCap routing on the packet level simulator. The side 
length of the square region is 50 in (a) and (b), and 10 in (c); the number of voids in the square region is 0 in (a) and (c), and 10 in 
(b). 
 
D.1.1.2 Routing Path Length 
Fig. 3 demonstrates that ABVCap routing has a longer routing path than GLIDER, Hop ID, GLDR, and 
VCap routing. Two reasons exist to explain this observation: 1) ABVCap routing routes the packet similarly 
to using the L1 norm while GLIDER, Hop ID, GLDR, and VCap routing route the packet similarly to using 
the L2 norm, and 2) ABVCap routing has a longer average distance of source-destination pairs because 
many source-destination pairs separated by long distances are unreachable in GLIDER, Hop ID, GLDR, and 
VCap routing. In addition, the higher the network density, the shorter the routing path because the progress 
distance is larger. For a source-destination pair, the more voids exist, the longer the routing path will be 
because the longer path is set to bypass voids. In a small-scale network, the short routing path results from 
the small average distance of source-destination pairs. 
 
D.1.1.3 Number of Next Hop Neighbors 
Fig. 4(a) illustrates that a node has few next hop neighbors in Hop ID or VCap routing because it can 
only forward a packet to the neighbor having the smallest distance from the destination. In Hop ID routing, 
most nodes have only one next hop neighbor because a node is addressed by the hop distances from 30 
landmarks. In VCap, many nodes share a virtual coordinate because a node is addressed by the hop distances 
from 3 anchors. Thus, in VCap routing, a node has more next hop neighbors compared to Hop ID routing. In 
GLIDER or GLDR routing, a node has many next hop neighbors because it can forward a packet to any 
17 
 
D.1.2 Simulation Results on a Network Simulator 
In ns-2, the MAC layer protocol is IEEE 802.11, and the signal propagation model is the two-ray 
ground reflection model. In the simulation, 100 connected networks were generated in square regions with 
side lengths equal to 10. We investigated the average packet delivery rate and the average routing path 
length of GLIDER, Hop ID, GLDR, VCap, and ABVCap routing in networks without node failures. We also 
studied the average packet delivery rate and the average routing path length of ABVCap routing in networks 
with node failure percentages of 5% or 10%. Empirical data were obtained by averaging data of 500 
source-destination pairs from 100 networks. In addition, we studied the average number of messages 
broadcast by a node in constructing or reconstructing the virtual coordinate system using GLIDER, Hop ID, 
GLDR, VCap, ABVCap, and ABVCap maintenance.  
 
D.1.2.1 Packet Delivery Rate 
Compared to Fig. 2(c), GLIDER, Hop ID, GLDR, VCap, and ABVCap routing in Fig. 5(a) have the 
approximately equal packet delivery rates. This implies that each protocol must achieve coordinate 
assignment robustness, in practice. In ABVCap routing, the higher the node failure percentage, the lower the 
packet delivery rate, a result considered to be reasonable. 
 
D.1.2.2 Routing Path Length 
As shown in Fig. 5(b), in ABVCap routing, the higher the node failure percentage, the longer the 
routing path because the network density is reduced. Compared to Fig. 3(c), GLIDER, Hop ID, GLDR, 
VCap, and ABVCap routing in Fig. 5(b) have the approximately equal routing path lengths.  
 
D.1.2.3 Number of Broadcasts 
As shown in Fig. 5(c), the higher the network density, fewer messages are broadcast by a node in VCap 
and ABVCap because fewer X_SET, Y_SET, and Z_SET messages are generated due to the higher 
probability of being the 2-hop neighbors of two nodes. In Hop ID and GLDR, the number of broadcasts is 
slightly greater than the number of landmarks because each node needs to obtain the minimum hop distances 
from all landmarks, where Hop ID selects less than 30 landmarks due to packet loss. As the network density 
increases, the number of landmarks changes slightly, resulting in a negligible difference in the number of 
broadcasts in Hop ID and GLDR. Each node in GLIDER is required to obtain the minimum hop distances 
from all neighboring landmarks. The higher the network density, the greater the broadcasts because of the 
greater neighboring landmarks. In ABVCap maintenance, as expected, the higher the node failure 
percentage, the greater the broadcasts. 
 
19 
 
number of broadcasts per node, and the packet delivery rate in networks with node failures, in which the 
load imbalance factor denoted the ratio of the maximum number of packets routed by a node (the maximum 
load) to the average number of packets routed by a node (the average load). The existence of a node routing 
many packets was indicated by a large load imbalance factor. In GLIDER and GLIDER+VF, 23 landmarks 
were randomly selected. In Hop ID and Hop ID+VF, the peripheral landmark selection of 30 landmarks was 
implemented. In GLDR and GLDR+VF, 10-sampling was used to select landmarks. The flooding 
mechanism in GLIDER, Hop ID, and GLDR was not implemented because it required a great deal of route 
overhead and suffered from the broadcasting storm problem [36]. Empirical data were obtained by 
averaging data of 1000 source-destination pairs from 100 networks. 
 
D.2.1 Packet Delivery Rate 
Fig. 6(a) illustrates the simulation results for the packet delivery rate. GLIDER+VF, Hop ID+VF, 
GLDR+VF, VCap+VF and ABVCap each successfully set a path for every sourcedestination pair. In 
GLIDER, Hop ID, GLDR, and VCap, the greater the network density, the higher the packet delivery rate 
because more dead-end nodes exist in a network with lower density due to the occurrence of more holes. 
GLIDER and VCap each have a lower packet delivery rate than Hop ID and GLDR, which results from the 
introduction of more dead-end nodes because large cells exist in GLIDER and multiple nodes share a virtual 
coordinate in VCap.  
 
D.2.2 Routing Path Length 
Fig. 6(b) illustrates the simulation results for the routing path length. GLIDER+VF, Hop ID+VF, 
GLDR+VF, and VCap+VF have longer routing paths than GLIDER, Hop ID, GLDR, and VCap, 
respectively, because many sourcedestination pairs separated by long distances are unreachable in GLIDER, 
Hop ID, GLDR, and VCap. The differences between Hop ID and Hop ID+VF and between GLDR and 
GLDR+VF are negligible because Hop ID or GLDR has a high packet delivery rate. Hop ID+VF, 
GLDR+VF, and VCap+VF each have a shorter routing path in most cases, as compared to ABVCap. By 
contrast, GLIDER+VF has a longer routing path than ABVCap. This observation results from the fact that 
GLIDER has a long routing path and a low packet delivery rate. Additionally, the greater is the network 
density the shorter is the routing path because the progress distance is larger.  
 
D.2.3 Number of Next Hop Neighbors 
Fig. 6(c) illustrates the simulation results for the number of next hop neighbors. In Hop ID and VCap, a 
node only forwards a packet to the neighbor closest to the destination; therefore, Hop ID and VCap have 
smaller numbers of next hop neighbors than GLIDER, GLDR, and ABVCap. In Hop ID, most forwarding 
nodes have only one next hop neighbor because a node is addressed by the hop distances to 30 landmarks. 
Compared to Hop ID, a forwarding node in VCap has more next hop neighbors because more neighbors, 
which are addressed by the hop distances to 3 landmarks, share a virtual coordinate. In GLIDER, GLDR, 
VCap, and ABVCap, the greater the network density, the larger will be the number of next hop neighbors. In 
addition, because Hop ID and GLDR each have a high packet delivery rate, the differences between Hop ID 
and Hop ID+VF and between GLDR and GLDR+VF are minor. GLIDER+VF and VCap+VF have smaller 
21 
 
 
Fig. 6 Performance simulation results: (a) packet delivery rate; (b) routing path length; (c) number of next hop neighbors; (d) load 
imbalance factor; (e) number of broadcasts; (f) packet delivery rate in networks with node failure equal to 10%. 
 
äº”ã€çµæœèˆ‡è¨è«– 
In this report, we describe a protocol, ABVCap maintenance, to reconstruct an ABVCap virtual 
coordinate system so that ABVCap routing guarantees packet delivery in a network with node failures. We 
also describe the protocols, VFCP and VFNP, to construct virtual faces with boundaries closely surrounding 
23 
 
åƒè€ƒæ–‡ç» 
REFERENCES 
[1] T. Park and K. G. Shin, â€œSoft tamper-proofing via program integrity verification in wireless sensor 
networks,â€ IEEE Transactions on Mobile Computing, vol. 4, pp. 297âˆ’309, 2005. 
[2] H. Sabbineni and K. Chakrabarty, â€œLocation-aided flooding: an energy efficient data dissemination 
protocol for wireless sensor networks,â€ IEEE Transactions on Computers, vol. 54, pp. 36âˆ’46, 2005. 
[3] Y. Zou and K. Chakrabarty, â€œA distributed coverage- and connectivity-centric technique for selecting 
active nodes in wireless sensor networks,â€ IEEE Transactions on Computers, vol. 54, pp. 978âˆ’991, 
2005. 
[4] J. Li, J. Jannotti, D. DeCouto, D. Karger, and R. Morris, â€œA scalable location service for geographic 
ad-hoc routing,â€ in IEEE/ACM MOBICOM, 2000, pp. 120âˆ’130. 
[5] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker, â€œGHT: a geographic hash 
table for data-centric storage,â€ in ACM WSNA, 2002, pp. 78âˆ’87. 
[6] B. Karp and H. T. Kung, â€œGPSR: greedy perimeter stateless routing for wireless networks,â€ in 
IEEE/ACM MOBICOM, 2000, pp. 243âˆ’254. 
[7] P. Bose, P. Morin, I. Stojmenovic, and J. Urrutia, â€œRouting with guaranteed delivery in ad hoc wireless 
networks,â€ Wireless Networks, vol. 7, pp. 609âˆ’616, 2001. 
[8] J. Gao, L. J. Guibas, J. Hershberger, L. Zhang, and A. Zhu, â€œGeometric spanners for routing in mobile 
networks,â€ IEEE Journal on Selected Areas in Communications, vol. 23, pp. 174âˆ’185, 2005. 
[9] S. Datta, I. Stojmenovic, and J. Wu, â€œInternal node and shortcut based routing with guaranteed delivery 
in wireless networks,â€ Cluster Computing, vol. 5, pp. 169âˆ’178, 2002. 
[10] Q. Fang, J. Gao, and L. J. Guibas, â€œLocating and by passing routing holes in sensor networks,â€ in IEEE 
INFOCOM, 2004, pp. 2458âˆ’2468. 
[11] F. Kuhn, R. Wattenhofer, Y. Zhang, and A. Zollinger, â€œGeometric ad-hoc routing: of theory and 
practice,â€ in ACM PODC, 2003, pp. 63âˆ’72. 
[12] A. Rao, S. Ratnasamy, C. Papadimitriou, S. Shenker, and I. Stoica, â€œGeographic routing without 
location information,â€ in IEEE/ACM MOBICOM, 2003, pp. 96âˆ’108. 
[13] K. Seada, A. Helmy, and R. Govindan, â€œOn the effect of localization errors on geographic face routing 
in sensor networks,â€ in IEEE/ACM IPSN, 2004, pp. 71âˆ’80. 
[14] J. Hightower and G. Borriello, â€œLocation systems for ubiquitous computing,â€ Computer, vol. 34, pp. 
57âˆ’66, 2001. 
[15] Q. Fang, J. Gao, L. J. Guibas, V. D. Silva, and L. Zhang, â€œGLIDER: gradient landmark-based 
distributed routing for sensor networks,â€ in IEEE INFOCOM, 2005, pp. 339âˆ’350. 
[16] J. Bruck, J. Gao, and A. Jiang, â€œMAP: medial axis based geometric routing in sensor networks,â€ in 
IEEE/ACM MOBICOM, 2005, pp. 88âˆ’102. 
[17] A. Nguyen, N. Milosavljevic, Q. Fang, J. Gao, and L. J. Guibas, â€œLandmark selection and greedy 
landmark-descent routing for sensor networks,â€ in IEEE INFOCOM, 2007. 
[18] Y. Liu, L. M.Ni, and M. Li, â€œA geography-free routing protocol for wireless sensor networks,â€ in IEEE 
25 
 
network,â€ in ACM MOBICOM, 2002. 
[37] Y. W. Hong and A. Scaglione. â€œA scalable synchronization protocol for large scale sensor networks and 
its applications,â€ IEEE Journal on Selected Areas in Communications, vol. 23, pp. 1085â€“1099, 2005. 
[38] W. Su and I. F. Akyildiz. â€œTime-diffusion synchronization protocol for wireless sensor networks,â€ 
IEEE/ACM Transactions on Networking, vol. 13, pp. 384â€“397, 2005. 
 
â–¡ èµ´åœ‹å¤–å‡ºå·®æˆ–ç ”ç¿’ 
â–¡ èµ´å¤§é™¸åœ°å€å‡ºå·®æˆ–ç ”ç¿’ 
â–  å‡ºå¸­åœ‹éš›å­¸è¡“æœƒè­° 
â–¡ åœ‹éš›åˆä½œç ”ç©¶è¨ˆç•«å‡ºåœ‹ 
å¿ƒå¾—å ±å‘Š 
è¨ˆ ç•« å ç¨±  è¨ˆ ç•« ç·¨ è™Ÿ  
å ± å‘Š äºº 
å§“ å 
é™³ä»¥é›· 
æœ å‹™ æ©Ÿ æ§‹ 
åŠ è· ç¨± 
åœ‹ç«‹æ¸…è¯å¤§å­¸è³‡è¨Šå·¥ç¨‹ç³» 
æœƒè­°/è¨ªå•æ™‚é–“ 
 åœ°é» 
Brussels, Belgium, September 11-14, 2011 
æœƒ è­° å ç¨± IEEE International Conference on Image Processing 
ç™¼è¡¨è«–æ–‡é¡Œç›® Time-variant modeling for general surface appearance  
 
ä¸€ã€ä¸»è¦ä»»å‹™æ‘˜è¦ï¼ˆäº”åå­—ä»¥å…§ï¼‰ 
 
åƒåŠ åœ‹éš›å½±åƒè™•ç†æœƒè­°ï¼Œé™¤ç™¼è¡¨è‘—ä½œè«–æ–‡å¤–ï¼ŒåŒæ™‚å­¸ç¿’ç›®å‰å­¸è¡“é ˜åŸŸå…§é—œæ³¨çš„ä¸»
é¡Œèˆ‡æŠ€è¡“ï¼Œä¸¦å¸æ”¶èˆ‡æœƒè€…å°æœªä¾†ç™¼å±•å¤šåª’é«”æ‡‰ç”¨çš„å‰ç»çœ‹æ³•ã€‚ 
 
äºŒã€å°è¨ˆç•«ä¹‹æ•ˆç›Šï¼ˆä¸€ç™¾å­—ä»¥å…§ï¼‰ 
 
  è¿‘å¹´ä¾†é‡å°å¤šåª’é«”é ˜åŸŸç™¼å±•çš„å„ç¨®æŠ€è¡“ï¼ŒåŒ…æ‹¬é›»è…¦è¦–è¦ºã€åœ–å½¢è¾¨è­˜ç­‰å‚³çµ±æ–¹æ³•çš„
å»¶ä¼¸ï¼Œçš†æœ‰åŠ©æ–¼è¨ˆåŠƒä¸­å°æ–¼æ•¸ä½äººè‡‰å½±åƒä¹‹åˆ†æã€‚è€ŒICIPæ›´æ˜¯æ•¸ä½å½±åƒè™•ç†æŠ€è¡“ä¸Šæœ€
é‡è¦çš„ä¸€å€‹æœƒè­°ï¼Œè—‰ç”±æ­¤è¡Œçš„è§€æ‘¹èˆ‡è¨è«–ï¼Œå¯ä»¥åæ€è‡ªèº«ç ”ç©¶ï¼Œç²å¾—è¨±å¤šå•Ÿç™¼ã€‚ 
 
ä¸‰ã€ç¶“é 
 
  æ­¤æ¬¡æœƒè­°èˆ‰è¾¦æ–¼æ¯”åˆ©æ™‚é¦–éƒ½å¸ƒé­¯å¡çˆ¾çš„square meeting centerã€‚ç”±æ–¼åœ‹å…§ç·šæ²’æœ‰ç›´é”
ç­æ©Ÿï¼Œæ•…å…ˆæ–¼é¦™æ¸¯è½‰æ©Ÿï¼Œé£›æŠµè·è˜­é¦–éƒ½é˜¿å§†æ–¯ç‰¹ä¸¹å¾Œå…¥å¢ƒï¼Œä¹‹å¾Œå†æ­ç´„äº”å°æ™‚çš„ç«è»Š
å‰å¾€æœƒå ´ã€‚ä¸éæŠµé”è·è˜­æ™‚é›¢æœƒè­°æ—¥æœŸå°šæ—©ï¼Œç­†è€…èˆ‡æ•™æˆæ²¿è·¯éŠè¨ªè·è˜­åŸé®ï¼Œæ„Ÿå—ç•¶
åœ°èˆ‡å–®è»Šäº¤é€šå¯†ä¸å¯åˆ†çš„ç”Ÿæ´»æ°‘æƒ…ï¼Œé¢¨æ™¯å¦‚ç•«ï¼Œååˆ†æ„œæ„ã€‚ä¹æœˆåæ—¥ï¼Œå³æœƒè­°æ­£å¼é–‹
å§‹å‰ä¸€å¤©ï¼Œæˆ‘å€‘æ–¹æ­è»Šå—ä¸‹ã€‚ç”±æ–¼æŠ•å®¿æ—…é¤¨ä½æ–¼å¸‚å€ä¸­å¿ƒï¼Œè·æœƒå ´åƒ…æ•¸åˆ†é˜è·¯ç¨‹ï¼Œä¸€
è¡Œäººä¾¿ç«‹å³è‡³æœƒå ´å ±åˆ°ã€‚ä¹æœˆçš„å¸ƒé­¯å¡çˆ¾å¤©æ°£é™°æ™´ä¸å®šï¼Œæ™‚æœ‰é™£é›¨ï¼Œä¸»è¾¦å–®ä½ä¹Ÿéå¸¸
è²¼å¿ƒåœ°è´ˆé€èˆ‡æœƒè€…äººäººä¸€æŠŠæŠ˜å‚˜ï¼Œè®“äººæ„Ÿå—é€™æ¬¡å¤§æœƒçš„èª æ‘¯å¿ƒæ„ã€‚å¸‚å€ä¸­å¿ƒçš„å¤§å»£å ´
(Grand place)ç‚ºä¸–ç•Œè‘—åæ™¯é»ï¼Œæ›¾ç²æ–‡è±ªé›¨æœç››è­½ã€Œæ­æ´²æœ€è¯ç¾çš„å»£å ´ã€ï¼Œæ•…ç­†è€…ä¸€è¡Œ
äººä¹Ÿå·é–’å‰å¾€æœè–ã€‚å»£å ´å¹…å“¡é¼é—Šï¼Œå››å‘¨çš†çŸ—ç«‹å·´æ´›å…‹é¢¨æ ¼å»ºç¯‰ï¼Œå·å³¨å£¯éº—ï¼Œåå‰¯å…¶
å¯¦ï¼Œä½¿äººèº«è™•å…¶ä¸­ä¸æ™‚èˆˆå˜†æ¸ºå°ä¹‹æ„Ÿã€‚è€Œå¹¾æ¢è¡—å¤–çš„å°¿å°¿å°ç«¥ä¹Ÿé©é€¢ç¯€æ—¥èº«æŠ«è¯æœï¼Œ
ä¸å°‘ç•°åœ‹èˆ‡æœƒè€…æœ‰å¹¸æ­é€¢å…¶ç››ï¼Œé‚å…‰ç‡ˆæ­¤èµ·å½¼è½ï¼Œå¥½ä¸ç†±é¬§ã€‚ä¹‹å¾Œï¼Œç­†è€…å³å›æ—…é¤¨ä¼‘
æ¯ï¼Œé¤Šè¶³ç²¾ç¥ä»¥å¾…éš”æ—¥çš„æœƒè­°ã€‚ 
   
  ç”±æ–¼ç™¼è¡¨è«–æ–‡å®‰æ’æ–¼ç¬¬ä¸€å¤©(2011/09/11)ä¸‹åˆï¼Œç¬¬ä¸€æ—¥ç­†è€…å…¨ç¨‹å¾…åœ¨æœƒå ´ã€‚æ—©ä¸Šçš„
plenary talkæ˜¯èˆ‡è‡ªèº«ç ”ç©¶è¼ƒä¸ç›¸é—œçš„é†«å­¸å½±åƒåˆ†æï¼Œæ”¶ç²è¼ƒå°‘ï¼Œç„¶è€Œä¹‹å¾Œé€²è¡Œçš„æ•¸å ´
lecture sessionï¼Œç­†è€…é¸æ“‡åƒèˆ‡è¨è«–structural modelç›¸é—œè«–æ–‡ï¼Œè½åˆ°ä¸å°‘åˆ†æäººé¡å§¿å‹¢èˆ‡
è¡Œç‚ºçš„ç ”ç©¶ä¸»é¡Œï¼Œé —æœ‰åŠ©ç›Šã€‚ä¸‹åˆç­†è€…è² è²¬å¼µè²¼æµ·å ±å ±å‘Šçš„sessionæ˜¯Image & video 
synthesisï¼Œä¸å°‘ç ”ç©¶å½±åƒç·¨ä¿®æˆ–åˆæˆçš„æœ‰è¶£é¡Œç›®éƒ½åŒ…å«å…¶ä¸­ã€‚ç­†è€…æœ¬èº«ç ”ç©¶éƒ¨åˆ†æ˜¯è¨è«–
æ•¸ä½å½±åƒæ‹æ”çš„ç‰©é«”å¤–è§€éš¨è‘—æ™‚é–“å¢é•·æ‰€ç”¢ç”Ÿçš„è®ŠåŒ–ï¼Œæå‡ºä¹‹å¤–è§€æ¨¡å‹å¯ä»¥ç›´æ¥åœ¨äºŒ
IEEE COPYRIGHT AND CONSENT FORM
 
 
To ensure uniformity of treatment among all contributors, other forms may not be substituted for this form, nor may any wording of the form be
changed. This form is intended for original material submitted to the IEEE and must accompany any such material in order to be published by the
IEEE.Please read the form carefully and keep a copy for your files.
 
 
 
TITLE OF PAPER/ARTICLE/REPORT, INCLUDING ALL CONTENT IN ANY FORM, FORMAT, OR MEDIA (hereinafter, "The
Work"):Time-Variant Modeling For General Surface Appearance 
 
COMPLETE LIST OF AUTHORS:Yi-Lei  Chen and Chiou-Ting  Hsu 
 
IEEE PUBLICATION TITLE (Journal, Magazine, Conference, Book):2011 IEEE International Conference on Image Processing
(IEEE ICIP2011) 
 
COPYRIGHT TRANSFER
 
1. The undersigned hereby assigns to The Institute of Electrical and Electronics Engineers,Incorporated (the "IEEE") all rights under copyright that
may exist in and to: (a) the above Work,including any revised or expanded derivative works submitted to the IEEE by the undersigned based on the
Work; and (b) any associated written or multimedia components or other enhancements accompanying the Work.
 
CONSENT AND RELEASE
2. ln the event the undersigned makes a presentation based upon the Work at a conference hosted or sponsored in whole or in part by the IEEE, the
undersigned, in consideration for his/her participation in the conference, hereby grants the IEEE the unlimited, worldwide, irrevocable permission to
use, distribute, publish, license, exhibit, record, digitize, broadcast, reproduce and archive, in any format or medium, whether now known or hereafter
developed: (a) his/her presentation and comments at the conference; (b) any written materials or multimedia files used in connection with his/her
presentation; and (c) any recorded interviews of him/her (collectively, the "Presentation"). The permission granted includes the transcription and
reproduction ofthe Presentation for inclusion in products sold or distributed by IEEE and live or recorded broadcast ofthe Presentation during or after
the conference.
 
3. In connection with the permission granted in Section 2, the undersigned hereby grants IEEE the unlimited, worldwide, irrevocable right to use
his/her name, picture, likeness, voice and biographical information as part of the advertisement, distribution and sale ofproducts incorporating the
Work or Presentation, and releases IEEE from any claim based on right of privacy or publicity.
 
4. The undersigned hereby warrants that the Work and Presentation (collectively, the "Materials") are original and that he/she is the author of the
Materials. To the extent the Materials incorporate text passages, figures, data or other material from the works of others, the undersigned has obtained
any necessary permissions. Where necessary, the undersigned has obtained all third party permissions and consents to grant the license above and has
provided copies of such permissions and consents to IEEE.
 
   [ ] Please check this box ifyou do not wish to have video/audio recordings made ofyour conference presentation.   
 
   See below for Retained Rights/Terms and Conditions, and Author Responsibilities.
 
 
AUTHOR RESPONSIBILITIES
 
 
The IEEE distributes its technical publications throughout the world and wants to ensure that the material submitted to its publications is properly
available to the readership of those publications. Authors must ensure that their Work meets the requirements as stated in section 8.2.1 of the IEEE
It is the formal policy of the IEEE to own the copyrights to all copyrightable material in its technical publications and to the individual contributions
contained therein, in order to protect the interests of the IEEE, its authors and their employers, and, at the same time, to facilitate the appropriate re-
use of this material by others.The IEEE distributes its technical publications throughout the world and does so by various means such as hard copy,
microfiche, microfilm, and electronic media.It also abstracts and may translate its publications, and articles contained therein, for inclusion in various
compendiums, collective works, databases and similar publications. 
 
Author/Employer Rights
 
If you are employed and prepared the Work on a subject within the scope of your employment, the copyright in the Work belongs to your employer
as a work-for-hire. In that case, the IEEE assumes that when you sign this Form, you are authorized to do so by your employer and that your
employer has consented to the transfer of copyright, to the representation and warranty of publication rights, and to all other terms and conditions of
this Form.If such authorization and consent has not been given to you, an authorized representative of your employer should sign this Form as the
Author.
 
GENERAL TERMS
 
1. The undersigned represents that he/she has the power and authority to make and execute this form.
2. The undersigned agrees to indemnify and hold harmless the IEEE from any damage or expense that may arise in the event of a breach of any of the
warranties set forth above.
3. In the event the above work is not accepted and published by the IEEE or is withdrawn by the author(s) before acceptance by the IEEE, the
foregoing grant of rights shall become null and void and all materials embodying the Work submitted to the IEEE will be destroyed.
4. For jointly authored Works, all joint authors should sign, or one of the authors should sign as authorized agent for the others.
 
Yi-Lei Chen 27-04-2011
Author/Authorized Agent For Joint Authors Date(dd-mm-yy)
 
THIS FORM MUST ACCOMPANY THE SUBMISSION OF THE AUTHOR'S MANUSCRIPT.
Questions about the submission of the form or manuscript must be sent to the publication's editor.Please direct all questions about IEEE copyright
policy to:
IEEE Intellectual Property Rights Office, copyrights@ieee.org, +1-732-562-3966 (telephone)
 
 
 
 
  
                                                                                                                                                        
 
 
and analyze the four types independently. Since different 
time-variant sequences have different time duration and 
image resolution (from 180x180 to 512x512), in our 
experiments, we use bilinear interpolation to normalize each 
time-variant sequence into 25 time steps and resize to the 
same resolution (i.e. size of 128x128).  
   
    
    
(a) (b) (c) (d) 
Figure 1. Released data from [7]: (a) burning; (b) corrosion; (c) 
decaying; and (d) drying. 
2.2. Time-variant appearance model via tensor 
representation 
Multi-linear algebra, also called tensor, indicates a 
generalization of vector or a multi-dimensional array. Using 
multi-linear analysis, we first construct a data tensor  T  to 
represent our database 
pixelcolortimelightmaterial IIIIIT Ã—Ã—Ã—Ã—âˆˆR , (1)
where materialI and lightI  indicate the number of different 
materials and lighting directions (details please see [7]), and 
timeI , colorI  and pixelI  indicate the number of time steps, color 
channels and image pixels, respectively. In our experiment, 
25=timeI , 3=colorI , and 128128Ã—=pixelI . In order to 
characterize the appearance variation, we construct another 
tensor, called the aging tensor A , by calculating the 
difference of the data appearance in T between the initial 
time step and all the other time steps.  
To further analyze T  and A  in different factors, we 
decompose the two tensors by high order singular value 
decomposition (HOSVD) and obtain 
pixelcolortimelightmaterial
pixelcolortimelightmaterial
YA
XT
VVVVV
UUUUU
54321
54321
Ã—Ã—Ã—Ã—Ã—=
Ã—Ã—Ã—Ã—Ã—= . (2)
With the data tensor T , we could represent any sample t  
by 
T
color
T
time
T
light
T
materialT cccct 4321 Ã—Ã—Ã—Ã—= . (3)
In equation (3), we use least square error (LSE) method and 
rank-1 approximation algorithm [16] to estimate the 
unknown coefficients materialc , lightc , timec and colorc . The 
coefficients materialc , lightc , colorc  relate to surface properties, 
and the coefficient timec  indicates the appearance similarity 
between input sample and the training data along time axis. 
If we use the global bases timeV in equation (2) to project 
timec , although timetimecV  could characterize the time-variant 
appearance change, the important surface-specific 
information (including  material, lighting direction and color) 
is  missing. Therefore, with materialc , lightc , and colorc obtained 
in equation (3), we propose to construct surface-specific 
aging bases to characterize both the time-variant and 
surface-specific properties. 
Below we describe how we construct the surface-
specific aging bases. We first use the surface coefficients 
materialc , lightc , and colorc  to obtain a sub-tensor AË†  
T
color
T
light
T
materialAA ccc 421Ë† Ã—Ã—Ã—= . (4)
Then we unfold AË†  and decompose the matrix AË†  by  SVD 
TVUA Ë†Ë†Ë† Î£= . (5)
Now the projection basis UË†  only depends on the sub-
database, which possesses the same surface properties as the 
input sample. Using UË† , we obtain the time coefficients timeÎ±  
))((Ë† 4210
T
color
T
light
T
material
T
time Tunfold ccctUÎ± Ã—Ã—Ã—âˆ’=  , (6)
where )(â‹…unfold  indicates a matrix unfolding operation to 
unfold a multi-dimensional array into a vector, and 0T  is a 
sub-tensor of T with data appearance at the initial time step. 
2.3. Aging degree estimation 
Given an unknown sample, once we obtain its surface 
coefficients TTcolorTlightTmaterialsurface ],,[ cccc =  and the time 
coefficients timeÎ±  by equations (3) and (6), an intuitive 
approach is to concatenate surfacec  and timeÎ±  as low-level 
features and to learn a regression function along time axis. 
However, since the time-variant appearance change is very 
complicate, these features tend to distribute discontinuously 
in temporal domain. Therefore, instead of using regression-
based methods, in our approach, we model the aging degree 
estimation as a classification problem. Classification-based 
methods are generally more feasible for discontinuous 
distributions in lower dimensional space. In addition, since 
the class number (i.e. 25 time steps) is limited, our 
classification approach often involves no ambiguity in 
multi-class estimation. 
We use Fig. 2 to show that classification-based is more 
feasible than regression-based method in our problem. Fig. 
2 shows the two estimation results, where the x axis is the 
data index and the y axis indicates the aging degree. Here 
we use the state-of-the-art techniques, support vector 
machine (SVM) and support vector regression (SVR), for 
demonstration. In Figure 2(a), SVM achieves better 
estimation than SVR in higher and lower aging degrees. 
Since SVR attempts to minimize the total estimation error, 
the estimated results usually close to average. Nevertheless, 
our other experiment (as shown in Fig. 3 (a)) shows that 
even SVM achieves poor estimation for intricate appearance 
2011 18th IEEE International Conference on Image Processing1102
we combine the two existing texture synthesis techniques to 
synthesize realistic appearance changes on general object 
surface. With this framework, in the future, we attempt to 
extend our approach to facial images, which can be seen as 
a special case of time-variant appearance. 
5. REFERENCES 
[1] H. W. Jensen, J. Legakis and J. Dorsey, â€œRendering of Wet 
Materials,â€ Proc. Rendering Techniques Conf., pp. 273-282, 1999. 
[2] J. Dorsey, H. K. Pedersen and P. Hanrahan, â€œFlow and Chan-
ges in Appearance,â€ Proc. SIGGRAPH, pp. 411-420, Aug. 1996. 
[3] J. Dorsey, A. Edelman, H. W. Jensen, J. Legakis, and H. K. 
Pedersen, â€œModeling and Rendering of Weathered Stone,â€ Proc. 
SIGGRAPH, vol. 33, pp.  225-234, Aug. 1999. 
[4] O. Clement, J. Benoit, and E. Paquette, â€œEfficient Editing of 
Aged Object Textures,â€ Proc. the 5th international conference on 
AFRIGRAPH, pp. 151-158, 2007. 
[5] B. Sun, K. Sunkavalli, R. Ramamoorthi, P. N. Belhumer, and S. 
K. Nayar, â€œTime-Varying BRDFs,â€ IEEE Trans. Visualization and 
Computer Graphics, vol. 13, No. 3, 2007. 
[6] J. Wang, X. Tong, S. Lin, M. Pan, C. Wang, H. Bao, B. Guo, H. 
Y. Shum, â€œAppearance Manifolds for Modeling Time-Variant 
Appearance of Materials,â€ ACM Trans on Graphics, 2006. 
[7] J. Gu, C. Tu, R. Ramamoorthi, P. Belhumeur, W. Matusik, and 
S. Nayar, â€œTime-Varying Surface Appearance: Acquisition, 
Modeling and Rendering,â€  Proc. SIGGRAPH, pp. 762-771, 2006. 
[8] M. A. O. Vasilescu, D. Terzopoulos, â€œMultilinear analysis of 
image ensembles: TensorFaces,â€ Proc. ECCV, 2002. 
[9] Hyung-Soo Lee and Daijin, â€œTensor based AAM with 
continous variation estimation: application to variation-robust face 
recognition,â€ IEEE Tran. PAMI, 2009. 
[10] Y. Fu and T. S. Huang, â€œImage Classification Using 
Correlation Tensor Analysis,â€ IEEE Tran. Image Processing, 2008. 
[11] Dacheng Tao, Xuelong Li, Xindong Wu and S. J. Maybank, 
â€œGeneral tensor discriminant analysis and gabor features for gait 
recognition,â€ IEEE Tran. PAMI, 2007. 
[12] M. A. O. Vasilescu, and D. Terzopoulos, â€œMultilinear 
projection for appearance-based recognition in the tensor 
framework,â€ Proc. ICCV, 2007. 
[13] T. G. Kolda, â€œOrthogonal tensor decompositions,â€ SIAM 
Journal on Matrix Analysis and Applications, 2001. 
[14] L. de Lathauwer, B. de Moor, and J. Vandewalle, â€œOn the 
Best Rank-1 and Rank-(R1;R2;â€¦;RN) Approximation of Higher-
Order Tensors,â€ SIAM J. Matrix Analysis and Applications, vol. 21, 
no. 4, pp. 1324-1342, 2000. 
[15] A. A. Efros and W. T. Freeman, â€œImage quilting for texture 
synthesis and transfer,â€ Porc. of 28th annual conf. on Computer 
graphics and  interactive techniques, pp. 341-346, 2001. 
[16] A. A. Efros and T. K. Leung, â€œTexture synthesis by non-
parametric sampling,â€ Proc. ICCV, 1999. 
 
Figure 4. Average MAE of estimated aging degree. 
 
(a) (b) 
 
 
 
 
 
(c) 
Figure 5. Synthesized example: (a) brick wall image; (b) a random 
patch cropped from (a); and (c) the synthesized appearance at 25 
different aging degrees. 
 
(a) (b) 
(c) (d) 
Figure 6. Appearance synthesis of an old door: (a) original image; 
(b) binary mask; (c) synthesized appearance change; and (d) the 
synthesized result. (Note that, to visualize the synthesized 
appearance change in (c), we multiply the value by five.) 
 
2011 18th IEEE International Conference on Image Processing1104
97 å¹´åº¦å°ˆé¡Œç ”ç©¶è¨ˆç•«ç ”ç©¶æˆæœå½™æ•´è¡¨ 
è¨ˆç•«ä¸»æŒäººï¼šè”¡æ˜å“² è¨ˆç•«ç·¨è™Ÿï¼š97-2221-E-007-042-MY3 
è¨ˆç•«åç¨±ï¼šåœ¨ç„¡ç·šæ„Ÿæ¸¬ç¶²è·¯ä¸€ç¨®åˆ©ç”¨è™›æ“¬åº§æ¨™å®¹éŒ¯å¯é åŠä¿è­‰å°åŒ…é€é”çš„ç¹å¾‘æ–¹æ³• 
é‡åŒ– 
æˆæœé …ç›® å¯¦éš›å·²é”æˆ
æ•¸ï¼ˆè¢«æ¥å—
æˆ–å·²ç™¼è¡¨ï¼‰
é æœŸç¸½é”æˆ
æ•¸(å«å¯¦éš›å·²
é”æˆæ•¸) 
æœ¬è¨ˆç•«å¯¦
éš›è²¢ç»ç™¾
åˆ†æ¯” 
å–®ä½ 
å‚™ è¨» ï¼ˆ è³ª åŒ– èªª
æ˜ï¼šå¦‚æ•¸å€‹è¨ˆç•«
å…±åŒæˆæœã€æˆæœ
åˆ— ç‚º è©² æœŸ åˆŠ ä¹‹
å° é¢ æ•… äº‹ ...
ç­‰ï¼‰ 
æœŸåˆŠè«–æ–‡ 0 0 100%  
ç ”ç©¶å ±å‘Š/æŠ€è¡“å ±å‘Š 0 0 100%  
ç ”è¨æœƒè«–æ–‡ 0 0 100% 
ç¯‡ 
 
è«–æ–‡è‘—ä½œ 
å°ˆæ›¸ 0 0 100%   
ç”³è«‹ä¸­ä»¶æ•¸ 0 0 100%  å°ˆåˆ© å·²ç²å¾—ä»¶æ•¸ 0 0 100% ä»¶  
ä»¶æ•¸ 0 0 100% ä»¶  
æŠ€è¡“ç§»è½‰ 
æ¬Šåˆ©é‡‘ 0 0 100% åƒå…ƒ  
ç¢©å£«ç”Ÿ 0 0 100%  
åšå£«ç”Ÿ 0 0 100%  
åšå£«å¾Œç ”ç©¶å“¡ 0 0 100%  
åœ‹å…§ 
åƒèˆ‡è¨ˆç•«äººåŠ› 
ï¼ˆæœ¬åœ‹ç±ï¼‰ 
å°ˆä»»åŠ©ç† 0 0 100% 
äººæ¬¡ 
 
æœŸåˆŠè«–æ–‡ 1 0 100%  
ç ”ç©¶å ±å‘Š/æŠ€è¡“å ±å‘Š 0 0 100%  
ç ”è¨æœƒè«–æ–‡ 1 0 100% 
ç¯‡ 
 
è«–æ–‡è‘—ä½œ 
å°ˆæ›¸ 0 0 100% ç« /æœ¬  
ç”³è«‹ä¸­ä»¶æ•¸ 0 0 100%  å°ˆåˆ© å·²ç²å¾—ä»¶æ•¸ 0 0 100% ä»¶  
ä»¶æ•¸ 0 0 100% ä»¶  
æŠ€è¡“ç§»è½‰ 
æ¬Šåˆ©é‡‘ 0 0 100% åƒå…ƒ  
ç¢©å£«ç”Ÿ 0 0 100%  
åšå£«ç”Ÿ 0 0 100%  
åšå£«å¾Œç ”ç©¶å“¡ 0 0 100%  
åœ‹å¤– 
åƒèˆ‡è¨ˆç•«äººåŠ› 
ï¼ˆå¤–åœ‹ç±ï¼‰ 
å°ˆä»»åŠ©ç† 0 0 100% 
äººæ¬¡ 
 
