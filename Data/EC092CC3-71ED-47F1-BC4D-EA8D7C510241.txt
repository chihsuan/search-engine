algorithm as a solution. To enable three-dimensional (3D) 
optimization, a greedy algorithm, referred to as the multiple 
fragment heuristic, is modified to derive a good initial solution at 
stage one. Stage two initiates two local refinement techniques, 3D 
planarization and 3D relaxation, to reduce the wire or power cost 
and to relax the number of TSVs in use to meet the constraint, 
respectively. Experimental results show that the proposed algorithm 
results in comparable performance to a Genetic-Algorithm (GA) 
method but it runs at least two-orders faster, which makes it more 
practical for TSV-constrained scan-chain ordering for 3D-IC 
designs.  
 
To achieve high-performance computing on embedded systems, 
three-dimensional (3D) multi-core processors have become a 
promising alternative where energy efficiency is crucial to its 
success. Many heuristics applying Dynamic 
Voltage and Frequency Scaling (DVFS) techniques were proposed 
for energy minimization. However, most of the previous works were 
built upon a fixed task-to-core mapping where many slack spaces 
can be further improved. Therefore, the other goal in this work is to 
propose two dynamic remapping strategies to enhance an energy-
aware task-scheduling algorithm considering transmission cost. 
Experimental results show that the energy-saving rate of the best 
strategy is 16 percent higher than the previous work on average. 
Moreover, compared to an ILP solution, the enhanced algorithm can 
run at least three-order faster while achieving comparable 
performance on total energy consumption. 
 
 I 
æ‘˜ è¦ 
 
å¤šæ ¸å¿ƒå–®æ™¶ç‰‡ç³»çµ±ç‚ºå¯¦ç¾é«˜æ•ˆèƒ½åµŒå…¥å¼ç³»çµ±çš„å¯é æ–¹å¼ï¼Œè€Œä¸‰ç¶­ç©é«”é›»è·¯ç‚º
ç¾åœ¨éšæ®µå¯¦ä½œå¤šæ ¸å¿ƒç³»çµ±çš„æœ€ä½³æŠ€è¡“ã€‚ä½†æ˜¯ä¸‰ç¶­ç©é«”é›»è·¯æœ¬èº«ä»å­˜åœ¨è¨±å¤šè­°é¡Œç­‰
å¾…è‘—æˆ‘å€‘ä¾†æ¢è¨ã€‚å…¶ä¸­ï¼Œæœ€å¸¸è¢«äººé—œæ³¨çš„å³æ˜¯è‰¯ç‡èˆ‡é«˜åŠŸè€—å¯†åº¦å•é¡Œã€‚é€™æ˜¯å› ç‚º
åœ¨å †ç–‰çš„éç¨‹ä¸­å¯èƒ½æœƒç”¢ç”Ÿç¼ºé™·ã€‚é™¤æ­¤ä¹‹å¤–ï¼ŒçŸ½ç©¿å­”é™¤äº†æœƒå é¢ç©ä¹Ÿå¯èƒ½æ˜¯æœƒå°
è‡´ç¼ºé™·çš„ä¾†æºã€‚é‚„æœ‰ä¸‰ç¶­å¤šæ ¸å¿ƒè™•ç†å™¨ç”±æ–¼é«˜åŠŸè€—å¯†åº¦å•é¡Œï¼Œæ˜“æœ‰å¤§é‡çš„èƒ½é‡æ¶ˆ
è€—ã€‚å› æ­¤ï¼Œé™¤ä½•é™ä½è€—èƒ½ä¾¿æˆç‚ºå¦ä¸€å€‹ä¸»è¦è­°é¡Œã€‚ 
 
é¦–å…ˆ åœ¨è€ƒæ…®çŸ½ç©¿å­”ä½¿ç”¨æ•¸ç›®çš„é™åˆ¶ä¸‹ï¼Œæˆ‘å€‘æå‡ºä¸€å€‹å¿«é€Ÿçš„å…©éšæ®µæ¼”ç®—
æ³•ï¼Œä¾†æ±ºå®šæƒæéˆçš„ä¸²æ¥é †åºã€‚ç¬¬ä¸€éšæ®µï¼Œå…ˆä½¿ç”¨è²ªå©ªæ¼”ç®—æ³•ç¨±ä¹‹ç‚ºå¤šç‰‡æ®µéŒ¯èª¤
åšè©¦æ³•ï¼Œå¾—åˆ°ä¸€çµ„åˆå§‹è§£ã€‚ç¬¬äºŒéšæ®µç‚ºå¾—åˆ°ä¸€çµ„æœ€ä½³è§£ï¼Œæœƒåˆ©ç”¨ä¸‰ç¶­å¹³å¦åŒ–èˆ‡ä¸‰
ç¶­é¬†å¼›åŒ–ä¾†é™ä½é€£ç·šæˆ–åŠŸè€—æˆæœ¬èˆ‡ç¬¦åˆçŸ½ç©¿å­”ä½¿ç”¨æ•¸ç›®é™åˆ¶ã€‚å¯¦é©—çµæœé¡¯ç¤ºæˆ‘å€‘
æ‰€æå‡ºçš„æ¼”ç®—æ³•ï¼Œå¯é”åˆ°èˆ‡åŸºå› æ¼”ç®—æ³•ç›¸å·®ä¸å¤šçš„æ•ˆèƒ½ï¼Œä¸¦ä¸”æ•ˆç‡æ¯”åŸºå› æ¼”ç®—æ³•
å¿«ä¸€ç™¾å€ä»¥ä¸Šã€‚é€™ä¹Ÿé¡¯ç¤ºæˆ‘å€‘çš„æ–¹æ³•å¯å¯¦éš›æ‡‰ç”¨æ–¼ä¸‰ç¶­ç©é«”é›»è·¯æƒæéˆçš„è¨­è¨ˆã€‚ 
 
ä¸‰ç¶­ç©é«”é›»è·¯ç‚ºå¯¦ä½œå‡ºé«˜æ•ˆèƒ½åµŒå…¥å¼ç³»çµ±çš„æœ€ä½³æŠ€è¡“ï¼Œä½†å…¶è€—èƒ½å•é¡Œå¯èƒ½æœƒ
å°è‡´ä¸ç†æƒ³çš„è¡¨ç¾ã€‚å› æ­¤ï¼Œé‡å°è€—èƒ½æœ€å°åŒ–ï¼Œè¨±å¤šåˆ©ç”¨å‹•æ…‹å£“é »èª¿æ•´æ³•è¢«æå‡ºã€‚
ç„¶è€Œï¼Œå¤§éƒ¨ä»½å…ˆå‰çš„ç ”ç©¶åœ˜éšŠä½¿ç”¨çš„éƒ½æ˜¯å›ºå®šå¼æ ¸å¿ƒå°æ‡‰æ³•ï¼Œç•™ä¸‹äº†è¨±å¤šå¯å†é™
ä½è€—èƒ½çš„é€²æ­¥ç©ºé–“ã€‚å› æ­¤ï¼Œå¦ä¸€å€‹ç ”ç©¶è­°é¡Œä¾¿æ˜¯åœ¨è€ƒæ…®æ ¸å¿ƒé–“è³‡æ–™å‚³è¼¸å»¶é²æ™‚
é–“ï¼Œæå‡ºé™ä½è€—èƒ½çš„ä»»å‹™æ’ç¨‹æ¼”ç®—æ³•ã€‚æ­¤æ¼”ç®—æ³•çµåˆå‹•æ…‹é‡è¦†å°æ‡‰æ³•ä¾†æé«˜è€—èƒ½
ç¯€çœç‡ã€‚å¯¦é©—çµæœé¡¯ç¤ºï¼Œæˆ‘å€‘æ‰€æå‡ºçš„æ¼”ç®—æ³•ï¼Œå…¶è€—èƒ½ç¯€çœç‡è¼ƒå…ˆå‰çš„æ¼”ç®—æ³•é«˜
å‡ºåå…­å€‹ç™¾åˆ†æ¯”ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘å€‘çš„æ¼”ç®—æ³•ä¸åƒ…æ¯”æ•´æ•¸ç·šæ€§è¦åŠƒå¿«ä¸Šä¸€åƒå€ä»¥
ä¸Šï¼Œé‚„å¯é”åˆ°èˆ‡æ•´æ•¸ç·šæ€§è¦åŠƒè§£ç›¸å·®ä¸å¤šçš„è€—èƒ½ç¯€çœç‡ã€‚ 
 
 
é—œéµå­—ï¼šçŸ½ç©¿å­” ; æƒææ¸¬è©¦ ; æ ¸å¿ƒå°æ‡‰æ³•; ä»»å‹™æ’ç¨‹; å‹•æ…‹å£“é »èª¿æ•´ 
 
 
 
 
 
 
 
 
 
 
 III
Table of Content 
 
List of Figure.............................................................................................................. V 
List of Tables .............................................................................................................. VI 
 
Chapter 1  Introduction ............................................................................................. 1 
1.1 Research goal ............................................................................................ 3 
1.2 Method ....................................................................................................... 4 
1.2.1 First year ........................................................................................ 5 
1.2.2 Second year .................................................................................... 6 
 
Chapter 2  Fast scan-chain ordering for 3D-IC designs under through-silicon-via 
(TSV) constraints .................................................................................... 9 
2.1 Introduction ............................................................................................... 9 
2.2 Problem formulation of scan-chain ordering for TSV-constrained 
3D-IC designs ............................................................................................ 12 
2.2.1 Wire-cost minimization problem ................................................ 12 
2.2.2 Power-cost minimization problem .............................................. 14 
2.2.3 Wire-and-power cost minimization problem .............................. 19 
2.3 A fast scan-chain ordering ......................................................................... 19 
2.3.1 Minimizing wire cost .................................................................. 19 
2.3.2 Minimizing power cost ............................................................... 26 
2.3.3 Minimizing wire-and-power cost simultaneously....................... 27 
  
Chapter 3 Enhancing Energy-Efficient Task Scheduling on 3D Multi-Core 
Processors by Dynamic Remapping ....................................................... 28 
3.1 Introduction ............................................................................................... 28 
3.2 Problem formulation .................................................................................. 31 
3.2.1 Data flow graph ........................................................................... 31 
3.2.2 Timing versus resource constraint .............................................. 31 
3.2.3 Energy model .............................................................................. 33 
3.3 Baseline algorithm under a fixed task-to-core mapping ........................... 34 
3.3.1 Task-to-core mapping ................................................................. 37 
3.3.2 Voltage scaling ............................................................................ 37 
3.4 Dynamic task-to-core remapping strategies .............................................. 38 
3.4.1 Dynamic remapping (DR) ........................................................... 38 
3.4.2 Iterative dynamic remapping (IDR) ............................................ 42 
 V 
 
List of Figures 
 
Figure 1.1: 2D and 3D integration of micro-systems ................................................ 1 
Figure 1.2: 3D IC stacking technology ...................................................................... 2 
Figure 1.3: 3D-MFH flow .......................................................................................... 6 
Figure 1.4: System overview of task scheduler ......................................................... 7 
Figure 1.5: Design flow of scheduling with dynamic remapping methods ............... 8 
 
Figure 2.1: Comparison between 2D and 3D scan-chain designs ............................. 10 
Figure 2.2: Flow of proposed scan reordering algorithm .......................................... 14 
Figure 2.3: Calculations for weighted transitions ...................................................... 17 
Figure 2.4: Multiple Fragment Heuristic example ..................................................... 22 
Figure 2.5: Illustration of the neighbor heuristic ....................................................... 22 
Figure 2.6: Illustration of the application of the FastPair method ............................. 23 
Figure 2.7: Example of six-point Planarization ......................................................... 24 
Figure 2.8: Example of 3D Planarization .................................................................. 25 
Figure 2.9: Example of 3D Relaxation ...................................................................... 26 
 
Figure 3.1: Examples for different task-to-core mapping strategies .......................... 30 
Figure 3.2: Example for DFG and scheduling result of 31 tasks ............................... 32 
Figure 3.3: Transmission cost in a 3D multi-core processor ..................................... 33 
Figure 3.4: Voltage versus latency curve ................................................................... 34 
Figure 3.5: Design flow of baseline scheduling......................................................... 36 
Figure 3.6: Design flow of DR/IDR .......................................................................... 40 
Figure 3.7: First stage of DR strategy under a timing constraint 16 .......................... 41 
Figure 3.8: Second stage of DR strategy under a timing constraint 20 ..................... 41 
 
Figure 4.1: Proposed 3D scan design flow ................................................................ 44 
Figure 4.2: Comparison among GA and our algorithm for considering power and wire 
simultaneously on circuit s1423............................................................... 51 
Figure 4.3: Comparison among GA and our algorithm for considering power and wire 
simultaneously on circuit s5378............................................................... 52 
Figure 4.4: 24 scan chains for circuit bench2 (50K gates with 4095 FFs) ................ 53 
Figure 4.5: 108 scan chains for circuit bench7 (385K gates with 17983 FFs) .......... 53 
 
 
 1 
Chapter 1  
Introduction 
 
The next generation of integrated micro-system technologies enables ever 
increasing functionality and performance by utilizing the 3rd dimension. 3D 
integration of designs can bring together the virtues of overall performance, 
heterogeneous integration and miniaturization. International Technology Roadmap of 
Semiconductor (ITRS) points out that 3D integration is one of the most promising 
solutions to sustain the performance improvement beyond 65nm. Figure 1.1(a) 
illustrates an example of the integrated micro-system composed of five individual 
functional blocks. Traditionally, these five blocks are integrated in 2D packaging or 
printed wiring board (PWB). In the fashion of 3D architecture, each block can be built 
in the separate layer and stacked one-by-one vertically as shown in Figure 1.1(b). 
Apparently, the form-factor (i.e. X and Y dimensions) of the micro-system shrinks 
significantly and the overall and worst-case interconnect length can be also reduced. 
 
B1
B2
B3 B4
B5
 
(a) 
 
(b) 
 
Figure 1.1: 2D and 3D integration of micro-systems 
 
 3 
interconnect delay, footprint, performance and heterogeneous technology mixing. 
 
Potential advantages of 3D integration technology captured significant attention. 
However, 3D multi-core system has a severe thermal issue due to high power density. 
High temperature spots worsen the system reliability and cause failure. The problem 
of consuming tremendous amount of energy is more severe on high-performance 
computing systems. Therefore, the minimization of power consumption has become a 
paramount concern for present large-scale 3D multi-core systems. 
 
Nowadays, energy-efficiency is crucial to low-power design and high-performance 
computing. Many previous researches focus on energy minimization that can be 
applied at both the behavior level and the physical level. Many physical design 
solutions are proposed for this issue, including microchannel liquid cooling [28], 
floorplanning [29] and thermal TSVs [30]. Among all the high-level techniques are 
more effective than the low-level ones for energy minimization especially on 3D 
multi-core systems, such as thermal-aware task scheduling [31] and power-aware task 
scheduling [32]. More advanced techniques for energy efficiency are proposed and 
can be classified into Voltage selection (VS) (also called voltage scheduling) [33] and 
power management (PM) [34]. Both techniques mainly target the system-level energy 
saving while VS is more attractive than PM in general [35]. One of VS scheduling, 
Dynamic voltage and frequency Scaling (DVFS) scheduling algorithms has become 
more popular recently. 
 
1.1 Research Goal 
 
Both pre-bond testing and post-bond testing are important for improving the 
yield of 3D ICs. Scan-chain design is the most prevailing Design-for-Testability (DFT) 
technique which aims to reduce the difficulty of testing on the Circuit Under Test 
(CUT). Experimental results in [17] also suggested that the more TSVs in use in the 
scan chain, the less wire cost. Such observation combined with the TSV induced yield 
loss indicates an important tradeoff between wire cost and the number of TSVs in use. 
Therefore, a constraint of TSVs in use must be considered for a 3D-IC design. This 
work addresses the problem of scan-chain ordering under a limited number of 
Through-Silicon Vias (TSVs) constraints by presenting a fast two-stage algorithm as a 
solution.  
 
In addition, since a 3D multi-core processor often consumes excessive energy, 
leading to a problem of high power density [26] [27], energy efficiency becomes its 
 5 
(DVFS) scheduling algorithm, has prevailed recently. Many heuristics applying 
Dynamic Voltage and Frequency Scaling (DVFS) techniques were proposed for 
energy minimization. However, most of the previous works were built upon a fixed 
task-to-core mapping where many slack spaces can be further improved. Therefore, in 
this work, we propose two dynamic remapping strategies to enhance an energy-aware 
task-scheduling algorithm considering transmission cost. 
 
1.2.1 First year 
 
According to the formulation for the TSV constrained scan-chain ordering 
problem, two approaches are proposed in [17]. One approach is developed on the 
basis of Genetic Algorithm (GA), and the other is based on Integer Linear 
Programming (ILP). Although the GA approach may possibly find the near-optimal 
solution, the quality of one identified solution cannot be guaranteed. Moreover, the 
ILP approach, which will find the optimal cost, may not be able to produce a feasible 
solution within a limited time. The experimental result in [17] shows a lower-bound 
value on the total scan-stitching wire cost, which was obtained quickly through the 
ILP approach without providing a detailed ordering of scan FFs. 
 
From a practical perspective, a fast algorithm needs to be developed that will 
overcome the runtime issue. Therefore, we propose a fast two-stage algorithm. In 
stage 1, we convert the 3D scan-chain ordering problem into a TSP problem. Then, a 
tour-construction heuristic [20] with the support of a particular closest-pair data 
structure, FastPair, [21] is used to stitch a simple path as an initial solution. During 
stage 2, local refinement by 3D planarization and constraint-solving by 3D relaxation 
minimize the total cost and reduce the number of TSVs in use, respectively. Figure 1.3 
shows the overall flow.  
 
We present problem formulations of TSV-constrained scan chain ordering for 
3D-IC designs, with three different objectives: 
â€¢ Wire-cost minimization 
â€¢ Power-cost minimization 
â€¢ Wire-and-power cost minimization 
 
 
 
 
 
 7 
energy-efficiency on a 3D-multi-core architecture. Figure 1.4 shows the system 
overview of the timing-and-resource constrained scheduler. Inputs to a scheduler 
include a task graph, a timing constraint, a resource constraint and an energy model. 
All tasks after scheduling must be assigned into one core with a correct execution 
order. Moreover, energy minimization is the objective of a scheduler where the 
energy-saving rate is computed to estimate the energy- efficiency of schedulers. 
 
 
Figure 1.4: system overview of task scheduler 
 
Wu et al. [41] proposed an energy-efficient task scheduling algorithm on top of 
[40] via DVFS at the system level and formulated a priority gain function considering 
both gains and losses for selecting tasks to scale down its frequency.  
 
Built on top of the previous task-scheduling algorithms [41], two dynamic 
task-to-core mapping strategies, Dynamic Remapping (DR) and Iterative Dynamic 
Remapping (IDR), are proposed to reduce slack slots and to improve Energy-Saving 
Rate (ESR). Experimental results show that ESR of the algorithm with the IDR 
strategy is 16 percent higher than the previous work [41] on average. Moreover, 
compared to an ILP solution, both two proposed strategies can run at least three-order 
faster and achieve comparable performance on energy saving. Figure 1.5 shows the 
flow of the DR or IDR strategy. There are two rounds in the DR strategy where 
task-to-core mapping and voltage scaling are performed in both round. 
 
 9 
Chapter 2  
Fast scan-chain ordering for 3D-IC designs 
under through-silicon-via (TSV) constraints 
 
2.1 Introduction 
 
Interconnect along with scaling technology plays an important role in deciding 
circuit performance. Structural Three-Dimensional (3D) integration is emerging as a 
promising solution to reduce the length of long interconnects across circuits [1]. 
Moreover, 3D integration provides many other advantages over the traditional 
Two-Dimensional (2D) implementation, such as better packaging efficiency and 
higher transistor density. These advantages, collectively, not only provide significant 
performance improvement but also alleviate the problems caused by long 
interconnects [2], [3], [4], [5]. Among all vertical-integration techniques, 
Through-Silicon Via (TSV) provides the best timing and power performance for 
interconnection. However, TSVs typically incur additional area overhead and may 
become another source of defects [6]. Therefore, considering yield loss and area cost, 
the number of TSVs in use is typically limited in a 3D Integrated Circuit (IC) design. 
 
On the other hand, scan-chain design is the most prevailing 
Design-for-Testability (DFT) technique which aims to reduce the difficulty of testing 
on the Circuit Under Test (CUT). In order to guarantee high fault coverage on 
complex designs, the CUT is modified during the synthesis stage to enhance its 
controllability and observability. All Flip-Flops (FFs) are replaced by 
multiplexed-input scan FFs with multiple operation modes. During the test mode, i.e., 
when a signal test is activated, the values of one test pattern are shifted to scan FFs of 
the scan chain in sequel. Later, the pattern is applied to the combinational logic 
through the primary inputs under the function mode. The response values are finally 
captured at the primary outputs and shifted out through the scan chain once again 
under the test mode. Scan testing reduces the sequential problem into a combinational 
problem; thus, high coverage can be efficiently achieved. 
 
Although scan FFs enhance the testability on the CUT, the stitching wire of a 
scan chain can be long and may deteriorate signal integrity or even violate the timing 
constraint. Therefore, scan-chain ordering, referring to the order decision for scan FFs 
 11 
constraint of TSVs in use must be considered for a 3D-IC design. 
 
Both pre-bond testing and post-bond testing are important for improving the 
yield of 3D ICs. For enabling pre-bond testability, Lewis et al. [18] proposed a 
scan-island based design and Kumar et al. [19] proposed a hyper-graph based 
partitioning for pre-bond 3D IC testing. Additionally, several scan-ordering 
approaches for 3D IC post-bond testing were accordingly proposed in [17]. VIA3D 
uses the fewest number of TSVs to alleviate TSV impact on the scan-stitching wire. 
MAP3D first maps all scan FFs onto one single layer, followed by the 2D scan-chain 
reordering technique. OPT3D considers TSV impact during cost computation for 
scan-stitching wire. OPT3D outperforms the other two in terms of total wire cost. 
However, scan-induced power dissipation is not considered by such work and is also 
an important issue for 3D ICs. A Genetic Algorithm (GA) method was then proposed 
in [17] where the runtime issue remains unresolved and solution quality is unstable. 
Hence, a fast 3D scan-chain design is presented in this work to simultaneously 
consider wire and power costs. 
 
In this work, TSV-constrained scan-chain ordering is first analyzed and 
formulated into a Traveling Salesman Problem (TSP). Later, a fast algorithm is 
developed to minimize the scan-stitching wire and/or scan-induced power dissipation, 
to simultaneously satisfy the constraint on the number of TSVs in use for 3D-IC 
designs. Our algorithm consists of two phases: First, we construct an initial simple 
path through all scan FFs using a modified greedy algorithm, the multiple fragment 
heuristic, via a dynamic closest pair data structure FastPair. Second, we propose two 
new techniques, 3D planarization and 3D relaxation, to minimize the wire/power cost 
and to reduce the TSV number, respectively. Experiments show the practicality of our 
algorithm by producing comparable scan-stitching wire length (and total power 
dissipation) to the GA method with a two-order speedup on average. 
 
As a result, the contributions of this work can be summarized as: 
â€¢ Formulate scan-chain ordering considering TSV constraints into a modified 
TSP problem. 
â€¢ Propose a greedy algorithm for scan-chain ordering of 3D-IC designs to 
simultaneously minimize wire and power costs. 
â€¢ Demonstrate that the proposed algorithm can be practically used while 
supporting multiple scan chains. 
 
 
 13 
 
âˆ‘ |ğ‘¥ğœ‹(ğ‘–) âˆ’ ğ‘¥ğœ‹(ğ‘–âˆ’1)| + |ğ‘¦ğœ‹(ğ‘–) âˆ’ ğ‘¦ğœ‹(ğ‘–âˆ’1)|ğ‘›âˆ’1ğ‘–=1              (1) 
 
In Equation (1), xÏ€(i) and yÏ€(i) denote the x and y coordinates of the ith scan FF in 
the scan-FF ordering, respectively. All scan FFs are placed on the same plane and the 
cost of scan-stitching wire is defined as the sum of the Manhattan distances between 
two consecutive FFs, ci and ci+1, in this formulation. However, since FFs can be 
located across different layers for 3D-IC designs, the TSV cost for connecting two 
cross-layer FFs needs to be considered and the layer information of FFs needs to be 
included. 
{(x0, y0, L0), (x1, y1, L1),â€¦, (xnâˆ’1, ynâˆ’1,Lnâˆ’1)} 
 
The total cost of scan-stitching wire is modified as follows: 
 
âˆ‘ |ğ‘¥ğœ‹(ğ‘–) âˆ’ ğ‘¥ğœ‹(ğ‘–âˆ’1)| + |ğ‘¦ğœ‹(ğ‘–) âˆ’ ğ‘¦ğœ‹(ğ‘–âˆ’1)|ğ‘›âˆ’1ğ‘–=1 + ğ¶ğ‘‡ğ‘‡ğ‘‡ Ã— |ğ¿ğœ‹(ğ‘–) âˆ’ ğ¿ğœ‹(ğ‘–âˆ’1)|  (2) 
 
In Equation (2), CTSV denotes the equivalent scan-stitching wire cost for one 
TSV connecting two consecutive layers. Generally, CTSV can be defined as the height 
of one TSV. Moreover, considering manufacturability and yield loss, the total number 
of TSVs in use becomes a constraint to this problem and can be expressed as 
 
ğ‘ğ‘‡ğ‘‡ğ‘‡ = âˆ‘ |ğ¿ğœ‹(ğ‘–) âˆ’ ğ¿ğœ‹(ğ‘–âˆ’1)|ğ‘›âˆ’1ğ‘–=1                   (3) 
 
According to the modified formulation for the TSV constrained scan-chain 
ordering problem, two approaches are proposed in [17]. One approach is developed 
on the basis of Genetic Algorithm (GA), and the other is based on Integer Linear 
Programming (ILP). Although the GA approach may possibly find the near-optimal 
solution, the quality of one identified solution cannot be guaranteed. Moreover, the 
ILP approach, which will find the optimal cost, may not be able to produce a feasible 
solution within a limited time. The experimental result in [17] shows a lower-bound 
value on the total scan-stitching wire cost, which was obtained quickly through the 
ILP approach without providing a detailed ordering of scan FFs. 
 15 
designs. 
 
1) Estimation of Power Dissipation: Previous power-optimized ordering 
techniques focus on both the total power and the peak power consumption. The total 
power consumption is the sum of power consumed during testing and the peak power 
consumption is the highest power consumption used among all test patterns. 
Therefore, the dynamic power consumption can be expressed as: 
 
 P = 0.5ãƒ»ğ¶ğ‘™ğ‘‘ãƒ»ğ‘‰ğ‘‘ğ‘‘2 ãƒ»Fãƒ»S                   (4) 
 
where P is the dynamic power consumption, Cld is the load capacitor, Vdd is the 
supply voltage, S is the switching activity, and F is the clock frequency, respectively. 
 
 According to Equation (4), the power consumption during scan-shift operations 
is highly correlated with the switching activities in the CUT. In practice, it is 
time-consuming to count the exact number of all switching activities in the CUT, but 
the number of scan-chain transitions and the triggered transitions of logic elements in 
CUT are proven highly correlated in [11]. In other words, the number of transitions in 
the scan chain is a good estimation for total switching activities in the CUT. 
 
 Total switching activities in the CUT during scan-shift operations depend on the 
transitions in the scan chain and the corresponding positions. Thus, the number of 
Weighted Transitions (WT) can be defined as follows, 
 WT = ï¿½(ğ‘ ğ‘–ğ‘§ğ‘’ âˆ’ ğ‘ğ‘œğ‘ ğ‘–ğ‘¡ğ‘–ğ‘œğ‘›) 
 
where WT represents the real switching activities in the CUT, size is the total number 
of scan FFs, and position is indexed from the different beginning locations between 
the input vector and output response. Hence, every transition in the input vector or the 
output response has its own weight to reflect the real condition. Defined below are 
several necessary notations used in the weight transitions throughout the remainder of 
the paper: 
ï¬ {c0, c1,â€¦, cnâˆ’1}: n scan FFs in the CUT C. 
ï¬ O =ã€ˆcÏ€(0), cÏ€(1), . . . , cÏ€(nâˆ’1)ã€‰: Scan-chain ordering with n scan FFs. 
ï¬ V = {v0, v1,â€¦ , vnâˆ’1}: n-bit input pattern where vi is scanned in the scan FF 
ci during scan testing. Therefore,ã€ˆvÏ€(0), vÏ€(1), . . . , vÏ€(nâˆ’1)ã€‰ represents an 
 17 
 
Figure 2.3: Calculations for weighted transitions 
 
 19 
the proposed algorithm. Further details are provided in Section 2.3. 
 
2.2.3 Wire-and-power cost minimization problem 
  
Two previous 3D-IC scan-chain ordering problem (with different objectives) are 
reviewed. One is to minimize the total cost of scan-stitching wire cost; the other is to 
minimize the scan-induced power cost during testing. In a more advanced case, we 
would like to simultaneously consider wire and power costs. Cost function in this new 
problem is combined from the wire and power cost function. 
 
The problem of scan-chain ordering to minimize the power and wire cost 
simultaneously can be formulated into: 
Input: CUT C with n scan cells {c0, c1, . . . , cnâˆ’1}, their layer information 
{L0,L1, . . . ,Lnâˆ’1}, and a fixed set of m test patterns {V1, R1, V2, R2, . . . , 
Vm, Rm}. 
Output: Scan-cell ordering is formed as followsã€ˆcÏ€(0), cÏ€(1), . . . , cÏ€(nâˆ’1)ã€‰ such 
that the combined cost ((1 âˆ’ Î±) Ã— wire cost + Î± Ã— power cost) is 
minimized under a TSV constraint. 
  
 The same flow illustrated in Figure 2.2 is used again to solve the combined-cost 
optimization problem. Experimental results in Section IV will also show that the 
proposed algorithm can efficiently minimize the combined cost when ordering scan 
FFs. 
 
2.3 A fast scan-chain ordering 
 
In this section, the proposed algorithm is elaborated with respect to different 
objectives, including wire-cost minimization in Section 2.3-A, power-cost 
minimization in Section 2.3-B, and wire-and-power (combined) cost minimization in 
Section 2.3-C, respectively. 
 
2.3.1 Minimizing wire cost 
 
According to Figure 2, in stage 1, a state-of-the-art tour-construction heuristic 
used in TSP problems, multiple fragment heuristic [20], is incorporated. Moreover, a 
dynamic closest-pair data structure, FastPair [21], is implemented to facilitate the 
considerable computation of pair-wise cost in the tour-construction heuristic. An 
initial solution is obtained in stage 1 and sent to stage 2 to perform 3D planarization to 
 21 
Figure 2.4(c). 
 
In Algorithm 2.1, the closest-pair computation in line 4 realized by different 
implementations can result in different performances. To the best of our knowledge, 
FastPair is one of the best data structures and first proposed for handling dynamic 
closest-pair problems with pair-wise cost functions [21]. It behaves similar to the 
neighbor heuristic where each point stores its own nearest neighbor, but differs from 
the creation of initial neighbor values. Before exploring FastPair, we first outline the 
concept of the neighbor heuristic where each point p stores its nearest point from the 
point set S based on the following equation: 
 d(p) = ğ‘šğ‘–ğ‘›ğ‘âˆˆğ‘‡âˆ’{ğ‘}ğ·(ğ‘, ğ‘)                   (10) 
 
where D(p, q) is a user-defined function and computes the distance between scan FFs. 
That is, 
 D(p, q) = |xp âˆ’ xq| + |yp âˆ’ yq| + cTSV Ã— |Lp âˆ’ Lq|   (11)  
Three operations of insertion, deletion, and query are employed by the neighbor 
heuristic to maintain nearest neighbors. A query scans over distances and selects the 
smallest one. This process is illustrated in Figure 2.5. Figure 2.5 (a) shows the 
initialization of one neighbor heuristic. The nearest neighbors of nodes 1, 6, and 7 are 
nodes 2, 5, 6, respectively; the node pairs (2, 3) and (4, 5) are the closest nodes to 
each other. After deleting node 5, node 4 and node 6 need to update their closest nodes 
to be node 3 and node 4, respectively. The corresponding result is illustrated as Figure 
2.5 (b). 
 
FastPair is developed on the basis of the neighbor heuristic with some 
improvements. Instead of computing all possible distances, FastPair is initialized as a 
single directed path. This structure has the advantage of requiring only one update 
after deleting one node, which differs from the neighbor heuristic. Figure 2.6 shows 
an example. In Figure 2.6 (a), a single directed path is formed as 1 â†’ 2 â†’ 3 â†’ 4 
â†’ 5 â†’ 6 â†’ 7. In the beginning, node 1 checks all other points and finds the 
min-cost point. Then, node 2 checks nodes 3, 4, 5, 6, and 7 without node 1. Finally, 
node 6 only checks one node, node 7, and connects to it. Therefore, such initialization 
can be explained by a graph that depicts how each node finds its closest node by only 
checking the nodes that have not been connected. The FastPair heuristic only updates  
 23 
the closest node for node 4 after deleting node 5 in Figure 2.6 (b). Overall, the 
FastPair heuristic runs in the time complexity of O(n2) and outperforms the neighbor 
heuristic empirically according to [21]. A comparison of run time for deleting an 
object and querying the closest pair among several different closest pair data 
structures is thoroughly surveyed; FastPair is known so far to be the best one for many 
applications. Therefore, considering time efficiency, FastPair and its operations are 
incorporated when developing our multiple-fragment-heuristic-based algorithm. 
 
 
Figure 2.6: Illustration of the application of the FastPair method 
 
2) Local Refinement and Constraint Solving: After obtaining the initial solution, 
the second stage of our algorithm applies two strategies to optimize total wire cost 
and/or to relax TSVs in use. Figure 2.7 (a) shows an initial path with the un-optimized 
wire cost. In the study of the optimization theory, 2D planarization is one common 
technique to reduce the total cost in the TSP problem. The key idea behind this is to 
planarize a graph and remove all cross edges on the plane. A modified tour with 
cross-edge removal results in a shorter cost than that from the initial tour. Figure 2.7 
(b) shows such an example. Cross edges, (2, 6) and (3,7) are replaced by edges (2,3) 
and (6,7). 
 
 25 
number of TSVs in use and to satisfy the TSV constraint. 3D relaxation reverses all 
fragments of 1 to (n-1) edges again to find the best reduction of TSVs in use until the 
target number is achieved. Later, 3D planarization is also performed to further reduce 
the total wire cost but it uses no extra TSVs. Figure 2.9 shows an example that 
illustrates the 3D relaxation process. The left part of Figure 9 represents an initial 
scan-chain ordering: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5. After reversing the fragment 2 â†’ 3 
â†’ 4 to 4 â†’ 3 â†’ 2, the total number of TSVs in use can be effectively reduced and 
shown as the right part in Figure 2.9. Two new reversed fragments, 1 â†’ 2 to 1 â†’ 4 
and 4 â†’ 5 to 2 â†’ 5, save six TSVs in use. 
 
 
 
Figure 2.8: Example of 3D Planarization 
 
 27 
stores the pair-wise transitions is established to avoid repeated calculations in the 
proposed algorithm. After constructing the scan-chain ordering, the sum of the total 
transitions between scan FFs is minimized by the multiple fragment heuristic. 
Furthermore, we improve the total weighted transitions by rotating it n times and 
choose the best solution. Figure 2.3 shows an example where the total scan-induced 
transitions between scan FFs are accumulated in the first row (Total Trans). Although 
the sum of the total transitions are the same, the power-optimized ordering shown in 
Figure 3(b) has better total weighted transitions by rotating the initial ordering SC1 
â†’ SC2 â†’ SC3 â†’ SC4 three times into SC2 â†’SC3 â†’SC4 â†’SC1. 
 
Although the construction of the look-up table takes more time than the cost 
computation in the scan-stitching wire minimization problem, the time complexity is 
still O (n2) and it outperforms the technique proposed in [22]. 
 
2.3.3 Minimizing wire-and-power cost simultaneously 
 
In the problem, the wire and power costs are optimized simultaneously to 
determine the scan-chain ordering. The flow to solve the combined-cost optimization 
problem is similar to the previous problems. According to the problem formulation, 
the inputs to the algorithm are test patterns and layout information, and the objective 
is to optimize the combined cost including the wire and power costs. 
 
For computing the initial solution, we combine the user-defined function D(p, q) 
in Equation (11) and Equation (12) to count the combined cost between scan FFs 
considering m test patterns. That is: 
 
ğ·(ğ‘, ğ‘) = (1 âˆ’ ğ›¼) Ã— ğ·ğ‘¤ğ‘–ğ‘¤ğ‘¤(ğ‘, ğ‘) + ğ›¼ Ã— ğ·ğ‘ğ‘ğ‘¤ğ‘¤ğ‘¤(ğ‘, ğ‘)            (13) 
 
where Dwire (p, q) and Dpower (p, q) are shown in Equation (12) and Equation (11). 
User-defined coefficient Î± ranges from 0 to 1. When Î± = 0, this problem becomes 
a pure wire cost minimization problem. While Î± = 1, only power cost is considered, 
as in the power-cost minimization problem. 
 
 
 
 
 
 
 29 
priority function only considers power gain, mobility and computation density for 
each task independently while neglecting the overall gains and losses from scaling 
down the frequency of one task candidate. To alleviate such problem, Wu et al. from 
[41] proposed an energy-efficient task scheduling algorithm via DVFS at the system 
level and formulated an priority gain function considering both gains and losses for 
selecting tasks to be scaled. Figure 3.1 (a) shows the result in [41] for scheduling 31 
tasks on 3D processors with eight cores considering transmission cost under a timing 
constraint 15. In summary, all the previous works used fixed task-to-core mapping 
strategies where many slack spaces can be further utilized. 
 
To take Figure 3.1 (a) for example, an exploration of the slack slots is conducted 
after applying DVFS. Due to the fixed task-to-core mapping, many time slots 
(denoted a .x. in Figure 3.1 (a)) can be further utilized. For example, if we move task 
N2 from core 001 to core 010 using a slower frequency as shown in Figure 3.1 (b), the 
remaining spaces can be better utilized and thus the energy-saving rate is improved.  
 
Built on top of the previous task-scheduling algorithms [40] [41], two dynamic 
task-to-core mapping strategies, Dynamic Remapping (DR) and Iterative Dynamic 
Remapping (IDR), are proposed to reduce slack slots and to improve Energy-Saving 
Rate (ESR). Experimental results show that ESR of the algorithm with the IDR 
strategy is 16 percent higher than the previous work [41] on average. Moreover, 
compared to an ILP solution, both two proposed strategies can run at least three-order 
faster and achieve comparable performance on energy saving. 
 
The rest of this work is organized as follows. Section 3.2 formulates the problem 
of this work. In Section 3.3, the framework of task-to-core mapping and scheduling 
with DVFS based on [40] and [41] is presented. Two dynamic task-to-core remapping 
strategies are elaborated in Section 3.4. Section 4.2 provides the experimental result to 
show the energy efficiency of modified algorithms compared with a previous work 
[41] and an ILP solution. Finally, Section 5 concludes this paper. 
 31 
3.2 Problem formulation 
 
In this work, the core problem is how to find a schedule which can achieve the 
best energy efficiency on 3D multi-core processors. Figure 3.2 (a) is such a sample 
schedule which assigns 31 tasks to eight cores on a 3D processor under a timing 
constraint 20. Input information required by a schedule includes a task graph, a timing 
constraint, a resource constraint and an energy model. All tasks after scheduling must 
be assigned to one core in a correct execution order. Moreover, energy minimization is 
the objective for schedule where energy-saving rate is defined to approximate the 
energy efficiency of the computed schedule. 
 
3.2.1 Data flow graph 
 
One of the input data for scheduling is an unscheduled task graph. A task graph is 
also called a Data Flow Graph (DFG) that usually describes the behavior of design. 
Figure 3.2 (b) shows an example of a task graph with 31 nodes. Precedent constraint 
refers to the situation that a node vi connected by a directed edge to a node vj under 
the constraint that vj can start execution if and only if vi finishes completely. 
 
3.2.2 Timing versus Resource Constraint 
 
A Critical Path of a DFG is defined as the longest path that the summation of 
execution time of the nodes in the path is the maximum among all paths. In our work, 
the timing constraint can be specified by the user but is required to be larger than the 
length of the critical path. 
 
3D multi-core processors are illustrated as Figure 3.3 where both the number of 
cores per layer and the number of layers are parameters in our work. The transmission 
cost between any two cores is also considered and can be specified by users. We 
denote the transmission cost on the same core as Î±, to the neighboring core on the 
same layer as Î², and to a neighboring core on the neighboring layer as Î³. Given 
Figure 3.2 and Figure 3.3, task N17 is assigned to core 010, and task N20 (a successor 
of task N17) is assigned to core 100. The transmission cost between these two tasks is 1 Ã— Î² + 1 Ã— Î³. 
 
 
 
 33 
 
Figure 3.3: Transmission cost in a 3D multi-core processor 
 
3.2.3 Energy model 
 
To minimize energy consumption, an energy model needs to be incorporated into 
the DVFS technique. The number of the allowable voltage levels determined by the 
designer's preference and the manufacturing technology. Figure 3.4 shows voltage 
versus latency curve from [31]. In [41], the energy model in Table 3.1 was proposed 
based on [31] and includes 3 voltage levels: 5V, 3V and 2.4V. In this work, energy 
consumption can be defined as the execution delay multiplied by the power. We use 
such energy model to perform the voltage scaling. As shown in the energy model, the 
increase of execution-delay for each task from 5V to 3V and 3V to 2.4V are the same 
and the gain of energy reduction by lowering down a task from 5V to 3V and 3V to 
2.4V are 17t and 3.2t, respectively. 
 
 
Table 3.1: Energy model 
 
 
 
 
 35 
operation are computed. Second, task-to-core mapping decides the core that a task 
runs on and its execution order. After task-to-core mapping, the initial energy of each 
task t 5V can be derived. Later, a task candidate set is computed based on a gain 
function and tasks with the highest rankings take turn to be selected for voltage 
scaling. Last, the energy-saving rate is derived to evaluate the energy efficiency of the 
schedule computed by the ORI algorithm. The pseudocode of the ORI algorithm is 
shown below. 
 
 
 
 
 
 
 37 
3.3.1 Task-to-core mapping 
 
In the baseline algorithm, task-to-core mapping is computed by 
List-Scheduling-based approach [42] [43] (through a dynamic priority list). The ready 
tasks are stored in the dynamic priority list for each time slot of each core. A task is 
ready to be mapped to a core if and only if all of its predecessors are mapped and the 
core mapping of such task satisfies its transmission constraint. The priority of tasks 
mapping to core is decided by their mobility: 
 
ğ‘šğ‘œğ‘ğ‘–ğ‘™ğ‘–ğ‘¡ğ‘¦ =  ğ´ğ¿ğ´ğ‘ƒ â€“  ğ´ğ‘†ğ´ğ‘ƒ        (15) 
 
A task with a lower mobility has the higher priority to be mapped. Mapping each 
task in the dynamic priority list to its free core needs to consider the dependence of 
the given DFG. Furthermore, a task is preferred to be mapped to the same core with 
its predecessor to avoid generating additional dependency. 
 
3.3.2 Voltage scaling 
 
After the task-to-core mapping, the remaining space can be further reduced by 
rescheduling tasks using DVFS which changes the voltage level and increases the 
execution time for a task. All tasks with space_rate â‰¥ 1 are selected to be the candidate 
for voltage scaling where the space_rate is: 
 
ğ‘ ğ‘ğ‘ğ‘ğ‘’_ğ‘Ÿğ‘ğ‘¡ğ‘’ =  mobility
ğ‘‘ğ‘¤ğ‘™ğ‘ğ‘¦
           (16) 
 
Variable delay in Equation (16) denotes the execution delay of a task. If a task 
with space rate < 1, there are not enough slack slots for scaling down the frequency of 
a task. After constructing the task candidate set, each task with the highest gain value 
is selected for voltage scaling. 
 
Another key problem is how to decide the priority of each candidate using the 
gain function, where the gain function of the task candidate Ci can be defined as: 
 Gainğ‘ğ‘£ğ‘¤ğ‘¤ğ‘ğ‘™ğ‘™(ğ¶ğ‘–) =  Gain(ğ¶ğ‘–) âˆ’ Lose(ğ‘ƒğ‘†ğ‘–)     (17) 
 
Gain (Ci) in Equation (18) denotes the gain (energy reduction) after scaling 
 39 
3V) is performed under the initial timing constraint. Only 5V â†’ 3V voltage scaling is 
applied to prevent the failure of task-to-core remapping later. After the first round of 
voltage scaling, the changed ASAP time and ALAP time of each task are updated. In 
the second round, mobility of each task need to be recomputed and then the 
task-to-core remapping and voltage scaling (5Vâ†’ 3V and 3V â†’ 2.4V) are applied 
under the timing-constraint limit, respectively. Task-to-core remapping is also 
computed by List-Scheduling-based approach [42] [43] and the priority of tasks 
remapping to core is decided according to their mobility. After the task-to-core 
remapping, the distribution of executed tasks on each core can be more uniform. 
 
Figure 3.7 and Figure 3.8 show the example of scheduling 31 tasks with the DR 
strategy on 3D processors with eight cores. The initial timing constraint is set to be 16 
(starting from 1.05 critical path length) and the timing constraint limit is set to be 20. 
Figure 3.7 (a) and Figure 3.7 (b) show the first round of the DR strategy including 
task-to-core mapping and voltage scaling with 5V â†’ 3V under a given timing 
constraint 16, respectively. After the voltage scaling in the first round, the distribution 
of executed tasks on each core is unbalanced. Especially on core 010, 18 slack slots 
are available. In the second round, the task-to-core remapping is applied to the result 
in Figure 3.8 (a) under the timing constraint limit 20, then voltage scaling 5Vâ†’ 3V 
and 3V â†’ 2:4V are applied as shown in Figure 3.8 (b). Comparing Figure 3.7 (b) with 
Figure 3.8 (a), after the task-to-core remapping in the second round, the distribution of 
executed tasks on each core is found more balanced. Hence, a higher energy-saving 
rate is achieved after the voltage scaling in the second round. The final energy-saving 
rate of the DR strategy is 55.32 percent more than that from the ORI method on the 
same case. 
 
 
 
 
 
 
 41 
 
Figure 3.7: First stage of DR strategy under a timing constraint 16 
 
Figure 3.8: Second stage of DR strategy under a timing constraint 20 
 43 
 
 
For example, scheduling 31 tasks with the IDR strategy on a 3D processor with 
eight cores is illustrated. In the first round of the IDR strategy under a initial timing 
constraint 16, task-to-core mapping and voltage scaling with 5V â†’  3V are 
performed as in Figure 3.7 (a) and Figure 3.7 (b). Then, the current timing constraint 
is relaxed to 17. In the second round, task-to-core remapping and voltage scaling with 
5V â†’  3V under the timing constraint 17 are performed, respectively. In the 
following rounds (the third and fourth rounds), task-to-core remapping and voltage 
scaling with 5V â†’ 3V are performed under the timing constraint 18 and 19. At last, 
when the current timing constraint is 20, we perform task-to-core remapping and 
voltage scaling (5V â†’  3V and 3V â†’  2.4V ) in the final round. The final 
energy-saving rate of the IDR strategy is 63:17 percent more than that from the ORI 
method on the same case. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 45 
In Figure 4.1, we also perform logic synthesis and scan insertion for the original 
design and then retrieve the test information via Standard Test Interface Language 
(STIL) files by using TetraMax. Two input data, including the layout information and 
test patterns, are achieved to reduce the scan induced power by performing the 
proposed algorithm. Using the same input data, we also perform the proposed 
algorithm by simultaneously considering wire and power costs. 
 
For an objective comparison, the settings used in the previous GA approach [17] 
are employed here. The population size is set to 2000; the same operators are used, 
which include reproduction, crossover, and mutation. The GA stops when no more 
than 0.0001 percent improvement on the fitness score (i.e., the total scan-stitching 
wire length or total weighted transitions) can be obtained for the last 1000 
generations. 
 
 Both the proposed 3D scan-chain ordering algorithm and the previous GA 
approach are exercised on a Linux machine with a Pentium Core Duo (2.4 GHz) 
processor and 4 GB memory. TSMC .18Î¼m library is used and the height of a TSV is 
set as 10Î¼m while the partitions for 3D ICs range from 3 to 5. ISCASâ€™89 benchmark 
circuits and two large 3D-IC designs from [23] are used to conduct experiments. 
 
 All experiments are divided into four parts. The first part minimizes the 
scan-stitching wire cost. The second part reflects the results of the scan-induced 
power dissipation reduction. The third part identifies the best scan-chain ordering 
while simultaneously considering wire-and-power costs. It is natural to use multiple 
scan chains to prevent long test-application time when the total number of scan FFs is 
large. Therefore, the last part applies the proposed algorithm to multiple scan chains 
on two large 3D-IC designs from [23]. 
 
4.1.2 Experimental results 
 
4.1.2.1 Minimizing wire cost 
 
Table 4.1 shows the preliminary performance of our algorithm with TSV 
constraints. The third column shows the TSV usage in the initial ordering. The fourth 
column reports the TSV constraints followed by the TSV usage in the wire-cost 
minimized ordering. The fifth and sixth columns show the total wire cost in Î¼m after 
performing 3D relaxation and 3D planarization, respectively. Both solutions can 
satisfy the related TSV constraints. The seventh column reports the reduction rate 
 47 
method and the proposed algorithm, respectively. The sixth column shows the 
improvement ratio of our approach compared with the GA method. The seventh and 
eighth columns report run time in seconds for our algorithm and the GA method, 
respectively. The last column shows the speed-up rate of our algorithm compared with 
the GA method. The run time of the proposed algorithm is proportional to the number 
of iterations used to perform 3D planarization and circuit size. Although the proposed 
algorithm results in the slightly inferior total cost on s15850, it produces comparable 
or even better results than the GA method on all other larger circuits. Moreover, the 
proposed algorithm can run at least two-orders faster than the GA method. 
 
 
Table 4.2: Wire length and runtime comparison with different TSV constraint 
 
4.1.2.2 Minimizing power cost 
 
Table 4.3 shows the performance of our algorithm with the TSV constraint. In 
this case, the information for the number of layers for all circuits are shown. The third 
column shows the TSV usage in the initial ordering. The fourth column reports the 
TSV usage in the power-cost minimized ordering and the TSV constraints. The fifth 
and sixth columns show the total weighted transitions after performing 3D relaxation 
and 3D planarization, respectively. The seventh column also reports the reduction rate 
from two proposed techniques during stage 2. 
 
Table 4.3 also shows good reduction in the total number of TSVs on the big 
circuits, especially on s35932. Particularly, the five-layer s35932 has the best 
 49 
 
Table 4.4: Power dissipation and runtime comparison with different TSV constraint 
 
4.1.2.3 Considering wire-and-power costs simultaneously 
 
We further perform the proposed algorithm under TSV constraints while 
simultaneously considering wire and power costs. Table 4.5 and table 4.6 report the 
results of comparing the wire-and-power costs between the GA method and our 
algorithm under TSV constraints 20 for circuit s1423 (total number of FFs is 74) and 
circuit s5378 (total number of FFs is 179) with three-layer partitions. The first column 
specifies the coefficient Î± in Equation (13) from 0 to 1. The second and third 
columns show the total wire cost after performing the GA method and the proposed 
algorithm, respectively. The fourth column shows the improvement ratio of our 
approach to the GA method. The fifth and sixth columns show the total power cost 
after performing the GA method and the proposed algorithm, respectively. The 
seventh column also shows the improvement ratio of our approach compared with the 
GA method. The last column shows the speed-up rate of our algorithm compared with 
the GA method. Similarly, the proposed algorithm produce comparable or even better 
results with at least two-orders run time speedups to the GA method. 
 
 51 
show the total weighted transitions under different coefficient values after performing 
the GA method and the proposed algorithm, respectively. According to Figure 4.2 and 
Figure 4.3, as the coefficient increases, power cost decreases but wire cost increases, 
and vice versa. The coefficient Î± can be adjusted by users at their discretion. Again, 
the proposed algorithm can result in comparable or even better wire and/or power cost 
compared with the result from the GA method. 
 
 
 
 
Figure 4.2: Comparison among GA and our algorithm for considering power and wire 
simultaneously on circuit s1423 
 
 53 
increases, the power cost decreases but the wire cost increases. The combined cost for 
bench 2 and bench 7 can be computed in seconds; thus, the efficiency of the proposed 
algorithm is demonstrated. In summary, our algorithm is capable of supporting 
multiple scan chains after scan partitioning. 
 
 
 
 
Figure 4.4: 24 scan chains for circuit bench2 (50K gates with 4095 FFs) 
 
 
 
 
 
Figure 4.5: 108 scan chains for circuit bench7 (385K gates with 17983 FFs) 
 
 
 
 
 
 55 
 
Table 4.7 demonstrates the efficiency of three methods. The energy-saving rate 
of ILP-based method is 55.24 percent on average. The energy-saving rate of ORI 
method is 48.60 percent and their difference is 12.40 percent on average. The 
energy-saving rate of DR method is 53.14 percent and their difference between DR 
and ILP is 3.82 percent on average. The energy-saving rate of IDR method is 53.87 
percent and their between IDR and ILP is 2.54 percent on average. Experimental 
result shows our two dynamic remapping methods are superior to the baseline method 
by achieving a comparable performance as ILP. Besides, two proposed methods only 
take less than 1 second to complete, resulting in 300X to 11, 000X speedups when 
comparing to the ILP-based method. 
 
 
 
 
Table 4.7: Energy-saving rate (ESR) and the ESR Difference (Î”ESR) of different 
mapping strategies 
 
 
 
4.2.2.2 Compare different strategies with transmission costs 
 
In this section, we only compare the dynamic-remapping scheduling algorithms 
with the baseline algorithm when considering transmission cost. We further tested two 
dynamic remapping strategies on graphs with node size 50, 100, 300, 500 and 1000, 
and randomly selected 10 cases of each size. Table 4.8 shows the settings of 3D 
multi-core processors with transmission costs (Î± = 0, Î² = 2 and Î³ = 1). Timing 
constraints were set from 1.2X to 1.5X Critical-Path Length (CPL) for each case. For 
the DR and IDR methods, we set the initial timing constraint 1.05X CPL. For the IDR 
method, the timing constraint increases 0.1X CPL for each round of voltage scaling. 
 57 
 
Table 4.9: Comparison of energy-saving rates (ESRs) and ESR improvement (+ESR) 
 
 
 
 
 
 
 
 
 
 
 
 
 
 59 
Experimental results show the solutions from the two task-to-core remapping 
strategies are more close to the ILP solution where IDR only has 2.54 percent 
difference. Besides, two proposed methods can run 300X to 11,000X faster than the 
ILP method. Our experiments also show that the energy-saving rate of the IDR 
method can achieve 16 percent higher than that of the baseline algorithm on average. 
As a result, the scheduling algorithm with dynamic task-to-core remapping can result 
in more energy efficient scheduling than that with a fixed task-to-core mapping. 
 
Based on such result, the scheduling algorithm with dynamic task-to-core 
remapping can result in more energy efficient scheduling than that with a fixed 
task-to-core mapping. We also implemented an ILP-based method for an optimal 
solution without considering the transmission costs between cores. The experimental 
results show IDR strategy can achieve comparable performance as the ILP and the 
energy-saving difference between IDR and ILP is only âˆ’2.54 percent on average. 
However, in our future work, we would like to further validate our IDR strategy 
considering transmission costs between cores. Hence, the problem is formulated into 
Quadratic Programming (QP) and compared to the IDR solution considering the 
transmission costs between cores. However, the scalability problem of QP-based 
method is more sever with transmission costs. Therefore, scheduling with a larger task 
graph is implemented into Genetic Algorithm (GA) and also compared to our IDR 
solution.  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 61 
Virazel, â€œDesign of routing-constrained low power scan chains,â€ in DATEâ€™04: 
Proceedings of the conference on Design, automation and test in Europe. Washington, 
DC, USA: IEEE Computer Society, 2004, p. 10062. 
[14] X.-L. Huang and J.-l. Huang, â€œA routability constrained scan chain ordering 
technique for test power reduction,â€ in Design Automation, 2006. Asia and South 
Paciï¬c Conference on, 24-27 2006, p. 5 pp. 
[15] B. Paul, R. Mukhopadhyay, and I. Gupta, â€œGenetic algorithm based scan chain 
optimization and test power reduction using physical information,â€ in TENCON 2006. 
2006 IEEE Region 10 Conference, 14-17 2006, pp. 1 â€“4. 
[16] Y.-Z. Wu and M.-T. Chao, â€œScan-chain reordering for minimizing scan-shift 
power based on non-speciï¬ed test cubes,â€ in VLSI Test Symposium, 2008. VTS 2008. 
26th IEEE, april 2008, pp. 147 â€“154. 
[17] X. Wu, P. Falkenstern, K. Chakrabarty, and Y. Xie, â€œScan-chain design and 
optimization for three-dimensional integrated circuits,â€ J. Emerg. Technol. Comput. 
Syst., vol. 5, no. 2, pp. 1â€“26, 2009. 
[18] D. Lewis and H.-H. Lee, â€œA scan island based design enabling prebond 
testability in die-stacked microprocessors,â€ in Test Conference, 2007. ITC 2007, 
IEEE International, oct. 2007, pp. 1 â€“8. 
[19] A. Kumar, S. Reddy, I. Pomeranz, and B. Becker, â€œHyper-graph based 
partitioning to reduce dft cost for pre-bond 3d-ic testing,â€ in Design, Automation Test 
in Europe Conference Exhibition (DATE), 2011, March 2011, pp. 1 â€“6. 
[20] J. L. Bentley, â€œExperiments on traveling salesman heuristics,â€ in SODA â€™90: 
Proceedings of the ï¬rst annual ACM-SIAM symposium on Discrete algorithms. 
Philadelphia, PA, USA: Society for Industrial and Applied Mathematics, 1990, pp. 
91â€“99. 
[21] D. Eppstein, â€œFast hierarchical clustering and other applications of dynamic 
closest pairs,â€ J. Exp. Algorithmics, vol. 5, p. 1, 2000. 
[22] C. Giri, S. K. Roy, B. Banerjee, and H. Rahaman, â€œScan chain design targeting 
dual power and delay optimization for 3d integrated circuit,â€ Advances in Computing, 
Control, and Telecommunication Technologies, International Conference on, vol. 0, 
pp. 845â€“849, 2009. 
[23] â€œTaiwan integrated circuit computer-aided design (ic/cad) contest, http : //cad 
contest.cs.nctu.edu.tw/cad11/,â€ 2011. 
[24] 'International Technology Roadmap for Semiconductors (ITRS)', 
http://www.itrs.net/ 
[25] Kahle, J. and Day, M. and Hofstee, H. and johns, C. and Maeurer, T.and Shippy, 
D.: 'Introduction to the Cell multiprocessor', IBM Journal of Research and 
Development, July, 2005, 49, (4/5), pp. 589-604 
 63 
2, (2), pp. 81-97 
[40] Wu, C.-B., Lin, Y.-L.: 'Energy-Ef_cient Task Scheduling for DVFS-Multi-Core 
3D IC'. Master thesis, National Tsing Hua University, 2010 
[41] Gajski, D. D. and Dutt, N. D. and Wu, A. C.-H. and Lin, S. Y.-L.: 
'Scheduling','High-Level Synthesis: Introduction to Chip and System Design'(Springer, 
1992, 1st edn.), pp. 213-258 
[42] Adam, T. L. and Chandy, K. M. and Dickson, J. R.: 'A comparison of list 
schedules for parallel processing systems'. ACM, Commun. 1974, 17, (12), pp. 
685-690 
[43] 'Standard Task Graph Set, Kasahara Laboratory Department of Electrical, 
Electronics and Computer Enginnering, Waseda University', 
http://www.kasahara.elec.waseda.ac.jp/schedule/index.html 
[44] Chandrakasan, A. P. and Potkonjak, M. and Mehra, R. and Rabaey, J. and 
Brodersen, R.: 'Optimizing power using transformations', IEEE Trans. on 
Computer-Aided Design of Integrated Circuits and Systems., Jan, 1995, 14, (1), pp. 
12-31 
 
99 å¹´åº¦å°ˆé¡Œç ”ç©¶è¨ˆç•«ç ”ç©¶æˆæœå½™æ•´è¡¨ 
è¨ˆç•«ä¸»æŒäººï¼šæº«å®æ–Œ è¨ˆç•«ç·¨è™Ÿï¼š99-2220-E-009-039- 
è¨ˆç•«åç¨±ï¼šé‡å° 3D æ•´åˆä¹‹é›»å­è¨­è¨ˆè‡ªå‹•åŒ–æŠ€è¡“é–‹ç™¼--å­è¨ˆç•«äº”ï¼šæ‡‰ç”¨åœ¨é©—è­‰èˆ‡æ¸¬è©¦ 3D IC æ•´åˆéç¨‹ä¸­
ä»¥è¨ˆç®—æ™ºæ…§ç‚ºåŸºç¤çš„æ¸¬è©¦å‘é‡ç”¢ç”Ÿæ–¹æ³•(2/2) 
é‡åŒ– 
æˆæœé …ç›® å¯¦éš›å·²é”æˆ
æ•¸ï¼ˆè¢«æ¥å—
æˆ–å·²ç™¼è¡¨ï¼‰
é æœŸç¸½é”æˆ
æ•¸(å«å¯¦éš›å·²
é”æˆæ•¸) 
æœ¬è¨ˆç•«å¯¦
éš›è²¢ç»ç™¾
åˆ†æ¯” 
å–®ä½ 
å‚™ è¨» ï¼ˆ è³ª åŒ– èªª
æ˜ï¼šå¦‚æ•¸å€‹è¨ˆç•«
å…±åŒæˆæœã€æˆæœ
åˆ— ç‚º è©² æœŸ åˆŠ ä¹‹
å° é¢ æ•… äº‹ ...
ç­‰ï¼‰ 
æœŸåˆŠè«–æ–‡ 0 0 100%  
ç ”ç©¶å ±å‘Š/æŠ€è¡“å ±å‘Š 1 1 100%  
ç ”è¨æœƒè«–æ–‡ 4 4 100% 
ç¯‡ 
 
è«–æ–‡è‘—ä½œ 
å°ˆæ›¸ 0 0 100%   
ç”³è«‹ä¸­ä»¶æ•¸ 0 0 100%  å°ˆåˆ© å·²ç²å¾—ä»¶æ•¸ 0 0 100% ä»¶  
ä»¶æ•¸ 0 0 100% ä»¶  
æŠ€è¡“ç§»è½‰ 
æ¬Šåˆ©é‡‘ 0 0 100% åƒå…ƒ  
ç¢©å£«ç”Ÿ 0 0 100%  
åšå£«ç”Ÿ 0 0 100%  
åšå£«å¾Œç ”ç©¶å“¡ 0 0 100%  
åœ‹å…§ 
åƒèˆ‡è¨ˆç•«äººåŠ› 
ï¼ˆæœ¬åœ‹ç±ï¼‰ 
å°ˆä»»åŠ©ç† 0 0 100% 
äººæ¬¡ 
 
æœŸåˆŠè«–æ–‡ 2 2 100%  
ç ”ç©¶å ±å‘Š/æŠ€è¡“å ±å‘Š 0 0 100%  
ç ”è¨æœƒè«–æ–‡ 1 1 100% 
ç¯‡ 
 
è«–æ–‡è‘—ä½œ 
å°ˆæ›¸ 0 0 100% ç« /æœ¬  
ç”³è«‹ä¸­ä»¶æ•¸ 0 0 100%  å°ˆåˆ© å·²ç²å¾—ä»¶æ•¸ 0 0 100% ä»¶  
ä»¶æ•¸ 0 0 100% ä»¶  
æŠ€è¡“ç§»è½‰ 
æ¬Šåˆ©é‡‘ 0 0 100% åƒå…ƒ  
ç¢©å£«ç”Ÿ 8 8 100%  
åšå£«ç”Ÿ 1 1 100%  
åšå£«å¾Œç ”ç©¶å“¡ 0 0 100%  
åœ‹å¤– 
åƒèˆ‡è¨ˆç•«äººåŠ› 
ï¼ˆå¤–åœ‹ç±ï¼‰ 
å°ˆä»»åŠ©ç† 0 0 100% 
äººæ¬¡ 
 
åœ‹ç§‘æœƒè£œåŠ©å°ˆé¡Œç ”ç©¶è¨ˆç•«æˆæœå ±å‘Šè‡ªè©•è¡¨ 
è«‹å°±ç ”ç©¶å…§å®¹èˆ‡åŸè¨ˆç•«ç›¸ç¬¦ç¨‹åº¦ã€é”æˆé æœŸç›®æ¨™æƒ…æ³ã€ç ”ç©¶æˆæœä¹‹å­¸è¡“æˆ–æ‡‰ç”¨åƒ¹
å€¼ï¼ˆç°¡è¦æ•˜è¿°æˆæœæ‰€ä»£è¡¨ä¹‹æ„ç¾©ã€åƒ¹å€¼ã€å½±éŸ¿æˆ–é€²ä¸€æ­¥ç™¼å±•ä¹‹å¯èƒ½æ€§ï¼‰ã€æ˜¯å¦é©
åˆåœ¨å­¸è¡“æœŸåˆŠç™¼è¡¨æˆ–ç”³è«‹å°ˆåˆ©ã€ä¸»è¦ç™¼ç¾æˆ–å…¶ä»–æœ‰é—œåƒ¹å€¼ç­‰ï¼Œä½œä¸€ç¶œåˆè©•ä¼°ã€‚
1. è«‹å°±ç ”ç©¶å…§å®¹èˆ‡åŸè¨ˆç•«ç›¸ç¬¦ç¨‹åº¦ã€é”æˆé æœŸç›®æ¨™æƒ…æ³ä½œä¸€ç¶œåˆè©•ä¼° 
â– é”æˆç›®æ¨™ 
â–¡æœªé”æˆç›®æ¨™ï¼ˆè«‹èªªæ˜ï¼Œä»¥ 100 å­—ç‚ºé™ï¼‰ 
â–¡å¯¦é©—å¤±æ•— 
â–¡å› æ•…å¯¦é©—ä¸­æ–· 
â–¡å…¶ä»–åŸå›  
èªªæ˜ï¼š 
2. ç ”ç©¶æˆæœåœ¨å­¸è¡“æœŸåˆŠç™¼è¡¨æˆ–ç”³è«‹å°ˆåˆ©ç­‰æƒ…å½¢ï¼š 
è«–æ–‡ï¼šâ– å·²ç™¼è¡¨ â–¡æœªç™¼è¡¨ä¹‹æ–‡ç¨¿ â–¡æ’°å¯«ä¸­ â–¡ç„¡ 
å°ˆåˆ©ï¼šâ–¡å·²ç²å¾— â– ç”³è«‹ä¸­ â–¡ç„¡ 
æŠ€è½‰ï¼šâ–¡å·²æŠ€è½‰ â–¡æ´½è«‡ä¸­ â– ç„¡ 
å…¶ä»–ï¼šï¼ˆä»¥ 100 å­—ç‚ºé™ï¼‰ 
3. è«‹ä¾å­¸è¡“æˆå°±ã€æŠ€è¡“å‰µæ–°ã€ç¤¾æœƒå½±éŸ¿ç­‰æ–¹é¢ï¼Œè©•ä¼°ç ”ç©¶æˆæœä¹‹å­¸è¡“æˆ–æ‡‰ç”¨åƒ¹
å€¼ï¼ˆç°¡è¦æ•˜è¿°æˆæœæ‰€ä»£è¡¨ä¹‹æ„ç¾©ã€åƒ¹å€¼ã€å½±éŸ¿æˆ–é€²ä¸€æ­¥ç™¼å±•ä¹‹å¯èƒ½æ€§ï¼‰ï¼ˆä»¥
500 å­—ç‚ºé™ï¼‰ 
A.å­¸è¡“æˆå°± 
1.æå‡ºé‡å° scan-chain ordering åœ¨è€ƒæ…®é™ä½ç¹ç·šé•·åº¦æˆ–æ˜¯åŠŸèƒ½æ¶ˆç§çš„æ¼”ç®—æ³•ã€‚ 
2.åœ¨é…åˆ DVFS(å‹•æ…‹é›»å£“é »ç‡è¦åŠƒ)çš„æŠ€è¡“ä¸‹ï¼Œè¨­è¨ˆä¸€å¥— task scheduling çš„æ¼”ç®—æ³•ä¾†é™ä½
IC çš„æ¶ˆç§èƒ½é‡ã€‚ 
3.ç›®å‰æœ‰å››ç¯‡è«–æ–‡ç™¼è¡¨åœ¨åœ‹å…§æœƒè­°ä¸­ (The 22nd VLSI Design / CAD Symposium 2 ç¯‡ï¼Œ2011 
VLSI Test Technology Workshop) 
4.å¦å¤–æœ‰å…©ç¯‡è«–æ–‡å·²æŠ•ç¨¿è‡³åœ‹éš›æœŸåˆŠ(IEEE TVLSI, IET Computer and Digital 
Techniques) 
ä¸‰ç¶­ç©é›»è·¯æ¯”å‚³çµ±çš„äºŒç¶­ç©é«”é›»è·¯æœ‰è‘—è¨±å¤šé¡¯è‘—çš„å„ªå‹¢ï¼Œä½†ä¸‰ç¶­ç©é«”é›»è·¯æ¯”äºŒç¶­ç©é«”é›»è·¯
é¢è‡¨äº†æ›´åš´é‡çš„ç†±å•é¡Œï¼Œå› ç‚ºæˆ‘å€‘æå‡ºäº† task scheduling çš„æ¼”ç®—æ³•ä¸¦é…åˆ DVFS(å‹•æ…‹é›»
å£“é »ç‡è¦åŠƒ)çš„æŠ€è¡“ï¼Œèª¿æ•´æ¯å€‹ task åŸ·è¡Œçš„é›»å£“é »ç‡ï¼Œé€²è€Œå¹³è¡¡ä¸‰ç¶­ç©é«”é›»è·¯ä¸­æ¯ä¸€å±¤çš„
æº«åº¦åˆ†ä½ˆã€‚ 
B.æŠ€è¡“å‰µæ–°ï¼š 
è‰¯ç‡å•é¡Œåœ¨ä¸‰ç¶­ç©é«”é›»è·¯ä¸­æ¥µç‚ºé‡è¦ï¼Œè€Œè‰¯ç‡èˆ‡è£½é€ æˆæœ¬æ¯æ¯ç›¸é—œï¼Œå› æ­¤ Design for 
Testability åœ¨ä¸‰ç©é«”é›»è·¯ä¸­æ›´æ˜¯ä¸å¯æˆ–ç¼ºçš„ä¸€é …æŠ€è¡“ï¼Œscan-chain based çš„æ¸¬è©¦æ˜¯ DFT
ä¸­å¸¸è¦‹çš„æ–¹æ³•ï¼Œæˆ‘å€‘æå‡ºäº†å¿«é€Ÿçš„æ¼”ç®—æ³•ä¾†å¹«åŠ©æˆ‘å€‘æ±ºå®š scan-chain çš„é †åºï¼Œç”¨ä¾†é™ä½
ç¹ç·šé•·åº¦ä»¥åŠåŠŸèƒ½æ¶ˆç§ã€‚ 
C.ç¤¾æœƒå½±éŸ¿ï¼š 
