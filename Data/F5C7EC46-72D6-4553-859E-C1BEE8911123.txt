 In second year (2010-2011), we develop the system 
such that it can support the functionality of data 
forward. In this system, the data owner can securely 
forward the stored data in the distributed storage 
system to another user. The owner does not need to 
retrieve the data back to process it for forwarding 
to another user. The owner simply sends a proxy re-
encryption key to the storage servers and the servers 
re-encrypt the data into a ciphertext that can be 
decrypted by the target user. This method reduces the 
bandwidth requirement dramatically. We have finished 
a manuscript and submitted it to an international 
journal. 
 In the third year (2011-2012), we continue to 
research on distributed storage systems. Based on the 
results of the previous two years, we consider repair 
mechanisms for our robust and secure storage system. 
We propose cooperative and non-cooperative repair 
mechanisms. The results have been published in the 
conference IEEE TrustCom-2011. The complete paper is 
submitted to a prestigious journal. 
 
è‹±æ–‡é—œéµè©ï¼š Distributed networked storage system, public key 
cryptosystem, random erasure code, data forwarding, 
repair mechanism 
 
 2 
ä¸­æ–‡æ‘˜è¦ 
æœ¬ç ”ç©¶è¨ˆç•«å°‡ç ”ç©¶åˆ†æ•£å¼ç¶²è·¯å„²å­˜ç³»çµ±çš„å®‰å…¨
å„²å­˜æ©Ÿåˆ¶ã€‚ç¶²è·¯å„²å­˜ç³»çµ±æä¾›ä½¿ç”¨è€…å„²å­˜è³‡æ–™åœ¨
ç¶²è·¯ä¸Šçš„å„²å­˜ç³»çµ±ä¸­ï¼Œå†é€éç¶²è·¯é€²è¡Œè³‡æ–™å­˜
å–ã€‚ç›®å‰çš„åˆ†æ•£å¼ç¶²è·¯å„²å­˜ç³»çµ±é¦–è¦æ³¨é‡çš„æ˜¯æ•ˆ
ç‡ï¼Œå…¶æ¬¡æ‰æ˜¯å®‰å…¨æ€§,æˆ‘å€‘èªç‚ºåœ¨è³‡æ–™éš±ç§æ€§ä¸Š
é‚„æœ‰è¨±å¤šæ”¹å–„çš„ç©ºé–“ã€‚ 
ç¬¬ä¸€å¹´åº¦ï¼ˆ98-99ï¼‰æˆ‘å€‘ç™¼å±•äº†ä¸€å€‹ä»¥éš¨æ©Ÿ
ç·šæ€§ç·¨ç¢¼åŸºç¤çš„å®‰å…¨åˆ†æ•£å¼ç¶²è·¯å„²å­˜ç³»çµ±ã€‚åœ¨æˆ‘
å€‘çš„ç³»çµ±ä¸­ï¼Œè³‡æ–™é€éå…¬é–‹é‡‘é‘°ç³»çµ±åŠ å¯†ä¾†é”åˆ°
é«˜åº¦è³‡æ–™éš±ç§æ€§ï¼Œéš¨æ©Ÿç·šæ€§ç·¨ç¢¼æ–¹æ³•å‰‡æ˜¯æä¾›äº†
å„²å­˜ç³»çµ±çš„å®¹éŒ¯èƒ½åŠ›ã€‚æ•´é«”ç³»çµ±çš„é‹ä½œç¬¦åˆåˆ†æ•£
å¼ç³»çµ±çš„ç’°å¢ƒç‰¹è³ª,è«–æ–‡å·²åœ¨ IEEE TPDS (2010)
æœŸåˆŠç™¼è¡¨ã€‚ 
ç¬¬äºŒå¹´åº¦ï¼ˆ99-100ï¼‰æˆ‘å€‘åŸºæ–¼å»å¹´ç™¼å±•çš„
å®‰å…¨å„²å­˜ç³»çµ±ï¼Œç¹¼çºŒæä¾›å¤šæ¨£æ€§çš„åŠŸèƒ½ï¼Œä¾‹å¦‚ï¼Œ
å¦‚ ä½• å°‡ å®‰ å…¨ å„² å­˜ çš„ è³‡ æ–™ é€ çµ¦ ç¬¬ ä¸‰ è€…
(forwarding)ï¼Œè³‡æ–™æ“æœ‰è€…ä¸éœ€å°‡å„²å­˜çš„è³‡æ–™å–
å›è§£å¯†å¾Œå†ä¸Šå‚³ï¼Œé€™æ¨£å¯ä»¥æ¸›å°‘å¤§é‡çš„é »å¯¬ä½¿
ç”¨ã€‚è«–æ–‡æˆæœå·²ç¶“åœ¨ IEEE TPDS (2012)ä¸Šç™¼è¡¨ã€‚ 
ç¬¬ä¸‰å¹´åº¦ï¼ˆ100-101ï¼‰ï¼Œæˆ‘å€‘åŸºæ–¼å…ˆå‰å…©å¹´
çš„æˆæœï¼Œæœ‰ä¸€å€‹å®‰å…¨å¼·å›ºä¸”å…·æœ‰è³‡æ–™å‚³é€çµ¦ç¬¬ä¸‰
è€…çš„åˆ†æ•£å¼é›²ç«¯å„²å­˜ç³»çµ±ä¸Šï¼Œæå‡ºç•¶ç³»çµ±çš„ä¸€äº›
ä¼ºæœå™¨å‡ºç¾éŒ¯èª¤æ™‚å¯ä»¥ä¿®å¾©çš„æ©Ÿåˆ¶ï¼Œæˆæœç™¼è¡¨åœ¨
IEEE TrustCom-2011 æœƒè­°ä¸Šï¼Œå®Œæ•´è«–æ–‡ä¹Ÿå·²æŠ•
ç¨¿åˆ°çŸ¥åæœŸåˆŠã€‚ 
é—œéµè©: åˆ†æ•£å¼ç¶²è·¯å„²å­˜ç³»çµ±ï¼Œå…¬é–‹é‡‘é‘°åŠ å¯†ï¼Œ
éš¨æ©Ÿå®¹éŒ¯ç·¨ç¢¼ï¼Œè³‡æ–™å®‰å…¨å‚³é€ï¼Œè³‡æ–™å‚³é€ã€‚ 
è‹±æ–‡æ‘˜è¦ 
In this project, we study security issues of 
distributed networked storage systems. A 
networked storage system enables users to store 
data and to access data via Internet access. 
Currently, distributed networked storage systems 
are designed for efficiency and security is a second 
issue. One of goals of this research is to improve 
the data confidentiality in distributed networked 
storage systems. 
 In the first year (2009-2010), we developed a 
random linear code-based secure distributed 
networked storage system. The system uses a 
public key encryption scheme to provide high data 
confidentiality and uses a random linear code to 
achieve the data robustness. The data storing and 
retrieval processes are fully distributed. The paper 
has been published in IEEE TPDE. 
 In second year (2010-2011), we develop the 
system such that it can support the functionality of 
data forward. In this system, the data owner can 
securely forward the stored data in the distributed 
storage system to another user. The owner does 
not need to retrieve the data back to process it for 
forwarding to another user. The owner simply 
sends a proxy re-encryption key to the storage 
servers and the servers re-encrypt the data into a 
ciphertext that can be decrypted by the target user. 
This method reduces the bandwidth requirement 
dramatically. We have finished a manuscript and 
submitted it to an international journal. 
 In the third year (2011-2012), we continue to 
research on distributed storage systems. Based on 
the results of the previous two years, we consider 
repair mechanisms for our robust and secure 
storage system. We propose cooperative and 
non-cooperative repair mechanisms. The results 
have been published in the conference IEEE 
TrustCom-2011. The complete paper is submitted 
to a prestigious journal. 
 4 
ç‡ã€‚å¦‚ä½•æä¾›æœ‰æ•ˆç‡ä½¿ç”¨å®‰å…¨å„²å­˜è³‡æ–™çš„æ–¹æ³•æ˜¯
ç ”ç©¶çš„é‡é»ã€‚ 
ç•¶è³‡æ–™ä»¥åˆ†æ•£å¼çš„æ–¹å¼å„²å­˜åœ¨å„²å­˜ä¼ºæœå™¨
æ™‚ï¼Œå¯èƒ½ææ¯€æˆ–é­åˆ°ç ´å£ï¼Œç•¶é€™äº›éŒ¯èª¤ç™¼ç”Ÿæ™‚ï¼Œ
å¦‚ä½•åˆ©ç”¨å„²å­˜åœ¨å…¶ä»–ä¼ºæœå™¨çš„è³‡æ–™å°‡éŒ¯èª¤çš„ä¼º
æœå™¨ä¿®è­·æˆ–å°æ–°åŠ å…¥çš„ä¼ºæœå™¨å¯«å…¥ä¸€äº›è³‡æ–™ï¼Œä½¿
å¾—æ•´å€‹ç³»çµ±é‚„å…·æœ‰å¼·å›ºèˆ‡å®‰å…¨çš„ç‰¹æ€§ï¼Œæ˜¯å€¼å¾—ç ”
ç©¶çš„èª²é¡Œã€‚ 
äºŒ. ç ”ç©¶æˆæœ 
ç¬¬ä¸€å¹´åº¦ï¼ˆ2009-2010ï¼‰ 
ç¬¬ä¸€å¹´åº¦çš„ç ”ç©¶æˆæœç‚ºæå‡ºä¸€å€‹å®‰å…¨çš„åˆ†
æ•£å¼ç¶²è·¯å„²å­˜ç³»çµ±ã€‚æˆ‘å€‘çš„ç³»çµ±æœ‰ä¸‰å€‹è§’è‰²ï¼Œå„²
å­˜ä¼ºæœå™¨ï¼Œé‡‘é‘°ç®¡ç†ä¼ºæœå™¨èˆ‡ä½¿ç”¨è€…ã€‚å‡å®šç³»çµ±
æœ‰ nå€‹å„²å­˜ä¼ºæœå™¨ï¼Œmå€‹é‡‘é‘°ç®¡ç†ä¼ºæœå™¨ï¼Œä½¿ç”¨
è€…è¦å„²å­˜ kç­†è³‡æ–™ã€‚ä½¿ç”¨è€…çš„è³‡æ–™å°‡è¢«åŠ å¯†å¾Œå­˜
å…¥ ç³» çµ± ï¼Œ ç³» çµ± æœƒ é€ é åˆ† æ•£ å¼ å®¹ éŒ¯ ç·¨ ç¢¼
(decentralized erasure coding) å°‡è³‡æ–™åˆ†æ•£
å„²å­˜åœ¨ vå€‹å„²å­˜ä¼ºæœå™¨ä¸­ï¼Œç•¶ä½¿ç”¨è€…è¦å°‡è³‡æ–™å–
å›æ™‚ï¼Œç³»çµ±ä¸­çš„é‡‘é‘°ç®¡ç†ä¼ºæœå™¨æœƒèˆ‡ uå€‹å„²å­˜ä¼º
æœå™¨è¯çµ¡å–å¾—è³‡æ–™ä¸¦å”åŠ©ä½¿ç”¨è€…é€²è¡Œè§£å¯†é‹
ç®—ï¼Œä½¿ç”¨è€…è‡ªå·±å†é€²è¡Œè§£ç¢¼ä»¥æ‹¿åˆ°è³‡æ–™ã€‚åœ¨é€™æœŸ
é–“ï¼Œç”±æ–¼å„²å­˜ä¼ºæœå™¨èˆ‡é‡‘é‘°ä¼ºæœå™¨éƒ½æ˜¯ç¨ç«‹é€²è¡Œ
ç·¨ç¢¼èˆ‡å”åŠ©è§£å¯†çš„ç¨‹åºï¼Œæ‰€ä»¥ä¸éœ€è¦ä¸€å€‹ä¸­å¤®æ§
åˆ¶å–®ä½çš„å”åŠ©ã€‚ 
åœ¨åŠŸèƒ½æ€§ä¸Šï¼Œæˆ‘å€‘é€ééŒ¯èª¤æ›´æ­£ç¢¼å„²å­˜ä¾†
å› æ‡‰ç³»çµ±ä¸­å„²å­˜ä¼ºæœå™¨å¯èƒ½æ„å¤–åœ°æ–·ç·šæˆ–å„²å­˜
è¨­å‚™çš„æ¯€æï¼Œä½¿å¾—ç³»çµ±åœ¨ç™¼ç”Ÿæ„å¤–ç‹€æ³æ™‚ä»èƒ½å¤ 
æä¾›æœå‹™ã€‚åœ¨è³‡æ–™éš±ç§æ€§ä¸Šï¼Œæˆ‘å€‘å‰‡æ˜¯è€ƒæ…®ä¸€å€‹
é«˜åº¦éš±ç§æ€§çš„è¦æ±‚ï¼Œä½¿ç”¨è€…çš„è³‡æ–™ä¸åƒ…åƒ…æ˜¯å…¶ä»–
ç³»çµ±ä¸­ä½¿ç”¨è€…ç„¡æ³•æ¥è§¸ï¼Œè² è²¬æä¾›æœå‹™çš„å„²å­˜ä¼º
æœå™¨æœ¬èº«äº¦ç„¡æ³•å¾—çŸ¥è³‡æ–™çš„å…§å®¹ã€‚ 
ç ”ç©¶æˆæœçš„ä¸»è¦è²¢ç»ï¼Œå¾å­¸è¡“ç†è«–ä¸Šä¾†
çœ‹ï¼Œæˆ‘å€‘æä¾›äº†ä¸€å€‹çµåˆäº†å®¹éŒ¯æŠ€è¡“èˆ‡å…¬é–‹é‡‘é‘°
åŠ å¯†ç³»çµ±çš„å¯†ç¢¼å­¸å·¥å…·ï¼Œé€™å€‹å·¥å…·èƒ½å¤ åœ¨ä¸€å€‹é
é›†ä¸­å¼çš„å„²å­˜ç³»çµ±ç’°å¢ƒä¸­è¢«ä½¿ç”¨ï¼Œä½¿å¾—ç³»çµ±åŒæ™‚
å…·æœ‰è³‡æ–™å¯ä¿¡è³´èˆ‡é«˜åº¦éš±ç§æ€§ä¸¦ä¸”å…¼é¡§äº†åˆ†æ•£
å¼çš„å„ªé»ï¼Œå¦å¤–é‡å°ç³»çµ±ä¸­è³‡æ–™å„²å­˜çš„å–å›æ­£ç¢º
ç‡ä¸Šï¼Œæˆ‘å€‘äº¦æä¾›äº†ä¸€å€‹å®Œæ•´çš„åˆ†ææ–¹å¼ä¸¦å»ºè­°
äº†ä¸€çµ„é€šç”¨çš„ç³»çµ±åƒæ•¸ã€‚ 
å¾å„²å­˜ç³»çµ±ç™¼å±•èˆ‡æ‡‰ç”¨ä¸Šä¾†çœ‹ï¼Œæˆ‘å€‘å¼·èª¿
äº†è³‡æ–™éš±ç§æ€§åœ¨é›²ç«¯å„²å­˜ç³»çµ±ä¸Šçš„é‡è¦æ€§èˆ‡ä¸€
å€‹å¼·åº¦ä¸Šçš„åˆ†é‡ï¼Œæ—©æœŸç¶²è·¯å„²å­˜ç³»çµ±çš„éš±ç§æ€§æ˜¯
å»ºç«‹åœ¨å®Œå…¨ä¿¡ä»»å„²å­˜ä¼ºæœå™¨çš„å‡è¨­ä¸‹ï¼Œåƒ…å°ç™»å…¥
çš„ä½¿ç”¨è€…é€²è¡Œèº«åˆ†èªè­‰ï¼Œæˆ‘å€‘å‰‡æ˜¯å¼·èª¿è³‡æ–™éš±ç§
æ€§çš„å¼·åº¦æ‡‰è©²è¦èƒ½å¤ æ¶ˆé™¤å°å„²å­˜ä¼ºæœå™¨çš„ä¿¡ä»»
çš„å‡è¨­æ¢ä»¶ã€‚ 
åœ¨å®¹éŒ¯èƒ½åŠ›ä¸Šä¾†èªªï¼Œæˆ‘å€‘çš„ç³»çµ±èƒ½å¤ å®¹å¿
(n-k)å€‹å„²å­˜ä¼ºæœå™¨éŒ¯èª¤èˆ‡(m-t)å€‹é‡‘é‘°ç®¡ç†ä¼º
æœå™¨éŒ¯èª¤ã€‚åªè¦æœ‰ kå€‹å„²å­˜ä¼ºæœå™¨èˆ‡ tå€‹é‡‘é‘°ç®¡
ç†ä¼ºæœå™¨ä»æ­£å¸¸é‹ä½œï¼Œå‰‡ä½¿ç”¨è€…å¯ä»¥æœ‰å¾ˆé«˜çš„æ©Ÿ
ç‡å°‡è³‡æ–™å–å›ã€‚ 
åœ¨è³‡æ–™éš±ç§æ€§æ–¹é¢ï¼Œå› ç‚ºè³‡æ–™éƒ½æ˜¯ä»¥åŠ å¯†
çš„å‹æ…‹è¢«å„²å­˜ï¼Œæ‰€ä»¥å³ä½¿æ˜¯æ‰€æœ‰çš„å„²å­˜ä¼ºæœå™¨éƒ½
è¢«æ”»æ“Šè€…æ§åˆ¶ï¼Œè³‡æ–™å…§å®¹ä»èƒ½ä¿å¯†ã€‚æˆ‘å€‘å°æ–¼é‡‘
é‘°ç®¡ç†ä¼ºæœå™¨å‰‡æœ‰è¼ƒé«˜çš„ä¿¡ä»»è¦æ±‚ï¼Œæˆ‘å€‘å‡è¨­é€™
äº›é‡‘é‘°ç®¡ç†ä¼ºæœå™¨æœ‰è¼ƒå¥½çš„å®‰å…¨æ©Ÿåˆ¶ä»¥ä¿éšœä½¿
ç”¨è€…çš„å„å€‹éƒ¨åˆ†è§£å¯†é‡‘é‘°ã€‚ 
ç¬¬äºŒå¹´åº¦ï¼ˆ2010-2011ï¼‰ 
ç‚ºäº†åœ¨åˆ†æ•£å¼å®‰å…¨çš„å„²å­˜ç³»çµ±ä¸Šé”åˆ°å…·æœ‰ data 
forwarding çš„èƒ½åŠ›ï¼Œæˆ‘å€‘æå‡ºäº†æ–°çš„é–€æª»å¼çš„
å† åŠ  å¯† å” å®š (threshold re-encryption 
scheme)ï¼Œç„¶å¾Œå°‡æ•´åˆåˆ°å®‰å…¨çš„å„²å­˜ç³»çµ±è£¡ã€‚çµ
åˆçš„ç³»çµ±å…·æœ‰å®‰å…¨ã€å®¹éŒ¯ã€data forwardingçš„
A Decentralized Repair Mechanism for
Decentralized Erasure Code based Storage Systems
Hsiao-Ying Linâˆ—, Wen-Guey Tzengâ€ , Bao-Shuh Linâˆ—
âˆ—Intelligent Information and Communications Research Center, â€ Department of Computer Science
National Chiao Tung University
Hsinchu, Taiwan
hsiaoying.lin@gmail.com, wgtzeng@cs.nctu.edu.tw, bplin@mail.nctu.edu.tw
Abstractâ€”Erasure code based distributed storage systems
provide data robustness by storing encoded-fragments over
servers. To maintain data robustness, a repair mechanism
recovers a storage system from server failures by repairing
encoded-fragments. For decentralized erasure code based stor-
age systems, we propose a decentralized repair mechanism.
Our mechanism has the following features. Firstly, an encoded-
fragment is replenished by a combination of a number u of
encoded-fragments that are randomly chosen. Secondly, the
number u depends on the number of the available encoded-
fragments and is independent of the pattern of missing
encoded-fragments. Thirdly, multiple encoded-fragments are
simultaneously replenished in parallel. We measure the com-
munication cost in terms of the number u of required network
connections for replenishing an encoded-fragment. We then
conducted a numerical analysis by using traces of real systems.
We find that our requirement on u is smaller than that from
existing methods. Both theoretical and numerical results show
that our decentralized repair mechanism outperforms existing
ones in terms of the communication cost under the same
consideration of efficiency cost for storage.
Keywords-decentralized erasure codes; regenerating codes;
network coding; distributed storage;
I. INTRODUCTION
Erasure code based distributed storage systems provide
data robustness by storing encoded-fragments over servers.
An (ğ‘›, ğ‘˜) erasure code encodes a message of ğ‘˜ symbols
to a codeword of ğ‘› symbols such that the message can be
decoded from any ğ‘˜ codeword symbols. The code tolerates
ğ‘›âˆ’ğ‘˜ erasure errors. To store a message in an (ğ‘›, ğ‘˜)-erasure
code based distributed storage system with ğ‘› servers, the
message is encoded into a codeword by the erasure code
and each of its codeword symbols is stored in a different
server. A server failure corresponds to an erasure error of the
stored codeword symbol. As long as ğ‘˜ servers are available,
the message can be recovered. In this paper, we sometimes
refer a codeword symbol as an encoded fragment and use
them interchangeably.
A decentralized erasure code is an erasure code that inde-
pendently computes each codeword symbol for a message.
Thus, the encoding process for a message consists of ğ‘›
parallel tasks of generating codeword symbols. Each server
executes one task to compute a codeword symbol. This kind
of systems is suitable for decentralized environments, where
no centralized authority coordinates the tasks, such as peer-
to-peer and ad-hoc networks. Parallel computing also speeds
up the storing process.
Maintenance of robustness in an erasure code based dis-
tributed storage system requires to replenish codeword sym-
bols when servers fail or leave the system. A straightforward
solution is to compute the original message from available
codeword symbols and then to regenerate missing codeword
symbols from the message. This approach leads to higher
communication and computation cost. Another approach
is to generate codeword symbols by directly combining ğ‘¢
available ones. When a new server joins the system, it
queries ğ‘¢ available servers to generate a codeword symbol.
The generated codeword symbol can be different from the
missing one. But, the property that any ğ‘˜ codeword symbols
can recover the message remains.
In previous studies, efficiency is measured by the storage
cost (the number of bits a server stores) and the repair
bandwidth (the number of bits a new server received for
replenishing a codeword symbol). However, in considering
the communication cost, the cost of establishing network
connections is significant. Establishing network connections
between servers involves authentication and negotiation
process. The entailed communication cost is significant,
especially when ğ‘¢ is large. For example, when ğ‘¢ = ğ‘› âˆ’ 1,
a new server needs to connect all available servers in the
system. Thus, we measure the communication cost by the
number ğ‘¢ of required network connections, as well as the
repair bandwidth.
We study repair mechanisms for decentralized erasure
code based storage systems. In a decentralized erasure code
based storage system, we show that ğ‘¢ = ğ‘˜ is a sufficient
condition for a repair mechanism. Specifically, we are inter-
ested in finding out whether ğ‘¢ can be smaller than ğ‘˜.
Contributions. We propose a decentralized repair mecha-
nism for decentralized erasure code based storage systems
with the following features:
âˆ™ A codeword symbol is replenished by a combination
of a number ğ‘¢ of randomly chosen codeword symbols
without recreating the original message.
2011 International Joint Conference of IEEE TrustCom-11/IEEE ICESS-11/FCST-11
978-0-7695-4600-1/11 $26.00 Â© 2011 IEEE
DOI 10.1109/TrustCom.2011.79
613
Figure 1. The model of decentralized erasure code based storage systems.
A. Decentralized Erasure Code based Storage System
Dimakis et al. [16] proposed a decentralized erasure code
based storage system where the encoding process is ac-
complished by decentralized servers in parallel. Afterward,
for strengthening data confidentiality, Lin and Tzeng [17],
[18] proposed secure decentralized erasure codes where data
are encoded in an encrypted form. Illustrated in Fig. 1,
a decentralized erasure code based storage systems is de-
scribed as follows. There are ğ‘› servers, SS1,SS2, . . .,
SSğ‘›, and a message is represented as a vector of symbols
ğ‘š1,ğ‘š2, . . . ,ğ‘šğ‘˜ in some finite field. To store the message,
each symbol is distributed to ğ‘£ randomly chosen servers.
A server SSğ‘– then picks a random coefficient ğ‘”ğ‘–,ğ‘— for a
received message symbol ğ‘šğ‘— and linearly combines all
received message symbols as a codeword symbol ğ‘ğ‘–. If ğ‘šğ‘—
is not received, ğ‘”ğ‘–,ğ‘— is set to 0. Note that the combination is
operated in the finite field. Globally, all chosen coefficients
form a generator matrix ğº = [ğ‘”ğ‘–,ğ‘— ], 1 â‰¤ ğ‘– â‰¤ ğ‘›, 1 â‰¤ ğ‘— â‰¤ ğ‘˜,
which encodes the vector of ğ‘˜ message symbols to the
vector of ğ‘› codeword symbols. To retrieve the message, a
user queries ğ‘˜ randomly chosen servers to get ğ‘˜ codeword
symbols, say ğ‘1, ğ‘2, . . . , ğ‘ğ‘˜, and the corresponding coeffi-
cients. The coefficients form a square matrix ğ¾, which is a
submatrix of ğº. The user decodes the message by computing
(ğ‘1, ğ‘2, . . . , ğ‘ğ‘˜)Ã—ğ¾âˆ’1, where ğ¾âˆ’1 is the inverse matrix of
ğ¾. A successful data retrieval of the system is the event that
ğ¾ is invertible. The probability of a successful data retrieval
is overwhelming when ğ‘£ is sufficiently large [16], [17], [18].
From the results in [16], the system parameters are
suggested as follows in order to guarantee a high probability
of a successful data retrieval. When ğ‘› = ğ‘ğ‘˜, ğ‘£ = ğ‘ ln ğ‘˜,
and ğ‘ > 5ğ‘ with constants ğ‘ and ğ‘, the probability of a
successful data retrieval is at least 1âˆ’ğ‘˜/ğ‘âˆ’ğ‘œ(1), where ğ‘ is
the prime order of the underlined group. Later in [18], these
parameters are generalized for ğ‘› = ğ‘ğ‘˜ğ‘ and ğ‘ â‰¥ 1. When
ğ‘› = ğ‘ğ‘˜ğ‘, ğ‘£ = ğ‘ğ‘˜ğ‘âˆ’1 ln ğ‘˜, ğ‘ > 5ğ‘, and ğ‘ â‰¥ 1 with constants
ğ‘ and ğ‘, the probability of a successful data retrieval is at
Figure 2. Our repair model for decentralized erasure code based storage
systems.
least 1âˆ’ ğ‘˜/ğ‘âˆ’ ğ‘œ(1).
B. Decentralized Repair Mechanism
Let messages be stored among ğ‘› servers in a decentralized
erasure code based storage system. After a period of time,
some servers fail. Let the number of remaining servers be
ğ›¼ğ‘›, where ğ›¼ < 1. By the results [16], [17], [18], any ğ‘˜
remaining servers can recover the message with probability
1âˆ’ ğ‘˜/ğ‘âˆ’ ğ‘œ(1). To repair the system from (1âˆ’ ğ›¼)ğ‘› server
failures, (1 âˆ’ ğ›¼)ğ‘› new servers join the system. We shall
call a remaining server as an old server and a newly joining
one as a new server. A repair procedure is initiated by new
servers (see Fig. 2). After executing the repair procedure,
the storage system is recovered from server failures so that
any ğ‘˜ servers, no matter new or old ones, shall recover the
message with an overwhelming probability.
Repair procedure. New server SSğ‘— performs the following
steps:
1) Query ğ‘¢ randomly chosen old servers, SSğ‘—1 ,
SSğ‘—2 , . . ., SSğ‘—ğ‘¢ . A queried old server SSğ‘—ğ‘– re-
turns the stored codeword symbol and coefficients
(ğ‘ğ‘—ğ‘– , ğ‘”ğ‘—ğ‘–,1, ğ‘”ğ‘—ğ‘–,2, . . . , ğ‘”ğ‘—ğ‘–,ğ‘˜).
2) Choose a random coefficient ğ‘§ğ‘—ğ‘– for a received
(ğ‘ğ‘—ğ‘– , ğ‘”ğ‘—ğ‘–,1, ğ‘”ğ‘—ğ‘–,2, . . . , ğ‘”ğ‘—ğ‘–,ğ‘˜).
3) Encode all received data into a new codeword
symbol and the corresponding coefficients
( ?Ëœ? , ?Ëœ?,1, ?Ëœ?,2, . . . , ?Ëœ?,ğ‘˜):
?Ëœ? =
âˆ‘
1â‰¤ğ‘–â‰¤ğ‘¢
ğ‘§ğ‘—ğ‘–ğ‘ğ‘—ğ‘– , ?Ëœ?,ğ‘  =
âˆ‘
1â‰¤ğ‘–â‰¤ğ‘¢
ğ‘§ğ‘—ğ‘–ğ‘”ğ‘—ğ‘–,ğ‘ , 1 â‰¤ ğ‘  â‰¤ ğ‘˜
4) Store the resulting ( ?Ëœ? , ?Ëœ?,1, ?Ëœ?,2, . . . , ?Ëœ?,ğ‘˜).
By considering communication cost of establishing net-
work connections between servers, we want a smaller ğ‘¢. A
larger ğ‘¢ means that the new server queries more codeword
symbols from old servers. The combination of these queried
codeword symbols contains more information about the mes-
sage. Therefore, we need to carefully select ğ‘¢. Apparently, if
ğ‘¢ â‰¥ ğ‘˜, more than ğ‘˜ codeword symbols are queried and they
are sufficient to recover the message with an overwhelming
probability. The combination of these codeword symbols in
the new server, together with the codeword symbols from
615
When E2 happens, there is a maximal matching from ğ‘†2
to ğ‘‰1 âˆ– ğ‘†1. That is, a subset ğ‘†â€²2 âŠ† ğ‘(ğ‘†2) âˆ– ğ‘†1 exists with
âˆ£ğ‘†â€²2âˆ£ = ğ‘›2
Let ğ¾ be the ğ‘˜ Ã— ğ‘˜ matrix formed by coefficients from
queried servers in ğ‘†1âˆªğ‘†2. When ğ¾ is invertible, E1 happens.
Let ğ¾1 be the ğ‘˜Ã— ğ‘˜ matrix formed by coefficients from the
servers in ğ‘†1âˆªğ‘†â€²2. Since ğ‘†1âˆªğ‘†â€²2 is a subset of ğ‘˜ vertices in
ğ‘‰1, ğ¾1 is invertible with probability at least 1âˆ’ğ‘˜/ğ‘âˆ’ğ‘œ(1).
Since the subgraph induced by ğ‘†2 and ğ‘†â€²2 has a perfect
matching, ğ¾ has full rank if ğ¾1 has full rank. Moreover,
each row in ğ¾ can be expressed as a linear combination of
rows in ğ¾1. Thus, ğ¾ can be expressed as ğ‘‡ Ã—ğ¾1 for some
ğ‘˜Ã—ğ‘˜ matrix ğ‘‡ . Entries of ğ‘‡ are randomly and independently
determined by new servers. To have ğ¾ invertible, ğ¾1 and
ğ‘‡ must be invertible. When ğ¾1 is invertible, ğ‘‡ is invertible
with probability at least 1âˆ’ ğ‘˜/ğ‘ according to the Schwartz-
Zippel Theorem. Thus, we have
Pr[E1âˆ£E2 âˆ§ (ğ‘›1 < ğ‘˜)]
= Pr[ğ¾ is invertibleâˆ£E2 âˆ§ (ğ‘›1 < ğ‘˜)]
â‰¥ Pr[ğ¾1 is invertible âˆ§ ğ‘‡ is invertibleâˆ£E2 âˆ§ (ğ‘›1 < ğ‘˜)]
â‰¥ (1âˆ’ ğ‘˜/ğ‘âˆ’ ğ‘œ(1))Ã— (1âˆ’ ğ‘˜/ğ‘)
â‰¥ 1âˆ’ 2ğ‘˜/ğ‘âˆ’ ğ‘œ(1)
Lemma 2. (Hallâ€™s Theorem) If and only of for any subset
ğµ âŠ† ğ‘†2, the number of neighbors of ğµ in ğ‘‰1 âˆ– ğ‘†1 is no
less than the size of ğµ, i.e., âˆ£ğ‘(ğµ) âˆ– ğ‘†1âˆ£ â‰¥ âˆ£ğµâˆ£, where
ğ‘(ğµ) âŠ† ğ‘‰1 is the set of neighbors of ğµ, there exists a
maximal matching from ğ‘†2 to ğ‘‰1 âˆ– ğ‘†1.
Lemma 3. Pr[E2âˆ£ğ‘›1 < ğ‘˜] = 1
Proof: When ğ‘¢ = ğ‘˜, each vertex ğ‘£ in ğ‘†2 has ğ‘˜
neighbors in ğ‘‰1. For all possible ğµ, where 1 â‰¤ âˆ£ğµâˆ£ â‰¤ ğ‘›2,
âˆ£ğ‘(ğµ) âˆ– ğ‘†1âˆ£ â‰¥ ğ‘˜ âˆ’ ğ‘›1 = ğ‘›2 â‰¥ âˆ£ğµâˆ£.
Hence, Pr[E2âˆ£ğ‘›1 < ğ‘˜] = 1.
From Equation (1), Lemma 1, and Lemma 3, we have
Pr[E1] = Pr[E1âˆ£ğ‘›1 = ğ‘˜] Pr[ğ‘›1 = ğ‘˜] + Pr[E1âˆ£ğ‘›1 < ğ‘˜] Pr[ğ‘›1 < ğ‘˜]
â‰¥ Pr[E1âˆ£ğ‘›1 = ğ‘˜] Pr[ğ‘›1 = ğ‘˜]
+ Pr[E1âˆ£E2 âˆ§ (ğ‘›1 < ğ‘˜)] Pr[E2âˆ£ğ‘›1 < ğ‘˜] Pr[ğ‘›1 < ğ‘˜]
â‰¥ (1âˆ’ ğ‘˜/ğ‘âˆ’ ğ‘œ(1)) Pr[ğ‘›1 = ğ‘˜]
+ (1âˆ’ 2ğ‘˜/ğ‘âˆ’ ğ‘œ(1)) Pr[ğ‘›1 < ğ‘˜]
â‰¥ 1âˆ’ 2ğ‘˜/ğ‘âˆ’ ğ‘œ(1)
It concludes this proof.
E. Proof of Theorem 2
The proof of Theorem 2 is similar to the proof of
Theorem 1 except for the analysis of the random graph. To
ease the analysis, the original repair procedure is modified
to that a new server randomly queries an old server ğ‘¢
times with replacement. Thus, a new server may query
less than ğ‘¢ distinct old servers. The modification leads to
a different random graph. The probability of a maximum
matching from ğ‘†2 to ğ‘‰1 âˆ– ğ‘†1 in the new random graph is
smaller than that in the original random graph. Hence the
probability in the original random graph is underestimated.
Let ğ”¾â€² = (ğ‘‰1, ğ‘‰2, ğ¸â€²) be the random bipartite graph, where
âˆ£ğ‘‰1âˆ£ = ğ›¼ğ‘›, âˆ£ğ‘‰2âˆ£ = (1 âˆ’ ğ›¼)ğ‘›, and ğ¸â€² is the edge set. Let
event Eâ€™2 is that there is a maximal matching from ğ‘†2 to
ğ‘‰1âˆ–ğ‘†1. Again, we need Lemma 1 and Lemma 4 for relations
between events E1 and Eâ€™2 to complete this proof.
Lemma 4. Pr[Eâ€²2âˆ£ğ‘›1 < ğ‘˜] â‰¥ 1âˆ’ ğ‘œ(1)
Proof: We use Lemma 2 (Hallâ€™s theorem) and Lemma 5
to bound the probability Pr[Eâ€²2âˆ£ğ‘›1 < ğ‘˜]. Lemma 5 is a
bound for ğ¶ğ‘¥ğ‘¦ (Due to limited space, the proof for Lemma 5
is omitted):
Lemma 5. ğ¶ğ‘¥ğ‘¦ â‰¤
(
ğ‘¥(ğ‘¥âˆ’ğ‘¦+1)
ğ‘¦
) ğ‘¦
2
When there exists a subset ğµ âŠ† ğ‘†2 where âˆ£ğ‘(ğµ)âˆ–ğ‘†1âˆ£ <
âˆ£ğµâˆ£, no maximal matching from ğ‘†2 to ğ‘‰1 âˆ– ğ‘†1 exists.
We consider every possible subset ğµ and overestimate the
probability of the complement event of Eâ€™2 by a union
bound.
Pr[âˆƒğµ âŠ† ğ‘†2, âˆ£ğ‘(ğµ) âˆ– ğ‘†1âˆ£ < âˆ£ğµâˆ£]
â‰¤ 2ğ‘˜ â‹… max
ğµâŠ†ğ‘†2
{Pr [âˆ£ğ‘(ğµ) âˆ– ğ‘†1âˆ£ < âˆ£ğµâˆ£]}
Let âˆ£ğµâˆ£ = ğ‘¡, where 1 â‰¤ ğ‘¡ â‰¤ ğ‘›2. The event that some
subset ğµ exists for âˆ£ğ‘(ğµ) âˆ– ğ‘†1âˆ£ < âˆ£ğµâˆ£ is equivalent to the
event that some subset ğ´ exists where ğ´ âŠ† ğ‘‰1 âˆ– ğ‘†1, âˆ£ğ´âˆ£ â‰¤
ğ‘¡âˆ’ 1, and ğ´ âˆª ğ‘†1 âŠ‡ ğ‘(ğµ)
Pr [âˆ£ğ‘(ğµ) âˆ– ğ‘†1âˆ£ â‰¤ âˆ£ğµâˆ£]
= Pr[âˆƒğ´, âˆ£ğ´âˆ£ â‰¤ ğ‘¡âˆ’ 1, ğ´ âˆª ğ‘†1 âŠ‡ ğ‘(ğµ)]
â‰¤ ğ¶ğ›¼ğ‘›âˆ’ğ‘›1ğ‘¡âˆ’1
(
ğ‘˜ âˆ’ 1
ğ›¼ğ‘›
)ğ‘¡ğ‘¢
(Lemma 5)
â‰¤
(
2(ğ›¼ğ‘›âˆ’ ğ‘›1)(ğ›¼ğ‘›âˆ’ ğ‘›1 âˆ’ ğ‘¡+ 2)
ğ‘¡
) ğ‘¡âˆ’1
2
(
ğ‘˜
ğ›¼ğ‘›
)ğ‘¡ğ‘¢
Since we want Pr[âˆƒğµ âŠ† ğ‘†2, âˆ£ğ‘(ğµ) âˆ– ğ‘†1âˆ£ < âˆ£ğµâˆ£] < ğ‘’âˆ’ğ‘˜, it
is sufficient to have:(
2(ğ›¼ğ‘›âˆ’ ğ‘›1)(ğ›¼ğ‘›âˆ’ ğ‘›1 âˆ’ ğ‘¡+ 2)
ğ‘¡
) ğ‘¡âˆ’1
2
(
ğ‘˜
ğ›¼ğ‘›
)ğ‘¡ğ‘¢
< ğ‘’âˆ’2ğ‘˜
(3)
Now we substitute ğ›¼ğ‘› = ğ‘˜ğ‘‘ in Equation (3) and overesti-
mate the left hand side:(
2ğ‘˜2ğ‘‘
ğ‘¡
) ğ‘¡âˆ’1
2
ğ‘˜(1âˆ’ğ‘‘)ğ‘¡ğ‘¢ < ğ‘’âˆ’2ğ‘˜ (4)
We take nature logarithm on both sides of Equation (4) and
617
Trace Microsoft PCs Gnutella Skype PlanetLab
ğ‘›: average number of nodes 41970 1846 710 303
ğ‘“ : fraction of failed node per day 0.038 0.3 0.12 0.017
Table I
STATISTICS OF SYSTEM TRACES [2].
ğ‘˜ = 4
ğ‘‘ 2 3 4 5 6
ğ‘¢ 3 3 3 3 2
ğ‘˜ğ‘‘ 16 64 256 1024 4096
ğ‘˜ = 8
ğ‘‘ 2 3 4 5
ğ‘¢ 6 4 3 3
ğ‘˜ğ‘‘ 64 512 4096 32768
ğ‘˜ = 16
ğ‘‘ 2 3 4 5
ğ‘¢ 8 5 4 3
ğ‘˜ğ‘‘ 256 4096 65536 1048576
Table II
NUMERICAL ANALYSIS FOR THE NUMBER ğ‘¢ FOR DIFFERENT ğ‘˜ AND ğ›¼ğ‘›.
Trace Microsoft Gnutella Skype PlanetLab
ğ‘› 41970 1846 710 303
ğ‘“ 0.038 0.3 0.12 0.017
ğ‘˜ 4 8 4 8 4 8 4 8
ğ‘¢ 3 3 3 4 3 4 3 6
ğ›¼ğ‘› 16 4096 16 512 16 512 16 64
Survival duration (days) 26 23 3 3 8 2 47 39
Table III
NUMERICAL ANALYSIS FOR SURVIVAL DURATION IN DAYS.
ğ‘¢ server failures bandwidth storage type
MBR [2] ğ‘›âˆ’ 1 single (2ğ‘›âˆ’2)ğ‘™(2ğ‘›âˆ’ğ‘˜âˆ’1)ğ‘˜ (2ğ‘›âˆ’2)ğ‘™(2ğ‘›âˆ’ğ‘˜âˆ’1)ğ‘˜ symmetric
MSR [2] ğ‘˜ + 1 single (ğ‘›âˆ’1)ğ‘™(ğ‘›âˆ’ğ‘˜)ğ‘˜
ğ‘™
ğ‘˜ symmetric
MCR [10] ğ‘›âˆ’ 1 multiple (ğ‘›âˆ’1)ğ‘™(ğ‘›âˆ’ğ‘˜)ğ‘˜ ğ‘™ğ‘˜ symmetric
SRHC [11] < ğ‘˜ multiple ğ‘¢ğ‘™ğ‘˜ ğ‘™ğ‘˜ asymmetric
Our work < ğ‘˜ multiple ğ‘¢ğ‘™ğ‘˜
ğ‘™
ğ‘˜ symmetric
Table IV
COMPARISON OVER REPAIR MECHANISMS.
queries more than ğ‘˜ servers. However, they only tolerate one
server failure. MCR tolerates multiple server failures, but
the number of required connections for repairing a failure is
ğ‘› âˆ’ 1. In other words, a new server has to communicate
with all other servers in the storage system. SRHC is a
novel way to recover the system from multiple server failures
with ğ‘¢ < ğ‘˜. But, SRHC is not suitable for distributed or
decentralized environment because it is asymmetric.
Our mechanism outperforms existing ones in terms of
the communication cost under the same consideration of
efficiency cost for storage. A new server queries less than
ğ‘˜ servers and the required bandwidth is less than ğ‘™. At the
same time, the storage cost is as less as the cost of the MSR.
Moreover, our repair mechanism recovers a decentralized
erasure code based storage system from multiple server
failures.
The sacrifice is the probability of a successful data re-
trieval. The probabilities of a successful data retrieval in
MBR, MSR, and MCR are all 1â€™s. Since SRHC exactly
regenerates missing codeword symbols, the probability is
1 as well. While our mechanism has lower communica-
tion cost, the probability of a successful data retrieval is
1âˆ’ 2ğ‘˜/ğ‘âˆ’ ğ‘œ(1). However, by choosing a sufficient large ğ‘,
the probability 1âˆ’2ğ‘˜/ğ‘âˆ’ğ‘œ(1) is overwhelming. Moreover,
the probability can be dramatically increased by letting a
user query more than ğ‘˜ servers for data retrieval.
V. CONCLUSION AND FUTURE WORK
We consider the measurement of communication cost in
terms of the number ğ‘¢ of connections that a new server
has to establish. Our repair mechanism provides flexible
adjustment between ğ‘¢ and the number of remaining servers.
More importantly, our results confirm that to repair a server
failure, a new server can query less than ğ‘˜ servers.
Our repair mechanism symmetrically repairs multiple
server failures of decentralized erasure code based storage
systems. Thus, a lazy repair strategy or a periodical repair
strategy can be taken upon our repair mechanism. It is
619
è¡Œæ”¿é™¢åœ‹å®¶ç§‘å­¸å§”å“¡æœƒè£œåŠ©åœ‹å…§å°ˆå®¶å­¸è€…å‡ºå¸­åœ‹éš›å­¸è¡“æœƒè­°å ±å‘Š 
                                                             101 å¹´ 7 æœˆ 13 æ—¥ 
å ±å‘Šäººå§“å æ›¾æ–‡è²´ 
æœå‹™æ©Ÿæ§‹ 
åŠè·ç¨± 
äº¤é€šå¤§å­¸è³‡å·¥ç³» æ•™æˆ 
     æ™‚é–“ 
æœƒè­° 
     åœ°é» 
101 å¹´ 6 æœˆ 20 æ—¥è‡³  101 å¹´ 6 æœˆ 22 æ—¥ 
(å‡ºåœ‹æ™‚é–“ç‚º 101 å¹´ 6 æœˆ 18 æ—¥è‡³  101 å¹´ 6 æœˆ 24 æ—¥) 
    ç¾åœ‹è¯ç››é “ç‰¹å€ NIST Administrator Building 101 
æœƒè­° 
åç¨± 
2012 IEEE International Conference on Software Security and 
Reliability ï¼ˆSERE 2012ï¼‰ 
å‡ºåœ‹ç›®çš„/
ç™¼è¡¨è«–æ–‡é¡Œ
ç›® 
ç™¼è¡¨è«–æ–‡ï¼š 
è«–æ–‡ä½œè€…æ–¼é¡Œç›®: Hsiao-Ying Lin, John Kubiatowicz and Wen-Guey Tzeng. 
A Secure Fine-Grained Access Control Mechanism for Networked Storage 
System. In the Sixth IEEE International Conference on Software Security and 
Reliability (IEEE SERE 2012), June 2012.  
 
å…§å®¹åŒ…æ‹¬ä¸‹åˆ—å„é …ï¼š 
ä¸€ã€ åƒåŠ æœƒè­°ç¶“é(å«ç…§ç‰‡) 
æœ¬äººæ–¼ 18æ—¥å¾å°ç£æ­æ©Ÿï¼Œç•¶æ—¥æŠµé”ï¼Œ19æ—¥èª¿æ•´æ™‚å·®ï¼Œ20é–‹å§‹åƒåŠ æœƒè­°ï¼Œæœƒè­°èˆ‰
è¾¦æœŸé–“ç‚º 6æœˆ 20æ—¥è‡³ 6æœˆ 22æ—¥ï¼ŒåƒåŠ å®Œæœƒè­°å¾Œï¼Œæ–¼ 23æ—¥é›¢é–‹è¯ç››é “ ç‰¹å€ï¼Œ24æ—¥åˆ°é”
å°ç£ã€‚æ–¼æœƒè­°èˆ‰è¾¦æœŸé–“ï¼Œæœ¬äººåƒåŠ æœƒè­°è¡Œç¨‹ï¼Œè©³ç´°è¡Œç¨‹è³‡è¨ŠæŒ‰æ™‚é–“é †åºæ•´ç†å¦‚ä¸‹: 
ï¬ 6æœˆ 20æ—¥: 
æœƒè­°é¦–æ—¥ï¼Œç”±è¬çºŒå¹³æ•™æˆå”åŠ©è¯ç¹«ç•¶åœ°çš„åŒå­¸ä¾†æ¥æˆ‘å€‘ä¸€è¡Œä¸‰äººæŠµé” NISTçš„ 101
å¤§æ¨“ã€‚é€²å…¥ NISTå€åŸŸéœ€è¦æŒæœ‰ä¸€ä»½é€šè¡Œæ–‡ä»¶èˆ‡ä¸€ä»½å«ç…§ç‰‡çš„å€‹äººè­˜åˆ¥è­‰ä»¶ï¼Œç¶“
éè­¦å¯Ÿæ ¸å°ä¹‹å¾Œæ‰èƒ½é€²å…¥ï¼Œé–€ç¦ç›¸ç•¶æ£®åš´ã€‚æˆ‘å€‘æŠµé”æœƒå ´æ™‚ç´„ç‚ºæ—©ä¸Š 9é»åŠã€‚
æœƒè­°åœ°é»åœ¨ NISTå€åŸŸçš„ A101å¤§æ¨“ã€‚ 
 
 
å ±åˆ°æ™‚ï¼Œæ‹¿åˆ°å¤§æœƒæ™‚ç¨‹ï¼Œæ³¨æ„åˆ°è‡ªå·±éœ€è¦åœ¨ 22æ—¥ä¸‹åˆä¸»æŒä¸€å ´è­°ç¨‹(session)ã€‚ 
      
ç¬¬ä¸€å ´ Keynote speechæ˜¯ç”± Virgil Gligorä¸»è¬›ã€‚ 
 
 
 
æ—©ä¸ŠåƒåŠ çš„è­°ç¨‹ç‚º: 
 
 
ä¸‹åˆå‰‡æ˜¯åƒåŠ ï¼š 
 
ä¸‹åˆçš„æ´»å‹•å«æœ‰ä¸€å€‹è‡ªåŠ©åƒè¨ªèˆ‡æ™šå®´ã€‚å…©é …æ´»å‹•éƒ½æ˜¯åœ¨ NIST 101å¤§æ¨“å…§èˆ‰è¡Œï¼Œ
æˆ‘å€‘åœ¨åƒè¨ªæ´»å‹•ä¸­ï¼Œæ‰¾åˆ°äº†ç‰›é “çš„è˜‹æœæ¨¹çš„å¾Œä»£ï¼Œä»¥åŠåƒè¨ªäº† NISTçš„åšç‰©é¤¨
(Museum): 
 åœ¨å ±å‘Šä¹‹å¾Œï¼Œæœ‰ä¸€ä½å­¸è€…æå‡ºä¸‰å€‹å•é¡Œï¼Œåˆ†åˆ¥æ˜¯é‡å°å–æ¶ˆæˆæ¬Šï¼Œå„²å­˜æˆæœ¬ï¼Œä»¥
åŠèˆ‡å…¶ä»–å­˜å–æ§åˆ¶æ–¹å¼çš„æ¯”è¼ƒè¨è«–ã€‚ä¸Šåˆè­°ç¨‹çµæŸå¾Œï¼Œèˆ‡æ­¤å­¸è€…è¨è«–äº†åœ¨çµåˆ
æ‡‰ç”¨ç³»çµ±èˆ‡å¯†ç¢¼å­¸å·¥å…·ä¸Šçš„ç¶“é©—ã€‚ 
 
é€™å¤©ä¸‹åˆçš„æ—¥ç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼Œé€™å…©å€‹è­°ç¨‹çš†ç”±æœ¬äººæ“”ä»»è­°ç¨‹ä¸»å¸­(Session chair): 
 
è‡³æ­¤ï¼Œæœƒè­°é †åˆ©é€²è¡ŒçµæŸã€‚ 
 
ï¬ 6æœˆ 23æ—¥: 
æ—©ä¸Š 8:30 é›¢é–‹é£¯åº—ï¼Œæ­ä¹˜åœ°éµå‰å¾€é›·æ ¹æ©Ÿå ´ï¼Œåœ¨æ©Ÿå ´é™¤äº†åˆ°èˆªç©ºæ«ƒå°å ±åˆ°ï¼Œé€²
è¡Œè¡Œææª¢æŸ¥ï¼Œäº¦é€šéç¹è¤‡çš„å®‰å…¨æª¢æŸ¥ï¼Œè¶³è¦‹ç¾åœ‹å°æ–¼æ©Ÿå ´å®‰å…¨çš„è¬¹æ…ã€‚åœ¨åº•ç‰¹
å¾‹åŠæ±äº¬è½‰æ©Ÿå¾Œï¼Œæ–¼å°ç£æ™‚é–“ 6 æœˆ 24 æ—¥æ™šé–“ 7 é»æŠµé”æ¡ƒåœ’æ©Ÿå ´ï¼ŒçµæŸæ­¤æ¬¡è¡Œç¨‹ã€‚ 
 
äºŒã€èˆ‡æœƒå¿ƒå¾— 
é€™æ¬¡èˆ‡æœƒåœ¨ç ”ç©¶æ–¹é¢æœ‰å¤šé …å¿ƒå¾—ï¼Œé¦–å…ˆç ”ç©¶å­¸è¡“è­°é¡Œèˆ‡æ½®æµæ–¹é¢ï¼Œç›®å‰é‡å°è»Ÿ
é«”å®‰å…¨èˆ‡ç³»çµ±å®‰å…¨çš„ç ”ç©¶å¤§éƒ½éœ€è¦æª¢é©—éå¸¸åº•å±¤çš„æ±è¥¿ï¼Œä¾‹å¦‚åŸå§‹ç¢¼(source 
code)æˆ–åŸ·è¡Œæª”(binary code)ï¼Œä»¥ç™¼æ˜æ½›åœ¨çš„è»Ÿé«”å¼±é»æˆ–ç³»çµ±å¼±é»ï¼Œå› æ­¤éœ€è¦å¤§é‡
çš„è¨ˆç®—ï¼Œéå¸¸é©åˆé›²ç«¯çš„æ¶æ§‹ä¾†åŸ·è¡Œï¼Œå¦ä¸€æ–¹é¢ï¼Œåˆ©ç”¨ Model checking çš„æŠ€è¡“ä¾†
æª¢é©—å„ç¨®ç³»çµ±çš„åŠŸèƒ½èˆ‡å®‰å…¨æ€§ä¹Ÿå—åˆ°é‡è¦–ã€‚æˆ‘å€‘ç™¼è¡¨çš„æ–‡ç« æ˜¯å±¬æ–¼ç³»çµ±æ¬Šé™çš„
å­˜å–æ§åˆ¶ï¼Œé›–ç„¶è¼ƒå°‘çš„æœƒè­°çš„åƒè€…ç†Ÿæ‚‰ï¼Œä½†æ˜¯åœ¨é€²è¡Œå ±å‘Šä¹‹å¾Œï¼Œè¨±å¤šå­¸è€…ç©æ¥µ
è¡Œæ”¿é™¢åœ‹å®¶ç§‘å­¸å§”å“¡æœƒè£œåŠ©åœ‹å…§å°ˆå®¶å­¸è€…å‡ºå¸­åœ‹éš›å­¸è¡“æœƒè­°å ±å‘Š 
                                                             101 å¹´ 7 æœˆ 13 æ—¥ 
å ±å‘Šäººå§“å æ›¾æ–‡è²´ 
æœå‹™æ©Ÿæ§‹ 
åŠè·ç¨± 
äº¤é€šå¤§å­¸è³‡å·¥ç³» æ•™æˆ 
     æ™‚é–“ 
æœƒè­° 
     åœ°é» 
101 å¹´ 6 æœˆ 20 æ—¥è‡³  101 å¹´ 6 æœˆ 22 æ—¥ 
(å‡ºåœ‹æ™‚é–“ç‚º 101 å¹´ 6 æœˆ 18 æ—¥è‡³  101 å¹´ 6 æœˆ 24 æ—¥) 
    ç¾åœ‹è¯ç››é “ç‰¹å€ NIST Administrator Building 101 
æœƒè­° 
åç¨± 
2012 IEEE International Conference on Software Security and 
Reliability ï¼ˆSERE 2012ï¼‰ 
å‡ºåœ‹ç›®çš„/
ç™¼è¡¨è«–æ–‡é¡Œ
ç›® 
ç™¼è¡¨è«–æ–‡ï¼š 
è«–æ–‡ä½œè€…æ–¼é¡Œç›®: Hsiao-Ying Lin, John Kubiatowicz and Wen-Guey Tzeng. 
A Secure Fine-Grained Access Control Mechanism for Networked Storage 
System. In the Sixth IEEE International Conference on Software Security and 
Reliability (IEEE SERE 2012), June 2012.  
 
å…§å®¹åŒ…æ‹¬ä¸‹åˆ—å„é …ï¼š 
ä¸€ã€ åƒåŠ æœƒè­°ç¶“é(å«ç…§ç‰‡) 
æœ¬äººæ–¼ 18æ—¥å¾å°ç£æ­æ©Ÿï¼Œç•¶æ—¥æŠµé”ï¼Œ19æ—¥èª¿æ•´æ™‚å·®ï¼Œ20é–‹å§‹åƒåŠ æœƒè­°ï¼Œæœƒè­°èˆ‰
è¾¦æœŸé–“ç‚º 6æœˆ 20æ—¥è‡³ 6æœˆ 22æ—¥ï¼ŒåƒåŠ å®Œæœƒè­°å¾Œï¼Œæ–¼ 23æ—¥é›¢é–‹è¯ç››é “ ç‰¹å€ï¼Œ24æ—¥åˆ°é”
å°ç£ã€‚æ–¼æœƒè­°èˆ‰è¾¦æœŸé–“ï¼Œæœ¬äººåƒåŠ æœƒè­°è¡Œç¨‹ï¼Œè©³ç´°è¡Œç¨‹è³‡è¨ŠæŒ‰æ™‚é–“é †åºæ•´ç†å¦‚ä¸‹: 
ï¬ 6æœˆ 20æ—¥: 
æœƒè­°é¦–æ—¥ï¼Œç”±è¬çºŒå¹³æ•™æˆå”åŠ©è¯ç¹«ç•¶åœ°çš„åŒå­¸ä¾†æ¥æˆ‘å€‘ä¸€è¡Œä¸‰äººæŠµé” NISTçš„ 101
å¤§æ¨“ã€‚é€²å…¥ NISTå€åŸŸéœ€è¦æŒæœ‰ä¸€ä»½é€šè¡Œæ–‡ä»¶èˆ‡ä¸€ä»½å«ç…§ç‰‡çš„å€‹äººè­˜åˆ¥è­‰ä»¶ï¼Œç¶“
éè­¦å¯Ÿæ ¸å°ä¹‹å¾Œæ‰èƒ½é€²å…¥ï¼Œé–€ç¦ç›¸ç•¶æ£®åš´ã€‚æˆ‘å€‘æŠµé”æœƒå ´æ™‚ç´„ç‚ºæ—©ä¸Š 9é»åŠã€‚
æœƒè­°åœ°é»åœ¨ NISTå€åŸŸçš„ A101å¤§æ¨“ã€‚ 
 
 
å ±åˆ°æ™‚ï¼Œæ‹¿åˆ°å¤§æœƒæ™‚ç¨‹ï¼Œæ³¨æ„åˆ°è‡ªå·±éœ€è¦åœ¨ 22æ—¥ä¸‹åˆä¸»æŒä¸€å ´è­°ç¨‹(session)ã€‚ 
      
ç¬¬ä¸€å ´ Keynote speechæ˜¯ç”± Virgil Gligorä¸»è¬›ã€‚ 
 
 
 
æ—©ä¸ŠåƒåŠ çš„è­°ç¨‹ç‚º: 
 
 
ä¸‹åˆå‰‡æ˜¯åƒåŠ ï¼š 
 
ä¸‹åˆçš„æ´»å‹•å«æœ‰ä¸€å€‹è‡ªåŠ©åƒè¨ªèˆ‡æ™šå®´ã€‚å…©é …æ´»å‹•éƒ½æ˜¯åœ¨ NIST 101å¤§æ¨“å…§èˆ‰è¡Œï¼Œ
æˆ‘å€‘åœ¨åƒè¨ªæ´»å‹•ä¸­ï¼Œæ‰¾åˆ°äº†ç‰›é “çš„è˜‹æœæ¨¹çš„å¾Œä»£ï¼Œä»¥åŠåƒè¨ªäº† NISTçš„åšç‰©é¤¨
(Museum): 
 åœ¨å ±å‘Šä¹‹å¾Œï¼Œæœ‰ä¸€ä½å­¸è€…æå‡ºä¸‰å€‹å•é¡Œï¼Œåˆ†åˆ¥æ˜¯é‡å°å–æ¶ˆæˆæ¬Šï¼Œå„²å­˜æˆæœ¬ï¼Œä»¥
åŠèˆ‡å…¶ä»–å­˜å–æ§åˆ¶æ–¹å¼çš„æ¯”è¼ƒè¨è«–ã€‚ä¸Šåˆè­°ç¨‹çµæŸå¾Œï¼Œèˆ‡æ­¤å­¸è€…è¨è«–äº†åœ¨çµåˆ
æ‡‰ç”¨ç³»çµ±èˆ‡å¯†ç¢¼å­¸å·¥å…·ä¸Šçš„ç¶“é©—ã€‚ 
 
é€™å¤©ä¸‹åˆçš„æ—¥ç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼Œé€™å…©å€‹è­°ç¨‹çš†ç”±æœ¬äººæ“”ä»»è­°ç¨‹ä¸»å¸­(Session chair): 
 
è‡³æ­¤ï¼Œæœƒè­°é †åˆ©é€²è¡ŒçµæŸã€‚ 
 
ï¬ 6æœˆ 23æ—¥: 
æ—©ä¸Š 8:30 é›¢é–‹é£¯åº—ï¼Œæ­ä¹˜åœ°éµå‰å¾€é›·æ ¹æ©Ÿå ´ï¼Œåœ¨æ©Ÿå ´é™¤äº†åˆ°èˆªç©ºæ«ƒå°å ±åˆ°ï¼Œé€²
è¡Œè¡Œææª¢æŸ¥ï¼Œäº¦é€šéç¹è¤‡çš„å®‰å…¨æª¢æŸ¥ï¼Œè¶³è¦‹ç¾åœ‹å°æ–¼æ©Ÿå ´å®‰å…¨çš„è¬¹æ…ã€‚åœ¨åº•ç‰¹
å¾‹åŠæ±äº¬è½‰æ©Ÿå¾Œï¼Œæ–¼å°ç£æ™‚é–“ 6 æœˆ 24 æ—¥æ™šé–“ 7 é»æŠµé”æ¡ƒåœ’æ©Ÿå ´ï¼ŒçµæŸæ­¤æ¬¡è¡Œç¨‹ã€‚ 
 
äºŒã€èˆ‡æœƒå¿ƒå¾— 
é€™æ¬¡èˆ‡æœƒåœ¨ç ”ç©¶æ–¹é¢æœ‰å¤šé …å¿ƒå¾—ï¼Œé¦–å…ˆç ”ç©¶å­¸è¡“è­°é¡Œèˆ‡æ½®æµæ–¹é¢ï¼Œç›®å‰é‡å°è»Ÿ
é«”å®‰å…¨èˆ‡ç³»çµ±å®‰å…¨çš„ç ”ç©¶å¤§éƒ½éœ€è¦æª¢é©—éå¸¸åº•å±¤çš„æ±è¥¿ï¼Œä¾‹å¦‚åŸå§‹ç¢¼(source 
code)æˆ–åŸ·è¡Œæª”(binary code)ï¼Œä»¥ç™¼æ˜æ½›åœ¨çš„è»Ÿé«”å¼±é»æˆ–ç³»çµ±å¼±é»ï¼Œå› æ­¤éœ€è¦å¤§é‡
çš„è¨ˆç®—ï¼Œéå¸¸é©åˆé›²ç«¯çš„æ¶æ§‹ä¾†åŸ·è¡Œï¼Œå¦ä¸€æ–¹é¢ï¼Œåˆ©ç”¨ Model checking çš„æŠ€è¡“ä¾†
æª¢é©—å„ç¨®ç³»çµ±çš„åŠŸèƒ½èˆ‡å®‰å…¨æ€§ä¹Ÿå—åˆ°é‡è¦–ã€‚æˆ‘å€‘ç™¼è¡¨çš„æ–‡ç« æ˜¯å±¬æ–¼ç³»çµ±æ¬Šé™çš„
å­˜å–æ§åˆ¶ï¼Œé›–ç„¶è¼ƒå°‘çš„æœƒè­°çš„åƒè€…ç†Ÿæ‚‰ï¼Œä½†æ˜¯åœ¨é€²è¡Œå ±å‘Šä¹‹å¾Œï¼Œè¨±å¤šå­¸è€…ç©æ¥µ
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•«è¡ç”Ÿç ”ç™¼æˆæœæ¨å»£è³‡æ–™è¡¨
æ—¥æœŸ:2012/10/26
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•«
è¨ˆç•«åç¨±: åˆ†æ•£å¼ç¶²è·¯å„²å­˜ç³»çµ±å®‰å…¨å‚³è¼¸å•é¡Œçš„ç ”ç©¶
è¨ˆç•«ä¸»æŒäºº: æ›¾æ–‡è²´
è¨ˆç•«ç·¨è™Ÿ: 98-2221-E-009-068-MY3 å­¸é–€é ˜åŸŸ: è³‡è¨Šå®‰å…¨
ç„¡ç ”ç™¼æˆæœæ¨å»£è³‡æ–™
å…¶ä»–æˆæœ 
(ç„¡æ³•ä»¥ï¥¾åŒ–è¡¨é”ä¹‹æˆ
æœå¦‚è¾¦ï§¤å­¸è¡“æ´»å‹•ã€ç²
å¾—çé …ã€é‡è¦åœ‹éš›åˆ
ä½œã€ç ”ç©¶æˆæœåœ‹éš›å½±éŸ¿
ï¦ŠåŠå…¶ä»–å”åŠ©ç”¢æ¥­æŠ€
è¡“ç™¼å±•ä¹‹å…·é«”æ•ˆï¨—äº‹
é …ç­‰ï¼Œè«‹ä»¥æ–‡å­—æ•˜è¿°å¡«
ï¦œã€‚) 
ç„¡ 
 æˆæœé …ç›® ï¥¾åŒ– åç¨±æˆ–å…§å®¹æ€§è³ªç°¡è¿° 
æ¸¬é©—å·¥å…·(å«è³ªæ€§èˆ‡ï¥¾æ€§) 0  
èª²ç¨‹/æ¨¡çµ„ 0  
é›»è…¦åŠç¶²ï¤·ç³»çµ±æˆ–å·¥å…· 0  
æ•™æ 0  
èˆ‰è¾¦ä¹‹æ´»å‹•/ç«¶è³½ 0  
ç ”è¨æœƒ/å·¥ä½œåŠ 0  
é›»å­å ±ã€ç¶²ç«™ 0  
ç§‘ 
æ•™ 
è™• 
è¨ˆ 
ç•« 
åŠ  
å¡« 
é … 
ç›® è¨ˆç•«æˆæœæ¨å»£ä¹‹ï¥«èˆ‡ï¼ˆé–±è½ï¼‰äººï¥© 0  
 
