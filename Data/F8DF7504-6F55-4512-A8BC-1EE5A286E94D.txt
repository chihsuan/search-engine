I 
 
æ‘˜è¦ 
è¿‘ï¦Žï¤­ï¼Œé¢å°ï¦¹æ„ç¨‹å¼æŒçºŒçš„å¨è„…ï¼Œç„¡ï¥æ˜¯åœ¨å€‹äººé›»è…¦æˆ–å•†ç”¨é›»è…¦ä¸Šï¼Œç¢ºå¯¦çš„å®‰è£é˜²
æ¯’è»Ÿé«”ä¸¦ä¸”å®šæœŸï¤æ–°ç—…æ¯’ç¢¼å·²ç¶“æ˜¯æ™®éå¿…è¦çš„å·¥ä½œã€‚ä½†æ˜¯é€™æ¨£åšå»å¾žæœªçœŸæ­£èƒ½è®“ï¦¹æ„ç¨‹å¼
éŠ·è²ï§«è·¡ï¼Œæ–°çš„æ”»æ“Šä»ç„¶æ˜¯ä¸‰ï¥§äº”æ™‚åœ°ç™¼ç”Ÿã€‚å¯ï¨Šæ¬²é€éŽé˜²æ¯’è»Ÿé«”éæ­¢ï¦¹æ„ç¨‹å¼æ”»æ“Šæ˜¯ä¸€
é …æ²»æ¨™ï¥§æ²»æœ¬ï¼Œç”šè‡³æ˜¯æœ¬æœ«å€’ç½®çš„ä½œæ³•ã€‚å…¶åŽŸå› åœ¨æ–¼å…¶æ‰€ä½¿ç”¨çš„ç‰¹å¾µç¢¼æ¯”å°æ³•å¿…é ˆäº‹å…ˆå»º
ç½®ï¦¹æ„ç¨‹å¼çš„ç‰¹å¾µç¢¼æ–¹èƒ½æœ‰æ•ˆåµæ¸¬ï¼Œå¦‚æ­¤é¢å°æ–°çš„ï¦¹æ„ç¨‹å¼åªèƒ½æ–¼äº‹å¾Œé€²ï¨ˆè£œå¼·åµæ¸¬ï¼Œç„¡
æ³•åœ¨å…¶å‡ºç¾çš„ç¬¬ä¸€æ™‚é–“å°±æœ‰æ•ˆçš„æ””é˜»ï¼Œé”åˆ°é é˜²çš„æ•ˆæžœã€‚ 
ç‚ºæ­¤æœ¬è¨ˆç•«çš„ç ”ç©¶ç›®çš„è‘—é‡æ–¼æä¾›ä¸€å¥—å…·æœ‰é æ¸¬èƒ½ï¦Šçš„ï¦¹æ„è»Ÿé«”åµæ¸¬æ©Ÿåˆ¶ï¼ŒæœŸæœ›èƒ½å¾¹
åº•æ”¹å–„ç›®å‰é˜²æ¯’è»Ÿé«”çš„ï¥§è¶³ã€‚æˆ‘å€‘èªç‚ºä¸€èˆ¬è»Ÿé«”å’Œï¦¹æ„ç¨‹å¼æ—¢ç„¶åœ¨åŸ·ï¨ˆç›®çš„ä¸Šæ˜¯ï¥§åŒçš„ï¼Œ
å…¶åœ¨è¨­è¨ˆæœ¬è³ªå’Œç¨‹å¼ï¨ˆç‚ºä¸Šäº¦æ˜¯æœ‰å·®ï¥¢ã€‚è—‰ç”±è§€å¯Ÿç¨‹å¼æ‰€ä½¿ç”¨çš„å‹•æ…‹ï¦šçµæª”ï¼ˆDynamically 
Linked Libraryï¼‰ä¹‹é–“çš„é—œï¦šæ€§å’Œæ‡‰ç”¨ç¨‹å¼(Application Programming Interface)ä»‹é¢ä¸Šçš„ä½¿
ç”¨ï¼Œä¸¦é€éŽè³‡è¨Šå¢žï¨—(Information Gain)æŠ€è¡“é€²ï¨ˆç‰¹å¾µç¸®æ¸›(Feature Reduction)å’Œæ”¯æŒå‘ï¥¾æ©Ÿ
(Support Vector Machine)æ–¹æ³•ï¼Œæˆ‘å€‘åˆ†åˆ¥å®Œæˆç‰¹å¾µé¸å–(Feature Selection)èˆ‡å­¸ç¿’åˆ†ï§å™¨
(Learning Classifier)çš„å»ºï§·ï¼Œä¸¦åœ¨ 1758 ç­†æ­£å¸¸ç¨‹å¼å’Œ 846 ç­†ï¦¹æ„ç¨‹å¼çš„å¯¦é©—è³‡ï¦¾ä¸‹ï¼ŒæˆåŠŸ
çš„å»ºç½®å…·æœ‰ 99%çš„æ•´é«”åµæ¸¬ï¥¡å’Œ 96.66%çš„æ•´é«”é æ¸¬ï¥¡çš„ç³»çµ±ã€‚ 
 
é—œéµå­—ï¼š ï¦¹æ„ç¨‹å¼ã€è³‡è¨Šå¢žï¨—ã€ç‰¹å¾µç¸®æ¸›ã€ç‰¹å¾µé¸å–ã€æ”¯æŒå‘ï¥¾æ©Ÿ 
 
 
 
 
 
 
 
 
 
 
 
1 
 
1. Introduction 
According to SymantecÂ® security reports [10, 11], during July 2006 to June 2007, the virus 
threats have been getting serious so far. There were total 8,258 new Win32 variants and 136 
previously unseen malware reported on the second half year of 2006. The number of virus 
without anti-virus signatures increased 22 percent over the first half of 2006. Furthermore, 
212,101 new malicious code threats appeared in the first half year of 2007. It was a 185 percent 
increase over the second half of 2006. The studies in Computer virus detection have been worked 
for many years; however, the records above show that they are apparently not well enough. 
A malware detection model could be classified into one of the two categories: a 
signature-based detector and a heuristic classifier. Signature-based anti-virus software catches 
malware based on â€œknownâ€ signature, but it is unrealistic for unknown virus or variants of existed 
ones. Most commercial antivirus applications use such signature-based approach and certainly get 
an excellent result on detecting known malicious codes. However, any novel malicious code can 
easily get chance to carry out its dirty work until vendors find it and distribute new signature 
definitions. Recall of the Melissa virus, Love letter, CodeRed, and Blaster, they all caused severe 
damages before antivirus vendors provided remedies. On the other hand, a heuristic classifier 
usually analyzes code sequences in a program to predict its behavior and judge whether it is a 
malicious code or not. Although a heuristic classifier may possibly cause some false positive 
alarms, it has potential ability to identify a new malware and thus thwart a virus outbreak before 
it becomes an epidemic.  
No matter signature-based or heuristic classifier, if the information for judgment is collected 
absolutely from the code itself, without any running information, such as memory and CPU time 
consumptions, traffic amount, etc, this kind of detection is called static analysis. Static analysis 
examines control flows, programming structures, and contents of codes to determine properties of 
an executable program without running it. While a dynamic analysis lets a program be run and 
monitors the execution process trying to find some abnormal behaviors if exist. Ideally, 
identifying a malware before running it is a better solution, since it would have no chance to be 
too late before damage occurred. Therefore, our aim is to propose a virus prevention model 
(VPM) based on novel data mining methods to fix the drawbacks of traditional anti-virus 
methods. 
The rest of this paper is organized in the following way. Section 2 is devoted to some related 
researches of malicious executable detection. Section 3 states the main ideas of our VPM with 
experiment results given in Section 4. Finally, a few concluding remarks are sketched in Section 
5. 
 
2. Related work 
In general, there are two kinds of approaches for virus detection: static analysis and dynamic 
analysis. Static analysis utilizes the information in suspected executable programs without 
running it; and dynamic analysis monitors software activities after loading it into memory. 
Dynamic approach pays more attention on activities, but it is hard to prevent damage in advance 
to request the operating system to execute critical operations such as file management, resource 
access, and device control etc. MicrosoftÂ® Windows operation system provided many APIs in all 
kinds of DLLs for applications to interact with it. Utilizations of DLLs and APIs could be defined 
as behaviors of the executable and considered as attributes, which provide some clues to 
discriminate viruses from benign programs.  
 The attributes of an executable can be statically extracted from its Portable Executable (PE) 
file format [8] without running the program. PE file format is a data structure, which records 
necessary information for the Windows OS loader to manage the wrapped executable 
code. Figure 2 gives a simple view of its format. We used a utility named â€œDependency Walkerâ€ 
to parse the PE file format and output in tree structure. Figure 3 is an example of a tree diagram, 
which illustrates the relationships of the invoking DLLs in an executable. In this tree structure, 
each parent DLL invokes some APIs exported from its child DLLs. Basing on the tree structure, 
we defined three types of attributes: T1, T2 and T3. T1 indicates the APIs directly used by the 
main program, i.e., the APIs reside in the first layer DLLs. T2 is the APIs contained in the first 
layer DLLs indirectly invoked by other DLLs except the main executable. T3 consists of the 
entire dependency paths to represent the relationship between DLLs. Each of them is a complete 
downward path, starting from a first layer DLL to each of its leaf DLL. Moreover, each DLL 
records a hash value to indicate the content of the APIs directly exploited by its parent DLL. An 
example of three different types of attributes is given in Figure 3. 
 
 
Figure 2. Portable Executable File Format 
 
3 
 
information about X provided by Y. 
 
                          Â  Â  Â  Â  Â  Â  Â  Â  Â  Â 
In our study, there were only two classes in the dataset and H(X) is equal to the equation below
                      
: 
(v=virus, b=benign) 
        
  
, where |.| denotes the number of particular kind of executable and |S| = |v| + |b|. In addition, Y is 
an attribute with Boolean value such that Y = 1 indicates the subset S1 in which each instance has 
attribute Y and Y = 0 represents the subset S0 = 
          Â 
S - S1. is denoted in (5) and |Sk| = |vk| +  
|bk|. 
 
According to the definition of IG, the higher the IG, the better discrimination the attribute has. 
As shown in Figure 4, it can also mean that attributes with equal IG are also the same in 
discrimination power that could be highly related. Therefore, it is unnecessary to reserve all of 
them to increase the burden of the data mining process especially when dealing with 
high-dimensional problem. Basing on this simple idea, the attribute elimination was performed by
disca
 
rding all but one of attributes with the same IG. Finally, according to the attributes that we 
had reserved, every executable was represented by a Boolean vector. Each vector element 
corresponds to an attribute and its Boolean value indicates the corresponding attribute exists in 
the executable or not. An example is given in Table 1. 
 
Figure 4. Attribute selection by Information gain 
5 
 
    
 
FigureÂ 5.Â LinearlyÂ separableÂ SVMÂ 
 
 
FigureÂ 6.Â LinearlyÂ nonâ€separableÂ SVMÂ 
7 
 
9 
 
otations for performance evaluation 
detects a spyware precisely. The true positive rate 
Table 2. N
True Positives 
(TP) 
The true positive indicates that the detection system 
(TP rate) is also called the detecting rate 
FN
TP  
TP +
False Positives 
(FP) 
The false positive indicates that a particular 
executable is detected as a spyware by the system 
but it is actually a benign. If it is too high, it will let 
ministrators to intentionally ignore the 
 warnings. The false positive rate 
the ad
detection system
(FP rate) also is called false alarms 
TNFP
FP
+  
Overall Accuracy 
(OA) 
It is defined as. Evaluating the detection efficiency of 
the spyware detection system, it is not only considering 
the higher TP rate but also considering the lower FP 
rate. Therefore, the overall accuracy could be the 
main reference for us to compromise both TP rate 
and FP rate. 
FNFPTNTP
TNTP
+++
+
 
Cross Validation 
(CV) 
The concept of cross validation rate (CV Rate) stated 
above; we use this to represent the prediction ability 
l 
 
 
of our system when facing an unknown or nove
spyware. 
 
Since both of the d t rate of benign program are 
important, we evaluated Accuracy ( A) 
ind the proportion tained two parts: 
the detection of known s. The prediction 
rate was calculated by fi t were randomly 
divided into five disjoint , one of them was 
chosen as the testing set ere merged into a training set. This 
pro  et. We calculated 
the average OA as the ge
After parsing the PE 3 16 attributes in 
the beginning. The expe  of the attributes 
with lower IG were disc y. Therefore, we 
successfully reduced the tributes from 93,116 to 1,398 after the process of attribute 
elim sl  pro edure stated 
in  3.3. Evidentl o made further 
progress in classificatio osen to train the 
RBF-SVM and achieved a proper performance with 96.66% in prevention rate and 99.00% in 
detection rate (TP=98.35%, FP=0.68%). 
 
etection rate of virus and the false aler
 them at the same time by the viewpoint of Overall 
of correctly classified executables. The experiment con
viruses and the prediction of previously unseen viruse
ve-fold cross-validation (CV). In other words, the datase
 portions with an equal number of sizes in each portion
, and the remaining four portions w
O
icates 
cedure was repeated five times by choosing different partition as a testing s
neralization ability of our system.  
 file format of each executable in the dataset, we got 9
riment results shown in Table 3 reveal that even some
arded; the performance of RBF-SVM remained stead
 number of at
,1
ination. Continuou
Section
y, Figure 3 presents the results of the feature selection
y, we not only succeeded in feature reduction but a
n performance. Finally, the top 429 features was ch
c
ls
11 
 
email addresses, bank account numbers or credit card numbers brings a huge damage if those 
collected important information are used by someone with evil intention. With the observation 
that it is natural for a spyware to work stealthily and peacefully with the host and not to destroy 
the victim, we used both static and dynamic methods to analyze the behaviors of spyware and 
benign programs. Then, adopt the concept of information gain to extract valuable behaviors 
which are distinguishingly used by normal executables and spyware to train a classifier. The 
experiment, results given in Table 4, shows that this integrated architecture is proposed in the first 
year had 98% detecting rate to known spyware and 96% detecting rate to unknown or novel 
spyware.  
 
Table 4. Performance of Spyware Detection System(SDS) 
 FP TP OA CV 
SDS 0.68% 95.33% 97.91% 96.43% 
 
Next, in the second year of this project, we was encouraged with the study results of the first 
year and wanted to 
revious work performed well in the spyware area, it is clearly that dynamic analysis canâ€™t be 
the fact that the destructive attacks could be 
features should be observed for elaborate the 
nua
d Support Vector Machine (SVM) to combat two types of malware-virus and 
wor
extent the architecture to the more generic situation-malware. Although our 
p
directly applied to the malware problem due to 
launched as well. Nevertheless, more kinds of 
nces between benign and malicious programs. Therefore, we proposed a complete static 
malware detection system points out relationships among the usages of DLLs of different kinds 
of executables and combined several data mining technologies such as Information Gain (IG), 
Bayes classifier an
m. We used IG to choose valuable raw features and finally adopted Bayes theory and SVM to 
train a classifier for detection engine. A large dataset totally containing about 3000 executable 
programs were used to evaluate performance of our system. Although Bayes classifier didnâ€™t 
perform well, the result of SVM showed that for known malware the detection rate is nearly 99% 
and the detection rate for unknown malware is about 96%. Table 5 presents the experiment results 
of this project in second year. 
 
Table 5. Performance of Malware Detection System 
 SVM OA Bayes OA SVM CV Bayes CV 
Virus 99.53% 83.2% 95.88ï¼… 83.1% 
Worm 98.8% 94.5% 96.10ï¼… 72.62% 
 
In the final period of this project, improvement of detection performance was continued in 
tandem with moderation of the computing resource. A better way to adopt feature reduction 
together with f to construct a 
detection system wi  proper per ance w 96.66  prev
detection rate. Table 6 conducts a summary of this project. 
eature selection method is proposed. Only 429 features were used 
th form ith % in ention rate and 99.00% in 
13 
 
 
References 
 
[1] J. Ber bi, J. Desharnais Static 
 Exec mposium on Requirements 
Engineering for Information Security (SREIS' 01), 2001. 
[2] J. Ber . Ktari, Static analysis of binary code to 
isolate malicious behaviors, Proceedings of the IEEE 8th International Workshops on 
9. 
[3] C.-C  
[4] N. Cristianini and J. Shawe-Taylor chines, 
Cam
[5] rning to detect malicious executables in the wild, 
Proceed  international conference on Knowledge discovery 
and USA, 2004. 
[6] M. M. Masud, L. Khan and B. Thuraisingham, A Hybrid Model to Detect Malicious 
 International Conference on Communications 
(ICC tions Network Security Symposium (2007), pp. 
1443-1448. 
[7] C. M lysis of executables to detect malicious patterns, 
Proceedings of the 12th conference on USENIX Security Symposium - Volume 12, 
[9] M. G. Schultz, E. Eskin, E. Zadok and S. J. Stolfo, Data mining methods for detection of 
new malicious executables, in E. Eskin, ed., Proceedings of the 2001 IEEE Symposium on 
Security and Privacy, 2001, pp. 38-49. 
[10] Symantec, Symantec Internet Security Threat Report, 11 (March 2007). 
[11] Symantec, Symantec Internet Security Threat Report, 12 (September 2007). 
[12] V. N. Vapnik, Statistical Learning Theory, John Wiley & Sons, 1998. 
itten and E. Frank, Data Mining- Practical Machine Learning Tools and 
Techniques with JAVA Implementations, Morgan Kaufmann, 2005. 
 
 
 
 
 
geron, M. Debba , M. M. Erhioui, Y. Lavoie and N. Tawbi, 
utable Programs, SyDetection of Malicious Code in
geron, M. Debbabi, M. M. Erhioui and B
Enabling Technologies: Infrastructure fo
. Chang and C.-J. Lin, LIBSVM: a l
bridge University Press, 2000. 
r Collaborative Enterprises, 1999, pp. 184-18
ibrary for support vector machines, 2001.
, An Introduction to Support Vector Ma
J. Z. Kolter and M. A. Maloof, Lea
ings of the tenth ACM SIGKDD
data mining, ACM, Seattle, WA, 
Executables, In Proceedings of the IEEE
), Computer and Communica
ihai and J. Somesh, Static ana
USENIX Association, Washington, DC, 2003. 
[8] M. Pietrek, Peering Inside the PE: A Tour of the Win32 Portable Executable File Format, 
Microsoft Systems Journal, 9 (1994), pp. 15-34. 
[13] I. H. W
 
 
 
 
å¯ä¾›æŽ¨å»£ä¹‹ç ”ç™¼æˆæžœè³‡ï¦¾è¡¨ 
â–  å¯ç”³è«‹å°ˆï§  â–  å¯æŠ€è¡“ç§»è½‰                                      æ—¥æœŸï¼š97ï¦Ž7æœˆ31æ—¥ 
åœ‹ç§‘æœƒè£œåŠ©è¨ˆç•« 
è¨ˆç•«åç¨±ï¼šå…·å­¸ç¿’åŠŸèƒ½ä¹‹é˜²ï¦¹æ„ç¨‹å¼ç³»çµ±ä¹‹ç ”ç©¶ 
è¨ˆç•«ä¸»æŒäººï¼šå³ï¤Šé›„ æ•™æŽˆ         
è¨ˆç•«ç·¨è™Ÿï¼šNSC 94-2213-E-158-005             
å­¸é–€ï¦´åŸŸï¼šè³‡è¨Šå®‰å…¨ 
æŠ€è¡“/å‰µä½œåç¨± å…·å­¸ç¿’èƒ½ï¦Šä¹‹ï¦¹æ„ç¨‹å¼åµæ¸¬æ©Ÿåˆ¶ 
ç™¼æ˜Žäºº/å‰µä½œäºº å³ï¤Šé›„ 
æŠ€è¡“ï¥¯æ˜Ž 
ä¸­æ–‡ï¼š 
æœ¬ç ”ç©¶è¨ˆç•«ä¹‹æŠ€è¡“ä¸»è¦æ˜¯é‡å°é‹ï¨ˆæ–¼ Windows å¹³å°ä¸Šçš„å¯åŸ·ï¨ˆæª”
ï§åž‹ä¹‹ä¸€èˆ¬æ‡‰ç”¨ç¨‹å¼èˆ‡ï¦¹æ„ç¨‹å¼(å¦‚ç—…æ¯’ã€è •èŸ²ã€æœ¨é¦¬ã€å¾Œé–€å’Œé–“
è«œè»Ÿé«”)é€²ï¨ˆéœæ…‹èˆ‡å‹•æ…‹æ–¹æ³•åˆ†æžè’é›†ç¨‹å¼ç›¸é—œï¨ˆç‚ºè³‡è¨Šã€‚éœæ…‹åˆ†
æžæ³•åŒ…å«å‹•æ…‹ï¦šçµæª”å€‹åˆ¥çš„å‘¼å«èˆ‡ä¹‹é–“çš„é—œï¦—æ€§ã€æ‡‰ç”¨ç¨‹å¼ä»‹é¢çš„
ä½¿ç”¨ã€‚è€Œå‹•æ…‹çš„éƒ¨åˆ†å‰‡åŒ…å«å°æ–¼ç³»çµ±è¨»å†Šæª”çš„ä¿®æ”¹ã€ç³»çµ±è³‡ï¦¾å¤¾å…§
æª”æ¡ˆçš„å¢žåˆªå’Œç¶²ï¤·ä½¿ç”¨æƒ…æ³ç­‰ã€‚ä¸¦ï§ç”¨è³‡ï¦¾æŽ¢å‹˜æ³•å¾žä¸­ä¹‹ç‰¹å¾µé¸å–
æŠ€è¡“èƒå–å‡ºæœ‰åŠ©æ–¼é‘‘åˆ¥å‡ºï¦¹æ„ç¨‹å¼çš„ç¨‹å¼ï¨ˆç‚ºä½œç‚ºç‰¹å¾µï¼Œçµåˆç‰¹å¾µ
ç¸®æ¸›æŠ€è¡“é”åˆ°ç‰¹å¾µï¥©ï¥¾çš„å£“ç¸®ã€‚æœ€å¾Œä»¥æ©Ÿå™¨å­¸ç¿’æ¼”ç®—æ³•è¨“ï¦–ï¥§åƒ…åŒ
æ™‚èƒ½åµæ¸¬ç¾æœ‰ï¦¹æ„ç¨‹å¼ï¼Œï¤å…·å‚™é é˜²æœªï¤­æ–°åž‹ï¦¹æ„ç¨‹å¼ä¹‹èƒ½ï¦Šçš„å­¸
ç¿’åˆ†ï§å™¨ã€‚ 
 
è‹±æ–‡ï¼š 
This research project is targeted at the analysis the 
behaviors of Windows executables which can be used to detect 
malware such as virus, worm, and spyware. 
First, static and Dynamic analyzing methods were both been 
adopted to acquired behaviors of executables. By static 
method, we collected information of the relationship between 
the invocated dynamically linked libraries (DLLs) in tandem 
with the usage of application programming interfaces (APIs)
of each executable. Besides, with the help of dynamic 
analysis, alterations in registry or any variation in file 
system or network state were also gathered for further 
analyzing. Next, feature selection and feature reduction 
methods were applied to extract the not only valuable but also 
significant behaviors which are finally used to train a 
learning classifier. The characteristic of our technique is 
the generalization ability which can even intercept any new 
malware performs some malicious actions.  
å¯ï§ç”¨ä¹‹ç”¢æ¥­ 
åŠ 
å¯é–‹ç™¼ä¹‹ç”¢å“ 
å¯èˆ‡ç¾æœ‰ä¹‹é˜²æ¯’è»Ÿé«”æ•´åˆï¼Œé‹ï¨ˆæ–¼å€‹äººé›»è…¦ã€å•†ç”¨é›»è…¦ã€PDAã€Smart 
Phone ç­‰å„é …ä½¿ç”¨ Windows OS ä¹‹ç³»çµ±ã€‚ 
é™„ä»¶äºŒ 
å‡ºå¸­åœ‹éš›å­¸è¡“æœƒè­°å¿ƒå¾—å ±å‘Š 
                                                             
è¨ˆç•«ç·¨è™Ÿ NSC96-2221-E-158-001-
è¨ˆç•«åç¨± å…·å­¸ç¿’åŠŸèƒ½ä¹‹é˜²ï¦¹æ„ç¨‹å¼ç³»çµ±ä¹‹ç ”ç©¶(3/3)
å‡ºåœ‹äººå“¡å§“å 
æœå‹™æ©Ÿé—œåŠè·ç¨± å³ï¤Šé›„ å¯¦è¸å¤§å­¸ è³‡è¨Šç§‘æŠ€èˆ‡é€šè¨Šå­¸ç³»æ•™æŽˆå…¼å‰¯æ•™å‹™é•· 
æœƒè­°æ™‚é–“åœ°é»ž  2008 ï¦Ž 7 æœˆ 8 æ—¥è‡³ 11 æ—¥ æ¾³å¤§ï§äºžé›ªï§¢å¸‚ 
æœƒè­°åç¨± 2008 IEEE 8th International Conference on Computer and Information Technology Workshops 
ç™¼è¡¨ï¥æ–‡é¡Œç›® A Virus Prevention Model Based on Static Analysis and Data Mining Methods 
 
 
ä¸€ã€ ï¥«åŠ æœƒè­°ç¶“éŽ 
IEEE International Conference on Computerand Information 
Technology æ˜¯ç”±IEEE Computer Societyï¼ˆé›»è…¦å­¸æœƒï¼‰ä¸»è¾¦çš„åœ‹éš›ç ”è¨Ž
æœƒï¼Œä»Šï¦Žç¬¬8å±†æ–¼7æœˆ8æ—¥è‡³11æ—¥ç”±é›ªï§¢ç§‘æŠ€å¤§å­¸åˆè¾¦ï¼Œåœ¨æ¾³å¤§ï§äºžé›ªï§¢
å¸‚çš„é›ªï§¢ç§‘æŠ€å¤§å­¸èˆ‰ï¨ˆï¼Œç‚ºåœ‹éš›é–“é›»è…¦èˆ‡è³‡è¨Šç§‘æŠ€ç›¸é—œï¦´åŸŸä¹‹é‡è¦ç ”è¨Ž
æœƒï¼Œæä¾›å­¸è€…å­¸è¡“åŠæŠ€è¡“äº¤ï§Šèšæœƒã€‚æœ¬ç ”ç©¶è¨ˆç•«ä¸»è¦æ˜¯æ‡‰ç”¨è³‡è¨Šï§¤ï¥åŠ
æ©Ÿæ¢°å­¸ç¿’åŽŸï§¤æ–¼ï¦¹æ„ç¨‹å¼ä¹‹åµæ¸¬ï¼Œèƒ½å‡ºå¸­æ­¤åœ‹éš›å­¸è¡“ç››æœƒäº¤æ›ç ”ç©¶å¿ƒå¾—
ä»¥åŠæœ€æ–°çŸ¥ï§¼ï¼Œæ·±æ„Ÿæ¦®å¹¸ï¼ 
æˆ‘æ–¼7 æœˆ8 æ—¥å¾žä¸­æ­£æ©Ÿå ´æ­ä¹˜ä¸­è¯èˆªç©ºç­æ©Ÿç›´é£›æ¾³å¤§ï§äºžé›ªï§¢
å¸‚ï¼Œç”±æ–¼2008ï¦Žå¤©ä¸»æ•™ä¸–ç•Œé’ï¦Žæ—¥ä¹Ÿæ˜¯åœ¨é›ªï§¢èˆ‰è¾¦ï¼Œç•¶ä»Šæ•™å®—æœ¬ç¯¤åï§‘
ä¸–è¦ªï§¶ä¸»æŒï¼Œç´„æœ‰ï¤­è‡ªä¸–ç•Œå„åœ°é’ï¦Ž30è¬äººï¥«åŠ ï¼Œä»¥è‡´æ©Ÿç¥¨åŠï¨ªåº—ï¨¦ï¥§
å®¹ï§ é è¨‚ï¼Œæ©Ÿå ´å®‰æª¢åŠé€šé—œä¹Ÿç‰¹åˆ¥åš´æ ¼ï¼Œåœ¨ï¨ˆç¨‹ä¸Šæœ‰äº›è€½å»¶ã€‚æœƒå ´æœ‰å¾ˆ
å¤šï¤­è‡ªï¥§åŒåœ‹å®¶çš„å­¸è€…èˆ‡æœƒï¼Œä½†ä»¥è¯äººå­¸è€…å±…å¤šï¼Œè€Œæ‰¿è¾¦åŠæŽ¥å¾…äººå“¡å¹¾
ä¹Žï¨¦æ˜¯ä¸­åœ‹å¤§ï§“ï¦ƒæ¾³å­¸è€…åŠï§å­¸ç”Ÿï¼Œå½·å½¿æ˜¯åˆ°ï¦ºé¦™æ¸¯ã€‚æ™šä¸Šçš„é–‹å¹•é¤
æœƒï¼Œç‚ºï¤­è‡ªä¸–ç•Œå„åœ°çš„å°ˆå®¶å­¸è€…æ´—å¡µï¼Œæœƒä¸­ä¸¦æœ‰ç•¶åœ°ç‰¹è‰²çš„è¡¨æ¼”ï¼Œåœ¨é¤
æœƒä¸­çµï§¼ï¦ºå¤§æœƒä¸»å¸­Xiangjian He(ä½•)æ•™æŽˆåŠè²¡æ”¿ä¸»å¸­Wenjing Jia(ï¤ƒ)æ•™
æŽˆï¼Œä»–å€‘ï¥¸ä½ï¨¦æ˜¯å¤§ï§“ï¦ƒæ¾³å­¸è€…ï¼Œæ˜¯é›ªï§¢ç§‘æŠ€å¤§å­¸çš„æ•™æŽˆï¼Œä½•æ•™æŽˆæ›¾åˆ°
å°ç£è¨ªå•ã€‚é¤æœƒä¸­ä¹Ÿçµï§¼ï¦ºï¤­è‡ªå°ç£å¤§åŒå¤§å­¸çš„ï§¡ï¥¼å¾·æ•™æŽˆåŠï¥£å°ç£ç§‘
æŠ€å¤§å­¸çš„å¼µé´»æºï¤´å¸«ï¼ŒçœŸæ˜¯ä»–é„‰é‡åŒï¨ˆå€æ„Ÿè¦ªï¨€ï¼Œæœƒå¾Œæˆ‘å€‘ä¸‰äººä¹Ÿä¸€èµ·
 1
çš„ç³»çµ±ï¥§åƒ…èƒ½æœ‰æ•ˆåµæ¸¬ç›®å‰ç¾æœ‰çš„é›»è…¦ç—…æ¯’ï¼Œï¤å…·å‚™åµæ¸¬æœªçŸ¥é›»è…¦ç—…æ¯’
çš„èƒ½ï¦Šã€‚æœ¬ï¥æ–‡å®‰æŽ’æ–¼åœ¨7 æœˆ11 æ—¥ä¸‹åˆç™¼è¡¨ï¼Œç•¶å ´ä¸¦ç²å¾—èˆ‡æœƒå­¸è€…è¨±
å¤šå¯¶è²´çš„æ„ï¨Šï¼Œå…¶ä¸­æ¾³æ´²å­¸è€…Ganesh NaikåŠAshley Chonkaå°æœ¬ï¥æ–‡ç‰¹
åˆ¥æ„Ÿèˆˆè¶£ï¼Œç›¸é—œç ”è¨Žæƒ…æ³å¦‚ä¸‹åœ–ã€‚æ‰¿è’™å¤§æœƒåŽšæ„›ï¼Œé‚€è«‹å€‹äººæ“”ä»»ä¸»é¡Œ
Networking and Mobile Computingä¸­ï¥¸å ´sessionsä¹‹ä¸»æŒäººï¼Œæ·±æ„Ÿæ¦®è€€ï¼ 
 
äºŒã€ èˆ‡æœƒå¿ƒå¾— 
å¤§æœƒè²»å¿ƒå®‰æŽ’èˆ‡çµ„ç¹”æœƒè­°å…§å®¹ï¼Œå…§å®¹æ—¢å¤šå…ƒåˆè±å¯Œã€‚é™¤ç ”ç©¶æˆæžœçš„
åˆ†äº«å¤–ï¼Œäº¦æœ‰å°ˆé¡Œæ¼”è¬›ã€å£é ­å ±å‘Šã€é¤æœƒã€ç ”è¨Žæœƒç­‰ï¥§åŒåž‹æ…‹çš„ç ”ç©¶åˆ†
äº«åŠå„é …ç¤¾äº¤æ´»å‹•ï¼›ç¸½ç™¼è¡¨ï¥æ–‡ç´„æœ‰270å¤šç¯‡æ–‡ç« ï¼Œæœ‰æ©Ÿæœƒèƒ½ï¥«èˆ‡æ­¤åœ‹
éš›ç ”è¨Žæœƒï¼Œèˆ‡åœ‹å…§å¤–æ­¤ä¸€ï¦´åŸŸå­¸æœ‰å°ˆï¨ä¹‹å¤§å¸«åŒå°ç ”è¨Žï¼Œèˆˆå¥®ä¹‹æƒ…æº¢æ–¼
è¨€è¡¨ã€‚é›–ç„¶æœƒå ´å¾ˆå¤šè¯äººï¼Œï¦¨äººæ„Ÿåˆ°ä»–é„‰é‡æ•…çŸ¥ï¼Œä½†æˆ‘çœŸçš„å­¸ç¿’åˆ°è‹±æ–‡
çœŸçš„å¾ˆé‡è¦ï¼Œæœƒå ´ï¤æ˜¯ä¸€å ´åœ‹éš›äº¤ï§Šçš„èˆžå°ï¼Œï¥´è‹±æ–‡è¡¨é”èƒ½ï¦Šï¥§å¥½ï¼Œå¦‚
ä½•èˆ‡äººæºé€šå‘¢ï¼Ÿå°¤å…¶æ“”ä»»ï¥¸å ´sessionsä¹‹ä¸»æŒäººï¼Œé›–ç„¶äº‹å…ˆå·²æŠŠå„å€‹æ¼”è¬›
è€…ä¹‹ç°¡ï¦ŒåŠæ‰€å…¶ç™¼è¡¨ï¥æ–‡æ‘˜è¦ï¨ï¥šï¼Œä½†é¢å°çœ¾å¤šåœ‹éš›å­¸è€…ï¼Œï§¶å ´çš„è‹±æ–‡
è¡¨é”èƒ½ï¦Šä»éœ€å†ç£¨ï¦–ã€‚ 
å°ç£éŽåŽ»åœ¨IEEEæœ‰å¾ˆå¥½çš„è¡¨ç¾ï¼Œä½†é¢ï§¶ä¸­åœ‹å¤§ï§“çš„å´›èµ·ï¼Œå°ç£çš„å
ç¨±èˆ‡åœ°ä½ä¹Ÿå—åˆ°å¾ˆå¤§çš„æŒ‘æˆ°ã€‚å€‹äººè¦ºå¾—ä¸­åœ‹å¤§ï§“ä¸Šçš„å­¸è¡“ç ”ç©¶é¢¨æ°£ã€èƒ½
ï¦Šèˆ‡æˆæžœï¼Œé€™äº›ï¦Žå·²æ¯”è‡ºç£é‚„å¼·ã€‚è€Œå¤§ï§“çš„ï§å­¸ç”Ÿä¹Ÿå‘ä¸–ç•Œå„çŸ¥åå¤§å­¸
ç™¼å±•ï¼Œè¸´èºï¥«èˆ‡åœ‹éš›ç ”è¨Žæœƒï¼Œå°¤å…¶ä»–å€‘çš„ï¦ƒå¤–å­¸è€…ç›¸é—œåœ˜çµï¼ŒåŠªï¦Šçˆ­å–
å„ç¨®åœ‹éš›æœƒè­°ä¸»è¾¦æ¬Šï¼Œå†å°‡ä¸‹å±†ç§»å¾€ä¸­åœ‹å¤§ï§“èˆ‰ï¨ˆï¼Œå…§å¤–åˆä½œå·²åœ¨åœ‹éš›
 3
A Virus Prevention Model Based on Static Analysis and Data Mining Methods 
 
 
Tzu-Yen Wang 
Dept. of Computer Sci., 
 National Chiao Tung Univ.,  
Hsinchu, Taiwan 
tzu-yen.wang@hotmail.com 
Chin-Hsiung Wu* 
Dept. of Info. Tech. & Comm.,  
Shih Chien Univ. Kaohsiung 
Campus, Taiwan 
chwu@mail.kh.usc.edu.tw 
Chu-Cheng Hsieh 
Dept. of Computer Sci.,  
Univ. of California,  
Los Angeles 
chucheng@ucla.edu 
 
 
Abstract 
 
Owing to the lack of prevention ability of traditional 
anti-virus methods, a behavior-based virus prevention 
model for detecting unknown virus is proposed in this 
study. We first defined the behaviors of an executable 
by observing its usage of dynamically linked libraries 
and Application Programming Interfaces. Then, 
information gain and support vector machines were 
applied to filter out the redundant behavior attributes 
and select informative feature for training a virus 
classifier. The performance of our model was evaluated 
by a dataset contains 1,758 benign executables and 846 
viruses. The experiment results are promising, and the 
overall accuracies are 99% and 96.66% for detecting 
the known viruses and the previously unseen viruses 
respectively. 
* 
 
1. Introduction 
According to SymantecÂ® security reports [9, 10], 

*Corresponding author. 
This work was partially supported by the National Science Council 
under the contract no. NSC-96-2221-E-158-001. 
during July 2006 to June 2007, the virus threats have 
been getting serious so far. There were total 8,258 new 
Win32 variants and 136 previously unseen malware 
reported on the second half year of 2006. The number 
of virus without anti-virus signatures increased 22 
percent over the first half of 2006. Furthermore, 
212,101 new malicious code threats appeared in the 
first half year of 2007. It was a 185 percent increase 
over the second half of 2006. The studies in Computer 
virus detection have been worked for many years; 
however, the records above show that they are 
apparently not well enough. 
Traditional signature-based anti-virus software 
catches malware based on â€œknownâ€ signature, but it is 
unrealistic for unknown virus or variants of existed ones. 
Therefore, our aim is to propose a virus prevention 
model (VPM) based on novel data mining methods to 
fix the drawbacks of traditional anti-virus methods. The 
rest of this paper is organized in the following way. 
Section 2 is devoted to some related researches of 
malicious executable detection. Section 3 states the 
main ideas of our VPM with experiment results given in 
Section 4. Finally, a few concluding remarks are 
sketched in Section 5. 
IEEE 8th International Conference on Computer and Information Technology Workshops
978-0-7695-3242-4/08 $25.00 Â© 2008 IEEE
DOI 10.1109/CIT.2008.Workshops.102
288
extracted from its Portable Executable (PE) file format 
[7] without running the program. PE file format is a 
data structure, which records necessary information for 
the Windows OS loader to manage the wrapped 
executable code. A utility named â€œDependency Walkerâ€ 
can parse the PE file format and output in tree structure. 
Figure 2 is an example of a tree diagram, which 
illustrates the relationships of the invoking DLLs in an 
executable. In this tree structure, each parent DLL 
invokes some APIs exported from its child DLLs. 
Basing on the tree structure, we defined three types of 
attributes: T1, T2 and T3. T1 indicates the APIs directly 
used by the main program, i.e., the APIs reside in the 
first layer DLLs. T2 is the APIs contained in the first 
layer DLLs indirectly invoked by other DLLs except 
the main executable. T3 consists of the entire 
dependency paths to represent the relationship between 
DLLs. Each of them is a complete downward path, 
starting from a first layer DLL to each of its leaf DLL. 
Moreover, each DLL records a hash value to indicate 
the content of the APIs directly exploited by its parent 
DLL. An example of three different types of attributes 
is given in Figure 2. 
 
3.2. Redundant attribute elimination 
 
When dealing with very high-dimensional data, 
eliminating redundant attributes is necessary to keep the 
informative ones called features. Information 
gain(IG)[12], which computes the discrimination of an 
attribute, is a kind of filter approach of feature 
selection. 
Given a random variable X, if there are k values of 
X, the entropy of X is defined in (1), where pi is the 
proportion of X = vi. 
      	
  
  	
  

    (1) 
High entropy implies X to abide by a uniform 
distribution and lack of discrimination. Furthermore, the 
conditional entropy, which is denoted in (2), implies the 
entropy of X conditioned by the values of Y.  

Figure 2. An example of dependency tree 

Then, information gain (3) is the amount by which the 
entropy of X decreases reflects additional information 
about X provided by Y. 
       	        (2) 
                       (3) 
In our study, there were only two classes in the dataset 
and H(X) is equal to the equation below: (v=virus, 
b=benign) 
  

 

 

            (4) 
, where |.| denotes the number of particular kind of 
executable and |S| = |v| + |b|. In addition, Y is an 
attribute with Boolean value such that Y = 1 indicates 
the subset S1 in which each instance has attribute Y and 
290
selection. Suppose that A is the set of attributes, which 
has been filtered out the redundant attributes by IG. P is 
the performance of RBF-SVM. The procedure of 
feature selection can be performed as follows: 
1. Train an L-SVM by A and obtain the normal 
vector w. Rank all the attributes in A, according to their 
corresponding wk2 value. 
2. Delete one or some of the attributes with lower 
rank from A and denote remaining attribute set as Aâ€™. 
3. Use Aâ€™ to train a RBF-SVM and get Pâ€™. If Pâ€™ > P, 
then set P=Pâ€™ and A=Aâ€™ and go to Step 2. Otherwise, 
stop this procedure and define Aâ€™ as the feature set. 
       
4. Experiment results 
 
Our dataset consisted of 846 virus and 1,758 
benign executables and all of them were Windows PE 
formatted and unpacked. We obtained some benign 
programs from the folders of pure Windows XP 
operating system. Besides, we downloaded additional 
ones from the web site PChomeÂ® Downloads 
(http://toget.pchome.com.tw/). On the other hand, 
viruses were downloaded from the web site VX 
Heavens (http://vx.netlux.org). The SVM classifier was 
obtained by LIBSVM[3]. 
Since both of the detection rate of virus and the 
false alert rate of benign program are important, we 
evaluated them at the same time by the viewpoint of 
Overall Accuracy (OA) indicates the proportion of 
correctly classified executables. The experiment 
contained two parts: the detection of known viruses and 
the prediction of previously unseen viruses. The 
prediction rate was calculated by five-fold 
cross-validation (CV). In other words, the dataset were 
randomly divided into five disjoint portions with an 
equal number of sizes in each portion, one of them was 
chosen as the testing set, and the remaining four 
portions were merged into a training set. This procedure 
was repeated five times by choosing different partition 
as a testing set. We calculated the average OA as the 
generalization ability of our system.  
After parsing the PE file format of each executable in 
the dataset, we got 93,116 attributes in the beginning. 
The experiment results shown in Table 2. reveal that 
even some of the attributes with lower IG were 
discarded; the performance of RBF-SVM remained 
steady. Therefore, we successfully reduced the number 
of attributes from 93,116 to 1,398 after the process of 
attribute elimination. Continuously, Figure 3 presents 
the results of the feature selection procedure stated in 
Section 3.3. Evidently, we not only succeeded in feature 
reduction but also made further progress in 
classification performance. Finally, the top 429 features 
was chosen to train the RBF-SVM and achieved a 
proper performance with 96.66% in prevention rate and 
99.00% in detection rate (True Positive=98.35%, False 
Positive=0.68%). 
 
5. Conclusion
Ê³
In summary, the following are the main concepts of 
VPM. First, executable behaviors are examined by the 
usage of DLLs and APIs and the DLL dependency 
examination is novel. Moreover, both attribute 
elimination and feature selection were performed by 
using IG and L-SVM respectively for collecting 
informative features. Finally, these features are used to 
train a RBF-SVM that is well performed in the 
evaluations of known and unknown virus detection. 
292
